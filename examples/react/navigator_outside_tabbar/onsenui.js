/*! onsenui v2.0.0-react.1 - 2016-03-28 */
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.3
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) global.MutationObserver = JsMutationObserver;
})(this);

window.CustomElements = window.CustomElements || {
  flags: {}
};

(function(scope) {
  var flags = scope.flags;
  var modules = [];
  var addModule = function(module) {
    modules.push(module);
  };
  var initializeModules = function() {
    modules.forEach(function(module) {
      module(scope);
    });
  };
  scope.addModule = addModule;
  scope.initializeModules = initializeModules;
  scope.hasNative = Boolean(document.registerElement);
  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || HTMLImports.useNative);
})(window.CustomElements);

window.CustomElements.addModule(function(scope) {
  var IMPORT_LINK_TYPE = window.HTMLImports ? HTMLImports.IMPORT_LINK_TYPE : "none";
  function forSubtree(node, cb) {
    findAllElements(node, function(e) {
      if (cb(e)) {
        return true;
      }
      forRoots(e, cb);
    });
    forRoots(node, cb);
  }
  function findAllElements(node, find, data) {
    var e = node.firstElementChild;
    if (!e) {
      e = node.firstChild;
      while (e && e.nodeType !== Node.ELEMENT_NODE) {
        e = e.nextSibling;
      }
    }
    while (e) {
      if (find(e, data) !== true) {
        findAllElements(e, find, data);
      }
      e = e.nextElementSibling;
    }
    return null;
  }
  function forRoots(node, cb) {
    var root = node.shadowRoot;
    while (root) {
      forSubtree(root, cb);
      root = root.olderShadowRoot;
    }
  }
  function forDocumentTree(doc, cb) {
    _forDocumentTree(doc, cb, []);
  }
  function _forDocumentTree(doc, cb, processingDocuments) {
    doc = wrap(doc);
    if (processingDocuments.indexOf(doc) >= 0) {
      return;
    }
    processingDocuments.push(doc);
    var imports = doc.querySelectorAll("link[rel=" + IMPORT_LINK_TYPE + "]");
    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {
      if (n.import) {
        _forDocumentTree(n.import, cb, processingDocuments);
      }
    }
    cb(doc);
  }
  scope.forDocumentTree = forDocumentTree;
  scope.forSubtree = forSubtree;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  var forSubtree = scope.forSubtree;
  var forDocumentTree = scope.forDocumentTree;
  function addedNode(node) {
    return added(node) || addedSubtree(node);
  }
  function added(node) {
    if (scope.upgrade(node)) {
      return true;
    }
    attached(node);
  }
  function addedSubtree(node) {
    forSubtree(node, function(e) {
      if (added(e)) {
        return true;
      }
    });
  }
  function attachedNode(node) {
    attached(node);
    if (inDocument(node)) {
      forSubtree(node, function(e) {
        attached(e);
      });
    }
  }
  var hasPolyfillMutations = !window.MutationObserver || window.MutationObserver === window.JsMutationObserver;
  scope.hasPolyfillMutations = hasPolyfillMutations;
  var isPendingMutations = false;
  var pendingMutations = [];
  function deferMutation(fn) {
    pendingMutations.push(fn);
    if (!isPendingMutations) {
      isPendingMutations = true;
      setTimeout(takeMutations);
    }
  }
  function takeMutations() {
    isPendingMutations = false;
    var $p = pendingMutations;
    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
      p();
    }
    pendingMutations = [];
  }
  function attached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _attached(element);
      });
    } else {
      _attached(element);
    }
  }
  function _attached(element) {
    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {
      if (!element.__attached && inDocument(element)) {
        element.__attached = true;
        if (element.attachedCallback) {
          element.attachedCallback();
        }
      }
    }
  }
  function detachedNode(node) {
    detached(node);
    forSubtree(node, function(e) {
      detached(e);
    });
  }
  function detached(element) {
    if (hasPolyfillMutations) {
      deferMutation(function() {
        _detached(element);
      });
    } else {
      _detached(element);
    }
  }
  function _detached(element) {
    if (element.__upgraded__ && (element.attachedCallback || element.detachedCallback)) {
      if (element.__attached && !inDocument(element)) {
        element.__attached = false;
        if (element.detachedCallback) {
          element.detachedCallback();
        }
      }
    }
  }
  function inDocument(element) {
    var p = element;
    var doc = wrap(document);
    while (p) {
      if (p == doc) {
        return true;
      }
      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;
    }
  }
  function watchShadow(node) {
    if (node.shadowRoot && !node.shadowRoot.__watched) {
      flags.dom && console.log("watching shadow-root for: ", node.localName);
      var root = node.shadowRoot;
      while (root) {
        observe(root);
        root = root.olderShadowRoot;
      }
    }
  }
  function handler(mutations) {
    if (flags.dom) {
      var mx = mutations[0];
      if (mx && mx.type === "childList" && mx.addedNodes) {
        if (mx.addedNodes) {
          var d = mx.addedNodes[0];
          while (d && d !== document && !d.host) {
            d = d.parentNode;
          }
          var u = d && (d.URL || d._URL || d.host && d.host.localName) || "";
          u = u.split("/?").shift().split("/").pop();
        }
      }
      console.group("mutations (%d) [%s]", mutations.length, u || "");
    }
    mutations.forEach(function(mx) {
      if (mx.type === "childList") {
        forEach(mx.addedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          addedNode(n);
        });
        forEach(mx.removedNodes, function(n) {
          if (!n.localName) {
            return;
          }
          detachedNode(n);
        });
      }
    });
    flags.dom && console.groupEnd();
  }
  function takeRecords(node) {
    node = wrap(node);
    if (!node) {
      node = wrap(document);
    }
    while (node.parentNode) {
      node = node.parentNode;
    }
    var observer = node.__observer;
    if (observer) {
      handler(observer.takeRecords());
      takeMutations();
    }
  }
  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  function observe(inRoot) {
    if (inRoot.__observer) {
      return;
    }
    var observer = new MutationObserver(handler);
    observer.observe(inRoot, {
      childList: true,
      subtree: true
    });
    inRoot.__observer = observer;
  }
  function upgradeDocument(doc) {
    doc = wrap(doc);
    flags.dom && console.group("upgradeDocument: ", doc.baseURI.split("/").pop());
    addedNode(doc);
    observe(doc);
    flags.dom && console.groupEnd();
  }
  function upgradeDocumentTree(doc) {
    forDocumentTree(doc, upgradeDocument);
  }
  var originalCreateShadowRoot = Element.prototype.createShadowRoot;
  if (originalCreateShadowRoot) {
    Element.prototype.createShadowRoot = function() {
      var root = originalCreateShadowRoot.call(this);
      CustomElements.watchShadow(this);
      return root;
    };
  }
  scope.watchShadow = watchShadow;
  scope.upgradeDocumentTree = upgradeDocumentTree;
  scope.upgradeSubtree = addedSubtree;
  scope.upgradeAll = addedNode;
  scope.attachedNode = attachedNode;
  scope.takeRecords = takeRecords;
});

window.CustomElements.addModule(function(scope) {
  var flags = scope.flags;
  function upgrade(node) {
    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
      var is = node.getAttribute("is");
      var definition = scope.getRegisteredDefinition(is || node.localName);
      if (definition) {
        if (is && definition.tag == node.localName) {
          return upgradeWithDefinition(node, definition);
        } else if (!is && !definition.extends) {
          return upgradeWithDefinition(node, definition);
        }
      }
    }
  }
  function upgradeWithDefinition(element, definition) {
    flags.upgrade && console.group("upgrade:", element.localName);
    if (definition.is) {
      element.setAttribute("is", definition.is);
    }
    implementPrototype(element, definition);
    element.__upgraded__ = true;
    created(element);
    scope.attachedNode(element);
    scope.upgradeSubtree(element);
    flags.upgrade && console.groupEnd();
    return element;
  }
  function implementPrototype(element, definition) {
    if (Object.__proto__) {
      element.__proto__ = definition.prototype;
    } else {
      customMixin(element, definition.prototype, definition.native);
      element.__proto__ = definition.prototype;
    }
  }
  function customMixin(inTarget, inSrc, inNative) {
    var used = {};
    var p = inSrc;
    while (p !== inNative && p !== HTMLElement.prototype) {
      var keys = Object.getOwnPropertyNames(p);
      for (var i = 0, k; k = keys[i]; i++) {
        if (!used[k]) {
          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
          used[k] = 1;
        }
      }
      p = Object.getPrototypeOf(p);
    }
  }
  function created(element) {
    if (element.createdCallback) {
      element.createdCallback();
    }
  }
  scope.upgrade = upgrade;
  scope.upgradeWithDefinition = upgradeWithDefinition;
  scope.implementPrototype = implementPrototype;
});

window.CustomElements.addModule(function(scope) {
  var isIE11OrOlder = scope.isIE11OrOlder;
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  var upgradeAll = scope.upgradeAll;
  var upgradeWithDefinition = scope.upgradeWithDefinition;
  var implementPrototype = scope.implementPrototype;
  var useNative = scope.useNative;
  function register(name, options) {
    var definition = options || {};
    if (!name) {
      throw new Error("document.registerElement: first argument `name` must not be empty");
    }
    if (name.indexOf("-") < 0) {
      throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(name) + "'.");
    }
    if (isReservedTag(name)) {
      throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(name) + "'. The type name is invalid.");
    }
    if (getRegisteredDefinition(name)) {
      throw new Error("DuplicateDefinitionError: a type with name '" + String(name) + "' is already registered");
    }
    if (!definition.prototype) {
      definition.prototype = Object.create(HTMLElement.prototype);
    }
    definition.__name = name.toLowerCase();
    definition.lifecycle = definition.lifecycle || {};
    definition.ancestry = ancestry(definition.extends);
    resolveTagName(definition);
    resolvePrototypeChain(definition);
    overrideAttributeApi(definition.prototype);
    registerDefinition(definition.__name, definition);
    definition.ctor = generateConstructor(definition);
    definition.ctor.prototype = definition.prototype;
    definition.prototype.constructor = definition.ctor;
    if (scope.ready) {
      upgradeDocumentTree(document);
    }
    return definition.ctor;
  }
  function overrideAttributeApi(prototype) {
    if (prototype.setAttribute._polyfilled) {
      return;
    }
    var setAttribute = prototype.setAttribute;
    prototype.setAttribute = function(name, value) {
      changeAttribute.call(this, name, value, setAttribute);
    };
    var removeAttribute = prototype.removeAttribute;
    prototype.removeAttribute = function(name) {
      changeAttribute.call(this, name, null, removeAttribute);
    };
    prototype.setAttribute._polyfilled = true;
  }
  function changeAttribute(name, value, operation) {
    name = name.toLowerCase();
    var oldValue = this.getAttribute(name);
    operation.apply(this, arguments);
    var newValue = this.getAttribute(name);
    if (this.attributeChangedCallback && newValue !== oldValue) {
      this.attributeChangedCallback(name, oldValue, newValue);
    }
  }
  function isReservedTag(name) {
    for (var i = 0; i < reservedTagList.length; i++) {
      if (name === reservedTagList[i]) {
        return true;
      }
    }
  }
  var reservedTagList = [ "annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph" ];
  function ancestry(extnds) {
    var extendee = getRegisteredDefinition(extnds);
    if (extendee) {
      return ancestry(extendee.extends).concat([ extendee ]);
    }
    return [];
  }
  function resolveTagName(definition) {
    var baseTag = definition.extends;
    for (var i = 0, a; a = definition.ancestry[i]; i++) {
      baseTag = a.is && a.tag;
    }
    definition.tag = baseTag || definition.__name;
    if (baseTag) {
      definition.is = definition.__name;
    }
  }
  function resolvePrototypeChain(definition) {
    if (!Object.__proto__) {
      var nativePrototype = HTMLElement.prototype;
      if (definition.is) {
        var inst = document.createElement(definition.tag);
        var expectedPrototype = Object.getPrototypeOf(inst);
        if (expectedPrototype === definition.prototype) {
          nativePrototype = expectedPrototype;
        }
      }
      var proto = definition.prototype, ancestor;
      while (proto && proto !== nativePrototype) {
        ancestor = Object.getPrototypeOf(proto);
        proto.__proto__ = ancestor;
        proto = ancestor;
      }
      definition.native = nativePrototype;
    }
  }
  function instantiate(definition) {
    return upgradeWithDefinition(domCreateElement(definition.tag), definition);
  }
  var registry = {};
  function getRegisteredDefinition(name) {
    if (name) {
      return registry[name.toLowerCase()];
    }
  }
  function registerDefinition(name, definition) {
    registry[name] = definition;
  }
  function generateConstructor(definition) {
    return function() {
      return instantiate(definition);
    };
  }
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  function createElementNS(namespace, tag, typeExtension) {
    if (namespace === HTML_NAMESPACE) {
      return createElement(tag, typeExtension);
    } else {
      return domCreateElementNS(namespace, tag);
    }
  }
  function createElement(tag, typeExtension) {
    if (tag) {
      tag = tag.toLowerCase();
    }
    if (typeExtension) {
      typeExtension = typeExtension.toLowerCase();
    }
    var definition = getRegisteredDefinition(typeExtension || tag);
    if (definition) {
      if (tag == definition.tag && typeExtension == definition.is) {
        return new definition.ctor();
      }
      if (!typeExtension && !definition.is) {
        return new definition.ctor();
      }
    }
    var element;
    if (typeExtension) {
      element = createElement(tag);
      element.setAttribute("is", typeExtension);
      return element;
    }
    element = domCreateElement(tag);
    if (tag.indexOf("-") >= 0) {
      implementPrototype(element, HTMLElement);
    }
    return element;
  }
  var domCreateElement = document.createElement.bind(document);
  var domCreateElementNS = document.createElementNS.bind(document);
  var isInstance;
  if (!Object.__proto__ && !useNative) {
    isInstance = function(obj, ctor) {
      var p = obj;
      while (p) {
        if (p === ctor.prototype) {
          return true;
        }
        p = p.__proto__;
      }
      return false;
    };
  } else {
    isInstance = function(obj, base) {
      return obj instanceof base;
    };
  }
  function wrapDomMethodToForceUpgrade(obj, methodName) {
    var orig = obj[methodName];
    obj[methodName] = function() {
      var n = orig.apply(this, arguments);
      upgradeAll(n);
      return n;
    };
  }
  wrapDomMethodToForceUpgrade(Node.prototype, "cloneNode");
  wrapDomMethodToForceUpgrade(document, "importNode");
  if (isIE11OrOlder) {
    (function() {
      var importNode = document.importNode;
      document.importNode = function() {
        var n = importNode.apply(document, arguments);
        if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {
          var f = document.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }
  document.registerElement = register;
  document.createElement = createElement;
  document.createElementNS = createElementNS;
  scope.registry = registry;
  scope.instanceof = isInstance;
  scope.reservedTagList = reservedTagList;
  scope.getRegisteredDefinition = getRegisteredDefinition;
  document.register = document.registerElement;
});

(function(scope) {
  var useNative = scope.useNative;
  var initializeModules = scope.initializeModules;
  var isIE11OrOlder = /Trident/.test(navigator.userAgent);
  if (useNative) {
    var nop = function() {};
    scope.watchShadow = nop;
    scope.upgrade = nop;
    scope.upgradeAll = nop;
    scope.upgradeDocumentTree = nop;
    scope.upgradeSubtree = nop;
    scope.takeRecords = nop;
    scope.instanceof = function(obj, base) {
      return obj instanceof base;
    };
  } else {
    initializeModules();
  }
  var upgradeDocumentTree = scope.upgradeDocumentTree;
  if (!window.wrap) {
    if (window.ShadowDOMPolyfill) {
      window.wrap = ShadowDOMPolyfill.wrapIfNeeded;
      window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;
    } else {
      window.wrap = window.unwrap = function(node) {
        return node;
      };
    }
  }
  function bootstrap() {
    upgradeDocumentTree(wrap(document));
    if (window.HTMLImports) {
      HTMLImports.__importsParsingHook = function(elt) {
        upgradeDocumentTree(wrap(elt.import));
      };
    }
    CustomElements.ready = true;
    setTimeout(function() {
      CustomElements.readyTime = Date.now();
      if (window.HTMLImports) {
        CustomElements.elapsed = CustomElements.readyTime - HTMLImports.readyTime;
      }
      document.dispatchEvent(new CustomEvent("WebComponentsReady", {
        bubbles: true
      }));
    });
  }
  if (isIE11OrOlder && typeof window.CustomEvent !== "function") {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent("CustomEvent");
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }
  if (document.readyState === "complete" || scope.flags.eager) {
    bootstrap();
  } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
    bootstrap();
  } else {
    var loadEvent = window.HTMLImports && !HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
    window.addEventListener(loadEvent, bootstrap);
  }
  scope.isIE11OrOlder = isIE11OrOlder;
})(window.CustomElements);

if (!window.CustomEvent) {
  (function() {
    var CustomEvent;

    CustomEvent = function(event, params) {
      var evt;
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
  })();
}

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/


/**
 * Minimal animation library for managing css transition on mobile browsers.
 */
window.animit = (function(){
  'use strict';

  var TIMEOUT_RATIO = 1.4;

  var util = {
  };

  // capitalize string
  util.capitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  /**
  * @param {Object} params
  * @param {String} params.property
  * @param {Float} params.duration
  * @param {String} params.timing
  */
  util.buildTransitionValue = function(params) {
    params.property = params.property || 'all';
    params.duration = params.duration || 0.4;
    params.timing = params.timing || 'linear';

    var props = params.property.split(/ +/);

    return props.map(function(prop) {
      return prop + ' ' + params.duration + 's ' + params.timing;
    }).join(', ');
  };

  /**
  * Add an event handler on "transitionend" event.
  */
  util.onceOnTransitionEnd = function(element, callback) {
    if (!element) {
      return function() {};
    }

    var fn = function(event) {
      if (element == event.target) {
        event.stopPropagation();
        removeListeners();

        callback();
      }
    };

    var removeListeners = function() {
      util._transitionEndEvents.forEach(function(eventName) {
        element.removeEventListener(eventName, fn, false);
      });
    };

    util._transitionEndEvents.forEach(function(eventName) {
      element.addEventListener(eventName, fn, false);
    });

    return removeListeners;
  };

  util._transitionEndEvents = (function() {

    if ('ontransitionend' in window) {
      return ['transitionend'];
    }

    if ('onwebkittransitionend' in window) {
      return ['webkitTransitionEnd'];
    }

    if (util.vendorPrefix === 'webkit' || util.vendorPrefix === 'o' || util.vendorPrefix === 'moz' || util.vendorPrefix === 'ms') {
      return [util.vendorPrefix + 'TransitionEnd', 'transitionend'];
    }

    return [];
  })();

  util._cssPropertyDict = (function() {
    var styles = window.getComputedStyle(document.documentElement, '');
    var dict = {};
    var a = 'A'.charCodeAt(0);
    var z = 'z'.charCodeAt(0);

    var upper = function(s) {
      return s.substr(1).toUpperCase();
    };

    for (var i = 0; i < styles.length; i++) {

      var key = styles[i]
        .replace(/^[\-]+/, '')
        .replace(/[\-][a-z]/g, upper)
        .replace(/^moz/, 'Moz');

      if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
        if (key !== 'cssText' && key !== 'parentText') {
          dict[key] = true;
        }
      }
    }

    return dict;
  })();

  util.hasCssProperty = function(name) {
    return name in util._cssPropertyDict;
  };

  /**
   * Vendor prefix for css property.
   */
  util.vendorPrefix = (function() {
    var styles = window.getComputedStyle(document.documentElement, ''),
    pre = (Array.prototype.slice
      .call(styles)
      .join('')
      .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
    )[1];
    return pre;
  })();

  util.forceLayoutAtOnce = function(elements, callback) {
    this.batchImmediate(function() {
      elements.forEach(function(element) {
        // force layout
        element.offsetHeight;
      });
      callback();
    });
  };

  util.batchImmediate = (function() {
    var callbacks = [];

    return function(callback) {
      if (callbacks.length === 0) {
        setImmediate(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.batchAnimationFrame = (function() {
    var callbacks = [];

    var raf = window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback) {
      setTimeout(callback, 1000 / 60);
    };

    return function(callback) {
      if (callbacks.length === 0) {
        raf(function() {
          var concreateCallbacks = callbacks.slice(0);
          callbacks = [];
          concreateCallbacks.forEach(function(callback) {
            callback();
          });
        });
      }

      callbacks.push(callback);
    };
  })();

  util.transitionPropertyName = (function() {
    if (util.hasCssProperty('transitionDuration')) {
      return 'transition';
    }

    if (util.hasCssProperty(util.vendorPrefix + 'TransitionDuration')) {
      return util.vendorPrefix + 'Transition';
    }

    throw new Error('Invalid state');
  })();


  /**
   * @param {HTMLElement} element
   */
  var Animit = function(element) {
    if (!(this instanceof Animit)) {
      return new Animit(element);
    }

    if (element instanceof HTMLElement) {
      this.elements = [element];
    } else if (Object.prototype.toString.call(element) === '[object Array]') {
      this.elements = element;

    } else {
      throw new Error('First argument must be an array or an instance of HTMLElement.');
    }

    this.transitionQueue = [];
    this.lastStyleAttributeDict = [];
  };

  Animit.prototype = {

    /**
     * @property {Array}
     */
    transitionQueue: undefined,

    /**
     * @property {Array}
     */
    elements: undefined,

    /**
     * Start animation sequence with passed animations.
     *
     * @param {Function} callback
     */
    play: function(callback) {
      if (typeof callback === 'function') {
        this.transitionQueue.push(function(done) {
          callback();
          done();
        });
      }

      this.startAnimation();

      return this;
    },

    /**
     * Queue transition animations or other function.
     *
     * e.g. animit(elt).queue({color: 'red'})
     * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
     * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
     *
     * @param {Object|Animit.Transition|Function} transition
     * @param {Object} [options]
     */
    queue: function(transition, options) {
      var queue = this.transitionQueue;

      if (transition && options) {
        options.css = transition;
        transition = new Animit.Transition(options);
      }

      if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
        if (transition.css) {
          transition = new Animit.Transition(transition);
        } else {
          transition = new Animit.Transition({
            css: transition
          });
        }
      }

      if (transition instanceof Function) {
        queue.push(transition);
      } else if (transition instanceof Animit.Transition) {
        queue.push(transition.build());
      } else {
        throw new Error('Invalid arguments');
      }

      return this;
    },

    /**
     * Queue transition animations.
     *
     * @param {Float} seconds
     */
    wait: function(seconds) {
      if (seconds > 0) {
        this.transitionQueue.push(function(done) {
          setTimeout(done, 1000 * seconds);
        });
      }

      return this;
    },

    saveStyle: function() {

      this.transitionQueue.push(function(done) {
        this.elements.forEach(function(element, index) {
          var css = this.lastStyleAttributeDict[index] = {};

          for (var i = 0; i < element.style.length; i++) {
            css[element.style[i]] = element.style[element.style[i]];
          }
        }.bind(this));
        done();
      }.bind(this));

      return this;
    },

    /**
     * Restore element's style.
     *
     * @param {Object} [options]
     * @param {Float} [options.duration]
     * @param {String} [options.timing]
     * @param {String} [options.transition]
     */
    restoreStyle: function(options) {
      options = options || {};
      var self = this;

      if (options.transition && !options.duration) {
        throw new Error('"options.duration" is required when "options.transition" is enabled.');
      }

      var transitionName = util.transitionPropertyName;

      if (options.transition || (options.duration && options.duration > 0)) {
        var transitionValue = options.transition || ('all ' + options.duration + 's ' + (options.timing || 'linear'));

        this.transitionQueue.push(function(done) {
          var elements = this.elements;
          var timeoutId;

          var clearTransition = function() {
            elements.forEach(function(element) {
              element.style[transitionName] = '';
            });
          };

          // add "transitionend" event handler
          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            clearTransition();
            done();
          });

          // for fail safe.
          timeoutId = setTimeout(function() {
            removeListeners();
            clearTransition();
            done();
          }, options.duration * 1000 * TIMEOUT_RATIO);

          // transition and style settings
          elements.forEach(function(element, index) {

            var css = self.lastStyleAttributeDict[index];

            if (!css) {
              throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
            }

            self.lastStyleAttributeDict[index] = undefined;

            var name;
            for (var i = 0, len = element.style.length; i < len; i++) {
              name = element.style[i];
              if (css[name] === undefined) {
                css[name] = '';
              }
            }

            element.style[transitionName] = transitionValue;

            Object.keys(css).forEach(function(key) {
              if (key !== transitionName) {
                element.style[key] = css[key];
              }
            });

            element.style[transitionName] = transitionValue;
          });
        });
      } else {
        this.transitionQueue.push(function(done) {
          reset();
          done();
        });
      }

      return this;

      function reset() {
        // Clear transition animation settings.
        self.elements.forEach(function(element, index) {
          element.style[transitionName] = 'none';

          var css = self.lastStyleAttributeDict[index];

          if (!css) {
            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
          }

          self.lastStyleAttributeDict[index] = undefined;

          for (var i = 0, name = ''; i < element.style.length; i++) {
            name = element.style[i];
            if (typeof css[element.style[i]] === 'undefined') {
              css[element.style[i]] = '';
            }
          }

          Object.keys(css).forEach(function(key) {
            element.style[key] = css[key];
          });

        });
      }
    },

    /**
     * Start animation sequence.
     */
    startAnimation: function() {
      this._dequeueTransition();

      return this;
    },

    _dequeueTransition: function() {
      var transition = this.transitionQueue.shift();
      if (this._currentTransition) {
        throw new Error('Current transition exists.');
      }
      this._currentTransition = transition;
      var self = this;
      var called = false;

      var done = function() {
        if (!called) {
          called = true;
          self._currentTransition = undefined;
          self._dequeueTransition();
        } else {
          throw new Error('Invalid state: This callback is called twice.');
        }
      };

      if (transition) {
        transition.call(this, done);
      }
    }

  };

  /**
   * @param {Animit} arguments
   */
  Animit.runAll = function(/* arguments... */) {
    for (var i = 0; i < arguments.length; i++) {
      arguments[i].play();
    }
  };


  /**
   * @param {Object} options
   * @param {Float} [options.duration]
   * @param {String} [options.property]
   * @param {String} [options.timing]
   */
  Animit.Transition = function(options) {
    this.options = options || {};
    this.options.duration = this.options.duration || 0;
    this.options.timing = this.options.timing || 'linear';
    this.options.css = this.options.css || {};
    this.options.property = this.options.property || 'all';
  };

  Animit.Transition.prototype = {

    /**
     * @param {HTMLElement} element
     * @return {Function}
     */
    build: function() {

      if (Object.keys(this.options.css).length === 0) {
        throw new Error('options.css is required.');
      }

      var css = createActualCssProps(this.options.css);

      if (this.options.duration > 0) {
        var transitionValue = util.buildTransitionValue(this.options);
        var self = this;

        return function(callback) {
          var elements = this.elements;
          var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
          var timeoutId;

          var removeListeners = util.onceOnTransitionEnd(elements[0], function() {
            clearTimeout(timeoutId);
            callback();
          });

          timeoutId = setTimeout(function() {
            removeListeners();
            callback();
          }, timeout);

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = transitionValue;

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

        };
      }

      if (this.options.duration <= 0) {
        return function(callback) {
          var elements = this.elements;

          elements.forEach(function(element) {
            element.style[util.transitionPropertyName] = '';

            Object.keys(css).forEach(function(name) {
              element.style[name] = css[name];
            });
          });

          if (elements.length > 0) {
            util.forceLayoutAtOnce(elements, function() {
              util.batchAnimationFrame(callback);
            });
          } else {
            util.batchAnimationFrame(callback);
          }
        };
      }

      function createActualCssProps(css) {
        var result = {};

        Object.keys(css).forEach(function(name) {
          var value = css[name];

          if (util.hasCssProperty(name)) {
            result[name] = value;
            return;
          }

          var prefixed = util.vendorPrefix + util.capitalize(name);
          if (util.hasCssProperty(prefixed)) {
            result[prefixed] = value;
          } else {
            result[prefixed] = value;
            result[name] = value;
          }
        });

        return result;
      }

    }
  };


  return Animit;
})();

/*
 * childNode.remove method polyfill for IE.
 * https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
 */

(function() {
	if (!('remove' in Element.prototype)) {
	  Element.prototype.remove = function() {
	    if (this.parentNode) {
	    	this.parentNode.removeChild(this);
	    }
	  };
	}
})();

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in self) {

// Full polyfill for browsers with no classList support
// Including IE < Edge missing SVGElement.classList
if (!("classList" in document.createElement("_"))
  || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))) {

(function (view) {

"use strict";

if (!('Element' in view)) return;

var
    classListProp = "classList"
  , protoProp = "prototype"
  , elemCtrProto = view.Element[protoProp]
  , objCtr = Object
  , strTrim = String[protoProp].trim || function () {
    return this.replace(/^\s+|\s+$/g, "");
  }
  , arrIndexOf = Array[protoProp].indexOf || function (item) {
    var
        i = 0
      , len = this.length
    ;
    for (; i < len; i++) {
      if (i in this && this[i] === item) {
        return i;
      }
    }
    return -1;
  }
  // Vendors: please allow content code to instantiate DOMExceptions
  , DOMEx = function (type, message) {
    this.name = type;
    this.code = DOMException[type];
    this.message = message;
  }
  , checkTokenAndGetIndex = function (classList, token) {
    if (token === "") {
      throw new DOMEx(
          "SYNTAX_ERR"
        , "An invalid or illegal string was specified"
      );
    }
    if (/\s/.test(token)) {
      throw new DOMEx(
          "INVALID_CHARACTER_ERR"
        , "String contains an invalid character"
      );
    }
    return arrIndexOf.call(classList, token);
  }
  , ClassList = function (elem) {
    var
        trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
      , classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
      , i = 0
      , len = classes.length
    ;
    for (; i < len; i++) {
      this.push(classes[i]);
    }
    this._updateClassName = function () {
      elem.setAttribute("class", this.toString());
    };
  }
  , classListProto = ClassList[protoProp] = []
  , classListGetter = function () {
    return new ClassList(this);
  }
;
// Most DOMException implementations don't allow calling DOMException's toString()
// on non-DOMExceptions. Error's toString() is sufficient here.
DOMEx[protoProp] = Error[protoProp];
classListProto.item = function (i) {
  return this[i] || null;
};
classListProto.contains = function (token) {
  token += "";
  return checkTokenAndGetIndex(this, token) !== -1;
};
classListProto.add = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
  ;
  do {
    token = tokens[i] + "";
    if (checkTokenAndGetIndex(this, token) === -1) {
      this.push(token);
      updated = true;
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.remove = function () {
  var
      tokens = arguments
    , i = 0
    , l = tokens.length
    , token
    , updated = false
    , index
  ;
  do {
    token = tokens[i] + "";
    index = checkTokenAndGetIndex(this, token);
    while (index !== -1) {
      this.splice(index, 1);
      updated = true;
      index = checkTokenAndGetIndex(this, token);
    }
  }
  while (++i < l);

  if (updated) {
    this._updateClassName();
  }
};
classListProto.toggle = function (token, force) {
  token += "";

  var
      result = this.contains(token)
    , method = result ?
      force !== true && "remove"
    :
      force !== false && "add"
  ;

  if (method) {
    this[method](token);
  }

  if (force === true || force === false) {
    return force;
  } else {
    return !result;
  }
};
classListProto.toString = function () {
  return this.join(" ");
};

if (objCtr.defineProperty) {
  var classListPropDesc = {
      get: classListGetter
    , enumerable: true
    , configurable: true
  };
  try {
    objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
  } catch (ex) { // IE 8 doesn't support enumerable:true
    if (ex.number === -0x7FF5EC54) {
      classListPropDesc.enumerable = false;
      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
    }
  }
} else if (objCtr[protoProp].__defineGetter__) {
  elemCtrProto.__defineGetter__(classListProp, classListGetter);
}

}(self));

} else {
// There is full or partial native classList support, so just check if we need
// to normalize the add/remove and toggle APIs.

(function () {
  "use strict";

  var testElement = document.createElement("_");

  testElement.classList.add("c1", "c2");

  // Polyfill for IE 10/11 and Firefox <26, where classList.add and
  // classList.remove exist but support only one argument at a time.
  if (!testElement.classList.contains("c2")) {
    var createMethod = function(method) {
      var original = DOMTokenList.prototype[method];

      DOMTokenList.prototype[method] = function(token) {
        var i, len = arguments.length;

        for (i = 0; i < len; i++) {
          token = arguments[i];
          original.call(this, token);
        }
      };
    };
    createMethod('add');
    createMethod('remove');
  }

  testElement.classList.toggle("c3", false);

  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
  // support the second argument.
  if (testElement.classList.contains("c3")) {
    var _toggle = DOMTokenList.prototype.toggle;

    DOMTokenList.prototype.toggle = function(token, force) {
      if (1 in arguments && !this.contains(token) === !force) {
        return force;
      } else {
        return _toggle.call(this, token);
      }
    };

  }

  testElement = null;
}());

}

}


;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesize a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay && (event.timeStamp - this.lastClickTime) > -1) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behavior on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recommended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};

  window.FastClick = FastClick;
}());

/**
 * MicroEvent - to make any js object an event emitter (server or browser)
 * 
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediately, no mystery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/

/** NOTE: This library is customized for Onsen UI. */

var MicroEvent  = function(){};
MicroEvent.prototype  = {
  on  : function(event, fct){
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once : function(event, fct){
    var self = this;
    var wrapper = function() {
      self.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off  : function(event, fct){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    this._events[event].splice(this._events[event].indexOf(fct), 1);
  },
  emit : function(event /* , args... */){
    this._events = this._events || {};
    if( event in this._events === false  )  return;
    for(var i = 0; i < this._events[event].length; i++){
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
 * mixin will delegate all MicroEvent.js function in the destination object
 *
 * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
 *
 * @param {Object} the object which will support MicroEvent
*/
MicroEvent.mixin  = function(destObject){
  var props = ['on', 'once', 'off', 'emit'];
  for(var i = 0; i < props.length; i ++){
    if( typeof destObject === 'function' ){
      destObject.prototype[props[i]]  = MicroEvent.prototype[props[i]];
    }else{
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
}

// export in common js
if( typeof module !== "undefined" && ('exports' in module)){
  module.exports  = MicroEvent;
}

window.MicroEvent = MicroEvent;

/*! modernizr 3.1.0 (Custom Build) | MIT *
 * http://modernizr.com/download/?-borderradius-boxshadow-canvas-cssanimations-csstransforms-csstransforms3d-csstransitions-svg-addtest-domprefixes-prefixes-shiv-testallprops-testprop-teststyles !*/
!function(e,t,n){function r(e,t){return typeof e===t}function o(){var e,t,n,o,i,s,a;for(var l in S)if(S.hasOwnProperty(l)){if(e=[],t=S[l],t.name&&(e.push(t.name.toLowerCase()),t.options&&t.options.aliases&&t.options.aliases.length))for(n=0;n<t.options.aliases.length;n++)e.push(t.options.aliases[n].toLowerCase());for(o=r(t.fn,"function")?t.fn():t.fn,i=0;i<e.length;i++)s=e[i],a=s.split("."),1===a.length?Modernizr[a[0]]=o:(!Modernizr[a[0]]||Modernizr[a[0]]instanceof Boolean||(Modernizr[a[0]]=new Boolean(Modernizr[a[0]])),Modernizr[a[0]][a[1]]=o),C.push((o?"":"no-")+a.join("-"))}}function i(e){var t=w.className,n=Modernizr._config.classPrefix||"";if(_&&(t=t.baseVal),Modernizr._config.enableJSClass){var r=new RegExp("(^|\\s)"+n+"no-js(\\s|$)");t=t.replace(r,"$1"+n+"js$2")}Modernizr._config.enableClasses&&(t+=" "+n+e.join(" "+n),_?w.className.baseVal=t:w.className=t)}function s(e,t){if("object"==typeof e)for(var n in e)N(e,n)&&s(n,e[n]);else{e=e.toLowerCase();var r=e.split("."),o=Modernizr[r[0]];if(2==r.length&&(o=o[r[1]]),"undefined"!=typeof o)return Modernizr;t="function"==typeof t?t():t,1==r.length?Modernizr[r[0]]=t:(!Modernizr[r[0]]||Modernizr[r[0]]instanceof Boolean||(Modernizr[r[0]]=new Boolean(Modernizr[r[0]])),Modernizr[r[0]][r[1]]=t),i([(t&&0!=t?"":"no-")+r.join("-")]),Modernizr._trigger(e,t)}return Modernizr}function a(){return"function"!=typeof t.createElement?t.createElement(arguments[0]):_?t.createElementNS.call(t,"http://www.w3.org/2000/svg",arguments[0]):t.createElement.apply(t,arguments)}function l(e,t){return!!~(""+e).indexOf(t)}function u(){var e=t.body;return e||(e=a(_?"svg":"body"),e.fake=!0),e}function f(e,n,r,o){var i,s,l,f,c="modernizr",d=a("div"),p=u();if(parseInt(r,10))for(;r--;)l=a("div"),l.id=o?o[r]:c+(r+1),d.appendChild(l);return i=a("style"),i.type="text/css",i.id="s"+c,(p.fake?p:d).appendChild(i),p.appendChild(d),i.styleSheet?i.styleSheet.cssText=e:i.appendChild(t.createTextNode(e)),d.id=c,p.fake&&(p.style.background="",p.style.overflow="hidden",f=w.style.overflow,w.style.overflow="hidden",w.appendChild(p)),s=n(d,e),p.fake?(p.parentNode.removeChild(p),w.style.overflow=f,w.offsetHeight):d.parentNode.removeChild(d),!!s}function c(e){return e.replace(/([a-z])-([a-z])/g,function(e,t,n){return t+n.toUpperCase()}).replace(/^-/,"")}function d(e,t){return function(){return e.apply(t,arguments)}}function p(e,t,n){var o;for(var i in e)if(e[i]in t)return n===!1?e[i]:(o=t[e[i]],r(o,"function")?d(o,n||t):o);return!1}function m(e){return e.replace(/([A-Z])/g,function(e,t){return"-"+t.toLowerCase()}).replace(/^ms-/,"-ms-")}function h(t,r){var o=t.length;if("CSS"in e&&"supports"in e.CSS){for(;o--;)if(e.CSS.supports(m(t[o]),r))return!0;return!1}if("CSSSupportsRule"in e){for(var i=[];o--;)i.push("("+m(t[o])+":"+r+")");return i=i.join(" or "),f("@supports ("+i+") { #modernizr { position: absolute; } }",function(e){return"absolute"==getComputedStyle(e,null).position})}return n}function g(e,t,o,i){function s(){f&&(delete L.style,delete L.modElem)}if(i=r(i,"undefined")?!1:i,!r(o,"undefined")){var u=h(e,o);if(!r(u,"undefined"))return u}for(var f,d,p,m,g,v=["modernizr","tspan"];!L.style;)f=!0,L.modElem=a(v.shift()),L.style=L.modElem.style;for(p=e.length,d=0;p>d;d++)if(m=e[d],g=L.style[m],l(m,"-")&&(m=c(m)),L.style[m]!==n){if(i||r(o,"undefined"))return s(),"pfx"==t?m:!0;try{L.style[m]=o}catch(y){}if(L.style[m]!=g)return s(),"pfx"==t?m:!0}return s(),!1}function v(e,t,n,o,i){var s=e.charAt(0).toUpperCase()+e.slice(1),a=(e+" "+k.join(s+" ")+s).split(" ");return r(t,"string")||r(t,"undefined")?g(a,t,o,i):(a=(e+" "+T.join(s+" ")+s).split(" "),p(a,t,n))}function y(e,t,r){return v(e,n,n,t,r)}var C=[],S=[],x={_version:"3.1.0",_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,t){var n=this;setTimeout(function(){t(n[e])},0)},addTest:function(e,t,n){S.push({name:e,fn:t,options:n})},addAsyncTest:function(e){S.push({name:null,fn:e})}},Modernizr=function(){};Modernizr.prototype=x,Modernizr=new Modernizr,Modernizr.addTest("svg",!!t.createElementNS&&!!t.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect);var b=x._config.usePrefixes?" -webkit- -moz- -o- -ms- ".split(" "):[];x._prefixes=b;var w=t.documentElement,_="svg"===w.nodeName.toLowerCase();_||!function(e,t){function n(e,t){var n=e.createElement("p"),r=e.getElementsByTagName("head")[0]||e.documentElement;return n.innerHTML="x<style>"+t+"</style>",r.insertBefore(n.lastChild,r.firstChild)}function r(){var e=C.elements;return"string"==typeof e?e.split(" "):e}function o(e,t){var n=C.elements;"string"!=typeof n&&(n=n.join(" ")),"string"!=typeof e&&(e=e.join(" ")),C.elements=n+" "+e,u(t)}function i(e){var t=y[e[g]];return t||(t={},v++,e[g]=v,y[v]=t),t}function s(e,n,r){if(n||(n=t),c)return n.createElement(e);r||(r=i(n));var o;return o=r.cache[e]?r.cache[e].cloneNode():h.test(e)?(r.cache[e]=r.createElem(e)).cloneNode():r.createElem(e),!o.canHaveChildren||m.test(e)||o.tagUrn?o:r.frag.appendChild(o)}function a(e,n){if(e||(e=t),c)return e.createDocumentFragment();n=n||i(e);for(var o=n.frag.cloneNode(),s=0,a=r(),l=a.length;l>s;s++)o.createElement(a[s]);return o}function l(e,t){t.cache||(t.cache={},t.createElem=e.createElement,t.createFrag=e.createDocumentFragment,t.frag=t.createFrag()),e.createElement=function(n){return C.shivMethods?s(n,e,t):t.createElem(n)},e.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+r().join().replace(/[\w\-:]+/g,function(e){return t.createElem(e),t.frag.createElement(e),'c("'+e+'")'})+");return n}")(C,t.frag)}function u(e){e||(e=t);var r=i(e);return!C.shivCSS||f||r.hasCSS||(r.hasCSS=!!n(e,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),c||l(e,r),e}var f,c,d="3.7.3",p=e.html5||{},m=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,h=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,g="_html5shiv",v=0,y={};!function(){try{var e=t.createElement("a");e.innerHTML="<xyz></xyz>",f="hidden"in e,c=1==e.childNodes.length||function(){t.createElement("a");var e=t.createDocumentFragment();return"undefined"==typeof e.cloneNode||"undefined"==typeof e.createDocumentFragment||"undefined"==typeof e.createElement}()}catch(n){f=!0,c=!0}}();var C={elements:p.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video",version:d,shivCSS:p.shivCSS!==!1,supportsUnknownElements:c,shivMethods:p.shivMethods!==!1,type:"default",shivDocument:u,createElement:s,createDocumentFragment:a,addElements:o};e.html5=C,u(t),"object"==typeof module&&module.exports&&(module.exports=C)}("undefined"!=typeof e?e:this,t);var E="Moz O ms Webkit",T=x._config.usePrefixes?E.toLowerCase().split(" "):[];x._domPrefixes=T;var N;!function(){var e={}.hasOwnProperty;N=r(e,"undefined")||r(e.call,"undefined")?function(e,t){return t in e&&r(e.constructor.prototype[t],"undefined")}:function(t,n){return e.call(t,n)}}(),x._l={},x.on=function(e,t){this._l[e]||(this._l[e]=[]),this._l[e].push(t),Modernizr.hasOwnProperty(e)&&setTimeout(function(){Modernizr._trigger(e,Modernizr[e])},0)},x._trigger=function(e,t){if(this._l[e]){var n=this._l[e];setTimeout(function(){var e,r;for(e=0;e<n.length;e++)(r=n[e])(t)},0),delete this._l[e]}},Modernizr._q.push(function(){x.addTest=s}),Modernizr.addTest("canvas",function(){var e=a("canvas");return!(!e.getContext||!e.getContext("2d"))});var P="CSS"in e&&"supports"in e.CSS,j="supportsCSS"in e;Modernizr.addTest("supports",P||j);var k=x._config.usePrefixes?E.split(" "):[];x._cssomPrefixes=k;var z=x.testStyles=f,F={elem:a("modernizr")};Modernizr._q.push(function(){delete F.elem});var L={style:F.elem.style};Modernizr._q.unshift(function(){delete L.style});x.testProp=function(e,t,r){return g([e],n,t,r)};x.testAllProps=v,x.testAllProps=y,Modernizr.addTest("borderradius",y("borderRadius","0px",!0)),Modernizr.addTest("boxshadow",y("boxShadow","1px 1px",!0)),Modernizr.addTest("cssanimations",y("animationName","a",!0)),Modernizr.addTest("csstransforms",function(){return-1===navigator.userAgent.indexOf("Android 2.")&&y("transform","scale(1)",!0)}),Modernizr.addTest("csstransforms3d",function(){var e=!!y("perspective","1px",!0),t=Modernizr._config.usePrefixes;if(e&&(!t||"webkitPerspective"in w.style)){var n;Modernizr.supports?n="@supports (perspective: 1px)":(n="@media (transform-3d)",t&&(n+=",(-webkit-transform-3d)")),n+="{#modernizr{left:9px;position:absolute;height:5px;margin:0;padding:0;border:0}}",z(n,function(t){e=9===t.offsetLeft&&5===t.offsetHeight})}return e}),Modernizr.addTest("csstransitions",y("transition","all",!0)),o(),i(C),delete x.addTest,delete x.addAsyncTest;for(var A=0;A<Modernizr._q.length;A++)Modernizr._q[A]();e.Modernizr=Modernizr}(window,document);
!function n(t,e,r){function o(u,f){if(!e[u]){if(!t[u]){var c="function"==typeof require&&require;if(!f&&c)return c(u,!0);if(i)return i(u,!0);var s=new Error("Cannot find module '"+u+"'");throw s.code="MODULE_NOT_FOUND",s}var l=e[u]={exports:{}};t[u][0].call(l.exports,function(n){var e=t[u][1][n];return o(e?e:n)},l,l.exports,n,t,e,r)}return e[u].exports}for(var i="function"==typeof require&&require,u=0;u<r.length;u++)o(r[u]);return o}({1:[function(n,t,e){"use strict";function r(){}function o(n){try{return n.then}catch(t){return d=t,w}}function i(n,t){try{return n(t)}catch(e){return d=e,w}}function u(n,t,e){try{n(t,e)}catch(r){return d=r,w}}function f(n){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof n)throw new TypeError("not a function");this._37=0,this._12=null,this._59=[],n!==r&&v(n,this)}function c(n,t,e){return new n.constructor(function(o,i){var u=new f(r);u.then(o,i),s(n,new p(t,e,u))})}function s(n,t){for(;3===n._37;)n=n._12;return 0===n._37?void n._59.push(t):void y(function(){var e=1===n._37?t.onFulfilled:t.onRejected;if(null===e)return void(1===n._37?l(t.promise,n._12):a(t.promise,n._12));var r=i(e,n._12);r===w?a(t.promise,d):l(t.promise,r)})}function l(n,t){if(t===n)return a(n,new TypeError("A promise cannot be resolved with itself."));if(t&&("object"==typeof t||"function"==typeof t)){var e=o(t);if(e===w)return a(n,d);if(e===n.then&&t instanceof f)return n._37=3,n._12=t,void h(n);if("function"==typeof e)return void v(e.bind(t),n)}n._37=1,n._12=t,h(n)}function a(n,t){n._37=2,n._12=t,h(n)}function h(n){for(var t=0;t<n._59.length;t++)s(n,n._59[t]);n._59=null}function p(n,t,e){this.onFulfilled="function"==typeof n?n:null,this.onRejected="function"==typeof t?t:null,this.promise=e}function v(n,t){var e=!1,r=u(n,function(n){e||(e=!0,l(t,n))},function(n){e||(e=!0,a(t,n))});e||r!==w||(e=!0,a(t,d))}var y=n("asap/raw"),d=null,w={};t.exports=f,f._99=r,f.prototype.then=function(n,t){if(this.constructor!==f)return c(this,n,t);var e=new f(r);return s(this,new p(n,t,e)),e}},{"asap/raw":4}],2:[function(n,t,e){"use strict";function r(n){var t=new o(o._99);return t._37=1,t._12=n,t}var o=n("./core.js");t.exports=o;var i=r(!0),u=r(!1),f=r(null),c=r(void 0),s=r(0),l=r("");o.resolve=function(n){if(n instanceof o)return n;if(null===n)return f;if(void 0===n)return c;if(n===!0)return i;if(n===!1)return u;if(0===n)return s;if(""===n)return l;if("object"==typeof n||"function"==typeof n)try{var t=n.then;if("function"==typeof t)return new o(t.bind(n))}catch(e){return new o(function(n,t){t(e)})}return r(n)},o.all=function(n){var t=Array.prototype.slice.call(n);return new o(function(n,e){function r(u,f){if(f&&("object"==typeof f||"function"==typeof f)){if(f instanceof o&&f.then===o.prototype.then){for(;3===f._37;)f=f._12;return 1===f._37?r(u,f._12):(2===f._37&&e(f._12),void f.then(function(n){r(u,n)},e))}var c=f.then;if("function"==typeof c){var s=new o(c.bind(f));return void s.then(function(n){r(u,n)},e)}}t[u]=f,0===--i&&n(t)}if(0===t.length)return n([]);for(var i=t.length,u=0;u<t.length;u++)r(u,t[u])})},o.reject=function(n){return new o(function(t,e){e(n)})},o.race=function(n){return new o(function(t,e){n.forEach(function(n){o.resolve(n).then(t,e)})})},o.prototype["catch"]=function(n){return this.then(null,n)}},{"./core.js":1}],3:[function(n,t,e){"use strict";function r(){if(c.length)throw c.shift()}function o(n){var t;t=f.length?f.pop():new i,t.task=n,u(t)}function i(){this.task=null}var u=n("./raw"),f=[],c=[],s=u.makeRequestCallFromTimer(r);t.exports=o,i.prototype.call=function(){try{this.task.call()}catch(n){o.onerror?o.onerror(n):(c.push(n),s())}finally{this.task=null,f[f.length]=this}}},{"./raw":4}],4:[function(n,t,e){(function(n){"use strict";function e(n){f.length||(u(),c=!0),f[f.length]=n}function r(){for(;s<f.length;){var n=s;if(s+=1,f[n].call(),s>l){for(var t=0,e=f.length-s;e>t;t++)f[t]=f[t+s];f.length-=s,s=0}}f.length=0,s=0,c=!1}function o(n){var t=1,e=new a(n),r=document.createTextNode("");return e.observe(r,{characterData:!0}),function(){t=-t,r.data=t}}function i(n){return function(){function t(){clearTimeout(e),clearInterval(r),n()}var e=setTimeout(t,0),r=setInterval(t,50)}}t.exports=e;var u,f=[],c=!1,s=0,l=1024,a=n.MutationObserver||n.WebKitMutationObserver;u="function"==typeof a?o(r):i(r),e.requestFlush=u,e.makeRequestCallFromTimer=i}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],5:[function(n,t,e){"function"!=typeof Promise.prototype.done&&(Promise.prototype.done=function(n,t){var e=arguments.length?this.then.apply(this,arguments):this;e.then(null,function(n){setTimeout(function(){throw n},0)})})},{}],6:[function(n,t,e){n("asap");"undefined"==typeof Promise&&(Promise=n("./lib/core.js"),n("./lib/es6-extensions.js")),n("./polyfill-done.js")},{"./lib/core.js":1,"./lib/es6-extensions.js":2,"./polyfill-done.js":5,asap:3}]},{},[6]);

/*
Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(function() {return this;}()));

(function() {
    function Viewport() {

        this.PRE_IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.IOS7_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";
        this.DEFAULT_VIEWPORT = "initial-scale=1, maximum-scale=1, user-scalable=no";

        this.ensureViewportElement();
        this.platform = {};
        this.platform.name = this.getPlatformName();
        this.platform.version = this.getPlatformVersion();

        return this;
    };

    Viewport.prototype.ensureViewportElement = function(){
        this.viewportElement = document.querySelector('meta[name=viewport]');
        if(!this.viewportElement){
            this.viewportElement = document.createElement('meta');
            this.viewportElement.name = "viewport";
            document.head.appendChild(this.viewportElement);
        }
    },

    Viewport.prototype.setup = function() {
        if (!this.viewportElement) {
            return;
        }

        if (this.viewportElement.getAttribute('data-no-adjust') == "true") {
            return;
        }

        if (this.platform.name == 'ios') {
            if (this.platform.version >= 7 && isWebView()) {
                this.viewportElement.setAttribute('content', this.IOS7_VIEWPORT);
            } else {
                this.viewportElement.setAttribute('content', this.PRE_IOS7_VIEWPORT);
            }
        } else {
            this.viewportElement.setAttribute('content', this.DEFAULT_VIEWPORT);
        }

        function isWebView() {
            return !!(window.cordova || window.phonegap || window.PhoneGap);
        }
    };

    Viewport.prototype.getPlatformName = function() {
        if (navigator.userAgent.match(/Android/i)) {
            return "android";
        }

        if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {
            return "ios";
        }

        // unknown
        return undefined;
    };

    Viewport.prototype.getPlatformVersion = function() {
        var start = window.navigator.userAgent.indexOf('OS ');
        return window.Number(window.navigator.userAgent.substr(start + 3, 3).replace('_', '.'));
    };

    window.Viewport = Viewport;
})();

// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// JavaScript Dynamic Content shim for Windows Store apps
(function () {

    if (window.MSApp && MSApp.execUnsafeLocalFunction) {

        // Some nodes will have an "attributes" property which shadows the Node.prototype.attributes property
        //  and means we don't actually see the attributes of the Node (interestingly the VS debug console
        //  appears to suffer from the same issue).
        //
        var Element_setAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "setAttribute").value;
        var Element_removeAttribute = Object.getOwnPropertyDescriptor(Element.prototype, "removeAttribute").value;
        var HTMLElement_insertAdjacentHTMLPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, "insertAdjacentHTML");
        var Node_get_attributes = Object.getOwnPropertyDescriptor(Node.prototype, "attributes").get;
        var Node_get_childNodes = Object.getOwnPropertyDescriptor(Node.prototype, "childNodes").get;
        var detectionDiv = document.createElement("div");

        function getAttributes(element) {
            return Node_get_attributes.call(element);
        }

        function setAttribute(element, attribute, value) {
            try {
                Element_setAttribute.call(element, attribute, value);
            } catch (e) {
                // ignore
            }
        }

        function removeAttribute(element, attribute) {
            Element_removeAttribute.call(element, attribute);
        }

        function childNodes(element) {
            return Node_get_childNodes.call(element);
        }

        function empty(element) {
            while (element.childNodes.length) {
                element.removeChild(element.lastChild);
            }
        }

        function insertAdjacentHTML(element, position, html) {
            HTMLElement_insertAdjacentHTMLPropertyDescriptor.value.call(element, position, html);
        }

        function inUnsafeMode() {
            var isUnsafe = true;
            try {
                detectionDiv.innerHTML = "<test/>";
            }
            catch (ex) {
                isUnsafe = false;
            }

            return isUnsafe;
        }

        function cleanse(html, targetElement) {
            var cleaner = document.implementation.createHTMLDocument("cleaner");
            empty(cleaner.documentElement);
            MSApp.execUnsafeLocalFunction(function () {
                insertAdjacentHTML(cleaner.documentElement, "afterbegin", html);
            });

            var scripts = cleaner.documentElement.querySelectorAll("script");
            Array.prototype.forEach.call(scripts, function (script) {
                switch (script.type.toLowerCase()) {
                    case "":
                        script.type = "text/inert";
                        break;
                    case "text/javascript":
                    case "text/ecmascript":
                    case "text/x-javascript":
                    case "text/jscript":
                    case "text/livescript":
                    case "text/javascript1.1":
                    case "text/javascript1.2":
                    case "text/javascript1.3":
                        script.type = "text/inert-" + script.type.slice("text/".length);
                        break;
                    case "application/javascript":
                    case "application/ecmascript":
                    case "application/x-javascript":
                        script.type = "application/inert-" + script.type.slice("application/".length);
                        break;

                    default:
                        break;
                }
            });

            function cleanseAttributes(element) {
                var attributes = getAttributes(element);
                if (attributes && attributes.length) {
                    // because the attributes collection is live it is simpler to queue up the renames
                    var events;
                    for (var i = 0, len = attributes.length; i < len; i++) {
                        var attribute = attributes[i];
                        var name = attribute.name;
                        if ((name[0] === "o" || name[0] === "O") &&
                            (name[1] === "n" || name[1] === "N")) {
                            events = events || [];
                            events.push({ name: attribute.name, value: attribute.value });
                        }
                    }
                    if (events) {
                        for (var i = 0, len = events.length; i < len; i++) {
                            var attribute = events[i];
                            removeAttribute(element, attribute.name);
                            setAttribute(element, "x-" + attribute.name, attribute.value);
                        }
                    }
                }
                var children = childNodes(element);
                for (var i = 0, len = children.length; i < len; i++) {
                    cleanseAttributes(children[i]);
                }
            }
            cleanseAttributes(cleaner.documentElement);

            var cleanedNodes = [];

            if (targetElement.tagName === 'HTML') {
                cleanedNodes = Array.prototype.slice.call(document.adoptNode(cleaner.documentElement).childNodes);
            } else {
                if (cleaner.head) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.head).childNodes));
                }
                if (cleaner.body) {
                    cleanedNodes = cleanedNodes.concat(Array.prototype.slice.call(document.adoptNode(cleaner.body).childNodes));
                }
            }

            return cleanedNodes;
        }

        function cleansePropertySetter(property, setter) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, property);
            var originalSetter = propertyDescriptor.set;
            Object.defineProperty(HTMLElement.prototype, property, {
                get: propertyDescriptor.get,
                set: function (value) {
                    if(window.WinJS && window.WinJS._execUnsafe && inUnsafeMode()) {
                        originalSetter.call(this, value);
                    } else {
                        var that = this;
                        var nodes = cleanse(value, that);
                        MSApp.execUnsafeLocalFunction(function () {
                            setter(propertyDescriptor, that, nodes);
                        });
                    }
                },
                enumerable: propertyDescriptor.enumerable,
                configurable: propertyDescriptor.configurable,
            });
        }
        cleansePropertySetter("innerHTML", function (propertyDescriptor, target, elements) {
            empty(target);
            for (var i = 0, len = elements.length; i < len; i++) {
                target.appendChild(elements[i]);
            }
        });
        cleansePropertySetter("outerHTML", function (propertyDescriptor, target, elements) {
            for (var i = 0, len = elements.length; i < len; i++) {
                target.insertAdjacentElement("afterend", elements[i]);
            }
            target.parentNode.removeChild(target);
        });

    }

}());
(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
   typeof define === 'function' && define.amd ? define(factory) :
   (global.ons = factory());
}(this, function () { 'use strict';

   var babelHelpers = {};

   babelHelpers.typeof = function (obj) {
     return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
   };

   babelHelpers.classCallCheck = function (instance, Constructor) {
     if (!(instance instanceof Constructor)) {
       throw new TypeError("Cannot call a class as a function");
     }
   };

   babelHelpers.createClass = (function () {
     function defineProperties(target, props) {
       for (var i = 0; i < props.length; i++) {
         var descriptor = props[i];
         descriptor.enumerable = descriptor.enumerable || false;
         descriptor.configurable = true;
         if ("value" in descriptor) descriptor.writable = true;
         Object.defineProperty(target, descriptor.key, descriptor);
       }
     }

     return function (Constructor, protoProps, staticProps) {
       if (protoProps) defineProperties(Constructor.prototype, protoProps);
       if (staticProps) defineProperties(Constructor, staticProps);
       return Constructor;
     };
   })();

   babelHelpers.inherits = function (subClass, superClass) {
     if (typeof superClass !== "function" && superClass !== null) {
       throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
     }

     subClass.prototype = Object.create(superClass && superClass.prototype, {
       constructor: {
         value: subClass,
         enumerable: false,
         writable: true,
         configurable: true
       }
     });
     if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
   };

   babelHelpers.possibleConstructorReturn = function (self, call) {
     if (!self) {
       throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
     }

     return call && (typeof call === "object" || typeof call === "function") ? call : self;
   };

   babelHelpers.slicedToArray = (function () {
     function sliceIterator(arr, i) {
       var _arr = [];
       var _n = true;
       var _d = false;
       var _e = undefined;

       try {
         for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
           _arr.push(_s.value);

           if (i && _arr.length === i) break;
         }
       } catch (err) {
         _d = true;
         _e = err;
       } finally {
         try {
           if (!_n && _i["return"]) _i["return"]();
         } finally {
           if (_d) throw _e;
         }
       }

       return _arr;
     }

     return function (arr, i) {
       if (Array.isArray(arr)) {
         return arr;
       } else if (Symbol.iterator in Object(arr)) {
         return sliceIterator(arr, i);
       } else {
         throw new TypeError("Invalid attempt to destructure non-iterable instance");
       }
     };
   })();

   babelHelpers;

   var unwrap = function unwrap(string) {
     return string.slice(1, -1);
   };
   var isObjectString = function isObjectString(string) {
     return string.startsWith('{') && string.endsWith('}');
   };
   var isArrayString = function isArrayString(string) {
     return string.startsWith('[') && string.endsWith(']');
   };
   var isQuotedString = function isQuotedString(string) {
     return string.startsWith('\'') && string.endsWith('\'') || string.startsWith('"') && string.endsWith('"');
   };

   var error = function error(token, string, originalString) {
     throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
   };

   var processToken = function processToken(token, string, originalString) {
     if (token === 'true' || token === 'false') {
       return token === 'true';
     } else if (isQuotedString(token)) {
       return unwrap(token);
     } else if (!isNaN(token)) {
       return +token;
     } else if (isObjectString(token)) {
       return parseObject(unwrap(token));
     } else if (isArrayString(token)) {
       return parseArray(unwrap(token));
     } else {
       error(token, string, originalString);
     }
   };

   var nextToken = function nextToken(string) {
     string = string.trimLeft();
     var limit = string.length;

     if (string[0] === ':' || string[0] === ',') {

       limit = 1;
     } else if (string[0] === '{' || string[0] === '[') {

       var c = string.charCodeAt(0);
       var nestedObject = 1;
       for (var i = 1; i < string.length; i++) {
         if (string.charCodeAt(i) === c) {
           nestedObject++;
         } else if (string.charCodeAt(i) === c + 2) {
           nestedObject--;
           if (nestedObject === 0) {
             limit = i + 1;
             break;
           }
         }
       }
     } else if (string[0] === '\'' || string[0] === '\"') {

       for (var i = 1; i < string.length; i++) {
         if (string[i] === string[0]) {
           limit = i + 1;
           break;
         }
       }
     } else {

       for (var i = 1; i < string.length; i++) {
         if ([' ', ',', ':'].indexOf(string[i]) !== -1) {
           limit = i;
           break;
         }
       }
     }

     return string.slice(0, limit);
   };

   var parseObject = function parseObject(string) {
     var isValidKey = function isValidKey(key) {
       return (/^[A-Z_\$][A-Z0-9_\$]*$/i.test(key)
       );
     };

     string = string.trim();
     var originalString = string,
         readingKey = true,
         key = undefined,
         previousToken = undefined,
         token = undefined,
         object = {};

     while (string.length > 0) {
       previousToken = token;
       token = nextToken(string);
       string = string.slice(token.length, string.length).trimLeft();

       if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
         error(token, string, originalString);
       } else if (token === ':' && readingKey && previousToken) {
         if (isValidKey(previousToken)) {
           key = previousToken;
           readingKey = false;
         } else {
           throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
         }
       } else if (token === ',' && !readingKey && previousToken) {
         object[key] = processToken(previousToken, string, originalString);
         readingKey = true;
       }
     }

     if (token) {
       object[key] = processToken(token, string, originalString);
     }

     return object;
   };

   var parseArray = function parseArray(string) {
     string = string.trim();
     var originalString = string,
         previousToken = undefined,
         token = undefined,
         array = [];

     while (string.length > 0) {
       previousToken = token;
       token = nextToken(string);
       string = string.slice(token.length, string.length).trimLeft();

       if (token === ',' && (!previousToken || previousToken === ',')) {
         error(token, string, originalString);
       } else if (token === ',') {
         array.push(processToken(previousToken, string, originalString));
       }
     }

     if (token) {
       if (token !== ',') {
         array.push(processToken(token, string, originalString));
       } else {
         error(token, string, originalString);
       }
     }

     return array;
   };

   var parse = function parse(string) {
     string = string.trim();

     if (isObjectString(string)) {
       return parseObject(unwrap(string));
     } else if (isArrayString(string)) {
       return parseArray(unwrap(string));
     } else {
       throw new Error('Provided string must be object or array like: ' + string);
     }
   };

   var util = {};

   /**
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {Function}
    */
   util.prepareQuery = function (query) {
     return query instanceof Function ? query : function (element) {
       return util.match(element, query);
     };
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name.
    * @return {Boolean}
    */
   util.match = function (element, query) {
     if (query[0] === '.') {
       return element.classList.contains(query.slice(1));
     }
     return element.nodeName.toLowerCase() === query;
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {HTMLElement/null}
    */
   util.findChild = function (element, query) {
     var match = util.prepareQuery(query);

     for (var i = 0; i < element.children.length; i++) {
       var node = element.children[i];
       if (match(node)) {
         return node;
       }
     }
     return null;
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {HTMLElement/null}
    */
   util.findChildRecursively = function (element, query) {
     var match = util.prepareQuery(query);

     for (var i = 0; i < element.children.length; i++) {
       var node = element.children[i];
       if (match(node)) {
         return node;
       } else {
         var nodeMatch = util.findChildRecursively(node, match);
         if (nodeMatch) {
           return nodeMatch;
         }
       }
     }

     return null;
   };

   /**
    * @param {Element} element
    * @param {String/Function} query dot class name or node name or matcher function.
    * @return {HTMLElement/null}
    */
   util.findParent = function (element, query) {
     var match = util.prepareQuery(query);

     var parent = element.parentNode;
     for (;;) {
       if (!parent || parent === document) {
         return null;
       }
       if (match(parent)) {
         return parent;
       }
       parent = parent.parentNode;
     }
   };

   /**
    * @param {Element} element
    * @return {boolean}
    */
   util.isAttached = function (element) {
     while (document.documentElement !== element) {
       if (!element) {
         return false;
       }
       element = element.parentNode;
     }
     return true;
   };

   /**
    * @param {Element} element
    * @return {boolean}
    */
   util.hasAnyComponentAsParent = function (element) {
     while (element && document.documentElement !== element) {
       element = element.parentNode;
       if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-sliding-menu|ons-split-view)/)) {
         return true;
       }
     }
     return false;
   };

   /**
    * @param {Element} element
    * @param {String} action to propagate
    */
   util.propagateAction = function (element, action) {
     for (var i = 0; i < element.childNodes.length; i++) {
       var child = element.childNodes[i];
       if (child[action] instanceof Function) {
         child[action]();
       } else {
         util.propagateAction(child, action);
       }
     }
   };

   /**
    * @param {String} selector - tag and class only
    * @param {Object} style
    * @param {Element}
    */
   util.create = function () {
     var selector = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
     var style = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     var classList = selector.split('.'),
         element = document.createElement(classList.shift() || 'div');

     if (classList.length) {
       element.className = classList.join(' ');
     }

     util.extend(element.style, style);

     return element;
   };

   /**
    * @param {String} html
    * @return {Element}
    */
   util.createElement = function (html) {
     var wrapper = document.createElement('div');
     wrapper.innerHTML = html;

     if (wrapper.children.length > 1) {
       throw new Error('"html" must be one wrapper element.');
     }

     return wrapper.children[0];
   };

   /**
    * @param {String} html
    * @return {HTMLFragment}
    */
   util.createFragment = function (html) {
     var wrapper = document.createElement('div');
     wrapper.innerHTML = html;
     var fragment = document.createDocumentFragment();

     while (wrapper.firstChild) {
       fragment.appendChild(wrapper.firstChild);
     }

     return fragment;
   };

   /*
    * @param {Object} dst Destination object.
    * @param {...Object} src Source object(s).
    * @returns {Object} Reference to `dst`.
    */
   util.extend = function (dst) {
     for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
       args[_key - 1] = arguments[_key];
     }

     for (var i = 0; i < args.length; i++) {
       if (args[i]) {
         var keys = Object.keys(args[i]);
         for (var j = 0; j < keys.length; j++) {
           var key = keys[j];
           dst[key] = args[i][key];
         }
       }
     }

     return dst;
   };

   /**
    * @param {Object} arrayLike
    * @return {Array}
    */
   util.arrayFrom = function (arrayLike) {
     return Array.prototype.slice.apply(arrayLike);
   };

   /**
    * @param {String} jsonString
    * @param {Object} [failSafe]
    * @return {Object}
    */
   util.parseJSONObjectSafely = function (jsonString) {
     var failSafe = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     try {
       var result = JSON.parse('' + jsonString);
       if ((typeof result === 'undefined' ? 'undefined' : babelHelpers.typeof(result)) === 'object' && result !== null) {
         return result;
       }
     } catch (e) {
       return failSafe;
     }
     return failSafe;
   };

   /**
    * @param {String} path - path such as 'myApp.controllers.data.loadData'
    * @return {Any} - whatever is located at that path
    */
   util.findFromPath = function (path) {
     path = path.split('.');
     var el = window,
         key;
     while (key = path.shift()) {
       // eslint-disable-line no-cond-assign
       el = el[key];
     }
     return el;
   };

   /**
    * @param {Element} element
    * @param {String} eventName
    * @param {Object} [detail]
    * @return {CustomEvent}
    */
   util.triggerElementEvent = function (target, eventName) {
     var detail = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

     var event = new CustomEvent(eventName, {
       bubbles: true,
       cancelable: true,
       detail: detail
     });

     Object.keys(detail).forEach(function (key) {
       event[key] = detail[key];
     });

     target.dispatchEvent(event);

     return event;
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean}
    */
   util.hasModifier = function (target, modifierName) {
     if (!target.hasAttribute('modifier')) {
       return false;
     }
     return target.getAttribute('modifier').split(/\s+/).some(function (e) {
       return e === modifierName;
     });
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean} Whether it was added or not.
    */
   util.addModifier = function (target, modifierName) {
     if (util.hasModifier(target, modifierName)) {
       return false;
     }

     modifierName = modifierName.trim();
     var modifierAttribute = target.getAttribute('modifier') || '';
     target.setAttribute('modifier', (modifierAttribute + ' ' + modifierName).trim());
     return true;
   };

   /**
    * @param {Element} target
    * @param {String} modifierName
    * @return {Boolean} Whether it was found or not.
    */
   util.removeModifier = function (target, modifierName) {
     if (!target.getAttribute('modifier')) {
       return false;
     }

     var modifiers = target.getAttribute('modifier').split(/\s+/);

     var newModifiers = modifiers.filter(function (item) {
       return item && item !== modifierName;
     });
     target.setAttribute('modifier', newModifiers.join(' '));

     return modifiers.length !== newModifiers.length;
   };

   util.updateParentPosition = function (el) {
     if (!el._parentUpdated && el.parentElement) {
       if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
         el.parentElement.style.position = 'relative';
       }
       el._parentUpdated = true;
     }
   };

   util.bindListeners = function (element, listenerNames) {
     listenerNames.forEach(function (name) {
       var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
       element[boundName] = element[boundName] || element[name].bind(element);
     });
   };

   util.each = function (obj, f) {
     return Object.keys(obj).forEach(function (key) {
       return f(key, obj[key]);
     });
   };

   var safe = function safe(f) {
     return function () {
       if (f instanceof Function) {
         return f.apply(this, arguments);
       }
     };
   };
   util.safeCall = function (object, prop) {
     for (var _len2 = arguments.length, rest = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
       rest[_key2 - 2] = arguments[_key2];
     }

     return safe(object[prop]).apply(object, rest);
   };
   util.safeApply = function (object, prop, rest) {
     return safe(object[prop]).apply(object, rest);
   };

   var isOfType = function isOfType(object, type) {
     if (Array.isArray(type)) {
       return type.some(function (type) {
         return isOfType(object, type);
       });
     }
     if (object === null) {
       return type === 'null';
     }
     return type instanceof Function && object instanceof type || typeof type === 'string' && (typeof object === 'undefined' ? 'undefined' : babelHelpers.typeof(object)) === type;
   };

   var _printType = function _printType(type) {
     if (Array.isArray(type)) {
       return type.map(_printType).join(' or ');
     }
     return type instanceof Function && 'an instance of ' + type || type === 'null' && 'null' || typeof type === 'string' && 'a ' + type || JSON.stringify(type);
   };

   /**
    * @param {String} name - name which will be used in the error if the validation fails
    * @param {Function|String|Number|Boolean} object - object to be validated
    * @param {Object} options - validation options or type
    * @param {Array|String|Function} options.type - expected type or array of valid types
    * @param {Array|String|Function} options.returns - expected type of return value of the function
    * @param {Boolean} options.safeCall - if this is true then return a function which calls the `object` argument if it's a function. It will not throw an error it it's not.
    * @param {Object} options.dynamicCall - if this is set then all checks will be completed when trying to execute the resulting function. Furthermore instead of using the `object` argument it will use options.dynamicCall's `object[key]`.
    * @param {Object} options.dynamicCall.object - required if dynamicCall is exists
    * @param {String} options.dynamicCall.key - required if dynamicCall is exists
    * @param {Object} options.context - this is still an experimental setting. Context of the function. Used only with dynamicCall and returns. Defaults to dynamicCall.object.
    * @return validated object
    * @throws Error if the validation fails
    * @example
    *    doge = validated('doge', doge, [Doge, 'string']);
    *    foo = validated('foo', foo, {type: ['number', Array, 'null']});
    *    bar = validated('bar', bar, {type: 'function', safeCall: true});
    *    baz = validated('baz', null, {type: 'function', returns: 'string', dynamicCall: {object: obj, key: 'foo'}});
    *
    *    hoge = validated('hoge', obj, {
    *      type: [Doge, Duck],
    *      object: {
    *        name: 'string',
    *        wow: 'boolean',
    *        walk: {type: 'function', returns: 'boolean'},
    *        talk: {type: 'function', dynamicCall: {object: obj, key: 'quack'}, safeCall: true}
    *      }
    *    });
    *
    * @todo Support for functions with options.object - {type: Function, object: obj}
    */

   var validated = util.validated = function (name, object, options) {
     var type = options && options.type || !options.object && options;
     if (type && !isOfType(object, type) && !(options.dynamicCall || options.safeCall)) {
       throw new Error(name + ' must be ' + _printType(type) + '. You provided ' + object);
     }
     if (options && options.object) {
       var _ret = (function () {
         name = name ? name + '.' : '';
         var result = {};
         Object.keys(options.object).forEach(function (key) {
           var dynamicCall = options.object[key].dynamicCall;
           if (dynamicCall) {
             dynamicCall.object = dynamicCall.object || object;
             dynamicCall.key = dynamicCall.key || key;
           }
           result[key] = validated(name + key, object[key], options.object[key]);
         });
         return {
           v: result
         };
       })();

       if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
     }
     if (type === Function || type === 'function') {
       var _ret2 = (function () {
         var _ref = options.dynamicCall || {};

         var obj = _ref.object;
         var key = _ref.key;

         var context = options.context || obj;
         var test = options.safeCall ? safe : options.dynamicCall ? function (f) {
           return validated(name, f, Function);
         } : function (f) {
           return f;
         };

         object = options.dynamicCall ? function () {
           for (var _len3 = arguments.length, rest = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
             rest[_key3] = arguments[_key3];
           }

           return test(obj[key]).apply(context, rest);
         } : test(object);

         if (options.returns) {
           return {
             v: function v() {
               for (var _len4 = arguments.length, rest = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                 rest[_key4] = arguments[_key4];
               }

               return validated(name + '\'s result', object.apply(context, rest), options.returns);
             }
           };
         }
       })();

       if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
     }
     return object;
   };

   /**
    * @param {Element} target
    */
   util.updateRipple = function (target) {
     var rippleElement = util.findChild(target, 'ons-ripple');

     if (target.hasAttribute('ripple')) {
       if (!rippleElement) {
         target.insertBefore(document.createElement('ons-ripple'), target.firstChild);
       }
     } else if (rippleElement) {
       rippleElement.remove();
     }
   };

   /**
    * @param {String}
    * @return {Object}
    */
   util.animationOptionsParse = parse;

   var Event$1;
   var Utils;
   var Detection;
   var PointerEvent;
   /**
    * @object ons.GestureDetector
    * @category util
    * @description
    *   [en]Utility class for gesture detection.[/en]
    *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]
    */

   /**
    * @method constructor
    * @signature constructor(element[, options])
    * @description
    *  [en]Create a new GestureDetector instance.[/en]
    *  [ja]GestureDetectorのインスタンスを生成します。[/ja]
    * @param {Element} element
    *   [en]Name of the event.[/en]
    *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]
    * @param {Object} [options]
    *   [en]Options object.[/en]
    *   [ja]オプションを指定します。[/ja]
    * @return {ons.GestureDetector.Instance}
    */
   var GestureDetector = function GestureDetector(element, options) {
     return new GestureDetector.Instance(element, options || {});
   };

   /**
    * default settings.
    * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
    * by setting it's name (like `swipe`) to false.
    * You can set the defaults for all instances by changing this object before creating an instance.
    * @example
    * ````
    *  GestureDetector.defaults.drag = false;
    *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
    *  delete GestureDetector.defaults.behavior.userSelect;
    * ````
    * @property defaults
    * @type {Object}
    */
   GestureDetector.defaults = {
     behavior: {
       userSelect: 'none',
       touchAction: 'pan-y',
       touchCallout: 'none',
       contentZooming: 'none',
       userDrag: 'none',
       tapHighlightColor: 'rgba(0,0,0,0)'
     }
   };

   /**
    * GestureDetector document where the base events are added at
    * @property DOCUMENT
    * @type {HTMLElement}
    * @default window.document
    */
   GestureDetector.DOCUMENT = document;

   /**
    * detect support for pointer events
    * @property HAS_POINTEREVENTS
    * @type {Boolean}
    */
   GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

   /**
    * detect support for touch events
    * @property HAS_TOUCHEVENTS
    * @type {Boolean}
    */
   GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;

   /**
    * detect mobile browsers
    * @property IS_MOBILE
    * @type {Boolean}
    */
   GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

   /**
    * detect if we want to support mouseevents at all
    * @property NO_MOUSEEVENTS
    * @type {Boolean}
    */
   GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;

   /**
    * interval in which GestureDetector recalculates current velocity/direction/angle in ms
    * @property CALCULATE_INTERVAL
    * @type {Number}
    * @default 25
    */
   GestureDetector.CALCULATE_INTERVAL = 25;

   /**
    * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
    * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
    * @property EVENT_TYPES
    * @private
    * @writeOnce
    * @type {Object}
    */
   var EVENT_TYPES = {};

   /**
    * direction strings, for safe comparisons
    * @property DIRECTION_DOWN|LEFT|UP|RIGHT
    * @final
    * @type {String}
    * @default 'down' 'left' 'up' 'right'
    */
   var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
   var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
   var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
   var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';

   /**
    * pointertype strings, for safe comparisons
    * @property POINTER_MOUSE|TOUCH|PEN
    * @final
    * @type {String}
    * @default 'mouse' 'touch' 'pen'
    */
   var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
   var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
   var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';

   /**
    * eventtypes
    * @property EVENT_START|MOVE|END|RELEASE|TOUCH
    * @final
    * @type {String}
    * @default 'start' 'change' 'move' 'end' 'release' 'touch'
    */
   var EVENT_START = GestureDetector.EVENT_START = 'start';
   var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
   var EVENT_END = GestureDetector.EVENT_END = 'end';
   var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
   var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';

   /**
    * if the window events are set...
    * @property READY
    * @writeOnce
    * @type {Boolean}
    * @default false
    */
   GestureDetector.READY = false;

   /**
    * plugins namespace
    * @property plugins
    * @type {Object}
    */
   GestureDetector.plugins = GestureDetector.plugins || {};

   /**
    * gestures namespace
    * see `/gestures` for the definitions
    * @property gestures
    * @type {Object}
    */
   GestureDetector.gestures = GestureDetector.gestures || {};

   /**
    * setup events to detect gestures on the document
    * this function is called when creating an new instance
    * @private
    */
   function setup() {
     if (GestureDetector.READY) {
       return;
     }

     // find what eventtypes we add listeners to
     Event$1.determineEventTypes();

     // Register all gestures inside GestureDetector.gestures
     Utils.each(GestureDetector.gestures, function (gesture) {
       Detection.register(gesture);
     });

     // Add touch events on the document
     Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect);
     Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect);

     // GestureDetector is ready...!
     GestureDetector.READY = true;
   }

   /**
    * @module GestureDetector
    *
    * @class Utils
    * @static
    */
   Utils = GestureDetector.utils = {
     /**
      * extend method, could also be used for cloning when `dest` is an empty object.
      * changes the dest object
      * @param {Object} dest
      * @param {Object} src
      * @param {Boolean} [merge=false]  do a merge
      * @return {Object} dest
      */
     extend: function extend(dest, src, merge) {
       for (var key in src) {
         if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
           dest[key] = src[key];
         }
       }
       return dest;
     },

     /**
      * simple addEventListener wrapper
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      */
     on: function on(element, type, handler) {
       element.addEventListener(type, handler, false);
     },

     /**
      * simple removeEventListener wrapper
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      */
     off: function off(element, type, handler) {
       element.removeEventListener(type, handler, false);
     },

     /**
      * forEach over arrays and objects
      * @param {Object|Array} obj
      * @param {Function} iterator
      * @param {any} iterator.item
      * @param {Number} iterator.index
      * @param {Object|Array} iterator.obj the source object
      * @param {Object} context value to use as `this` in the iterator
      */
     each: function each(obj, iterator, context) {
       var i, len;

       // native forEach on arrays
       if ('forEach' in obj) {
         obj.forEach(iterator, context);
         // arrays
       } else if (obj.length !== undefined) {
           for (i = 0, len = obj.length; i < len; i++) {
             if (iterator.call(context, obj[i], i, obj) === false) {
               return;
             }
           }
           // objects
         } else {
             for (i in obj) {
               if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
                 return;
               }
             }
           }
     },

     /**
      * find if a string contains the string using indexOf
      * @param {String} src
      * @param {String} find
      * @return {Boolean} found
      */
     inStr: function inStr(src, find) {
       return src.indexOf(find) > -1;
     },

     /**
      * find if a array contains the object using indexOf or a simple polyfill
      * @param {String} src
      * @param {String} find
      * @return {Boolean|Number} false when not found, or the index
      */
     inArray: function inArray(src, find) {
       if (src.indexOf) {
         var index = src.indexOf(find);
         return index === -1 ? false : index;
       } else {
         for (var i = 0, len = src.length; i < len; i++) {
           if (src[i] === find) {
             return i;
           }
         }
         return false;
       }
     },

     /**
      * convert an array-like object (`arguments`, `touchlist`) to an array
      * @param {Object} obj
      * @return {Array}
      */
     toArray: function toArray(obj) {
       return Array.prototype.slice.call(obj, 0);
     },

     /**
      * find if a node is in the given parent
      * @param {HTMLElement} node
      * @param {HTMLElement} parent
      * @return {Boolean} found
      */
     hasParent: function hasParent(node, parent) {
       while (node) {
         if (node == parent) {
           return true;
         }
         node = node.parentNode;
       }
       return false;
     },

     /**
      * get the center of all the touches
      * @param {Array} touches
      * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
      */
     getCenter: function getCenter(touches) {
       var pageX = [],
           pageY = [],
           clientX = [],
           clientY = [],
           min = Math.min,
           max = Math.max;

       // no need to loop when only one touch
       if (touches.length === 1) {
         return {
           pageX: touches[0].pageX,
           pageY: touches[0].pageY,
           clientX: touches[0].clientX,
           clientY: touches[0].clientY
         };
       }

       Utils.each(touches, function (touch) {
         pageX.push(touch.pageX);
         pageY.push(touch.pageY);
         clientX.push(touch.clientX);
         clientY.push(touch.clientY);
       });

       return {
         pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
         pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
         clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
         clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
       };
     },

     /**
      * calculate the velocity between two points. unit is in px per ms.
      * @param {Number} deltaTime
      * @param {Number} deltaX
      * @param {Number} deltaY
      * @return {Object} velocity `x` and `y`
      */
     getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
       return {
         x: Math.abs(deltaX / deltaTime) || 0,
         y: Math.abs(deltaY / deltaTime) || 0
       };
     },

     /**
      * calculate the angle between two coordinates
      * @param {Touch} touch1
      * @param {Touch} touch2
      * @return {Number} angle
      */
     getAngle: function getAngle(touch1, touch2) {
       var x = touch2.clientX - touch1.clientX,
           y = touch2.clientY - touch1.clientY;

       return Math.atan2(y, x) * 180 / Math.PI;
     },

     /**
      * do a small comparison to get the direction between two touches.
      * @param {Touch} touch1
      * @param {Touch} touch2
      * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
      */
     getDirection: function getDirection(touch1, touch2) {
       var x = Math.abs(touch1.clientX - touch2.clientX),
           y = Math.abs(touch1.clientY - touch2.clientY);

       if (x >= y) {
         return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
       }
       return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
     },

     /**
      * calculate the distance between two touches
      * @param {Touch}touch1
      * @param {Touch} touch2
      * @return {Number} distance
      */
     getDistance: function getDistance(touch1, touch2) {
       var x = touch2.clientX - touch1.clientX,
           y = touch2.clientY - touch1.clientY;

       return Math.sqrt(x * x + y * y);
     },

     /**
      * calculate the scale factor between two touchLists
      * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
      * @param {Array} start array of touches
      * @param {Array} end array of touches
      * @return {Number} scale
      */
     getScale: function getScale(start, end) {
       // need two fingers...
       if (start.length >= 2 && end.length >= 2) {
         return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
       }
       return 1;
     },

     /**
      * calculate the rotation degrees between two touchLists
      * @param {Array} start array of touches
      * @param {Array} end array of touches
      * @return {Number} rotation
      */
     getRotation: function getRotation(start, end) {
       // need two fingers
       if (start.length >= 2 && end.length >= 2) {
         return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
       }
       return 0;
     },

     /**
      * find out if the direction is vertical   *
      * @param {String} direction matches `DIRECTION_UP|DOWN`
      * @return {Boolean} is_vertical
      */
     isVertical: function isVertical(direction) {
       return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
     },

     /**
      * set css properties with their prefixes
      * @param {HTMLElement} element
      * @param {String} prop
      * @param {String} value
      * @param {Boolean} [toggle=true]
      * @return {Boolean}
      */
     setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
       var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
       prop = Utils.toCamelCase(prop);

       for (var i = 0; i < prefixes.length; i++) {
         var p = prop;
         // prefixes
         if (prefixes[i]) {
           p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
         }

         // test the style
         if (p in element.style) {
           element.style[p] = (toggle === null || toggle) && value || '';
           break;
         }
       }
     },

     /**
      * toggle browser default behavior by setting css properties.
      * `userSelect='none'` also sets `element.onselectstart` to false
      * `userDrag='none'` also sets `element.ondragstart` to false
      *
      * @param {HtmlElement} element
      * @param {Object} props
      * @param {Boolean} [toggle=true]
      */
     toggleBehavior: function toggleBehavior(element, props, toggle) {
       if (!props || !element || !element.style) {
         return;
       }

       // set the css properties
       Utils.each(props, function (value, prop) {
         Utils.setPrefixedCss(element, prop, value, toggle);
       });

       var falseFn = toggle && function () {
         return false;
       };

       // also the disable onselectstart
       if (props.userSelect == 'none') {
         element.onselectstart = falseFn;
       }
       // and disable ondragstart
       if (props.userDrag == 'none') {
         element.ondragstart = falseFn;
       }
     },

     /**
      * convert a string with underscores to camelCase
      * so prevent_default becomes preventDefault
      * @param {String} str
      * @return {String} camelCaseStr
      */
     toCamelCase: function toCamelCase(str) {
       return str.replace(/[_-]([a-z])/g, function (s) {
         return s[1].toUpperCase();
       });
     }
   };

   /**
    * @module GestureDetector
    */
   /**
    * @class Event
    * @static
    */
   Event$1 = GestureDetector.event = {
     /**
      * when touch events have been fired, this is true
      * this is used to stop mouse events
      * @property prevent_mouseevents
      * @private
      * @type {Boolean}
      */
     preventMouseEvents: false,

     /**
      * if EVENT_START has been fired
      * @property started
      * @private
      * @type {Boolean}
      */
     started: false,

     /**
      * when the mouse is hold down, this is true
      * @property should_detect
      * @private
      * @type {Boolean}
      */
     shouldDetect: false,

     /**
      * simple event binder with a hook and support for multiple types
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      * @param {Function} [hook]
      * @param {Object} hook.type
      */
     on: function on(element, type, handler, hook) {
       var types = type.split(' ');
       Utils.each(types, function (type) {
         Utils.on(element, type, handler);
         hook && hook(type);
       });
     },

     /**
      * simple event unbinder with a hook and support for multiple types
      * @param {HTMLElement} element
      * @param {String} type
      * @param {Function} handler
      * @param {Function} [hook]
      * @param {Object} hook.type
      */
     off: function off(element, type, handler, hook) {
       var types = type.split(' ');
       Utils.each(types, function (type) {
         Utils.off(element, type, handler);
         hook && hook(type);
       });
     },

     /**
      * the core touch event handler.
      * this finds out if we should to detect gestures
      * @param {HTMLElement} element
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Function} handler
      * @return onTouchHandler {Function} the core event handler
      */
     onTouch: function onTouch(element, eventType, handler) {
       var self = this;

       var onTouchHandler = function onTouchHandler(ev) {
         var srcType = ev.type.toLowerCase(),
             isPointer = GestureDetector.HAS_POINTEREVENTS,
             isMouse = Utils.inStr(srcType, 'mouse'),
             triggerType;

         // if we are in a mouseevent, but there has been a touchevent triggered in this session
         // we want to do nothing. simply break out of the event.
         if (isMouse && self.preventMouseEvents) {
           return;

           // mousebutton must be down
         } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
             self.preventMouseEvents = false;
             self.shouldDetect = true;
           } else if (isPointer && eventType == EVENT_START) {
             self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
             // just a valid start event, but no mouse
           } else if (!isMouse && eventType == EVENT_START) {
               self.preventMouseEvents = true;
               self.shouldDetect = true;
             }

         // update the pointer event before entering the detection
         if (isPointer && eventType != EVENT_END) {
           PointerEvent.updatePointer(eventType, ev);
         }

         // we are in a touch/down state, so allowed detection of gestures
         if (self.shouldDetect) {
           triggerType = self.doDetect.call(self, ev, eventType, element, handler);
         }

         // ...and we are done with the detection
         // so reset everything to start each detection totally fresh
         if (triggerType == EVENT_END) {
           self.preventMouseEvents = false;
           self.shouldDetect = false;
           PointerEvent.reset();
           // update the pointerevent object after the detection
         }

         if (isPointer && eventType == EVENT_END) {
           PointerEvent.updatePointer(eventType, ev);
         }
       };

       this.on(element, EVENT_TYPES[eventType], onTouchHandler);
       return onTouchHandler;
     },

     /**
      * the core detection method
      * this finds out what GestureDetector-touch-events to trigger
      * @param {Object} ev
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {HTMLElement} element
      * @param {Function} handler
      * @return {String} triggerType matches `EVENT_START|MOVE|END`
      */
     doDetect: function doDetect(ev, eventType, element, handler) {
       var touchList = this.getTouchList(ev, eventType);
       var touchListLength = touchList.length;
       var triggerType = eventType;
       var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
       var changedLength = touchListLength;

       // at each touchstart-like event we want also want to trigger a TOUCH event...
       if (eventType == EVENT_START) {
         triggerChange = EVENT_TOUCH;
         // ...the same for a touchend-like event
       } else if (eventType == EVENT_END) {
           triggerChange = EVENT_RELEASE;

           // keep track of how many touches have been removed
           changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
         }

       // after there are still touches on the screen,
       // we just want to trigger a MOVE event. so change the START or END to a MOVE
       // but only after detection has been started, the first time we actually want a START
       if (changedLength > 0 && this.started) {
         triggerType = EVENT_MOVE;
       }

       // detection has been started, we keep track of this, see above
       this.started = true;

       // generate some event data, some basic information
       var evData = this.collectEventData(element, triggerType, touchList, ev);

       // trigger the triggerType event before the change (TOUCH, RELEASE) events
       // but the END event should be at last
       if (eventType != EVENT_END) {
         handler.call(Detection, evData);
       }

       // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
       if (triggerChange) {
         evData.changedLength = changedLength;
         evData.eventType = triggerChange;

         handler.call(Detection, evData);

         evData.eventType = triggerType;
         delete evData.changedLength;
       }

       // trigger the END event
       if (triggerType == EVENT_END) {
         handler.call(Detection, evData);

         // ...and we are done with the detection
         // so reset everything to start each detection totally fresh
         this.started = false;
       }

       return triggerType;
     },

     /**
      * we have different events for each device/browser
      * determine what we need and set them in the EVENT_TYPES constant
      * the `onTouch` method is bind to these properties.
      * @return {Object} events
      */
     determineEventTypes: function determineEventTypes() {
       var types;
       if (GestureDetector.HAS_POINTEREVENTS) {
         if (window.PointerEvent) {
           types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
         } else {
           types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
         }
       } else if (GestureDetector.NO_MOUSEEVENTS) {
         types = ['touchstart', 'touchmove', 'touchend touchcancel'];
       } else {
         types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
       }

       EVENT_TYPES[EVENT_START] = types[0];
       EVENT_TYPES[EVENT_MOVE] = types[1];
       EVENT_TYPES[EVENT_END] = types[2];
       return EVENT_TYPES;
     },

     /**
      * create touchList depending on the event
      * @param {Object} ev
      * @param {String} eventType
      * @return {Array} touches
      */
     getTouchList: function getTouchList(ev, eventType) {
       // get the fake pointerEvent touchlist
       if (GestureDetector.HAS_POINTEREVENTS) {
         return PointerEvent.getTouchList();
       }

       // get the touchlist
       if (ev.touches) {
         if (eventType == EVENT_MOVE) {
           return ev.touches;
         }

         var identifiers = [];
         var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
         var touchList = [];

         Utils.each(concat, function (touch) {
           if (Utils.inArray(identifiers, touch.identifier) === false) {
             touchList.push(touch);
           }
           identifiers.push(touch.identifier);
         });

         return touchList;
       }

       // make fake touchList from mouse position
       ev.identifier = 1;
       return [ev];
     },

     /**
      * collect basic event data
      * @param {HTMLElement} element
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Array} touches
      * @param {Object} ev
      * @return {Object} ev
      */
     collectEventData: function collectEventData(element, eventType, touches, ev) {
       // find out pointerType
       var pointerType = POINTER_TOUCH;
       if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
         pointerType = POINTER_MOUSE;
       } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
         pointerType = POINTER_PEN;
       }

       return {
         center: Utils.getCenter(touches),
         timeStamp: Date.now(),
         target: ev.target,
         touches: touches,
         eventType: eventType,
         pointerType: pointerType,
         srcEvent: ev,

         /**
          * prevent the browser default actions
          * mostly used to disable scrolling of the browser
          */
         preventDefault: function preventDefault() {
           var srcEvent = this.srcEvent;
           srcEvent.preventManipulation && srcEvent.preventManipulation();
           srcEvent.preventDefault && srcEvent.preventDefault();
         },

         /**
          * stop bubbling the event up to its parents
          */
         stopPropagation: function stopPropagation() {
           this.srcEvent.stopPropagation();
         },

         /**
          * immediately stop gesture detection
          * might be useful after a swipe was detected
          * @return {*}
          */
         stopDetect: function stopDetect() {
           return Detection.stopDetect();
         }
       };
     }
   };

   /**
    * @module GestureDetector
    *
    * @class PointerEvent
    * @static
    */
   PointerEvent = GestureDetector.PointerEvent = {
     /**
      * holds all pointers, by `identifier`
      * @property pointers
      * @type {Object}
      */
     pointers: {},

     /**
      * get the pointers as an array
      * @return {Array} touchlist
      */
     getTouchList: function getTouchList() {
       var touchlist = [];
       // we can use forEach since pointerEvents only is in IE10
       Utils.each(this.pointers, function (pointer) {
         touchlist.push(pointer);
       });
       return touchlist;
     },

     /**
      * update the position of a pointer
      * @param {String} eventType matches `EVENT_START|MOVE|END`
      * @param {Object} pointerEvent
      */
     updatePointer: function updatePointer(eventType, pointerEvent) {
       if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
         delete this.pointers[pointerEvent.pointerId];
       } else {
         pointerEvent.identifier = pointerEvent.pointerId;
         this.pointers[pointerEvent.pointerId] = pointerEvent;
       }
     },

     /**
      * check if ev matches pointertype
      * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
      * @param {PointerEvent} ev
      */
     matchType: function matchType(pointerType, ev) {
       if (!ev.pointerType) {
         return false;
       }

       var pt = ev.pointerType,
           types = {};

       types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
       types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
       types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
       return types[pointerType];
     },

     /**
      * reset the stored pointers
      */
     reset: function resetList() {
       this.pointers = {};
     }
   };

   /**
    * @module GestureDetector
    *
    * @class Detection
    * @static
    */
   Detection = GestureDetector.detection = {
     // contains all registered GestureDetector.gestures in the correct order
     gestures: [],

     // data of the current GestureDetector.gesture detection session
     current: null,

     // the previous GestureDetector.gesture session data
     // is a full clone of the previous gesture.current object
     previous: null,

     // when this becomes true, no gestures are fired
     stopped: false,

     /**
      * start GestureDetector.gesture detection
      * @param {GestureDetector.Instance} inst
      * @param {Object} eventData
      */
     startDetect: function startDetect(inst, eventData) {
       // already busy with a GestureDetector.gesture detection on an element
       if (this.current) {
         return;
       }

       this.stopped = false;

       // holds current session
       this.current = {
         inst: inst, // reference to GestureDetectorInstance we're working for
         startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
         lastEvent: false, // last eventData
         lastCalcEvent: false, // last eventData for calculations.
         futureCalcEvent: false, // last eventData for calculations.
         lastCalcData: {}, // last lastCalcData
         name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
       };

       this.detect(eventData);
     },

     /**
      * GestureDetector.gesture detection
      * @param {Object} eventData
      * @return {any}
      */
     detect: function detect(eventData) {
       if (!this.current || this.stopped) {
         return;
       }

       // extend event data with calculations about scale, distance etc
       eventData = this.extendEventData(eventData);

       // GestureDetector instance and instance options
       var inst = this.current.inst,
           instOptions = inst.options;

       // call GestureDetector.gesture handlers
       Utils.each(this.gestures, function triggerGesture(gesture) {
         // only when the instance options have enabled this gesture
         if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
           gesture.handler.call(gesture, eventData, inst);
         }
       }, this);

       // store as previous event event
       if (this.current) {
         this.current.lastEvent = eventData;
       }

       if (eventData.eventType == EVENT_END) {
         this.stopDetect();
       }

       return eventData; // eslint-disable-line consistent-return
     },

     /**
      * clear the GestureDetector.gesture vars
      * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
      * to stop other GestureDetector.gestures from being fired
      */
     stopDetect: function stopDetect() {
       // clone current data to the store as the previous gesture
       // used for the double tap gesture, since this is an other gesture detect session
       this.previous = Utils.extend({}, this.current);

       // reset the current
       this.current = null;
       this.stopped = true;
     },

     /**
      * calculate velocity, angle and direction
      * @param {Object} ev
      * @param {Object} center
      * @param {Number} deltaTime
      * @param {Number} deltaX
      * @param {Number} deltaY
      */
     getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
       var cur = this.current,
           recalc = false,
           calcEv = cur.lastCalcEvent,
           calcData = cur.lastCalcData;

       if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
         center = calcEv.center;
         deltaTime = ev.timeStamp - calcEv.timeStamp;
         deltaX = ev.center.clientX - calcEv.center.clientX;
         deltaY = ev.center.clientY - calcEv.center.clientY;
         recalc = true;
       }

       if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
         cur.futureCalcEvent = ev;
       }

       if (!cur.lastCalcEvent || recalc) {
         calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
         calcData.angle = Utils.getAngle(center, ev.center);
         calcData.direction = Utils.getDirection(center, ev.center);

         cur.lastCalcEvent = cur.futureCalcEvent || ev;
         cur.futureCalcEvent = ev;
       }

       ev.velocityX = calcData.velocity.x;
       ev.velocityY = calcData.velocity.y;
       ev.interimAngle = calcData.angle;
       ev.interimDirection = calcData.direction;
     },

     /**
      * extend eventData for GestureDetector.gestures
      * @param {Object} ev
      * @return {Object} ev
      */
     extendEventData: function extendEventData(ev) {
       var cur = this.current,
           startEv = cur.startEvent,
           lastEv = cur.lastEvent || startEv;

       // update the start touchlist to calculate the scale/rotation
       if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
         startEv.touches = [];
         Utils.each(ev.touches, function (touch) {
           startEv.touches.push({
             clientX: touch.clientX,
             clientY: touch.clientY
           });
         });
       }

       var deltaTime = ev.timeStamp - startEv.timeStamp,
           deltaX = ev.center.clientX - startEv.center.clientX,
           deltaY = ev.center.clientY - startEv.center.clientY;

       this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

       Utils.extend(ev, {
         startEvent: startEv,

         deltaTime: deltaTime,
         deltaX: deltaX,
         deltaY: deltaY,

         distance: Utils.getDistance(startEv.center, ev.center),
         angle: Utils.getAngle(startEv.center, ev.center),
         direction: Utils.getDirection(startEv.center, ev.center),
         scale: Utils.getScale(startEv.touches, ev.touches),
         rotation: Utils.getRotation(startEv.touches, ev.touches)
       });

       return ev;
     },

     /**
      * register new gesture
      * @param {Object} gesture object, see `gestures/` for documentation
      * @return {Array} gestures
      */
     register: function register(gesture) {
       // add an enable gesture options if there is no given
       var options = gesture.defaults || {};
       if (options[gesture.name] === undefined) {
         options[gesture.name] = true;
       }

       // extend GestureDetector default options with the GestureDetector.gesture options
       Utils.extend(GestureDetector.defaults, options, true);

       // set its index
       gesture.index = gesture.index || 1000;

       // add GestureDetector.gesture to the list
       this.gestures.push(gesture);

       // sort the list by index
       this.gestures.sort(function (a, b) {
         if (a.index < b.index) {
           return -1;
         }
         if (a.index > b.index) {
           return 1;
         }
         return 0;
       });

       return this.gestures;
     }
   };

   /**
    * @module GestureDetector
    */

   /**
    * create new GestureDetector instance
    * all methods should return the instance itself, so it is chainable.
    *
    * @class Instance
    * @constructor
    * @param {HTMLElement} element
    * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
    * @return {GestureDetector.Instance}
    */
   GestureDetector.Instance = function (element, options) {
     var self = this;

     // setup GestureDetectorJS window events and register all gestures
     // this also sets up the default options
     setup();

     /**
      * @property element
      * @type {HTMLElement}
      */
     this.element = element;

     /**
      * @property enabled
      * @type {Boolean}
      * @protected
      */
     this.enabled = true;

     /**
      * options, merged with the defaults
      * options with an _ are converted to camelCase
      * @property options
      * @type {Object}
      */
     Utils.each(options, function (value, name) {
       delete options[name];
       options[Utils.toCamelCase(name)] = value;
     });

     this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});

     // add some css to the element to prevent the browser from doing its native behavior
     if (this.options.behavior) {
       Utils.toggleBehavior(this.element, this.options.behavior, true);
     }

     /**
      * event start handler on the element to start the detection
      * @property eventStartHandler
      * @type {Object}
      */
     this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
       if (self.enabled && ev.eventType == EVENT_START) {
         Detection.startDetect(self, ev);
       } else if (ev.eventType == EVENT_TOUCH) {
         Detection.detect(ev);
       }
     });

     /**
      * keep a list of user event handlers which needs to be removed when calling 'dispose'
      * @property eventHandlers
      * @type {Array}
      */
     this.eventHandlers = [];
   };

   GestureDetector.Instance.prototype = {
     /**
      * @method on
      * @signature on(gestures, handler)
      * @description
      *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
      *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]
      * @param {String} gestures
      *   [en]A space separated list of gestures.[/en]
      *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
      * @param {Function} handler
      *   [en]An event handling function.[/en]
      *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
      */
     on: function onEvent(gestures, handler) {
       var self = this;
       Event$1.on(self.element, gestures, handler, function (type) {
         self.eventHandlers.push({ gesture: type, handler: handler });
       });
       return self;
     },

     /**
      * @method off
      * @signature off(gestures, handler)
      * @description
      *  [en]Remove an event listener.[/en]
      *  [ja]イベントリスナーを削除します。[/ja]
      * @param {String} gestures
      *   [en]A space separated list of gestures.[/en]
      *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
      * @param {Function} handler
      *   [en]An event handling function.[/en]
      *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
      */
     off: function offEvent(gestures, handler) {
       var self = this;

       Event$1.off(self.element, gestures, handler, function (type) {
         var index = Utils.inArray({ gesture: type, handler: handler });
         if (index !== false) {
           self.eventHandlers.splice(index, 1);
         }
       });
       return self;
     },

     /**
      * trigger gesture event
      * @method trigger
      * @signature trigger(gesture, eventData)
      * @param {String} gesture
      * @param {Object} [eventData]
      */
     trigger: function triggerEvent(gesture, eventData) {
       // optional
       if (!eventData) {
         eventData = {};
       }

       // create DOM event
       var event = GestureDetector.DOCUMENT.createEvent('Event');
       event.initEvent(gesture, true, true);
       event.gesture = eventData;

       // trigger on the target if it is in the instance element,
       // this is for event delegation tricks
       var element = this.element;
       if (Utils.hasParent(eventData.target, element)) {
         element = eventData.target;
       }

       element.dispatchEvent(event);
       return this;
     },

     /**
      * @method enable
      * @signature enable(state)
      * @description
      *  [en]Enable or disable gesture detection.[/en]
      *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]
      * @param {Boolean} state
      *   [en]Specify if it should be enabled or not.[/en]
      *   [ja]有効にするかどうかを指定します。[/ja]
      */
     enable: function enable(state) {
       this.enabled = state;
       return this;
     },

     /**
      * @method dispose
      * @signature dispose()
      * @description
      *  [en]Remove and destroy all event handlers for this instance.[/en]
      *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]
      */
     dispose: function dispose() {
       var i, eh;

       // undo all changes made by stop_browser_behavior
       Utils.toggleBehavior(this.element, this.options.behavior, false);

       // unbind all custom event handlers
       for (i = -1; eh = this.eventHandlers[++i];) {
         // eslint-disable-line no-cond-assign
         Utils.off(this.element, eh.gesture, eh.handler);
       }

       this.eventHandlers = [];

       // unbind the start event listener
       Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

       return null;
     }
   };

   /**
    * @module gestures
    */
   /**
    * Move with x fingers (default 1) around on the page.
    * Preventing the default browser behavior is a good way to improve feel and working.
    * ````
    *  GestureDetectortime.on("drag", function(ev) {
    *    console.log(ev);
    *    ev.gesture.preventDefault();
    *  });
    * ````
    *
    * @class Drag
    * @static
    */
   /**
    * @event drag
    * @param {Object} ev
    */
   /**
    * @event dragstart
    * @param {Object} ev
    */
   /**
    * @event dragend
    * @param {Object} ev
    */
   /**
    * @event drapleft
    * @param {Object} ev
    */
   /**
    * @event dragright
    * @param {Object} ev
    */
   /**
    * @event dragup
    * @param {Object} ev
    */
   /**
    * @event dragdown
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var triggered = false;

     function dragGesture(ev, inst) {
       var cur = Detection.current;

       // max touches
       if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
         return;
       }

       switch (ev.eventType) {
         case EVENT_START:
           triggered = false;
           break;

         case EVENT_MOVE:
           // when the distance we moved is too small we skip this gesture
           // or we can be already in dragging
           if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
             return;
           }

           var startCenter = cur.startEvent.center;

           // we are dragging!
           if (cur.name != name) {
             cur.name = name;
             if (inst.options.dragDistanceCorrection && ev.distance > 0) {
               // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
               // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
               // It might be useful to save the original start point somewhere
               var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
               startCenter.pageX += ev.deltaX * factor;
               startCenter.pageY += ev.deltaY * factor;
               startCenter.clientX += ev.deltaX * factor;
               startCenter.clientY += ev.deltaY * factor;

               // recalculate event data using new start point
               ev = Detection.extendEventData(ev);
             }
           }

           // lock drag to axis?
           if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
             ev.dragLockToAxis = true;
           }

           // keep direction on the axis that the drag gesture started on
           var lastDirection = cur.lastEvent.direction;
           if (ev.dragLockToAxis && lastDirection !== ev.direction) {
             if (Utils.isVertical(lastDirection)) {
               ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
             } else {
               ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
             }
           }

           // first time, trigger dragstart event
           if (!triggered) {
             inst.trigger(name + 'start', ev);
             triggered = true;
           }

           // trigger events
           inst.trigger(name, ev);
           inst.trigger(name + ev.direction, ev);

           var isVertical = Utils.isVertical(ev.direction);

           // block the browser events
           if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
             ev.preventDefault();
           }
           break;

         case EVENT_RELEASE:
           if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
             inst.trigger(name + 'end', ev);
             triggered = false;
           }
           break;

         case EVENT_END:
           triggered = false;
           break;
       }
     }

     GestureDetector.gestures.Drag = {
       name: name,
       index: 50,
       handler: dragGesture,
       defaults: {
         /**
          * minimal movement that have to be made before the drag event gets triggered
          * @property dragMinDistance
          * @type {Number}
          * @default 10
          */
         dragMinDistance: 10,

         /**
          * Set dragDistanceCorrection to true to make the starting point of the drag
          * be calculated from where the drag was triggered, not from where the touch started.
          * Useful to avoid a jerk-starting drag, which can make fine-adjustments
          * through dragging difficult, and be visually unappealing.
          * @property dragDistanceCorrection
          * @type {Boolean}
          * @default true
          */
         dragDistanceCorrection: true,

         /**
          * set 0 for unlimited, but this can conflict with transform
          * @property dragMaxTouches
          * @type {Number}
          * @default 1
          */
         dragMaxTouches: 1,

         /**
          * prevent default browser behavior when dragging occurs
          * be careful with it, it makes the element a blocking element
          * when you are using the drag gesture, it is a good practice to set this true
          * @property dragBlockHorizontal
          * @type {Boolean}
          * @default false
          */
         dragBlockHorizontal: false,

         /**
          * same as `dragBlockHorizontal`, but for vertical movement
          * @property dragBlockVertical
          * @type {Boolean}
          * @default false
          */
         dragBlockVertical: false,

         /**
          * dragLockToAxis keeps the drag gesture on the axis that it started on,
          * It disallows vertical directions if the initial direction was horizontal, and vice versa.
          * @property dragLockToAxis
          * @type {Boolean}
          * @default false
          */
         dragLockToAxis: false,

         /**
          * drag lock only kicks in when distance > dragLockMinDistance
          * This way, locking occurs only when the distance has become large enough to reliably determine the direction
          * @property dragLockMinDistance
          * @type {Number}
          * @default 25
          */
         dragLockMinDistance: 25
       }
     };
   })('drag');

   /**
    * @module gestures
    */
   /**
    * trigger a simple gesture event, so you can do anything in your handler.
    * only usable if you know what your doing...
    *
    * @class Gesture
    * @static
    */
   /**
    * @event gesture
    * @param {Object} ev
    */
   GestureDetector.gestures.Gesture = {
     name: 'gesture',
     index: 1337,
     handler: function releaseGesture(ev, inst) {
       inst.trigger(this.name, ev);
     }
   };

   /**
    * @module gestures
    */
   /**
    * Touch stays at the same place for x time
    *
    * @class Hold
    * @static
    */
   /**
    * @event hold
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var timer;

     function holdGesture(ev, inst) {
       var options = inst.options,
           current = Detection.current;

       switch (ev.eventType) {
         case EVENT_START:
           clearTimeout(timer);

           // set the gesture so we can check in the timeout if it still is
           current.name = name;

           // set timer and if after the timeout it still is hold,
           // we trigger the hold event
           timer = setTimeout(function () {
             if (current && current.name == name) {
               inst.trigger(name, ev);
             }
           }, options.holdTimeout);
           break;

         case EVENT_MOVE:
           if (ev.distance > options.holdThreshold) {
             clearTimeout(timer);
           }
           break;

         case EVENT_RELEASE:
           clearTimeout(timer);
           break;
       }
     }

     GestureDetector.gestures.Hold = {
       name: name,
       index: 10,
       defaults: {
         /**
          * @property holdTimeout
          * @type {Number}
          * @default 500
          */
         holdTimeout: 500,

         /**
          * movement allowed while holding
          * @property holdThreshold
          * @type {Number}
          * @default 2
          */
         holdThreshold: 2
       },
       handler: holdGesture
     };
   })('hold');

   /**
    * @module gestures
    */
   /**
    * when a touch is being released from the page
    *
    * @class Release
    * @static
    */
   /**
    * @event release
    * @param {Object} ev
    */
   GestureDetector.gestures.Release = {
     name: 'release',
     index: Infinity,
     handler: function releaseGesture(ev, inst) {
       if (ev.eventType == EVENT_RELEASE) {
         inst.trigger(this.name, ev);
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * triggers swipe events when the end velocity is above the threshold
    * for best usage, set `preventDefault` (on the drag gesture) to `true`
    * ````
    *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
    *    console.log(ev);
    *    ev.gesture.preventDefault();
    *  });
    * ````
    *
    * @class Swipe
    * @static
    */
   /**
    * @event swipe
    * @param {Object} ev
    */
   /**
    * @event swipeleft
    * @param {Object} ev
    */
   /**
    * @event swiperight
    * @param {Object} ev
    */
   /**
    * @event swipeup
    * @param {Object} ev
    */
   /**
    * @event swipedown
    * @param {Object} ev
    */
   GestureDetector.gestures.Swipe = {
     name: 'swipe',
     index: 40,
     defaults: {
       /**
        * @property swipeMinTouches
        * @type {Number}
        * @default 1
        */
       swipeMinTouches: 1,

       /**
        * @property swipeMaxTouches
        * @type {Number}
        * @default 1
        */
       swipeMaxTouches: 1,

       /**
        * horizontal swipe velocity
        * @property swipeVelocityX
        * @type {Number}
        * @default 0.6
        */
       swipeVelocityX: 0.6,

       /**
        * vertical swipe velocity
        * @property swipeVelocityY
        * @type {Number}
        * @default 0.6
        */
       swipeVelocityY: 0.6
     },

     handler: function swipeGesture(ev, inst) {
       if (ev.eventType == EVENT_RELEASE) {
         var touches = ev.touches.length,
             options = inst.options;

         // max touches
         if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
           return;
         }

         // when the distance we moved is too small we skip this gesture
         // or we can be already in dragging
         if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
           // trigger swipe events
           inst.trigger(this.name, ev);
           inst.trigger(this.name + ev.direction, ev);
         }
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * Single tap and a double tap on a place
    *
    * @class Tap
    * @static
    */
   /**
    * @event tap
    * @param {Object} ev
    */
   /**
    * @event doubletap
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var hasMoved = false;

     function tapGesture(ev, inst) {
       var options = inst.options,
           current = Detection.current,
           prev = Detection.previous,
           sincePrev,
           didDoubleTap;

       switch (ev.eventType) {
         case EVENT_START:
           hasMoved = false;
           break;

         case EVENT_MOVE:
           hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
           break;

         case EVENT_END:
           if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
             // previous gesture, for the double tap since these are two different gesture detections
             sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
             didDoubleTap = false;

             // check if double tap
             if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
               inst.trigger('doubletap', ev);
               didDoubleTap = true;
             }

             // do a single tap
             if (!didDoubleTap || options.tapAlways) {
               current.name = name;
               inst.trigger(current.name, ev);
             }
           }
           break;
       }
     }

     GestureDetector.gestures.Tap = {
       name: name,
       index: 100,
       handler: tapGesture,
       defaults: {
         /**
          * max time of a tap, this is for the slow tappers
          * @property tapMaxTime
          * @type {Number}
          * @default 250
          */
         tapMaxTime: 250,

         /**
          * max distance of movement of a tap, this is for the slow tappers
          * @property tapMaxDistance
          * @type {Number}
          * @default 10
          */
         tapMaxDistance: 10,

         /**
          * always trigger the `tap` event, even while double-tapping
          * @property tapAlways
          * @type {Boolean}
          * @default true
          */
         tapAlways: true,

         /**
          * max distance between two taps
          * @property doubleTapDistance
          * @type {Number}
          * @default 20
          */
         doubleTapDistance: 20,

         /**
          * max time between two taps
          * @property doubleTapInterval
          * @type {Number}
          * @default 300
          */
         doubleTapInterval: 300
       }
     };
   })('tap');

   /**
    * @module gestures
    */
   /**
    * when a touch is being touched at the page
    *
    * @class Touch
    * @static
    */
   /**
    * @event touch
    * @param {Object} ev
    */
   GestureDetector.gestures.Touch = {
     name: 'touch',
     index: -Infinity,
     defaults: {
       /**
        * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
        * but it improves gestures like transforming and dragging.
        * be careful with using this, it can be very annoying for users to be stuck on the page
        * @property preventDefault
        * @type {Boolean}
        * @default false
        */
       preventDefault: false,

       /**
        * disable mouse events, so only touch (or pen!) input triggers events
        * @property preventMouse
        * @type {Boolean}
        * @default false
        */
       preventMouse: false
     },
     handler: function touchGesture(ev, inst) {
       if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
         ev.stopDetect();
         return;
       }

       if (inst.options.preventDefault) {
         ev.preventDefault();
       }

       if (ev.eventType == EVENT_TOUCH) {
         inst.trigger('touch', ev);
       }
     }
   };

   /**
    * @module gestures
    */
   /**
    * User want to scale or rotate with 2 fingers
    * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
    * `preventDefault` option.
    *
    * @class Transform
    * @static
    */
   /**
    * @event transform
    * @param {Object} ev
    */
   /**
    * @event transformstart
    * @param {Object} ev
    */
   /**
    * @event transformend
    * @param {Object} ev
    */
   /**
    * @event pinchin
    * @param {Object} ev
    */
   /**
    * @event pinchout
    * @param {Object} ev
    */
   /**
    * @event rotate
    * @param {Object} ev
    */

   /**
    * @param {String} name
    */
   (function (name) {
     var triggered = false;

     function transformGesture(ev, inst) {
       switch (ev.eventType) {
         case EVENT_START:
           triggered = false;
           break;

         case EVENT_MOVE:
           // at least multitouch
           if (ev.touches.length < 2) {
             return;
           }

           var scaleThreshold = Math.abs(1 - ev.scale);
           var rotationThreshold = Math.abs(ev.rotation);

           // when the distance we moved is too small we skip this gesture
           // or we can be already in dragging
           if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
             return;
           }

           // we are transforming!
           Detection.current.name = name;

           // first time, trigger dragstart event
           if (!triggered) {
             inst.trigger(name + 'start', ev);
             triggered = true;
           }

           inst.trigger(name, ev); // basic transform event

           // trigger rotate event
           if (rotationThreshold > inst.options.transformMinRotation) {
             inst.trigger('rotate', ev);
           }

           // trigger pinch event
           if (scaleThreshold > inst.options.transformMinScale) {
             inst.trigger('pinch', ev);
             inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
           }
           break;

         case EVENT_RELEASE:
           if (triggered && ev.changedLength < 2) {
             inst.trigger(name + 'end', ev);
             triggered = false;
           }
           break;
       }
     }

     GestureDetector.gestures.Transform = {
       name: name,
       index: 45,
       defaults: {
         /**
          * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
          * @property transformMinScale
          * @type {Number}
          * @default 0.01
          */
         transformMinScale: 0.01,

         /**
          * rotation in degrees
          * @property transformMinRotation
          * @type {Number}
          * @default 1
          */
         transformMinRotation: 1
       },

       handler: transformGesture
     };
   })('transform');

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   /**
    * @object ons.platform
    * @category util
    * @description
    *   [en]Utility methods to detect current platform.[/en]
    *   [ja]現在実行されているプラットフォームを検知するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
    */

   var Platform = (function () {

     /**
      * All elements will be rendered as if the app was running on this platform.
      * @type {String}
      */

     function Platform() {
       babelHelpers.classCallCheck(this, Platform);

       this._renderPlatform = null;
     }

     /**
      * @method select
      * @signature select(platform)
      * @param  {string} platform Name of the platform.
      *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
      *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"のいずれかを指定します。[/ja]
      * @description
      *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
      *   [ja]要素を描画するために利用するプラットフォーム名を設定します。テストに便利です。[/ja]
      */

     babelHelpers.createClass(Platform, [{
       key: 'select',
       value: function select(platform) {
         if (typeof platform === 'string') {
           this._renderPlatform = platform.trim().toLowerCase();
         }
       }

       /**
        * @method isWebView
        * @signature isWebView()
        * @description
        *   [en]Returns whether app is running in Cordova.[/en]
        *   [ja]Cordova内で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isWebView',
       value: function isWebView() {
         if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
           throw new Error('isWebView() method is available after dom contents loaded.');
         }

         return !!(window.cordova || window.phonegap || window.PhoneGap);
       }

       /**
        * @method isIOS
        * @signature isIOS()
        * @description
        *   [en]Returns whether the OS is iOS.[/en]
        *   [ja]iOS上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIOS',
       value: function isIOS() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'ios';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/iOS/i.test(device.platform)
           );
         } else {
           return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isAndroid
        * @signature isAndroid()
        * @description
        *   [en]Returns whether the OS is Android.[/en]
        *   [ja]Android上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroid',
       value: function isAndroid() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'android';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/Android/i.test(device.platform)
           );
         } else {
           return (/Android/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isAndroidPhone
        * @signature isAndroidPhone()
        * @description
        *   [en]Returns whether the device is Android phone.[/en]
        *   [ja]Android携帯上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroidPhone',
       value: function isAndroidPhone() {
         return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isAndroidTablet
        * @signature isAndroidTablet()
        * @description
        *   [en]Returns whether the device is Android tablet.[/en]
        *   [ja]Androidタブレット上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isAndroidTablet',
       value: function isAndroidTablet() {
         return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
         );
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isWP',
       value: function isWP() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'wp';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/Win32NT|WinCE/i.test(device.platform)
           );
         } else {
           return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @methos isIPhone
        * @signature isIPhone()
        * @description
        *   [en]Returns whether the device is iPhone.[/en]
        *   [ja]iPhone上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIPhone',
       value: function isIPhone() {
         return (/iPhone/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isIPad
        * @signature isIPad()
        * @description
        *   [en]Returns whether the device is iPad.[/en]
        *   [ja]iPad上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIPad',
       value: function isIPad() {
         return (/iPad/i.test(navigator.userAgent)
         );
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isIPod',
       value: function isIPod() {
         return (/iPod/i.test(navigator.userAgent)
         );
       }

       /**
        * @method isBlackBerry
        * @signature isBlackBerry()
        * @description
        *   [en]Returns whether the device is BlackBerry.[/en]
        *   [ja]BlackBerry上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isBlackBerry',
       value: function isBlackBerry() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'blackberry';
         } else if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/BlackBerry/i.test(device.platform)
           );
         } else {
           return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
           );
         }
       }

       /**
        * @method isOpera
        * @signature isOpera()
        * @description
        *   [en]Returns whether the browser is Opera.[/en]
        *   [ja]Opera上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isOpera',
       value: function isOpera() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'opera';
         } else {
           return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
         }
       }

       /**
        * @method isFirefox
        * @signature isFirefox()
        * @description
        *   [en]Returns whether the browser is Firefox.[/en]
        *   [ja]Firefox上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isFirefox',
       value: function isFirefox() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'firefox';
         } else {
           return typeof InstallTrigger !== 'undefined';
         }
       }

       /**
        * @method isSafari
        * @signature isSafari()
        * @description
        *   [en]Returns whether the browser is Safari.[/en]
        *   [ja]Safari上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isSafari',
       value: function isSafari() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'safari';
         } else {
           return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
         }
       }

       /**
        * @method isChrome
        * @signature isChrome()
        * @description
        *   [en]Returns whether the browser is Chrome.[/en]
        *   [ja]Chrome上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isChrome',
       value: function isChrome() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'chrome';
         } else {
           return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
         }
       }

       /**
        * @method isIE
        * @signature isIE()
        * @description
        *   [en]Returns whether the browser is Internet Explorer.[/en]
        *   [ja]Internet Explorer上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIE',
       value: function isIE() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'ie';
         } else {
           return false || !!document.documentMode;
         }
       }

       /**
        * @method isEdge
        * @signature isEdge()
        * @description
        *   [en]Returns whether the browser is Edge.[/en]
        *   [ja]Edge上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isEdge',
       value: function isEdge() {
         if (this._renderPlatform) {
           return this._renderPlatform === 'edge';
         } else {
           return navigator.userAgent.indexOf(' Edge/') >= 0;
         }
       }

       /**
        * @method isIOS7above
        * @signature isIOS7above()
        * @description
        *   [en]Returns whether the iOS version is 7 or above.[/en]
        *   [ja]iOS7以上で実行されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isIOS7above',
       value: function isIOS7above() {
         if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
           return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
           );
         } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
           var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
           return parseInt(ver.split('.')[0]) >= 7;
         }
         return false;
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getMobileOS',
       value: function getMobileOS() {
         if (this.isAndroid()) {
           return 'android';
         } else if (this.isIOS()) {
           return 'ios';
         } else if (this.isWP()) {
           return 'wp';
         } else {
           return 'other';
         }
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getIOSDevice',
       value: function getIOSDevice() {
         if (this.isIPhone()) {
           return 'iphone';
         } else if (this.isIPad()) {
           return 'ipad';
         } else if (this.isIPod()) {
           return 'ipod';
         } else {
           return 'na';
         }
       }
     }]);
     return Platform;
   })();

   var platform = new Platform();

   /**
    * @object ons.notification
    * @category dialog
    * @codepen Qwwxyp
    * @description
    *   [en]Utility methods to create different kinds of alert dialogs. There are three methods available: alert, confirm and prompt.[/en]
    *   [ja]いくつかの種類のアラートダイアログを作成するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
    * @example
    * <script>
    *   ons.notification.alert({
    *     message: 'Hello, world!'
    *   });
    *
    *   // Show a Material Design alert dialog.
    *   ons.notification.alert({
    *    message: 'Hello, world!',
    *    modifier: 'material'
    *   });
    *
    *   ons.notification.confirm({
    *     message: 'Are you ready?',
    *     callback: function(answer) {
    *       // Do something here.
    *     }
    *   });
    *
    *   ons.notification.prompt({
    *     message: 'How old are you?',
    *     callback: function(age) {
    *       ons.notification.alert({
    *         message: 'You are ' + age + ' years old.'
    *       });
    *     });
    *   });
    * </script>
    */
   var notification = {};

   notification._createAlertDialog = function (title, message, buttonLabels, primaryButtonIndex, modifier, animation, id, _callback, messageIsHTML, cancelable, promptDialog, autofocus, placeholder, defaultValue, submitOnEnter, compile) {

     compile = compile || function (object) {
       return object;
     };

     var titleElementHTML = typeof title === 'string' ? '<div class="alert-dialog-title"></div>' : '';

     var dialogElement = util.createElement('\n  <ons-alert-dialog>\n    ' + titleElementHTML + '\n    <div class="alert-dialog-content"></div>\n    <div class="alert-dialog-footer"></div>\n  </ons-alert-dialog>');

     CustomElements.upgrade(dialogElement);

     if (id) {
       dialogElement.setAttribute('id', id);
     }

     var titleElement = dialogElement.querySelector('.alert-dialog-title');
     var messageElement = dialogElement.querySelector('.alert-dialog-content');
     var footerElement = dialogElement.querySelector('.alert-dialog-footer');
     var inputElement = undefined,
         result = {};

     result.promise = new Promise(function (resolve, reject) {
       result.resolve = resolve;
       result.reject = reject;
     });

     modifier = modifier || dialogElement.getAttribute('modifier');

     if (typeof title === 'string') {
       titleElement.textContent = title;
     }

     titleElement = null;

     dialogElement.setAttribute('animation', animation);

     if (messageIsHTML) {
       messageElement.innerHTML = message;
     } else {
       messageElement.textContent = message;
     }

     if (promptDialog) {
       inputElement = util.createElement('<input class="text-input" type="text"></input>');

       if (modifier) {
         inputElement.classList.add('text-input--' + modifier);
       }

       inputElement.setAttribute('placeholder', placeholder);
       inputElement.value = defaultValue;
       inputElement.style.width = '100%';
       inputElement.style.marginTop = '10px';

       messageElement.appendChild(inputElement);

       if (submitOnEnter) {
         inputElement.addEventListener('keypress', function (event) {
           if (event.keyCode === 13) {
             dialogElement.hide({
               callback: function callback() {
                 _callback(inputElement.value);
                 result.resolve(inputElement.value);
                 dialogElement.destroy();
                 dialogElement = null;
               }
             });
           }
         }, false);
       }
     }

     document.body.appendChild(dialogElement);

     compile(dialogElement);

     if (buttonLabels.length <= 2) {
       footerElement.classList.add('alert-dialog-footer--one');
     }

     var createButton = function createButton(i) {
       var buttonElement = util.createElement('<button class="alert-dialog-button"></button>');
       buttonElement.appendChild(document.createTextNode(buttonLabels[i]));

       if (i == primaryButtonIndex) {
         buttonElement.classList.add('alert-dialog-button--primal');
       }

       if (buttonLabels.length <= 2) {
         buttonElement.classList.add('alert-dialog-button--one');
       }

       var onClick = function onClick() {
         buttonElement.removeEventListener('click', onClick, false);

         dialogElement.hide({
           callback: function callback() {
             if (promptDialog) {
               _callback(inputElement.value);
               result.resolve(inputElement.value);
             } else {
               _callback(i);
               result.resolve(i);
             }
             dialogElement.destroy();
             dialogElement = inputElement = buttonElement = null;
           }
         });
       };

       buttonElement.addEventListener('click', onClick, false);
       footerElement.appendChild(buttonElement);
     };

     for (var i = 0; i < buttonLabels.length; i++) {
       createButton(i);
     }

     if (cancelable) {
       dialogElement.setCancelable(cancelable);
       dialogElement.addEventListener('cancel', function () {
         if (promptDialog) {
           _callback(null);
           result.reject(null);
         } else {
           _callback(-1);
           result.reject(-1);
         }
         setTimeout(function () {
           dialogElement.destroy();
           dialogElement = null;
           inputElement = null;
         });
       }, false);
     }

     dialogElement.show({
       callback: function callback() {
         if (inputElement && promptDialog && autofocus) {
           inputElement.focus();
         }
       }
     });

     messageElement = footerElement = null;

     if (modifier) {
       dialogElement.setAttribute('modifier', '');
       dialogElement.setAttribute('modifier', modifier);
     }

     return result.promise;
   };

   notification._alertOriginal = function (message) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     typeof message === 'string' ? options.message = message : options = message;

     var defaults = {
       buttonLabel: 'OK',
       animation: 'default',
       title: 'Alert',
       callback: function callback() {}
     };

     options = util.extend({}, defaults, options);
     if (!options.message && !options.messageHTML) {
       throw new Error('Alert dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, [options.buttonLabel], 0, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, false, false, false, '', '', false, options.compile);
   };

   /**
    * @method alert(options)
    * @param {Object} options
    *   [en]Parameter object.[/en]
    *   [ja]オプションを指定するオブジェクトです。[/ja]
    * @param {String} [options.message]
    *   [en]Alert message.[/en]
    *   [ja]アラートダイアログに表示する文字列を指定します。[/ja]
    * @param {String} [options.messageHTML]
    *   [en]Alert message in HTML.[/en]
    *   [ja]アラートダイアログに表示するHTMLを指定します。[/ja]
    * @param {String} [options.buttonLabel]
    *   [en]Label for confirmation button. Default is "OK".[/en]
    *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are "none", "fade" and "slide".[/en]
    *   [ja]アラートダイアログを表示する際のアニメーション名を指定します。"none", "fade", "slide"のいずれかを指定できます。[/ja]
    * @param {String} [options.id]
    *   [en]ons-alert-dialog element's ID.[/en]
    *   [ja]ons-alert-dialog要素のID。[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is "Alert".[/en]
    *   [ja]アラートダイアログの上部に表示するタイトルを指定します。"Alert"がデフォルトです。[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]アラートダイアログのmodifier属性の値を指定します。[/ja]
    * @param {Function} [options.callback]
    *   [en]Function that executes after dialog has been closed.[/en]
    *   [ja]アラートダイアログが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
    * @description
    *   [en]
    *     Display an alert dialog to show the user a message.
    *     The content of the message can be either simple text or HTML.
    *     Must specify either message or messageHTML.
    *   [/en]
    *   [ja]
    *     ユーザーへメッセージを見せるためのアラートダイアログを表示します。
    *     表示するメッセージは、テキストかもしくはHTMLを指定できます。
    *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
    *   [/ja]
    */
   notification.alert = notification._alertOriginal;

   notification._confirmOriginal = function (options) {
     var defaults = {
       buttonLabels: ['Cancel', 'OK'],
       primaryButtonIndex: 1,
       animation: 'default',
       title: 'Confirm',
       callback: function callback() {},
       cancelable: false
     };

     options = util.extend({}, defaults, options);

     if (!options.message && !options.messageHTML) {
       throw new Error('Confirm dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, options.buttonLabels, options.primaryButtonIndex, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, options.cancelable, false, false, '', '', false, options.compile);
   };

   /**
    * @method confirm
    * @signature confirm(options)
    * @param {Object} options
    *   [en]Parameter object.[/en]
    * @param {String} [options.message]
    *   [en]Confirmation question.[/en]
    *   [ja]確認ダイアログに表示するメッセージを指定します。[/ja]
    * @param {String} [options.messageHTML]
    *   [en]Dialog content in HTML.[/en]
    *   [ja]確認ダイアログに表示するHTMLを指定します。[/ja]
    * @param {Array} [options.buttonLabels]
    *   [en]Labels for the buttons. Default is ["Cancel", "OK"].[/en]
    *   [ja]ボタンのラベルの配列を指定します。["Cancel", "OK"]がデフォルトです。[/ja]
    * @param {Number} [options.primaryButtonIndex]
    *   [en]Index of primary button. Default is 1.[/en]
    *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 1 です。[/ja]
    * @param {Boolean} [options.cancelable]
    *   [en]Whether the dialog is cancelable or not. Default is false.[/en]
    *   [ja]ダイアログがキャンセル可能かどうかを指定します。[/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are "none", "fade" and "slide".[/en]
    *   [ja]アニメーション名を指定します。"none", "fade", "slide"のいずれかを指定します。[/ja]
    * @param {String} [options.id]
    *   [en]ons-alert-dialog element's ID.[/en]
    *   [ja]ons-alert-dialog要素のID。[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is "Confirm".[/en]
    *   [ja]ダイアログのタイトルを指定します。"Confirm"がデフォルトです。[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]ダイアログのmodifier属性の値を指定します。[/ja]
    * @param {Function} [options.callback]
    *   [en]
    *     Function that executes after the dialog has been closed.
    *     Argument for the function is the index of the button that was pressed or -1 if the dialog was canceled.
    *   [/en]
    *   [ja]
    *     ダイアログが閉じられた後に呼び出される関数オブジェクトを指定します。
    *     この関数の引数として、押されたボタンのインデックス値が渡されます。
    *     もしダイアログがキャンセルされた場合には-1が渡されます。
    *   [/ja]
    * @description
    *   [en]
    *     Display a dialog to ask the user for confirmation.
    *     The default button labels are "Cancel" and "OK" but they can be customized.
    *     Must specify either message or messageHTML.
    *   [/en]
    *   [ja]
    *     ユーザに確認を促すダイアログを表示します。
    *     デオルとのボタンラベルは、"Cancel"と"OK"ですが、これはこのメソッドの引数でカスタマイズできます。
    *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
    *   [/ja]
    */
   notification.confirm = notification._confirmOriginal;

   notification._promptOriginal = function (options) {
     var defaults = {
       buttonLabel: 'OK',
       animation: 'default',
       title: 'Alert',
       defaultValue: '',
       placeholder: '',
       callback: function callback() {},
       cancelable: false,
       autofocus: true,
       submitOnEnter: true
     };

     options = util.extend({}, defaults, options);
     if (!options.message && !options.messageHTML) {
       throw new Error('Prompt dialog must contain a message.');
     }

     return notification._createAlertDialog(options.title, options.message || options.messageHTML, [options.buttonLabel], 0, options.modifier, options.animation, options.id, options.callback, !options.message ? true : false, options.cancelable, true, options.autofocus, options.placeholder, options.defaultValue, options.submitOnEnter, options.compile);
   };

   /**
    * @method prompt
    * @signature prompt(options)
    * @return {Promise}
    * @param {Object} options
    *   [en]Parameter object.[/en]
    *   [ja]オプションを指定するオブジェクトです。[/ja]
    * @param {String} [options.message]
    *   [en]Prompt question.[/en]
    *   [ja]ダイアログに表示するメッセージを指定します。[/ja]
    * @param {String} [options.messageHTML]
    *   [en]Dialog content in HTML.[/en]
    *   [ja]ダイアログに表示するHTMLを指定します。[/ja]
    * @param {String} [options.buttonLabel]
    *   [en]Label for confirmation button. Default is "OK".[/en]
    *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
    * @param {Number} [options.primaryButtonIndex]
    *   [en]Index of primary button. Default is 1.[/en]
    *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 1 です。[/ja]
    * @param {Boolean} [options.cancelable]
    *   [en]Whether the dialog is cancelable or not. Default is false.[/en]
    *   [ja]ダイアログがキャンセル可能かどうかを指定します。デフォルトは false です。[/ja]
    * @param {String} [options.animation]
    *   [en]Animation name. Available animations are "none", "fade" and "slide".[/en]
    *   [ja]アニメーション名を指定します。"none", "fade", "slide"のいずれかを指定します。[/ja]
    * @param {String} [options.id]
    *   [en]ons-alert-dialog element's ID.[/en]
    *   [ja]ons-alert-dialog要素のID。[/ja]
    * @param {String} [options.title]
    *   [en]Dialog title. Default is "Alert".[/en]
    *   [ja]ダイアログのタイトルを指定します。デフォルトは "Alert" です。[/ja]
    * @param {String} [options.placeholder]
    *   [en]Placeholder for the text input.[/en]
    *   [ja]テキスト欄のプレースホルダに表示するテキストを指定します。[/ja]
    * @param {String} [options.defaultValue]
    *   [en]Default value for the text input.[/en]
    *   [ja]テキスト欄のデフォルトの値を指定します。[/ja]
    * @param {Boolean} [options.autofocus]
    *   [en]Autofocus the input element. Default is true.[/en]
    *   [ja]input要素に自動的にフォーカスするかどうかを指定します。デフォルトはtrueです。[/ja]
    * @param {String} [options.modifier]
    *   [en]Modifier for the dialog.[/en]
    *   [ja]ダイアログのmodifier属性の値を指定します。[/ja]
    * @param {Function} [options.callback]
    *   [en]
    *     Function that executes after the dialog has been closed.
    *     Argument for the function is the value of the input field or null if the dialog was canceled.
    *   [/en]
    *   [ja]
    *     ダイアログが閉じられた後に実行される関数オブジェクトを指定します。
    *     関数の引数として、インプット要素の中の値が渡されます。ダイアログがキャンセルされた場合には、nullが渡されます。
    *   [/ja]
    * @param {Boolean} [options.submitOnEnter]
    *   [en]Submit automatically when enter is pressed. Default is "true".[/en]
    *   [ja]Enterが押された際にそのformをsubmitするかどうかを指定します。デフォルトはtrueです。[/ja]
    * @description
    *   [en]
    *     Display a dialog with a prompt to ask the user a question.
    *     Must specify either message or messageHTML.
    *   [/en]
    *   [ja]
    *     ユーザーに入力を促すダイアログを表示します。
    *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
    *   [/ja]
    */
   notification.prompt = notification._promptOriginal;

   var pageAttributeExpression = {
     _variables: {},

     /**
      * Define a variable.
      *
      * @param {String} name Name of the variable
      * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
      * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
      */
     defineVariable: function defineVariable(name, value) {
       var overwrite = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

       if (typeof name !== 'string') {
         throw new Error('Variable name must be a string.');
       } else if (typeof value !== 'string' && typeof value !== 'function') {
         throw new Error('Variable value must be a string or a function.');
       } else if (this._variables.hasOwnProperty(name) && !overwrite) {
         throw new Error('"' + name + '" is already defined.');
       }
       this._variables[name] = value;
     },

     /**
      * Get a variable.
      *
      * @param {String} name Name of the variable.
      * @return {String|Function|null}
      */
     getVariable: function getVariable(name) {
       if (!this._variables.hasOwnProperty(name)) {
         return null;
       }

       return this._variables[name];
     },

     /**
      * Remove a variable.
      *
      * @param {String} name Name of the varaible.
      */
     removeVariable: function removeVariable(name) {
       delete this._variables[name];
     },

     /**
      * Get all variables.
      *
      * @return {Object}
      */
     getAllVariables: function getAllVariables() {
       return this._variables;
     },
     _parsePart: function _parsePart(part) {
       var c = undefined,
           inInterpolation = false,
           currentIndex = 0,
           tokens = [];

       if (part.length === 0) {
         throw new Error('Unable to parse empty string.');
       }

       for (var i = 0; i < part.length; i++) {
         c = part.charAt(i);

         if (c === '$' && part.charAt(i + 1) === '{') {
           if (inInterpolation) {
             throw new Error('Nested interpolation not supported.');
           }

           var token = part.substring(currentIndex, i);
           if (token.length > 0) {
             tokens.push(part.substring(currentIndex, i));
           }

           currentIndex = i;
           inInterpolation = true;
         } else if (c === '}') {
           if (!inInterpolation) {
             throw new Error('} must be preceeded by ${');
           }

           var token = part.substring(currentIndex, i + 1);
           if (token.length > 0) {
             tokens.push(part.substring(currentIndex, i + 1));
           }

           currentIndex = i + 1;
           inInterpolation = false;
         }
       }

       if (inInterpolation) {
         throw new Error('Unterminated interpolation.');
       }

       tokens.push(part.substring(currentIndex, part.length));

       return tokens;
     },
     _replaceToken: function _replaceToken(token) {
       var re = /^\${(.*?)}$/,
           match = token.match(re);

       if (match) {
         var name = match[1].trim(),
             variable = this.getVariable(name);

         if (variable === null) {
           throw new Error('Variable "' + name + '" does not exist.');
         } else if (typeof variable === 'string') {
           return variable;
         } else {
           var rv = variable();

           if (typeof rv !== 'string') {
             throw new Error('Must return a string.');
           }

           return rv;
         }
       } else {
         return token;
       }
     },
     _replaceTokens: function _replaceTokens(tokens) {
       return tokens.map(this._replaceToken.bind(this));
     },
     _parseExpression: function _parseExpression(expression) {
       return expression.split(',').map(function (part) {
         return part.trim();
       }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
         return part.join('');
       });
     },

     /**
      * Evaluate an expression.
      *
      * @param {String} expression An page attribute expression.
      * @return {Array}
      */
     evaluate: function evaluate(expression) {
       if (!expression) {
         return [];
       }

       return this._parseExpression(expression);
     }
   };

   // Define default variables.
   pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
   pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
   pageAttributeExpression.defineVariable('runtime', function () {
     return platform.isWebView() ? 'cordova' : 'browser';
   });

   var internal = {};

   internal.config = {
     autoStatusBarFill: true,
     animationsDisabled: false
   };

   internal.nullElement = window.document.createElement('div');

   /**
    * @return {Boolean}
    */
   internal.isEnabledAutoStatusBarFill = function () {
     return !!internal.config.autoStatusBarFill;
   };

   /**
    * @param {String} html
    * @return {String}
    */
   internal.normalizePageHTML = function (html) {
     html = ('' + html).trim();

     if (!html.match(/^<ons-page/)) {
       html = '<ons-page _muted>' + html + '</ons-page>';
     }

     return html;
   };

   internal.waitDOMContentLoaded = function (callback) {
     if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
       window.document.addEventListener('DOMContentLoaded', callback);
     } else {
       setImmediate(callback);
     }
   };

   /**
    * @param {HTMLElement} element
    * @return {Boolean}
    */
   internal.shouldFillStatusBar = function (element) {
     var checkStatusBar = function checkStatusBar() {
       if (internal.isEnabledAutoStatusBarFill() && platform.isWebView() && platform.isIOS7above()) {
         if (!(element instanceof HTMLElement)) {
           throw new Error('element must be an instance of HTMLElement');
         }

         for (;;) {
           if (element.hasAttribute('no-status-bar-fill')) {
             return false;
           }

           element = element.parentNode;
           if (!element || !element.hasAttribute) {
             return true;
           }
         }
       }
       return false;
     };

     return new Promise(function (resolve, reject) {
       if ((typeof device === 'undefined' ? 'undefined' : babelHelpers.typeof(device)) === 'object') {
         document.addEventListener('deviceready', function () {
           if (checkStatusBar()) {
             resolve();
           }
         });
       } else if (checkStatusBar()) {
         resolve();
       }
       reject();
     });
   };

   internal.templateStore = {
     _storage: {},

     /**
      * @param {String} key
      * @return {String/null} template
      */
     get: function get(key) {
       return internal.templateStore._storage[key] || null;
     },

     /**
      * @param {String} key
      * @param {String} template
      */
     set: function set(key, template) {
       internal.templateStore._storage[key] = template;
     }
   };

   window.document.addEventListener('_templateloaded', function (e) {
     if (e.target.nodeName.toLowerCase() === 'ons-template') {
       internal.templateStore.set(e.templateId, e.template);
     }
   }, false);

   window.document.addEventListener('DOMContentLoaded', function () {
     register('script[type="text/ons-template"]');
     register('script[type="text/template"]');
     register('script[type="text/ng-template"]');

     function register(query) {
       var templates = window.document.querySelectorAll(query);
       for (var i = 0; i < templates.length; i++) {
         internal.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent);
       }
     }
   }, false);

   /**
    * @param {String} page
    * @return {Promise}
    */
   internal.getTemplateHTMLAsync = function (page) {
     return new Promise(function (resolve, reject) {
       setImmediate(function () {
         var cache = internal.templateStore.get(page);

         if (cache) {
           var html = typeof cache === 'string' ? cache : cache[1];
           resolve(html);
         } else {
           (function () {
             var xhr = new XMLHttpRequest();
             xhr.open('GET', page, true);
             xhr.onload = function (response) {
               var html = xhr.responseText;
               if (xhr.status >= 400 && xhr.status < 600) {
                 reject(html);
               } else {
                 resolve(html);
               }
             };
             xhr.onerror = function () {
               throw new Error('The page is not found: ' + page);
             };
             xhr.send(null);
           })();
         }
       });
     });
   };

   /**
    * @param {String} page
    * @return {Promise}
    */
   internal.getPageHTMLAsync = function (page) {
     var pages = pageAttributeExpression.evaluate(page);

     var getPage = function getPage(page) {
       if (typeof page !== 'string') {
         return Promise.reject('Must specify a page.');
       }

       return internal.getTemplateHTMLAsync(page).then(function (html) {
         return internal.normalizePageHTML(html);
       }, function (error) {
         if (pages.length === 0) {
           return Promise.reject(error);
         }

         return getPage(pages.shift());
       }).then(function (html) {
         return internal.normalizePageHTML(html);
       });
     };

     return getPage(pages.shift());
   };

   var AnimatorFactory = (function () {

     /**
      * @param {Object} opts
      * @param {Object} opts.animators The dictionary for animator classes
      * @param {Function} opts.baseClass The base class of animators
      * @param {String} [opts.baseClassName] The name of the base class of animators
      * @param {String} [opts.defaultAnimation] The default animation name
      * @param {Object} [opts.defaultAnimationOptions] The default animation options
      */

     function AnimatorFactory(opts) {
       babelHelpers.classCallCheck(this, AnimatorFactory);

       this._animators = opts.animators;
       this._baseClass = opts.baseClass;
       this._baseClassName = opts.baseClassName || opts.baseClass.name;
       this._animation = opts.defaultAnimation || 'default';
       this._animationOptions = opts.defaultAnimationOptions || {};

       if (!this._animators[this._animation]) {
         throw new Error('No such animation: ' + this._animation);
       }
     }

     /**
      * @param {String} jsonString
      * @return {Object/null}
      */

     babelHelpers.createClass(AnimatorFactory, [{
       key: 'setAnimationOptions',

       /**
        * @param {Object} options
        */
       value: function setAnimationOptions(options) {
         this._animationOptions = options;
       }

       /**
        * @param {Object} options
        * @param {String} [options.animation] The animation name
        * @param {Object} [options.animationOptions] The animation options
        * @param {Object} defaultAnimator The default animator instance
        * @return {Object} An animator instance
        */

     }, {
       key: 'newAnimator',
       value: function newAnimator() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
         var defaultAnimator = arguments[1];

         var animator = null;

         if (options.animation instanceof this._baseClass) {
           return options.animation;
         }

         var Animator = null;

         if (typeof options.animation === 'string') {
           Animator = this._animators[options.animation];
         }

         if (!Animator && defaultAnimator) {
           animator = defaultAnimator;
         } else {
           Animator = Animator || this._animators[this._animation];

           var animationOpts = util.extend({}, this._animationOptions, options.animationOptions || {}, internal.config.animationsDisabled ? { duration: 0, delay: 0 } : {});

           animator = new Animator(animationOpts);

           if (typeof animator === 'function') {
             animator = new animator(animationOpts); // eslint-disable-line new-cap
           }
         }

         if (!(animator instanceof this._baseClass)) {
           throw new Error('"animator" is not an instance of ' + this._baseClassName + '.');
         }

         return animator;
       }
     }], [{
       key: 'parseAnimationOptionsString',
       value: function parseAnimationOptionsString(jsonString) {
         try {
           if (typeof jsonString === 'string') {
             var result = util.animationOptionsParse(jsonString);
             if ((typeof result === 'undefined' ? 'undefined' : babelHelpers.typeof(result)) === 'object' && result !== null) {
               return result;
             } else {
               console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
             }
           }
           return {};
         } catch (e) {
           console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
           return {};
         }
       }
     }]);
     return AnimatorFactory;
   })();

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var ModifierUtil = (function () {
     function ModifierUtil() {
       babelHelpers.classCallCheck(this, ModifierUtil);
     }

     babelHelpers.createClass(ModifierUtil, null, [{
       key: 'diff',

       /**
        * @param {String} last
        * @param {String} current
        */
       value: function diff(last, current) {
         last = makeDict(('' + last).trim());
         current = makeDict(('' + current).trim());

         var removed = Object.keys(last).reduce(function (result, token) {
           if (!current[token]) {
             result.push(token);
           }
           return result;
         }, []);

         var added = Object.keys(current).reduce(function (result, token) {
           if (!last[token]) {
             result.push(token);
           }
           return result;
         }, []);

         return { added: added, removed: removed };

         function makeDict(modifier) {
           var dict = {};
           ModifierUtil.split(modifier).forEach(function (token) {
             return dict[token] = token;
           });
           return dict;
         }
       }

       /**
        * @param {Object} diff
        * @param {Object} classList
        * @param {String} template
        */

     }, {
       key: 'applyDiffToClassList',
       value: function applyDiffToClassList(diff, classList, template) {
         diff.added.map(function (modifier) {
           return template.replace(/\*/g, modifier);
         }).forEach(function (klass) {
           return classList.add(klass);
         });

         diff.removed.map(function (modifier) {
           return template.replace(/\*/g, modifier);
         }).forEach(function (klass) {
           return classList.remove(klass);
         });
       }

       /**
        * @param {Object} diff
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'applyDiffToElement',
       value: function applyDiffToElement(diff, element, scheme) {
         var matches = function matches(e, s) {
           return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
         };
         for (var selector in scheme) {
           if (scheme.hasOwnProperty(selector)) {
             var targetElements = !selector || matches(element, selector) ? [element] : element.querySelectorAll(selector);
             for (var i = 0; i < targetElements.length; i++) {
               ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
             }
           }
         }
       }

       /**
        * @param {String} last
        * @param {String} current
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'onModifierChanged',
       value: function onModifierChanged(last, current, element, scheme) {
         return ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
       }

       /**
        * @param {HTMLElement} element
        * @param {Object} scheme
        */

     }, {
       key: 'initModifier',
       value: function initModifier(element, scheme) {
         var modifier = element.getAttribute('modifier');
         if (typeof modifier !== 'string') {
           return;
         }

         ModifierUtil.applyDiffToElement({
           removed: [],
           added: ModifierUtil.split(modifier)
         }, element, scheme);
       }
     }, {
       key: 'split',
       value: function split(modifier) {
         if (typeof modifier !== 'string') {
           return [];
         }

         return modifier.trim().split(/ +/).filter(function (token) {
           return token !== '';
         });
       }
     }]);
     return ModifierUtil;
   })();

   /* eslint-disable key-spacing */
   var scheme = {
     createItemContent: { type: 'function', returns: Element },
     countItems: { type: 'function', returns: 'number' },
     calculateItemHeight: { type: 'function', returns: 'number' },
     updateItemContent: { type: 'function', safeCall: true },
     destroy: { type: 'function', safeCall: true },
     destroyItem: { type: 'function', safeCall: true }
   };
   /* eslint-enable key-spacing */

   var LazyRepeatDelegate = (function () {
     function LazyRepeatDelegate(userDelegate) {
       var templateElement = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
       babelHelpers.classCallCheck(this, LazyRepeatDelegate);

       this._userDelegate = util.validated('delegate', userDelegate, 'object');
       this._templateElement = util.validated('templateElement', templateElement, [Element, 'null']);
     }

     babelHelpers.createClass(LazyRepeatDelegate, [{
       key: '_validated',
       value: function _validated(key) {
         var _scheme = arguments.length <= 1 || arguments[1] === undefined ? scheme : arguments[1];

         return util.validated(key, null, util.extend({}, _scheme[key], {
           dynamicCall: { object: this._userDelegate, key: key }
         }));
       }

       /**
        * @param {Number}
        * @param {Function} done A function that take item object as parameter.
        */

     }, {
       key: 'prepareItem',
       value: function prepareItem(index, done) {
         return done({
           element: this._validated('createItemContent')(index, this._templateElement)
         });
       }

       /**
        * @return {Number}
        */

     }, {
       key: 'countItems',
       value: function countItems() {
         return this._validated('countItems')();
       }

       /**
        * @param {Number} index
        * @param {Object} item
        * @param {Element} item.element
        */

     }, {
       key: 'updateItem',
       value: function updateItem(index, item) {
         return this._validated('updateItemContent')(index, item);
       }

       /**
        * @return {Number}
        */

     }, {
       key: 'calculateItemHeight',
       value: function calculateItemHeight(index) {
         return this._validated('calculateItemHeight')(index);
       }

       /**
        * @param {Number} index
        * @param {Object} item
        */

     }, {
       key: 'destroyItem',
       value: function destroyItem(index, item) {
         return this._validated('destroyItem')(index, item);
       }

       /**
        * @return {void}
        */

     }, {
       key: 'destroy',
       value: function destroy() {
         this._validated('destroy')();
         this._userDelegate = this._templateElement = null;
       }
     }, {
       key: 'itemHeight',
       get: function get() {
         return this._userDelegate.itemHeight;
       }
     }]);
     return LazyRepeatDelegate;
   })();

   /**
    * This class provide core functions for ons-lazy-repeat.
    */
   var LazyRepeatProvider = (function () {

     /**
      * @param {Element} wrapperElement
      * @param {LazyRepeatDelegate} delegate
      */

     function LazyRepeatProvider(wrapperElement, delegate) {
       babelHelpers.classCallCheck(this, LazyRepeatProvider);

       this._wrapperElement = util.validated('wrapperElement', wrapperElement, Element);
       this._delegate = util.validated('delegate', delegate, LazyRepeatDelegate);

       if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
         wrapperElement.classList.add('lazy-list');
       }

       // to be removed soon
       this._pageContent = util.findParent(wrapperElement, '.ons-scroller__content');

       if (!this._pageContent) {
         this._pageContent = util.findParent(wrapperElement, '.page__content');
       }

       if (!this._pageContent) {
         throw new Error('ons-lazy-repeat must be a descendant of an <ons-page> or an <ons-scroller> element.');
       }

       this._topPositions = [];
       this._renderedItems = {};

       try {
         this._delegate.itemHeight || this._delegate.calculateItemHeight(0);
       } catch (e) {
         if (!/must be (a|an instance of) function/.test('' + e)) {
           throw e;
         }
         this._unknownItemHeight = true;
       }
       this._addEventListeners();
       this._onChange();
     }

     babelHelpers.createClass(LazyRepeatProvider, [{
       key: '_checkItemHeight',
       value: function _checkItemHeight(callback) {
         var _this = this;

         this._delegate.prepareItem(0, function (_ref) {
           var element = _ref.element;

           if (_this._unknownItemHeight) {
             _this._wrapperElement.appendChild(element);
             _this._itemHeight = element.offsetHeight;
             _this._wrapperElement.removeChild(element);
             delete _this._unknownItemHeight;
             callback();
           }
         });
       }
     }, {
       key: '_countItems',
       value: function _countItems() {
         return this._delegate.countItems();
       }
     }, {
       key: '_getItemHeight',
       value: function _getItemHeight(i) {
         return this.staticItemHeight || this._delegate.calculateItemHeight(i);
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         this._render();
       }
     }, {
       key: 'refresh',
       value: function refresh() {
         this._removeAllElements();
         this._onChange();
       }
     }, {
       key: '_render',
       value: function _render() {
         var _this2 = this;

         if (this._unknownItemHeight) {
           return this._checkItemHeight(this._render.bind(this));
         }

         var items = this._getItemsInView();
         var keep = {};

         items.forEach(function (item) {
           _this2._renderElement(item);
           keep[item.index] = true;
         });

         Object.keys(this._renderedItems).forEach(function (key) {
           return keep[key] || _this2._removeElement(key);
         });

         this._wrapperElement.style.height = this._listHeight + 'px';
       }

       /**
        * @param {Object} item
        * @param {Number} item.index
        * @param {Number} item.top
        */

     }, {
       key: '_renderElement',
       value: function _renderElement(_ref2) {
         var _this3 = this;

         var index = _ref2.index;
         var top = _ref2.top;

         var item = this._renderedItems[index];
         if (item) {
           this._delegate.updateItem(index, item); // update if it exists
           item.element.style.top = top + 'px';
           return;
         }

         this._delegate.prepareItem(index, function (item) {
           util.extend(item.element.style, {
             position: 'absolute',
             top: top + 'px',
             left: 0,
             right: 0
           });

           _this3._wrapperElement.appendChild(item.element);
           _this3._renderedItems[index] = item;
         });
       }

       /**
        * @param {Number} index
        */

     }, {
       key: '_removeElement',
       value: function _removeElement(index) {
         var item = this._renderedItems[index];

         this._delegate.destroyItem(index, item);

         if (item.element.parentElement) {
           item.element.parentElement.removeChild(item.element);
         }

         delete this._renderedItems[index];
       }
     }, {
       key: '_removeAllElements',
       value: function _removeAllElements() {
         var _this4 = this;

         Object.keys(this._renderedItems).forEach(function (key) {
           return _this4._removeElement(key);
         });
       }
     }, {
       key: '_calculateStartIndex',
       value: function _calculateStartIndex(current) {
         var start = 0;
         var end = this._itemCount - 1;

         if (this.staticItemHeight) {
           return parseInt(-current / this.staticItemHeight);
         }

         // Binary search for index at top of screen so we can speed up rendering.
         for (;;) {
           var middle = Math.floor((start + end) / 2);
           var value = current + this._topPositions[middle];

           if (end < start) {
             return 0;
           } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
             return middle;
           } else if (isNaN(value) || value >= 0) {
             end = middle - 1;
           } else {
             start = middle + 1;
           }
         }
       }
     }, {
       key: '_recalculateTopPositions',
       value: function _recalculateTopPositions() {
         var l = Math.min(this._topPositions.length, this._itemCount);
         this._topPositions[0] = 0;
         for (var i = 1, _l; i < _l; i++) {
           this._topPositions[i] = this._topPositions[i - 1] + this._getItemHeight(i);
         }
       }
     }, {
       key: '_getItemsInView',
       value: function _getItemsInView() {
         var offset = this._wrapperElement.getBoundingClientRect().top;
         var limit = 4 * window.innerHeight - offset;
         var count = this._countItems();

         if (count !== this._itemCount) {
           this._itemCount = count;
           this._recalculateTopPositions();
         }

         var i = Math.max(0, this._calculateStartIndex(offset) - 30);

         var items = [];
         for (var top = this._topPositions[i]; i < count && top < limit; i++) {
           if (i >= this._topPositions.length) {
             // perf optimization
             this._topPositions.length += 100;
           }

           this._topPositions[i] = top;
           items.push({ top: top, index: i });
           top += this._getItemHeight(i);
         }
         this._listHeight = top;

         return items;
       }
     }, {
       key: '_debounce',
       value: function _debounce(func, wait, immediate) {
         var timeout = undefined;
         return function () {
           var _this5 = this,
               _arguments = arguments;

           var callNow = immediate && !timeout;
           clearTimeout(timeout);
           if (callNow) {
             func.apply(this, arguments);
           } else {
             timeout = setTimeout(function () {
               timeout = null;
               func.apply(_this5, _arguments);
             }, wait);
           }
         };
       }
     }, {
       key: '_doubleFireOnTouchend',
       value: function _doubleFireOnTouchend() {
         this._render();
         this._debounce(this._render.bind(this), 100);
       }
     }, {
       key: '_addEventListeners',
       value: function _addEventListeners() {
         util.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);

         if (platform.isIOS()) {
           this._boundOnChange = this._debounce(this._boundOnChange, 30);
         }

         this._pageContent.addEventListener('scroll', this._boundOnChange, true);

         if (platform.isIOS()) {
           this._pageContent.addEventListener('touchmove', this._boundOnChange, true);
           this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
         }

         window.document.addEventListener('resize', this._boundOnChange, true);
       }
     }, {
       key: '_removeEventListeners',
       value: function _removeEventListeners() {
         this._pageContent.removeEventListener('scroll', this._boundOnChange, true);

         if (platform.isIOS()) {
           this._pageContent.removeEventListener('touchmove', this._boundOnChange, true);
           this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
         }

         window.document.removeEventListener('resize', this._boundOnChange, true);
       }
     }, {
       key: 'destroy',
       value: function destroy() {
         this._removeAllElements();
         this._delegate.destroy();
         this._parentElement = this._delegate = this._renderedItems = null;
         this._removeEventListeners();
       }
     }, {
       key: 'staticItemHeight',
       get: function get() {
         return this._delegate.itemHeight || this._itemHeight;
       }
     }]);
     return LazyRepeatProvider;
   })();

   internal.AnimatorFactory = AnimatorFactory;
   internal.ModifierUtil = ModifierUtil;
   internal.LazyRepeatProvider = LazyRepeatProvider;
   internal.LazyRepeatDelegate = LazyRepeatDelegate;

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var create = function create() {

     /**
      * @object ons.orientation
      * @category util
      * @description
      *   [en]Utility methods for orientation detection.[/en]
      *   [ja]画面のオリエンテーション検知のためのユーティリティメソッドを収めているオブジェクトです。[/ja]
      */
     var obj = {
       /**
        * @event change
        * @description
        *   [en]Fired when the device orientation changes.[/en]
        *   [ja]デバイスのオリエンテーションが変化した際に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクトです。[/ja]
        * @param {Boolean} event.isPortrait
        *   [en]Will be true if the current orientation is portrait mode.[/en]
        *   [ja]現在のオリエンテーションがportraitの場合にtrueを返します。[/ja]
        */

       /**
        * @method on
        * @signature on(eventName, listener)
        * @description
        *   [en]Add an event listener.[/en]
        *   [ja]イベントリスナーを追加します。[/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja]イベント名を指定します。[/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja]このイベントが発火された際に呼び出される関数オブジェクトを指定します。[/ja]
        */

       /**
        * @method once
        * @signature once(eventName, listener)
        * @description
        *  [en]Add an event listener that's only triggered once.[/en]
        *  [ja]一度だけ呼び出されるイベントリスナーを追加します。[/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja]イベント名を指定します。[/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja]イベントが発火した際に呼び出される関数オブジェクトを指定します。[/ja]
        */

       /**
        * @method off
        * @signature off(eventName, [listener])
        * @description
        *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
        *  [ja]イベントリスナーを削除します。もしイベントリスナーを指定しなかった場合には、そのイベントに紐づく全てのイベントリスナーが削除されます。[/ja]
        * @param {String} eventName
        *   [en]Name of the event.[/en]
        *   [ja]イベント名を指定します。[/ja]
        * @param {Function} listener
        *   [en]Function to execute when the event is triggered.[/en]
        *   [ja]削除するイベントリスナーを指定します。[/ja]
        */

       // actual implementation to detect if whether current screen is portrait or not
       _isPortrait: false,

       /**
        * @method isPortrait
        * @signature isPortrait()
        * @return {Boolean}
        *   [en]Will be true if the current orientation is portrait mode.[/en]
        *   [ja]オリエンテーションがportraitモードの場合にtrueになります。[/ja]
        * @description
        *   [en]Returns whether the current screen orientation is portrait or not.[/en]
        *   [ja]オリエンテーションがportraitモードかどうかを返します。[/ja]
        */
       isPortrait: function isPortrait() {
         return this._isPortrait();
       },

       /**
        * @method isLandscape
        * @signature isLandscape()
        * @return {Boolean}
        *   [en]Will be true if the current orientation is landscape mode.[/en]
        *   [ja]オリエンテーションがlandscapeモードの場合にtrueになります。[/ja]
        * @description
        *   [en]Returns whether the current screen orientation is landscape or not.[/en]
        *   [ja]オリエンテーションがlandscapeモードかどうかを返します。[/ja]
        */
       isLandscape: function isLandscape() {
         return !this.isPortrait();
       },

       _init: function _init() {
         document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);

         if ('orientation' in window) {
           window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
         } else {
           window.addEventListener('resize', this._onResize.bind(this), false);
         }

         this._isPortrait = function () {
           return window.innerHeight > window.innerWidth;
         };

         return this;
       },

       _onDOMContentLoaded: function _onDOMContentLoaded() {
         this._installIsPortraitImplementation();
         this.emit('change', { isPortrait: this.isPortrait() });
       },

       _installIsPortraitImplementation: function _installIsPortraitImplementation() {
         var isPortrait = window.innerWidth < window.innerHeight;

         if (!('orientation' in window)) {
           this._isPortrait = function () {
             return window.innerHeight > window.innerWidth;
           };
         } else if (window.orientation % 180 === 0) {
           this._isPortrait = function () {
             return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
           };
         } else {
           this._isPortrait = function () {
             return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
           };
         }
       },

       _onOrientationChange: function _onOrientationChange() {
         var _this = this;

         var isPortrait = this._isPortrait();

         // Wait for the dimensions to change because
         // of Android inconsistency.
         var nIter = 0;
         var interval = setInterval(function () {
           nIter++;

           var w = window.innerWidth;
           var h = window.innerHeight;

           if (isPortrait && w <= h || !isPortrait && w >= h) {
             _this.emit('change', { isPortrait: isPortrait });
             clearInterval(interval);
           } else if (nIter === 50) {
             _this.emit('change', { isPortrait: isPortrait });
             clearInterval(interval);
           }
         }, 20);
       },

       // Run on not mobile browser.
       _onResize: function _onResize() {
         this.emit('change', { isPortrait: this.isPortrait() });
       }
     };

     MicroEvent.mixin(obj);

     return obj;
   };

   var orientation = create()._init();

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var softwareKeyboard = new MicroEvent();
   softwareKeyboard._visible = false;

   var onShow = function onShow() {
     softwareKeyboard._visible = true;
     softwareKeyboard.emit('show');
   };

   var onHide = function onHide() {
     softwareKeyboard._visible = false;
     softwareKeyboard.emit('hide');
   };

   var bindEvents = function bindEvents() {
     if (typeof Keyboard !== 'undefined') {
       // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
       Keyboard.onshow = onShow;
       Keyboard.onhide = onHide;
       softwareKeyboard.emit('init', { visible: Keyboard.isVisible });

       return true;
     } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
       // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
       window.addEventListener('native.keyboardshow', onShow);
       window.addEventListener('native.keyboardhide', onHide);
       softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });

       return true;
     }

     return false;
   };

   var noPluginError = function noPluginError() {
     console.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
   };

   document.addEventListener('deviceready', function () {
     if (!bindEvents()) {
       if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
         noPluginError();
       }

       softwareKeyboard.on = noPluginError;
     }
   });

   var util$1 = {
     _ready: false,

     _domContentLoaded: false,

     _onDOMContentLoaded: function _onDOMContentLoaded() {
       util$1._domContentLoaded = true;

       if (platform.isWebView()) {
         window.document.addEventListener('deviceready', function () {
           util$1._ready = true;
         }, false);
       } else {
         util$1._ready = true;
       }
     },

     addBackButtonListener: function addBackButtonListener(fn) {
       if (!this._domContentLoaded) {
         throw new Error('This method is available after DOMContentLoaded');
       }

       if (this._ready) {
         window.document.addEventListener('backbutton', fn, false);
       } else {
         window.document.addEventListener('deviceready', function () {
           window.document.addEventListener('backbutton', fn, false);
         });
       }
     },

     removeBackButtonListener: function removeBackButtonListener(fn) {
       if (!this._domContentLoaded) {
         throw new Error('This method is available after DOMContentLoaded');
       }

       if (this._ready) {
         window.document.removeEventListener('backbutton', fn, false);
       } else {
         window.document.addEventListener('deviceready', function () {
           window.document.removeEventListener('backbutton', fn, false);
         });
       }
     }
   };
   window.addEventListener('DOMContentLoaded', function () {
     return util$1._onDOMContentLoaded();
   }, false);

   var HandlerRepository = {
     _store: {},

     _genId: (function () {
       var i = 0;
       return function () {
         return i++;
       };
     })(),

     set: function set(element, handler) {
       if (element.dataset.deviceBackButtonHandlerId) {
         this.remove(element);
       }
       var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
       this._store[id] = handler;
     },

     remove: function remove(element) {
       if (element.dataset.deviceBackButtonHandlerId) {
         delete this._store[element.dataset.deviceBackButtonHandlerId];
         delete element.dataset.deviceBackButtonHandlerId;
       }
     },

     get: function get(element) {
       if (!element.dataset.deviceBackButtonHandlerId) {
         return undefined;
       }

       var id = element.dataset.deviceBackButtonHandlerId;

       if (!this._store[id]) {
         throw new Error();
       }

       return this._store[id];
     },

     has: function has(element) {
       var id = element.dataset.deviceBackButtonHandlerId;

       return !!this._store[id];
     }
   };

   var DeviceBackButtonDispatcher = (function () {
     function DeviceBackButtonDispatcher() {
       babelHelpers.classCallCheck(this, DeviceBackButtonDispatcher);

       this._isEnabled = false;
       this._boundCallback = this._callback.bind(this);
     }

     /**
      * Enable to handle 'backbutton' events.
      */

     babelHelpers.createClass(DeviceBackButtonDispatcher, [{
       key: 'enable',
       value: function enable() {
         if (!this._isEnabled) {
           util$1.addBackButtonListener(this._boundCallback);
           this._isEnabled = true;
         }
       }

       /**
        * Disable to handle 'backbutton' events.
        */

     }, {
       key: 'disable',
       value: function disable() {
         if (this._isEnabled) {
           util$1.removeBackButtonListener(this._boundCallback);
           this._isEnabled = false;
         }
       }

       /**
        * Fire a 'backbutton' event manually.
        */

     }, {
       key: 'fireDeviceBackButtonEvent',
       value: function fireDeviceBackButtonEvent() {
         var event = document.createEvent('Event');
         event.initEvent('backbutton', true, true);
         document.dispatchEvent(event);
       }
     }, {
       key: '_callback',
       value: function _callback() {
         this._dispatchDeviceBackButtonEvent();
       }

       /**
        * @param {HTMLElement} element
        * @param {Function} callback
        */

     }, {
       key: 'createHandler',
       value: function createHandler(element, callback) {
         if (!(element instanceof HTMLElement)) {
           throw new Error('element must be an instance of HTMLElement');
         }

         if (!(callback instanceof Function)) {
           throw new Error('callback must be an instance of Function');
         }

         var handler = {
           _callback: callback,
           _element: element,

           disable: function disable() {
             HandlerRepository.remove(element);
           },

           setListener: function setListener(callback) {
             this._callback = callback;
           },

           enable: function enable() {
             HandlerRepository.set(element, this);
           },

           isEnabled: function isEnabled() {
             return HandlerRepository.get(element) === this;
           },

           destroy: function destroy() {
             HandlerRepository.remove(element);
             this._callback = this._element = null;
           }
         };

         handler.enable();

         return handler;
       }
     }, {
       key: '_dispatchDeviceBackButtonEvent',
       value: function _dispatchDeviceBackButtonEvent() {
         var tree = this._captureTree();

         var element = this._findHandlerLeafElement(tree);

         var handler = HandlerRepository.get(element);
         handler._callback(createEvent(element));

         function createEvent(element) {
           return {
             _element: element,
             callParentHandler: function callParentHandler() {
               var parent = this._element.parentNode;

               while (parent) {
                 handler = HandlerRepository.get(parent);
                 if (handler) {
                   return handler._callback(createEvent(parent));
                 }
                 parent = parent.parentNode;
               }
             }
           };
         }
       }

       /**
        * @return {Object}
        */

     }, {
       key: '_captureTree',
       value: function _captureTree() {
         return createTree(document.body);

         function createTree(element) {
           return {
             element: element,
             children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {

               if (childElement.style.display === 'none') {
                 return [];
               }

               if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
                 return [];
               }

               var result = createTree(childElement);

               if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
                 return [];
               }

               return [result];
             }))
           };
         }

         function arrayOf(target) {
           var result = [];
           for (var i = 0; i < target.length; i++) {
             result.push(target[i]);
           }
           return result;
         }
       }

       /**
        * @param {Object} tree
        * @return {HTMLElement}
        */

     }, {
       key: '_findHandlerLeafElement',
       value: function _findHandlerLeafElement(tree) {
         return find(tree);

         function find(node) {
           if (node.children.length === 0) {
             return node.element;
           }

           if (node.children.length === 1) {
             return find(node.children[0]);
           }

           return node.children.map(function (childNode) {
             return childNode.element;
           }).reduce(function (left, right) {
             if (!left) {
               return right;
             }

             var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
             var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);

             if (!isNaN(leftZ) && !isNaN(rightZ)) {
               return leftZ > rightZ ? left : right;
             }

             throw new Error('Capturing backbutton-handler is failure.');
           }, null);
         }
       }
     }]);
     return DeviceBackButtonDispatcher;
   })();

   var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();

   var autoStyleEnabled = true;

   // Modifiers
   var modifiersMap = {
     'quiet': 'material--flat',
     'light': 'material--flat',
     'outline': 'material--flat',
     'cta': '',
     'large--quiet': 'material--flat large',
     'large--cta': 'large',
     'noborder': '',
     'chevron': '',
     'tappable': '',
     'underbar': ''
   };

   var platforms = {};

   platforms.android = function (element) {

     if (!/ons-fab|ons-speed-dial|ons-progress/.test(element.tagName.toLowerCase()) && !/material/.test(element.getAttribute('modifier'))) {

       var oldModifier = element.getAttribute('modifier') || '';

       var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
         return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
       });
       newModifier.unshift('material');

       element.setAttribute('modifier', newModifier.join(' ').trim());
     }

     // Effects
     if (/ons-button|ons-list-item|ons-fab|ons-speed-dial|ons-tab$/.test(element.tagName.toLowerCase()) && !element.hasAttribute('ripple') && !util.findChild(element, 'ons-ripple')) {

       if (element.tagName.toLowerCase() === 'ons-list-item') {
         if (element.hasAttribute('tappable')) {
           element.setAttribute('ripple', '');
           element.removeAttribute('tappable');
         }
       } else {
         element.setAttribute('ripple', '');
       }
     }
   };

   platforms.ios = function (element) {

     // Modifiers
     if (/material/.test(element.getAttribute('modifier'))) {
       util.removeModifier(element, 'material');

       if (util.removeModifier(element, 'material--flat')) {
         util.addModifier(element, util.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
       }

       if (!element.getAttribute('modifier')) {
         element.removeAttribute('modifier');
       }
     }

     // Effects
     if (element.hasAttribute('ripple')) {
       if (element.tagName.toLowerCase() === 'ons-list-item') {
         element.setAttribute('tappable', '');
       }

       element.removeAttribute('ripple');
     }
   };

   var unlocked = {
     android: true
   };

   var prepareAutoStyle = function prepareAutoStyle(element, force) {
     if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
       var mobileOS = platform.getMobileOS();
       if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
         platforms[mobileOS](element);
       }
     }
   };

   var autoStyle = {
     isEnabled: function isEnabled() {
       return autoStyleEnabled;
     },
     enable: function enable() {
       return autoStyleEnabled = true;
     },
     disable: function disable() {
       return autoStyleEnabled = false;
     },
     prepare: prepareAutoStyle
   };

   var generateId = (function () {
     var i = 0;
     return function () {
       return i++;
     };
   })();

   /**
    * Door locking system.
    *
    * @param {Object} [options]
    * @param {Function} [options.log]
    */

   var DoorLock = (function () {
     function DoorLock() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, DoorLock);

       this._lockList = [];
       this._waitList = [];
       this._log = options.log || function () {};
     }

     /**
      * Register a lock.
      *
      * @return {Function} Callback for unlocking.
      */

     babelHelpers.createClass(DoorLock, [{
       key: 'lock',
       value: function lock() {
         var _this = this;

         var unlock = function unlock() {
           _this._unlock(unlock);
         };
         unlock.id = generateId();
         this._lockList.push(unlock);
         this._log('lock: ' + unlock.id);

         return unlock;
       }
     }, {
       key: '_unlock',
       value: function _unlock(fn) {
         var index = this._lockList.indexOf(fn);
         if (index === -1) {
           throw new Error('This function is not registered in the lock list.');
         }

         this._lockList.splice(index, 1);
         this._log('unlock: ' + fn.id);

         this._tryToFreeWaitList();
       }
     }, {
       key: '_tryToFreeWaitList',
       value: function _tryToFreeWaitList() {
         while (!this.isLocked() && this._waitList.length > 0) {
           this._waitList.shift()();
         }
       }

       /**
        * Register a callback for waiting unlocked door.
        *
        * @params {Function} callback Callback on unlocking the door completely.
        */

     }, {
       key: 'waitUnlock',
       value: function waitUnlock(callback) {
         if (!(callback instanceof Function)) {
           throw new Error('The callback param must be a function.');
         }

         if (this.isLocked()) {
           this._waitList.push(callback);
         } else {
           callback();
         }
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isLocked',
       value: function isLocked() {
         return this._lockList.length > 0;
       }
     }]);
     return DoorLock;
   })();

   /**
    * @object ons
    * @category util
    * @description
    *   [ja]Onsen UIで利用できるグローバルなオブジェクトです。[/ja]
    *   [en]A global object that's used in Onsen UI. [/en]
    */
   var ons = {};

   ons._util = util;
   ons._deviceBackButtonDispatcher = deviceBackButtonDispatcher;
   ons._internal = internal;
   ons.GestureDetector = GestureDetector;
   ons.platform = platform;
   ons.softwareKeyboard = softwareKeyboard;
   ons.pageAttributeExpression = pageAttributeExpression;
   ons.orientation = orientation;
   ons.notification = notification;
   ons._animationOptionsParser = parse;
   ons._autoStyle = autoStyle;
   ons._DoorLock = DoorLock;

   ons._readyLock = new DoorLock();

   ons.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);

   waitDeviceReady();

   /**
    * @method isReady
    * @signature isReady()
    * @return {Boolean}
    *   [en]Will be true if Onsen UI is initialized.[/en]
    *   [ja]初期化されているかどうかを返します。[/ja]
    * @description
    *   [en]Returns true if Onsen UI is initialized.[/en]
    *   [ja]Onsen UIがすでに初期化されているかどうかを返すメソッドです。[/ja]
    */
   ons.isReady = function () {
     return !ons._readyLock.isLocked();
   };

   /**
    * @method isWebView
    * @signature isWebView()
    * @return {Boolean}
    *   [en]Will be true if the app is running in Cordova.[/en]
    *   [ja]Cordovaで実行されている場合にtrueになります。[/ja]
    * @description
    *   [en]Returns true if running inside Cordova.[/en]
    *   [ja]Cordovaで実行されているかどうかを返すメソッドです。[/ja]
    */
   ons.isWebView = ons.platform.isWebView;

   /**
    * @method ready
    * @signature ready(callback)
    * @description
    *   [ja]アプリの初期化に利用するメソッドです。渡された関数は、Onsen UIの初期化が終了している時点で必ず呼ばれます。[/ja]
    *   [en]Method used to wait for app initialization. The callback will not be executed until Onsen UI has been completely initialized.[/en]
    * @param {Function} callback
    *   [en]Function that executes after Onsen UI has been initialized.[/en]
    *   [ja]Onsen UIが初期化が完了した後に呼び出される関数オブジェクトを指定します。[/ja]
    */
   ons.ready = function (callback) {
     if (ons.isReady()) {
       callback();
     } else {
       ons._readyLock.waitUnlock(callback);
     }
   };

   /**
    * @method setDefaultDeviceBackButtonListener
    * @signature setDefaultDeviceBackButtonListener(listener)
    * @param {Function} listener
    *   [en]Function that executes when device back button is pressed.[/en]
    *   [ja]デバイスのバックボタンが押された時に実行される関数オブジェクトを指定します。[/ja]
    * @description
    *   [en]Set default handler for device back button.[/en]
    *   [ja]デバイスのバックボタンのためのデフォルトのハンドラを設定します。[/ja]
    */
   ons.setDefaultDeviceBackButtonListener = function (listener) {
     ons._defaultDeviceBackButtonHandler.setListener(listener);
   };

   /**
    * @method disableDeviceBackButtonHandler
    * @signature disableDeviceBackButtonHandler()
    * @description
    * [en]Disable device back button event handler.[/en]
    * [ja]デバイスのバックボタンのイベントを受け付けないようにします。[/ja]
    */
   ons.disableDeviceBackButtonHandler = function () {
     ons._deviceBackButtonDispatcher.disable();
   };

   /**
    * @method enableDeviceBackButtonHandler
    * @signature enableDeviceBackButtonHandler()
    * @description
    * [en]Enable device back button event handler.[/en]
    * [ja]デバイスのバックボタンのイベントを受け付けるようにします。[/ja]
    */
   ons.enableDeviceBackButtonHandler = function () {
     ons._deviceBackButtonDispatcher.enable();
   };

   /**
    * @method enableAutoStatusBarFill
    * @signature enableAutoStatusBarFill()
    * @description
    *   [en]Enable status bar fill feature on iOS7 and above.[/en]
    *   [ja]iOS7以上で、ステータスバー部分の高さを自動的に埋める処理を有効にします。[/ja]
    */
   ons.enableAutoStatusBarFill = function () {
     if (ons.isReady()) {
       throw new Error('This method must be called before ons.isReady() is true.');
     }
     ons._internal.config.autoStatusBarFill = true;
   };

   /**
    * @method disableAutoStatusBarFill
    * @signature disableAutoStatusBarFill()
    * @description
    *   [en]Disable status bar fill feature on iOS7 and above.[/en]
    *   [ja]iOS7以上で、ステータスバー部分の高さを自動的に埋める処理を無効にします。[/ja]
    */
   ons.disableAutoStatusBarFill = function () {
     if (ons.isReady()) {
       throw new Error('This method must be called before ons.isReady() is true.');
     }
     ons._internal.config.autoStatusBarFill = false;
   };

   /**
    * @method disableAnimations
    * @signature disableAnimations()
    * @description
    *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
    *   [ja]アニメーションを全て無効にします。テストの際に便利です。[/ja]
    */
   ons.disableAnimations = function () {
     ons._internal.config.animationsDisabled = true;
   };

   /**
    * @method enableAnimations
    * @signature enableAnimations()
    * @description
    *   [en]Enable animations (default).[/en]
    *   [ja]アニメーションを有効にします。[/ja]
    */
   ons.enableAnimations = function () {
     ons._internal.config.animationsDisabled = false;
   };

   /**
    * Disable automatic styling.
    */
   ons.disableAutoStyling = ons._autoStyle.disable;

   /**
    * Enable automatic styling based on OS (default).
    */
   ons.enableAutoStyling = ons._autoStyle.enable;

   /**
    * @method forcePlatformStyling
    * @signature forcePlatformStyling(platform)
    * @description
    *   [en]Refresh styling for the given platform.[/en]
    *   [ja][/ja]
    * @param {string} platform New platform to style the elements.
    */
   ons.forcePlatformStyling = function (newPlatform) {
     ons.enableAutoStyling();
     ons.platform.select(newPlatform || 'ios');
     ons._util.arrayFrom(document.querySelectorAll('ons-if')).forEach(function (element) {
       element._platformUpdate();
     });
     ons._util.arrayFrom(document.querySelectorAll('[_compiled]')).forEach(function (element) {
       ons._autoStyle.prepare(element, true);
     });
   };

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons._createPopoverOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-popover/gi) ? '<div>' + html + '</div>' : '<ons-popover>' + html + '</ons-popover>';
       var div = ons._util.createElement('<div>' + html + '</div>');

       var popover = div.querySelector('ons-popover');
       CustomElements.upgrade(popover);
       document.body.appendChild(popover);

       if (options.link instanceof Function) {
         options.link(popover);
       }

       return popover;
     });
   };

   /**
    * @method createPopover
    * @signature createPopover(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
    *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja]オプションを指定するオブジェクト。[/ja]
    * @param {Object} [options.parentScope]
    *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
    *   [ja]ダイアログ内で利用する親スコープを指定します。ダイアログからモデルやスコープのメソッドにアクセスするのに使います。このパラメータはAngularJSバインディングでのみ利用できます。[/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the popover component object.[/en]
    *   [ja]ポップオーバーのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
    * @description
    *   [en]Create a popover instance from a template.[/en]
    *   [ja]テンプレートからポップオーバーのインスタンスを生成します。[/ja]
    */
   ons.createPopover = ons._createPopoverOriginal;

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons._createDialogOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-dialog/gi) ? '<div>' + html + '</div>' : '<ons-dialog>' + html + '</ons-dialog>';
       var div = ons._util.createElement('<div>' + html + '</div>');

       var dialog = div.querySelector('ons-dialog');
       CustomElements.upgrade(dialog);
       document.body.appendChild(dialog);

       if (options.link instanceof Function) {
         options.link(dialog);
       }

       return dialog;
     });
   };

   /**
    * @method createDialog
    * @signature createDialog(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]
    *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja]オプションを指定するオブジェクト。[/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the dialog component object.[/en]
    *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
    * @description
    *   [en]Create a dialog instance from a template.[/en]
    *   [ja]テンプレートからダイアログのインスタンスを生成します。[/ja]
    */
   ons.createDialog = ons._createDialogOriginal;

   /**
    * @param {String} page
    * @param {Object} [options]
    * @param {Function} [options.link]
    * @return {Promise}
    */
   ons._createAlertDialogOriginal = function (page) {
     var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

     if (!page) {
       throw new Error('Page url must be defined.');
     }

     return ons._internal.getPageHTMLAsync(page).then(function (html) {
       html = html.match(/<ons-alert-dialog/gi) ? '<div>' + html + '</div>' : '<ons-alert-dialog>' + html + '</ons-alert-dialog>';
       var div = ons._util.createElement('<div>' + html + '</div>');

       var alertDialog = div.querySelector('ons-alert-dialog');
       CustomElements.upgrade(alertDialog);
       document.body.appendChild(alertDialog);

       if (options.link instanceof Function) {
         options.link(alertDialog);
       }

       return alertDialog;
     });
   };

   /**
    * @method createAlertDialog
    * @signature createAlertDialog(page, [options])
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-alert-dialog> component.[/en]
    *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
    * @param {Object} [options]
    *   [en]Parameter object.[/en]
    *   [ja]オプションを指定するオブジェクト。[/ja]
    * @return {Promise}
    *   [en]Promise object that resolves to the alert dialog component object.[/en]
    *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
    * @description
    *   [en]Create a alert dialog instance from a template.[/en]
    *   [ja]テンプレートからアラートダイアログのインスタンスを生成します。[/ja]
    */
   ons.createAlertDialog = ons._createAlertDialogOriginal;

   /**
    * @param {String} page
    * @param {Function} link
    */
   ons._resolveLoadingPlaceholderOriginal = function (page, link) {
     var elements = ons._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

     if (elements.length > 0) {
       elements.filter(function (element) {
         return !element.getAttribute('page');
       }).forEach(function (element) {
         element.setAttribute('ons-loading-placeholder', page);
         ons._resolveLoadingPlaceholder(element, page, link);
       });
     } else {
       throw new Error('No ons-loading-placeholder exists.');
     }
   };

   /**
    * @method resolveLoadingPlaceholder
    * @signature resolveLoadingPlaceholder(page)
    * @param {String} page
    *   [en]Page name. Can be either an HTML file or an <ons-template> element.[/en]
    *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
    * @description
    *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
    *   [ja]ons-loading-placeholderの属性値としてページが指定されていない場合は、ページロード前に呼ばれるons.resolveLoadingPlaceholder処理が行われるまで表示されません。[/ja]
    */
   ons.resolveLoadingPlaceholder = ons._resolveLoadingPlaceholderOriginal;

   ons._setupLoadingPlaceHolders = function () {
     ons.ready(function () {
       var elements = ons._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

       elements.forEach(function (element) {
         var page = element.getAttribute('ons-loading-placeholder');
         if (typeof page === 'string') {
           ons._resolveLoadingPlaceholder(element, page);
         }
       });
     });
   };

   ons._resolveLoadingPlaceholder = function (element, page, link) {
     link = link || function (element, done) {
       done();
     };
     ons._internal.getPageHTMLAsync(page).then(function (html) {

       while (element.firstChild) {
         element.removeChild(element.firstChild);
       }

       var contentElement = ons._util.createElement('<div>' + html + '</div>');
       contentElement.style.display = 'none';

       element.appendChild(contentElement);

       link(contentElement, function () {
         contentElement.style.display = '';
       });
     }).catch(function (error) {
       throw new Error('Unabled to resolve placeholder: ' + error);
     });
   };

   function waitDeviceReady() {
     var unlockDeviceReady = ons._readyLock.lock();
     window.addEventListener('WebComponentsReady', function () {
       if (ons.isWebView()) {
         window.document.addEventListener('deviceready', unlockDeviceReady, false);
       } else {
         unlockDeviceReady();
       }
     }, false);
   }

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var BaseElement = (function () {
     if (typeof HTMLElement !== 'function') {
       var BaseElement = function BaseElement() {};
       BaseElement.prototype = document.createElement('div');
       return BaseElement;
     } else {
       return HTMLElement;
     }
   })();

   /**
    * @element ons-template
    * @category util
    * @description
    *   [en]Define a separate HTML fragment and use as a template.[/en]
    *   [ja]テンプレートとして使用するためのHTMLフラグメントを定義します。この要素でHTMLを宣言すると、id属性に指定した名前をpageのURLとしてons-navigatorなどのコンポーネントから参照できます。[/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]複数のページを1つのHTMLに記述する[/ja]
    * @example
    * <ons-template id="foobar.html">
    *   ...
    * </ons-template>
    */

   var TemplateElement = (function (_BaseElement) {
     babelHelpers.inherits(TemplateElement, _BaseElement);

     function TemplateElement() {
       babelHelpers.classCallCheck(this, TemplateElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TemplateElement).apply(this, arguments));
     }

     babelHelpers.createClass(TemplateElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this.template = this.innerHTML;

         while (this.firstChild) {
           this.removeChild(this.firstChild);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
         event.template = this.template;
         event.templateId = this.getAttribute('id');

         this.dispatchEvent(event);
       }
     }]);
     return TemplateElement;
   })(BaseElement);

   window.OnsTemplateElement = document.registerElement('ons-template', {
     prototype: TemplateElement.prototype
   });

   var ConditionalElement = (function (_BaseElement) {
     babelHelpers.inherits(ConditionalElement, _BaseElement);

     function ConditionalElement() {
       babelHelpers.classCallCheck(this, ConditionalElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ConditionalElement).apply(this, arguments));
     }

     babelHelpers.createClass(ConditionalElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         if (platform._renderPlatform !== null) {
           this._platformUpdate();
         } else if (!this._isAllowedPlatform()) {
           this.innerHTML = '';
         }

         this._onOrientationChange();
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         orientation.on('change', this._onOrientationChange.bind(this));
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name) {
         if (name === 'orientation') {
           this._onOrientationChange();
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         orientation.off('change', this._onOrientationChange);
       }
     }, {
       key: '_platformUpdate',
       value: function _platformUpdate() {
         this.style.display = this._isAllowedPlatform() ? '' : 'none';
       }
     }, {
       key: '_isAllowedPlatform',
       value: function _isAllowedPlatform() {
         return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
       }
     }, {
       key: '_onOrientationChange',
       value: function _onOrientationChange() {
         if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
           var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
           var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';

           this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
         }
       }
     }]);
     return ConditionalElement;
   })(BaseElement);

   window.OnsConditionalElement = document.registerElement('ons-if', {
     prototype: ConditionalElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var AlertDialogAnimator = (function () {
     function AlertDialogAnimator() {
       var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref$timing = _ref.timing;
       var timing = _ref$timing === undefined ? 'linear' : _ref$timing;
       var _ref$delay = _ref.delay;
       var delay = _ref$delay === undefined ? 0 : _ref$delay;
       var _ref$duration = _ref.duration;
       var duration = _ref$duration === undefined ? 0.2 : _ref$duration;
       babelHelpers.classCallCheck(this, AlertDialogAnimator);

       this.timing = timing;
       this.delay = delay;
       this.duration = duration;
     }

     /**
      * @param {HTMLElement} dialog
      * @param {Function} done
      */

     babelHelpers.createClass(AlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, done) {
         done();
       }

       /**
        * @param {HTMLElement} dialog
        * @param {Function} done
        */

     }, {
       key: 'hide',
       value: function hide(dialog, done) {
         done();
       }
     }]);
     return AlertDialogAnimator;
   })();

   /**
    * Android style animator for alert dialog.
    */
   var AndroidAlertDialogAnimator = (function (_AlertDialogAnimator) {
     babelHelpers.inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);

     function AndroidAlertDialogAnimator() {
       var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref2$timing = _ref2.timing;
       var timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing;
       var _ref2$duration = _ref2.duration;
       var duration = _ref2$duration === undefined ? 0.2 : _ref2$duration;
       var _ref2$delay = _ref2.delay;
       var delay = _ref2$delay === undefined ? 0 : _ref2$delay;
       babelHelpers.classCallCheck(this, AndroidAlertDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AndroidAlertDialogAnimator).call(this, { duration: duration, timing: timing, delay: delay }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */

     babelHelpers.createClass(AndroidAlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return AndroidAlertDialogAnimator;
   })(AlertDialogAnimator);

   /**
    * iOS style animator for alert dialog.
    */
   var IOSAlertDialogAnimator = (function (_AlertDialogAnimator2) {
     babelHelpers.inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);

     function IOSAlertDialogAnimator() {
       var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref3$timing = _ref3.timing;
       var timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing;
       var _ref3$duration = _ref3.duration;
       var duration = _ref3$duration === undefined ? 0.2 : _ref3$duration;
       var _ref3$delay = _ref3.delay;
       var delay = _ref3$delay === undefined ? 0 : _ref3$delay;
       babelHelpers.classCallCheck(this, IOSAlertDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSAlertDialogAnimator).call(this, { duration: duration, timing: timing, delay: delay }));
     }

     /*
      * @param {Object} dialog
      * @param {Function} callback
      */

     babelHelpers.createClass(IOSAlertDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1.0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return IOSAlertDialogAnimator;
   })(AlertDialogAnimator);

   var scheme$1 = {
     '.alert-dialog': 'alert-dialog--*',
     '.alert-dialog-container': 'alert-dialog-container--*',
     '.alert-dialog-title': 'alert-dialog-title--*',
     '.alert-dialog-content': 'alert-dialog-content--*',
     '.alert-dialog-footer': 'alert-dialog-footer--*',
     '.alert-dialog-button': 'alert-dialog-button--*',
     '.alert-dialog-footer--one': 'alert-dialog-footer--one--*',
     '.alert-dialog-button--one': 'alert-dialog-button--one--*',
     '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
     '.alert-dialog-mask': 'alert-dialog-mask--*'
   };

   var templateSource = util.createElement('\n  <div>\n    <div class="alert-dialog-mask"></div>\n    <div class="alert-dialog">\n      <div class="alert-dialog-container"></div>\n    </div>\n  </div>\n');

   var _animatorDict = {
     'none': AlertDialogAnimator,
     'default': function _default() {
       return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
     },
     'fade': function fade() {
       return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
     }
   };

   /**
    * @element ons-alert-dialog
    * @category dialog
    * @description
    *   [en]Alert dialog that is displayed on top of the current screen.[/en]
    *   [ja]現在のスクリーンにアラートダイアログを表示します。[/ja]
    * @codepen Qwwxyp
    * @guide UsingAlert
    *   [en]Learn how to use the alert dialog.[/en]
    *   [ja]アラートダイアログの使い方の解説。[/ja]
    * @seealso ons-dialog
    *   [en]ons-dialog component[/en]
    *   [ja]ons-dialogコンポーネント[/ja]
    * @seealso ons-popover
    *   [en]ons-popover component[/en]
    *   [ja]ons-dialogコンポーネント[/ja]
    * @seealso ons.notification
    *   [en]Using ons.notification utility functions.[/en]
    *   [ja]アラートダイアログを表示するには、ons.notificationオブジェクトのメソッドを使うこともできます。[/ja]
    * @example
    * <script>
    *   ons.ready(function() {
    *     ons.createAlertDialog('alert.html').then(function(alertDialog) {
    *       alertDialog.show();
    *     });
    *   });
    * </script>
    *
    * <script type="text/ons-template" id="alert.html">
    *   <ons-alert-dialog animation="default" cancelable>
    *     <div class="alert-dialog-title">Warning!</div>
    *     <div class="alert-dialog-content">
    *       An error has occurred!
    *     </div>
    *     <div class="alert-dialog-footer">
    *       <button class="alert-dialog-button">OK</button>
    *     </div>
    *   </ons-alert-dialog>
    * </script>
    */

   var AlertDialogElement = (function (_BaseElement) {
     babelHelpers.inherits(AlertDialogElement, _BaseElement);

     function AlertDialogElement() {
       babelHelpers.classCallCheck(this, AlertDialogElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AlertDialogElement).apply(this, arguments));
     }

     babelHelpers.createClass(AlertDialogElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._visible = false;
         this._doorLock = new DoorLock();
         this._boundCancel = this._cancel.bind(this);

         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict,
           baseClass: AlertDialogAnimator,
           baseClassName: 'AlertDialogAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         var style = this.getAttribute('style');

         this.style.display = 'none';

         var template = templateSource.cloneNode(true);
         var alertDialog = template.children[1];

         if (style) {
           alertDialog.setAttribute('style', style);
         }

         while (this.firstChild) {
           alertDialog.children[0].appendChild(this.firstChild);
         }

         while (template.firstChild) {
           this.appendChild(template.firstChild);
         }

         this._dialog.style.zIndex = 20001;
         this._mask.style.zIndex = 20000;

         if (this.getAttribute('mask-color')) {
           this._mask.style.backgroundColor = this.getAttribute('mask-color');
         }

         ModifierUtil.initModifier(this, scheme$1);

         this.setAttribute('_compiled', '');
       }

       /**
        * @method setDisabled
        * @signature setDisabled(disabled)
        * @description
        *   [en]Disable or enable the alert dialog.[/en]
        *   [ja]このアラートダイアログをdisabled状態にするかどうかを設定します。[/ja]
        * @param {Boolean} disabled
        *   [en]If true the dialog will be disabled.[/en]
        *   [ja]disabled状態にするかどうかを真偽値で指定します。[/ja]
        */

     }, {
       key: 'setDisabled',
       value: function setDisabled(disabled) {
         if (typeof disabled !== 'boolean') {
           throw new Error('Argument must be a boolean.');
         }

         if (disabled) {
           this.setAttribute('disabled', '');
         } else {
           this.removeAttribute('disabled');
         }
       }

       /**
        * @method isDisabled
        * @signature isDisabled()
        * @description
        *   [en]Returns whether the dialog is disabled or enabled.[/en]
        *   [ja]このアラートダイアログがdisabled状態かどうかを返します。[/ja]
        * @return {Boolean}
        *   [en]true if the dialog is disabled.[/en]
        *   [ja]disabled状態であればtrueを返します。[/ja]
        */

     }, {
       key: 'isDisabled',
       value: function isDisabled() {
         return this.hasAttribute('disabled');
       }

       /**
        * @method setCancelable
        * @signature setCancelable(cancelable)
        * @description
        *   [en]Define whether the dialog can be canceled by the user or not.[/en]
        *   [ja]アラートダイアログを表示した際に、ユーザがそのダイアログをキャンセルできるかどうかを指定します。[/ja]
        * @param {Boolean} cancelable
        *   [en]If true the dialog will be cancelable.[/en]
        *   [ja]キャンセルできるかどうかを真偽値で指定します。[/ja]
        */

     }, {
       key: 'setCancelable',
       value: function setCancelable(cancelable) {
         if (typeof cancelable !== 'boolean') {
           throw new Error('Argument must be a boolean.');
         }

         if (cancelable) {
           this.setAttribute('cancelable', '');
         } else {
           this.removeAttribute('cancelable');
         }
       }

       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクトです。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "fade", "slide" and "none".[/en]
        *   [ja]アニメーション名を指定します。指定できるのは、"fade", "slide", "none"のいずれかです。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]Function to execute after the dialog has been revealed.[/en]
        *   [ja]ダイアログが表示され終わった時に呼び出されるコールバックを指定します。[/ja]
        * @description
        *   [en]Show the alert dialog.[/en]
        *   [ja]ダイアログを表示します。[/ja]
        * @return {Promise}
        *   [en]Resolves to the displayed element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'show',
       value: function show() {
         var _this2 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel2 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'preshow', {
           alertDialog: this,
           cancel: function cancel() {
             _cancel2 = true;
           }
         });

         if (!_cancel2) {
           var _ret = (function () {
             var tryShow = function tryShow() {
               var unlock = _this2._doorLock.lock();
               var animator = _this2._animatorFactory.newAnimator(options);

               _this2.style.display = 'block';
               _this2._mask.style.opacity = '1';

               return new Promise(function (resolve) {
                 animator.show(_this2, function () {
                   _this2._visible = true;
                   unlock();

                   util.triggerElementEvent(_this2, 'postshow', { alertDialog: _this2 });

                   callback();
                   resolve(_this2);
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this2._doorLock.waitUnlock(function () {
                   return resolve(tryShow());
                 });
               })
             };
           })();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         } else {
           return Promise.reject('Canceled in preshow event.');
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "fade", "slide" and "none".[/en]
        *   [ja]アニメーション名を指定します。"fade", "slide", "none"のいずれかを指定します。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]Function to execute after the dialog has been hidden.[/en]
        *   [ja]このダイアログが閉じた時に呼び出されるコールバックを指定します。[/ja]
        * @description
        *   [en]Hide the alert dialog.[/en]
        *   [ja]ダイアログを閉じます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel3 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'prehide', {
           alertDialog: this,
           cancel: function cancel() {
             _cancel3 = true;
           }
         });

         if (!_cancel3) {
           var _ret2 = (function () {
             var tryHide = function tryHide() {
               var unlock = _this3._doorLock.lock();
               var animator = _this3._animatorFactory.newAnimator(options);

               return new Promise(function (resolve) {
                 animator.hide(_this3, function () {
                   _this3.style.display = 'none';
                   _this3._visible = false;
                   unlock();

                   util.triggerElementEvent(_this3, 'posthide', { alertDialog: _this3 });

                   callback();
                   resolve(_this3);
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this3._doorLock.waitUnlock(function () {
                   return resolve(tryHide());
                 });
               })
             };
           })();

           if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
         } else {
           return Promise.reject('Canceled in prehide event.');
         }
       }

       /**
        * @method isShown
        * @signature isShown()
        * @return {Boolean}
        * @description
        *   [en]Returns whether the dialog is visible or not.[/en]
        *   [ja]ダイアログが表示されているかどうかを返します。[/ja]
        * @return {Boolean}
        *   [en]true if the dialog is currently visible.[/en]
        *   [ja]ダイアログが表示されていればtrueを返します。[/ja]
        */

     }, {
       key: 'isShown',
       value: function isShown() {
         return this._visible;
       }

       /**
        * @method destroy
        * @signature destroy()
        * @description
        *   [en]Destroy the alert dialog and remove it from the DOM tree.[/en]
        *   [ja]ダイアログを破棄して、DOMツリーから取り除きます。[/ja]
        */

     }, {
       key: 'destroy',
       value: function destroy() {
         if (this.parentElement) {
           this.parentElement.removeChild(this);
         }
       }

       /**
        * @method isCancelable
        * @signature isCancelable()
        * @description
        *   [en]Returns whether the dialog is cancelable or not.[/en]
        *   [ja]このアラートダイアログがキャンセル可能かどうかを返します。[/ja]
        * @return {Boolean}
        *   [en]true if the dialog is cancelable.[/en]
        *   [ja]キャンセル可能であればtrueを返します。[/ja]
        */

     }, {
       key: 'isCancelable',
       value: function isCancelable() {
         return this.hasAttribute('cancelable');
       }
     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         if (this.isCancelable()) {
           this._cancel();
         } else {
           event.callParentHandler();
         }
       }
     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this4 = this;

         if (this.isCancelable() && !this._running) {
           this._running = true;
           this.hide({
             callback: function callback() {
               _this4._running = false;
               util.triggerElementEvent(_this4, 'cancel');
             }
           });
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._deviceBackButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._onDeviceBackButton.bind(this));

         this._mask.addEventListener('click', this._boundCancel, false);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._deviceBackButtonHandler.destroy();
         this._deviceBackButtonHandler = null;

         this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$1);
         }
       }
     }, {
       key: '_mask',

       /**
        * @event preshow
        * @description
        *   [en]Fired just before the alert dialog is displayed.[/en]
        *   [ja]アラートダイアログが表示される直前に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja]アラートダイアログのオブジェクト。[/ja]
        * @param {Function} event.cancel
        *   [en]Execute to stop the dialog from showing.[/en]
        *   [ja]この関数を実行すると、アラートダイアログの表示を止めます。[/ja]
        */

       /**
        * @event postshow
        * @description
        *   [en]Fired just after the alert dialog is displayed.[/en]
        *   [ja]アラートダイアログが表示された直後に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja]アラートダイアログのオブジェクト。[/ja]
        */

       /**
        * @event prehide
        * @description
        *   [en]Fired just before the alert dialog is hidden.[/en]
        *   [ja]アラートダイアログが隠れる直前に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja]アラートダイアログのオブジェクト。[/ja]
        * @param {Function} event.cancel
        *   [en]Execute to stop the dialog from hiding.[/en]
        *   [ja]この関数を実行すると、アラートダイアログが閉じようとするのを止めます。[/ja]
        */

       /**
        * @event posthide
        * @description
        * [en]Fired just after the alert dialog is hidden.[/en]
        * [ja]アラートダイアログが隠れた後に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.alertDialog
        *   [en]Alert dialog object.[/en]
        *   [ja]アラートダイアログのオブジェクト。[/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the dialog.[/en]
        *  [ja]ダイアログの見た目を指定します。[/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button.[/en]
        *  [ja]この属性があると、ダイアログが表示された時に、背景やバックボタンをタップした時にダイアログを閉じます。[/ja]
        */

       /**
        * @attribute disabled
        * @description
        *  [en]If this attribute is set the dialog is disabled.[/en]
        *  [ja]この属性がある時、アラートダイアログはdisabled状態になります。[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the dialog. Can be either "none" or "default".[/en]
        *  [ja]ダイアログを表示する際のアニメーション名を指定します。デフォルトでは"none"か"default"が指定できます。[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/en]
        *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
        */

       /**
        * @attribute mask-color
        * @type {String}
        * @default rgba(0, 0, 0, 0.2)
        * @description
        *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
        *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
        */

       /**
        * @return {Element}
        */
       get: function get() {
         return util.findChild(this, '.alert-dialog-mask');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_dialog',
       get: function get() {
         return util.findChild(this, '.alert-dialog');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_titleElement',
       get: function get() {
         return util.findChild(this._dialog.children[0], '.alert-dialog-title');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_contentElement',
       get: function get() {
         return util.findChild(this._dialog.children[0], '.alert-dialog-content');
       }
     }]);
     return AlertDialogElement;
   })(BaseElement);

   var OnsAlertDialogElement = window.OnsAlertDialogElement = document.registerElement('ons-alert-dialog', {
     prototype: AlertDialogElement.prototype
   });

   /**
    * @param {String} name
    * @param {DialogAnimator} Animator
    */
   OnsAlertDialogElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof AlertDialogAnimator)) {
       throw new Error('"Animator" param must inherit OnsAlertDialogElement.AlertDialogAnimator');
     }
     _animatorDict[name] = Animator;
   };

   OnsAlertDialogElement.AlertDialogAnimator = AlertDialogAnimator;

   var scheme$2 = {
     '': 'back-button--*',
     '.back-button__icon': 'back-button--*__icon',
     '.back-button__label': 'back-button--*__label'
   };

   /**
    * @element ons-back-button
    * @category page
    * @description
    *   [en]Back button component for ons-toolbar. Can be used with ons-navigator to provide back button support.[/en]
    *   [ja]ons-toolbarに配置できる「戻るボタン」用コンポーネントです。ons-navigatorと共に使用し、ページを1つ前に戻る動作を行います。[/ja]
    * @codepen aHmGL
    * @seealso ons-toolbar
    *   [en]ons-toolbar component[/en]
    *   [ja]ons-toolbarコンポーネント[/ja]
    * @seealso ons-navigator
    *   [en]ons-navigator component[/en]
    *   [ja]ons-navigatorコンポーネント[/en]
    * @guide Addingatoolbar
    *   [en]Adding a toolbar[/en]
    *   [ja]ツールバーの追加[/ja]
    * @guide Returningfromapage
    *   [en]Returning from a page[/en]
    *   [ja]一つ前のページに戻る[/ja]
    * @example
    * <ons-back-button>
    *   Back
    * </ons-back-button>
    */

   var BackButtonElement = (function (_BaseElement) {
     babelHelpers.inherits(BackButtonElement, _BaseElement);

     function BackButtonElement() {
       babelHelpers.classCallCheck(this, BackButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BackButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(BackButtonElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._options = {};
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('back-button');

         var label = util.createElement('\n      <span class="back-button__label">' + this.innerHTML + '</span>\n    ');

         this.innerHTML = '';

         var icon = util.createElement('\n      <span class="back-button__icon"></span>\n    ');

         this.appendChild(icon);
         this.appendChild(label);

         ModifierUtil.initModifier(this, scheme$2);

         this.setAttribute('_compiled', '');
       }

       /**
        * @return {object}
        */

     }, {
       key: '_onClick',
       value: function _onClick() {
         var navigator = util.findParent(this, 'ons-navigator');
         if (navigator) {
           if (this.hasAttribute('animation')) {
             this.options.animation = this.getAttribute('animation');
           }

           if (this.hasAttribute('animation-options')) {
             this.options.animationOptions = util.animationOptionsParse(this.getAttribute('animation-options'));
           }

           if (this.hasAttribute('on-transition-end')) {
             this.options.onTransitionEnd = window.eval('(' + this.getAttribute('on-transition-end') + ')');
           }

           if (this.hasAttribute('refresh')) {
             this.options.refresh = this.getAttribute('refresh') === 'true';
           }

           navigator.popPage(this.options);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$2);
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'show',
       value: function show() {
         this.style.display = 'inline-block';
       }
     }, {
       key: 'hide',
       value: function hide() {
         this.style.display = 'none';
       }
     }, {
       key: 'options',
       get: function get() {
         return this._options;
       }

       /**
        * @param {object}
        */
       ,
       set: function set(object) {
         this._options = object;
       }
     }]);
     return BackButtonElement;
   })(BaseElement);

   window.OnsBackButtonElement = document.registerElement('ons-back-button', {
     prototype: BackButtonElement.prototype
   });

   var scheme$3 = { '': 'bottom-bar--*' };

   /**
    * @element ons-bottom-toolbar
    * @category page
    * @description
    *   [en]Toolbar component that is positioned at the bottom of the page.[/en]
    *   [ja]ページ下部に配置されるツールバー用コンポーネントです。[/ja]
    * @modifier transparent
    *   [en]Make the toolbar transparent.[/en]
    *   [ja]ツールバーの背景を透明にして表示します。[/ja]
    * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbarコンポーネント[/ja]
    * @guide Addingatoolbar
    *   [en]Adding a toolbar[/en]
    *   [ja]ツールバーの追加[/ja]
    * @example
    * <ons-bottom-toolbar>
    *   <div style="text-align: center; line-height: 44px">Text</div>
    * </ons-bottom-toolbar>
    */

   var BottomToolbarElement = (function (_BaseElement) {
     babelHelpers.inherits(BottomToolbarElement, _BaseElement);

     function BottomToolbarElement() {
       babelHelpers.classCallCheck(this, BottomToolbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(BottomToolbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(BottomToolbarElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the toolbar.[/en]
        *   [ja]ツールバーの見た目の表現を指定します。[/ja]
        */

       /**
        * @attribute inline
        * @initonly
        * @description
        *   [en]Display the toolbar as an inline element.[/en]
        *   [ja]この属性があると、ツールバーを画面下部ではなくスクロール領域内にそのまま表示します。[/ja]
        */

       value: function createdCallback() {
         this.classList.add('bottom-bar');

         ModifierUtil.initModifier(this, scheme$3);
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var page = util.findParent(this, 'ons-page');
         if (this.parentNode != page) {
           page._registerBottomToolbar(this);
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           ModifierUtil.onModifierChanged(last, current, this, scheme$3);
         }
       }
     }]);
     return BottomToolbarElement;
   })(BaseElement);

   window.OnsBottomToolbarElement = document.registerElement('ons-bottom-toolbar', {
     prototype: BottomToolbarElement.prototype
   });

   var scheme$4 = { '': 'button--*' };

   /**
    * @element ons-button
    * @category form
    * @modifier outline
    *   [en]Button with outline and transparent background[/en]
    *   [ja]アウトラインを持ったボタンを表示します。[/ja]
    * @modifier light
    *   [en]Button that doesn't stand out.[/en]
    *   [ja]目立たないボタンを表示します。[/ja]
    * @modifier quiet
    *   [en]Button with no outline and or background..[/en]
    *   [ja]枠線や背景が無い文字だけのボタンを表示します。[/ja]
    * @modifier cta
    *   [en]Button that really stands out.[/en]
    *   [ja]目立つボタンを表示します。[/ja]
    * @modifier large
    *   [en]Large button that covers the width of the screen.[/en]
    *   [ja]横いっぱいに広がる大きなボタンを表示します。[/ja]
    * @modifier large--quiet
    *   [en]Large quiet button.[/en]
    *   [ja]横いっぱいに広がるquietボタンを表示します。[/ja]
    * @modifier large--cta
    *   [en]Large call to action button.[/en]
    *   [ja]横いっぱいに広がるctaボタンを表示します。[/ja]
    * @description
    *   [en]Button component. If you want to place a button in a toolbar, use ons-toolbar-button or ons-back-button instead.[/en]
    *   [ja]ボタン用コンポーネント。ツールバーにボタンを設置する場合は、ons-toolbar-buttonもしくはons-back-buttonコンポーネントを使用します。[/ja]
    * @codepen hLayx
    * @guide Button [en]Guide for ons-button[/en][ja]ons-buttonの使い方[/ja]
    * @guide OverridingCSSstyles [en]More details about modifier attribute[/en][ja]modifier属性の使い方[/ja]
    * @example
    * <ons-button modifier="large--cta">
    *   Tap Me
    * </ons-button>
    */

   var ButtonElement = (function (_BaseElement) {
     babelHelpers.inherits(ButtonElement, _BaseElement);

     function ButtonElement() {
       babelHelpers.classCallCheck(this, ButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(ButtonElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the button.[/en]
        *  [ja]ボタンの表現を指定します。[/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja]ボタンを無効化する場合は指定します。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$4);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('button');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$4);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }]);
     return ButtonElement;
   })(BaseElement);

   window.OnsButtonElement = document.registerElement('ons-button', {
     prototype: ButtonElement.prototype
   });

   var scheme$5 = { '': 'carousel-item--*' };

   /**
    * @element ons-carousel-item
    * @category carousel
    * @description
    *   [en]Carousel item component.[/en]
    *   [ja]カルーセルの要素を表現するコンポーネント。[/ja]
    * @codepen xbbzOQ
    * @seealso ons-carousel
    *   [en]ons-carousel components[/en]
    *   [ja]ons-carouselコンポーネント[/ja]
    * @example
    * <ons-carousel style="width: 100%; height: 200px">
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    * </ons-carousel>
    */

   var CarouselItemElement = (function (_BaseElement) {
     babelHelpers.inherits(CarouselItemElement, _BaseElement);

     function CarouselItemElement() {
       babelHelpers.classCallCheck(this, CarouselItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CarouselItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(CarouselItemElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this.style.width = '100%';
         ModifierUtil.initModifier(this, scheme$5);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$5);
         }
       }
     }]);
     return CarouselItemElement;
   })(BaseElement);

   window.OnsCarouselItemElement = document.registerElement('ons-carousel-item', {
     prototype: CarouselItemElement.prototype
   });

   var VerticalModeTrait = {

     _getScrollDelta: function _getScrollDelta(event) {
       return event.gesture.deltaY;
     },

     _getScrollVelocity: function _getScrollVelocity(event) {
       return event.gesture.velocityY;
     },

     _getElementSize: function _getElementSize() {
       if (!this._currentElementSize) {
         this._currentElementSize = this.getBoundingClientRect().height;
       }

       return this._currentElementSize;
     },

     _generateScrollTransform: function _generateScrollTransform(scroll) {
       return 'translate3d(0px, ' + -scroll + 'px, 0px)';
     },

     _updateDimensionData: function _updateDimensionData() {
       this._style = window.getComputedStyle(this);
       this._dimensions = this.getBoundingClientRect();
     },

     _updateOffset: function _updateOffset() {
       if (this.isCentered()) {
         var height = (this._dimensions.height || 0) - parseInt(this._style.paddingTop, 10) - parseInt(this._style.paddingBottom, 10);
         this._offset = -(height - this._getCarouselItemSize()) / 2;
       }
     },

     _layoutCarouselItems: function _layoutCarouselItems() {
       var children = this._getCarouselItemElements();

       var sizeAttr = this._getCarouselItemSizeAttr();
       var sizeInfo = this._decomposeSizeString(sizeAttr);

       var width = (this._dimensions.width || 0) - parseInt(this._style.paddingLeft, 10) - parseInt(this._style.paddingRight, 10);

       for (var i = 0; i < children.length; i++) {
         children[i].style.position = 'absolute';
         children[i].style.height = sizeAttr;
         children[i].style.width = width + 'px';
         children[i].style.visibility = 'visible';
         children[i].style.top = i * sizeInfo.number + sizeInfo.unit;
       }
     },

     _setup: function _setup() {
       this._updateDimensionData();
       this._updateOffset();
       this._layoutCarouselItems();
     }
   };

   var HorizontalModeTrait = {

     _getScrollDelta: function _getScrollDelta(event) {
       return event.gesture.deltaX;
     },

     _getScrollVelocity: function _getScrollVelocity(event) {
       return event.gesture.velocityX;
     },

     _getElementSize: function _getElementSize() {
       if (!this._currentElementSize) {
         this._currentElementSize = this.getBoundingClientRect().width;
       }

       return this._currentElementSize;
     },

     _generateScrollTransform: function _generateScrollTransform(scroll) {
       return 'translate3d(' + -scroll + 'px, 0px, 0px)';
     },

     _updateDimensionData: function _updateDimensionData() {
       this._style = window.getComputedStyle(this);
       this._dimensions = this.getBoundingClientRect();
     },

     _updateOffset: function _updateOffset() {
       if (this.isCentered()) {
         var width = (this._dimensions.width || 0) - parseInt(this._style.paddingLeft, 10) - parseInt(this._style.paddingRight, 10);
         this._offset = -(width - this._getCarouselItemSize()) / 2;
       }
     },

     _layoutCarouselItems: function _layoutCarouselItems() {
       var children = this._getCarouselItemElements();

       var sizeAttr = this._getCarouselItemSizeAttr();
       var sizeInfo = this._decomposeSizeString(sizeAttr);

       var height = (this._dimensions.height || 0) - parseInt(this._style.paddingTop, 10) - parseInt(this._style.paddingBottom, 10);

       for (var i = 0; i < children.length; i++) {
         children[i].style.position = 'absolute';
         children[i].style.height = height + 'px';
         children[i].style.width = sizeAttr;
         children[i].style.visibility = 'visible';
         children[i].style.left = i * sizeInfo.number + sizeInfo.unit;
       }
     },

     _setup: function _setup() {
       this._updateDimensionData();
       this._updateOffset();
       this._layoutCarouselItems();
     }
   };

   /**
    * @element ons-carousel
    * @category carousel
    * @description
    *   [en]Carousel component.[/en]
    *   [ja]カルーセルを表示できるコンポーネント。[/ja]
    * @codepen xbbzOQ
    * @seealso ons-carousel-item
    *   [en]ons-carousel-item component[/en]
    *   [ja]ons-carousel-itemコンポーネント[/ja]
    * @guide UsingCarousel
    *   [en]Learn how to use the carousel component.[/en]
    *   [ja]carouselコンポーネントの使い方[/ja]
    * @example
    * <ons-carousel style="width: 100%; height: 200px">
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    *   <ons-carousel-item>
    *    ...
    *   </ons-carousel-item>
    * </ons-carousel>
    */

   var CarouselElement = (function (_BaseElement) {
     babelHelpers.inherits(CarouselElement, _BaseElement);

     function CarouselElement() {
       babelHelpers.classCallCheck(this, CarouselElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CarouselElement).apply(this, arguments));
     }

     babelHelpers.createClass(CarouselElement, [{
       key: 'createdCallback',

       /**
        * @event postchange
        * @description
        *   [en]Fired just after the current carousel item has changed.[/en]
        *   [ja]現在表示しているカルーセルの要素が変わった時に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクトです。[/ja]
        * @param {Object} event.carousel
        *   [en]Carousel object.[/en]
        *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
        * @param {Number} event.activeIndex
        *   [en]Current active index.[/en]
        *   [ja]現在アクティブになっている要素のインデックス。[/ja]
        * @param {Number} event.lastActiveIndex
        *   [en]Previous active index.[/en]
        *   [ja]以前アクティブだった要素のインデックス。[/ja]
        */

       /**
        * @event refresh
        * @description
        *   [en]Fired when the carousel has been refreshed.[/en]
        *   [ja]カルーセルが更新された時に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクトです。[/ja]
        * @param {Object} event.carousel
        *   [en]Carousel object.[/en]
        *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
        */

       /**
        * @event overscroll
        * @description
        *   [en]Fired when the carousel has been overscrolled.[/en]
        *   [ja]カルーセルがオーバースクロールした時に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクトです。[/ja]
        * @param {Object} event.carousel
        *   [en]Fired when the carousel has been refreshed.[/en]
        *   [ja]カルーセルが更新された時に発火します。[/ja]
        * @param {Number} event.activeIndex
        *   [en]Current active index.[/en]
        *   [ja]現在アクティブになっている要素のインデックス。[/ja]
        * @param {String} event.direction
        *   [en]Can be one of either "up", "down", "left" or "right".[/en]
        *   [ja]オーバースクロールされた方向が得られます。"up", "down", "left", "right"のいずれかの方向が渡されます。[/ja]
        * @param {Function} event.waitToReturn
        *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
        *   [ja]この関数はPromiseオブジェクトを引数として受け取ります。渡したPromiseオブジェクトがresolveされるかrejectされるまで、カルーセルはスクロールバックしません。[/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
        *   [ja]カルーセルの方向を指定します。"horizontal"か"vertical"を指定できます。"horizontal"がデフォルト値です。[/ja]
        */

       /**
        * @attribute fullscreen
        * @description
        *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
        *   [ja]この属性があると、absoluteポジションを使ってカルーセルが自動的に画面いっぱいに広がります。[/ja]
        */

       /**
        * @attribute overscrollable
        * @description
        *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
        *   [ja]この属性がある時、タッチやドラッグで端までスクロールした時に、バウンドするような効果が当たります。[/ja]
        */

       /**
        * @attribute centered
        * @description
        *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
        *   [ja]この属性がある時、選んでいるons-carousel-itemはカルーセルの真ん中へ行きます。項目がカルーセルよりも小さい場合にのみ、これは便利です。[/ja]
        */

       /**
        * @attribute item-width
        * @type {String}
        * @description
        *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
        *    [ja]ons-carousel-itemの幅を指定します。この属性は、direction属性に"horizontal"を指定した時のみ有効になります。[/ja]
        */

       /**
        * @attribute item-height
        * @type {String}
        * @description
        *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
        *   [ja]ons-carousel-itemの高さを指定します。この属性は、direction属性に"vertical"を指定した時のみ有効になります。[/ja]
        */

       /**
        * @attribute auto-scroll
        * @description
        *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
        *   [ja]この属性がある時、一番近いcarousel-itemの境界まで自動的にスクロールするようになります。[/ja]
        */

       /**
        * @attribute auto-scroll-ratio
        * @type {Number}
        * @description
        *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
        *    [ja]0.0から1.0までの値を指定します。カルーセルの要素をどれぐらいの割合までドラッグすると次の要素に自動的にスクロールするかを指定します。[/ja]
        */

       /**
        * @attribute swipeable
        * @description
        *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
        *   [ja]この属性がある時、カルーセルをスワイプやドラッグで移動できるようになります。[/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set the carousel is disabled.[/en]
        *   [ja]この属性がある時、dragやtouchやswipeを受け付けなくなります。[/ja]
        */

       /**
        * @attribute initial-index
        * @initonly
        * @type {Number}
        * @description
        *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
        *   [ja]最初に表示するons-carousel-itemを0始まりのインデックスで指定します。デフォルト値は 0 です。[/ja]
        */

       /**
        * @attribute auto-refresh
        * @description
        *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
        *   [ja]この属性がある時、子要素の数が変わるとカルーセルは自動的に更新されるようになります。[/ja]
        */

       value: function createdCallback() {
         this._doorLock = new DoorLock();
         this._scroll = 0;
         this._offset = 0;
         this._lastActiveIndex = 0;

         this._boundOnDrag = this._onDrag.bind(this);
         this._boundOnDragEnd = this._onDragEnd.bind(this);
         this._boundOnResize = this._onResize.bind(this);

         this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);

         this._setup();
         this._setupInitialIndex();

         this._saveLastState();
       }
     }, {
       key: '_onResize',
       value: function _onResize() {
         this.refresh();
       }
     }, {
       key: '_onDirectionChange',
       value: function _onDirectionChange() {
         if (this._isVertical()) {
           this.style.overflowX = 'auto';
           this.style.overflowY = '';
         } else {
           this.style.overflowX = '';
           this.style.overflowY = 'auto';
         }

         this.refresh();
       }
     }, {
       key: '_saveLastState',
       value: function _saveLastState() {
         this._lastState = {
           elementSize: this._getCarouselItemSize(),
           carouselElementCount: this.getCarouselItemCount(),
           width: this._getCarouselItemSize() * this.getCarouselItemCount()
         };
       }

       /**
        * @return {Number}
        */

     }, {
       key: '_getCarouselItemSize',
       value: function _getCarouselItemSize() {
         var sizeAttr = this._getCarouselItemSizeAttr();
         var sizeInfo = this._decomposeSizeString(sizeAttr);
         var elementSize = this._getElementSize();

         if (sizeInfo.unit === '%') {
           return Math.round(sizeInfo.number / 100 * elementSize);
         } else if (sizeInfo.unit === 'px') {
           return sizeInfo.number;
         } else {
           throw new Error('Invalid state');
         }
       }

       /**
        * @return {Number}
        */

     }, {
       key: '_getInitialIndex',
       value: function _getInitialIndex() {
         var index = parseInt(this.getAttribute('initial-index'), 10);

         if (typeof index === 'number' && !isNaN(index)) {
           return Math.max(Math.min(index, this.getCarouselItemCount() - 1), 0);
         } else {
           return 0;
         }
       }

       /**
        * @return {String}
        */

     }, {
       key: '_getCarouselItemSizeAttr',
       value: function _getCarouselItemSizeAttr() {
         var attrName = 'item-' + (this._isVertical() ? 'height' : 'width');
         var itemSizeAttr = ('' + this.getAttribute(attrName)).trim();

         return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
       }

       /**
        * @return {Object}
        */

     }, {
       key: '_decomposeSizeString',
       value: function _decomposeSizeString(size) {
         var matches = size.match(/^(\d+)(px|%)/);

         return {
           number: parseInt(matches[1], 10),
           unit: matches[2]
         };
       }
     }, {
       key: '_setupInitialIndex',
       value: function _setupInitialIndex() {
         this._scroll = (this._offset || 0) + this._getCarouselItemSize() * this._getInitialIndex();
         this._lastActiveIndex = this._getInitialIndex();
         this._scrollTo(this._scroll);
       }

       /**
        * @method setSwipeable
        * @signature setSwipeable(swipeable)
        * @param {Boolean} swipeable
        *   [en]If value is true the carousel will be swipeable.[/en]
        *   [ja]swipeableにする場合にはtrueを指定します。[/ja]
        * @description
        *   [en]Set whether the carousel is swipeable or not.[/en]
        *   [ja]swipeできるかどうかを指定します。[/ja]
        */

     }, {
       key: 'setSwipeable',
       value: function setSwipeable(swipeable) {
         if (swipeable) {
           this.setAttribute('swipeable', '');
         } else {
           this.removeAttribute('swipeable');
         }
       }

       /**
        * @method isSwipeable
        * @signature isSwipeable()
        * @return {Boolean}
        *   [en]true if the carousel is swipeable.[/en]
        *   [ja]swipeableであればtrueを返します。[/ja]
        * @description
        *   [en]Returns whether the carousel is swipeable or not.[/en]
        *   [ja]swipeable属性があるかどうかを返します。[/ja]
        */

     }, {
       key: 'isSwipeable',
       value: function isSwipeable() {
         return this.hasAttribute('swipeable');
       }

       /**
        * @method setAutoScrollRatio
        * @signature setAutoScrollRatio(ratio)
        * @param {Number} ratio
        *   [en]The desired ratio.[/en]
        *   [ja]オートスクロールするのに必要な0.0から1.0までのratio値を指定します。[/ja]
        * @description
        *   [en]Set the auto scroll ratio. Must be a value between 0.0 and 1.0.[/en]
        *   [ja]オートスクロールするのに必要なratio値を指定します。0.0から1.0を必ず指定しなければならない。[/ja]
        */

     }, {
       key: 'setAutoScrollRatio',
       value: function setAutoScrollRatio(ratio) {
         if (ratio < 0.0 || ratio > 1.0) {
           throw new Error('Invalid ratio.');
         }

         this.setAttribute('auto-scroll-ratio', ratio);
       }

       /**
        * @method getAutoScrollRatio
        * @signature getAutoScrollRatio()
        * @return {Number}
        *   [en]The current auto scroll ratio.[/en]
        *   [ja]現在のオートスクロールのratio値。[/ja]
        * @description
        *   [en]Returns the current auto scroll ratio.[/en]
        *   [ja]現在のオートスクロールのratio値を返します。[/ja]
        */

     }, {
       key: 'getAutoScrollRatio',
       value: function getAutoScrollRatio() {
         var attr = this.getAttribute('auto-scroll-ratio');

         if (!attr) {
           return 0.5;
         }

         var scrollRatio = parseFloat(attr);
         if (scrollRatio < 0.0 || scrollRatio > 1.0) {
           throw new Error('Invalid ratio.');
         }

         return isNaN(scrollRatio) ? 0.5 : scrollRatio;
       }

       /**
        * @method setActiveCarouselItemIndex
        * @signature setActiveCarouselItemIndex(index, [options])
        * @param {Number} index
        *   [en]The index that the carousel should be set to.[/en]
        *   [ja]carousel要素のインデックスを指定します。[/ja]
        * @param {Object} [options]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en][/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en][/en]
        *   [ja][/ja]
        * @description
        *   [en]Specify the index of the ons-carousel-item to show.[/en]
        *   [ja]表示するons-carousel-itemをindexで指定します。[/ja]
        * @param {Object} [options.animationOptions]
        * @return {Promise} Resolves to the carousel element
        */

     }, {
       key: 'setActiveCarouselItemIndex',
       value: function setActiveCarouselItemIndex(index) {
         var _this2 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         options.animationOptions = util.extend({ duration: 0.3, timing: 'cubic-bezier(.1, .7, .1, 1)' }, options.animationOptions || {}, this.hasAttribute('animation-options') ? util.animationOptionsParse(this.getAttribute('animation-options')) : {});

         index = Math.max(0, Math.min(index, this.getCarouselItemCount() - 1));
         var scroll = (this._offset || 0) + this._getCarouselItemSize() * index;
         var max = this._calculateMaxScroll();

         this._scroll = Math.max(0, Math.min(max, scroll));
         return this._scrollTo(this._scroll, options).then(function () {
           _this2._tryFirePostChangeEvent();
           return _this2;
         });
       }

       /**
        * @method getActiveCarouselItemIndex
        * @signature getActiveCarouselItemIndex()
        * @return {Number}
        *   [en]The current carousel item index.[/en]
        *   [ja]現在表示しているカルーセル要素のインデックスが返されます。[/ja]
        * @description
        *   [en]Returns the index of the currently visible ons-carousel-item.[/en]
        *   [ja]現在表示されているons-carousel-item要素のインデックスを返します。[/ja]
        */

     }, {
       key: 'getActiveCarouselItemIndex',
       value: function getActiveCarouselItemIndex() {
         var scroll = this._scroll - (this._offset || 0);
         var count = this.getCarouselItemCount();
         var size = this._getCarouselItemSize();

         if (scroll < 0) {
           return 0;
         }

         var i = undefined;
         for (i = 0; i < count; i++) {
           if (size * i <= scroll && size * (i + 1) > scroll) {
             return i;
           }
         }

         // max carousel index
         return i;
       }

       /**
        * @method next
        * @signature next([options])
        * @param {Object} [options]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en][/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en][/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show next ons-carousel item.[/en]
        *   [ja]次のons-carousel-itemを表示します。[/ja]
        */

     }, {
       key: 'next',
       value: function next(options) {
         return this.setActiveCarouselItemIndex(this.getActiveCarouselItemIndex() + 1, options);
       }

       /**
        * @method prev
        * @signature prev([options])
        * @param {Object} [options]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Function} [options.callback]
        *   [en][/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Object} [options.animationOptions]
        *   [en][/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show previous ons-carousel item.[/en]
        *   [ja]前のons-carousel-itemを表示します。[/ja]
        */

     }, {
       key: 'prev',
       value: function prev(options) {
         return this.setActiveCarouselItemIndex(this.getActiveCarouselItemIndex() - 1, options);
       }

       /**
        * @method setAutoScrollEnabled
        * @signature setAutoScrollEnabled(enabled)
        * @param {Boolean} enabled
        *   [en]If true auto scroll will be enabled.[/en]
        *   [ja]オートスクロールを有効にする場合にはtrueを渡します。[/ja]
        * @description
        *   [en]Enable or disable "auto-scroll" attribute.[/en]
        *   [ja]auto-scroll属性があるかどうかを設定します。[/ja]
        */

     }, {
       key: 'setAutoScrollEnabled',
       value: function setAutoScrollEnabled(enabled) {
         if (enabled) {
           this.setAttribute('auto-scroll', '');
         } else {
           this.removeAttribute('auto-scroll');
         }
       }

       /**
        * @method isAutoScrollEnabled
        * @signature isAutoScrollEnabled()
        * @return {Boolean}
        *   [en]true if auto scroll is enabled.[/en]
        *   [ja]オートスクロールが有効であればtrueを返します。[/ja]
        * @description
        *   [en]Returns whether the "auto-scroll" attribute is set or not.[/en]
        *   [ja]auto-scroll属性があるかどうかを返します。[/ja]
        */

     }, {
       key: 'isAutoScrollEnabled',
       value: function isAutoScrollEnabled() {
         return this.hasAttribute('auto-scroll');
       }

       /**
        * @method setDisabled
        * @signature setDisabled(disabled)
        * @param {Boolean} disabled
        *   [en]If true the carousel will be disabled.[/en]
        *   [ja]disabled状態にする場合にはtrueを指定します。[/ja]
        * @description
        *   [en]Disable or enable the dialog.[/en]
        *   [ja]disabled属性があるかどうかを設定します。[/ja]
        */

     }, {
       key: 'setDisabled',
       value: function setDisabled(disabled) {
         if (disabled) {
           this.setAttribute('disabled', '');
         } else {
           this.removeAttribute('disabled');
         }
       }

       /**
        * @method isDisabled
        * @signature isDisabled()
        * @return {Boolean}
        *   [en]Whether the carousel is disabled or not.[/en]
        *   [ja]disabled状態になっていればtrueを返します。[/ja]
        * @description
        *   [en]Returns whether the dialog is disabled or enabled.[/en]
        *   [ja]disabled属性があるかどうかを返します。[/ja]
        */

     }, {
       key: 'isDisabled',
       value: function isDisabled() {
         return this.hasAttribute('disabled');
       }

       /**
        * @method setOverscrollable
        * @signature setOverscrollable(overscrollable)
        * @param {Boolean} overscrollable
        *   [en]If true the carousel will be overscrollable.[/en]
        *   [ja]overscrollできるかどうかを指定します。[/ja]
        * @description
        *   [en]Set whether the carousel is overscrollable or not.[/en]
        *   [ja]overscroll属性があるかどうかを設定します。[/ja]
        */

     }, {
       key: 'setOverscrollable',
       value: function setOverscrollable(scrollable) {
         if (scrollable) {
           this.setAttribute('overscrollable', '');
         } else {
           this.removeAttribute('overscrollable');
         }
       }

       /**
        * @method isOverscrollable
        * @signature isOverscrollable()
        * @return {Boolean}
        *   [en]Whether the carousel is overscrollable or not.[/en]
        *   [ja]overscrollできればtrueを返します。[/ja]
        * @description
        *   [en]Returns whether the carousel is overscrollable or not.[/en]
        *   [ja]overscroll属性があるかどうかを返します。[/ja]
        */

     }, {
       key: 'isOverscrollable',
       value: function isOverscrollable() {
         return this.hasAttribute('overscrollable');
       }

       /**
        * @method setCentered
        * @signature setCentered(centered)
        * @param {Boolean} centered
        *   [en]If true the carousel will be centered.[/en]
        *   [ja]centered状態にする場合にはtrueを指定します。[/ja]
        * @description
        *   [en]Set whether the carousel is centered or not.[/en]
        *   [ja]centered属性があるかどうかを設定します。[/ja]
        */

     }, {
       key: 'setCentered',
       value: function setCentered(centered) {
         if (centered) {
           this.setAttribute('centered', '');
         } else {
           this.removeAttribute('centered');
         }
       }

       /**
        * @method isCentered
        * @signature isCentered()
        * @return {Boolean}
        *   [en]Whether the carousel is centered or not.[/en]
        *   [ja]centered状態になっていればtrueを返します。[/ja]
        * @description
        *   [en]Returns whether the carousel is centered or not.[/en]
        *   [ja]centered属性があるかどうかを返します。[/ja]
        */

     }, {
       key: 'isCentered',
       value: function isCentered() {
         return this.hasAttribute('centered');
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_isEnabledChangeEvent',
       value: function _isEnabledChangeEvent() {
         var elementSize = this._getElementSize();
         var carouselItemSize = this._getCarouselItemSize();

         return this.isAutoScrollEnabled() && elementSize === carouselItemSize;
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_isVertical',
       value: function _isVertical() {
         return this.getAttribute('direction') === 'vertical';
       }
     }, {
       key: '_prepareEventListeners',
       value: function _prepareEventListeners() {
         this._gestureDetector = new GestureDetector(this, {
           dragMinDistance: 1
         });

         this._updateSwipeable();

         window.addEventListener('resize', this._boundOnResize, true);
       }
     }, {
       key: '_removeEventListeners',
       value: function _removeEventListeners() {
         this._gestureDetector.dispose();
         this._gestureDetector = null;

         window.removeEventListener('resize', this._boundOnResize, true);
       }
     }, {
       key: '_updateSwipeable',
       value: function _updateSwipeable() {
         if (this._gestureDetector) {
           if (this.isSwipeable()) {
             this._gestureDetector.on('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
             this._gestureDetector.on('dragend', this._boundOnDragEnd);
           } else {
             this._gestureDetector.off('drag dragleft dragright dragup dragdown swipe swipeleft swiperight swipeup swipedown', this._boundOnDrag);
             this._gestureDetector.off('dragend', this._boundOnDragEnd);
           }
         }
       }
     }, {
       key: '_tryFirePostChangeEvent',
       value: function _tryFirePostChangeEvent() {
         var currentIndex = this.getActiveCarouselItemIndex();

         if (this._lastActiveIndex !== currentIndex) {
           var lastActiveIndex = this._lastActiveIndex;
           this._lastActiveIndex = currentIndex;

           util.triggerElementEvent(this, 'postchange', {
             carousel: this,
             activeIndex: currentIndex,
             lastActiveIndex: lastActiveIndex
           });
         }
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         var direction = event.gesture.direction;
         if (this._isVertical() && (direction === 'left' || direction === 'right') || !this._isVertical() && (direction === 'up' || direction === 'down')) {
           return;
         }

         event.stopPropagation();

         this._lastDragEvent = event;

         var scroll = this._scroll - this._getScrollDelta(event);
         this._scrollTo(scroll);
         event.gesture.preventDefault();

         this._tryFirePostChangeEvent();
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         var _this3 = this;

         this._currentElementSize = undefined;

         this._scroll = this._scroll - this._getScrollDelta(event);

         if (this._getScrollDelta(event) !== 0) {
           event.stopPropagation();
         }

         if (this._isOverScroll(this._scroll)) {
           var waitForAction = false;
           util.triggerElementEvent(this, 'overscroll', {
             carousel: this,
             activeIndex: this.getActiveCarouselItemIndex(),
             direction: this._getOverScrollDirection(),
             waitToReturn: function waitToReturn(promise) {
               waitForAction = true;
               promise.then(function () {
                 return _this3._scrollToKillOverScroll();
               });
             }
           });

           if (!waitForAction) {
             this._scrollToKillOverScroll();
           }
         } else {
           this._startMomentumScroll();
         }
         this._lastDragEvent = null;

         event.gesture.preventDefault();
       }

       /**
        * @param {Object} trait
        */

     }, {
       key: '_mixin',
       value: function _mixin(trait) {
         Object.keys(trait).forEach((function (key) {
           this[key] = trait[key];
         }).bind(this));
       }
     }, {
       key: '_startMomentumScroll',
       value: function _startMomentumScroll() {
         if (this._lastDragEvent) {
           var velocity = this._getScrollVelocity(this._lastDragEvent);
           var duration = 0.3;
           var scrollDelta = duration * 100 * velocity;
           var scroll = this._normalizeScrollPosition(this._scroll + (this._getScrollDelta(this._lastDragEvent) > 0 ? -scrollDelta : scrollDelta));

           this._scroll = scroll;

           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(this._scroll)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .7, .1, 1)'
           }).queue((function (done) {
             done();
             this._tryFirePostChangeEvent();
           }).bind(this)).play();
         }
       }
     }, {
       key: '_normalizeScrollPosition',
       value: function _normalizeScrollPosition(scroll) {
         var max = this._calculateMaxScroll();

         if (!this.isAutoScrollEnabled()) {
           return Math.max(0, Math.min(max, scroll));
         }
         var arr = [];
         var size = this._getCarouselItemSize();
         var nbrOfItems = this.getCarouselItemCount();

         for (var i = 0; i < nbrOfItems; i++) {
           if (i * size + this._offset < max) {
             arr.push(i * size + this._offset);
           }
         }
         arr.push(max);

         arr.sort(function (left, right) {
           left = Math.abs(left - scroll);
           right = Math.abs(right - scroll);

           return left - right;
         });

         arr = arr.filter(function (item, pos) {
           return !pos || item != arr[pos - 1];
         });

         var lastScroll = this._lastActiveIndex * size + this._offset;
         var scrollRatio = Math.abs(scroll - lastScroll) / size;
         var result = arr[0];

         if (scrollRatio <= this.getAutoScrollRatio()) {
           result = lastScroll;
         } else if (scrollRatio < 1.0) {
           if (arr[0] === lastScroll && arr.length > 1) {
             result = arr[1];
           }
         }

         return Math.max(0, Math.min(max, result));
       }

       /**
        * @return {Array}
        */

     }, {
       key: '_getCarouselItemElements',
       value: function _getCarouselItemElements() {
         return util.arrayFrom(this.children).filter(function (child) {
           return child.nodeName.toLowerCase() === 'ons-carousel-item';
         });
       }

       /**
        * @param {Number} scroll
        * @param {Object} [options]
        * @return {Promise} Resolves to the carousel element
        */

     }, {
       key: '_scrollTo',
       value: function _scrollTo(scroll) {
         var _this4 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var isOverscrollable = this.isOverscrollable();

         var normalizeScroll = function normalizeScroll(scroll) {
           var ratio = 0.35;

           if (scroll < 0) {
             return isOverscrollable ? Math.round(scroll * ratio) : 0;
           }

           var maxScroll = _this4._calculateMaxScroll();
           if (maxScroll < scroll) {
             return isOverscrollable ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
           }

           return scroll;
         };

         return new Promise(function (resolve) {
           animit(_this4._getCarouselItemElements()).queue({
             transform: _this4._generateScrollTransform(normalizeScroll(scroll))
           }, options.animation !== 'none' ? options.animationOptions : {}).play(function () {
             if (options.callback instanceof Function) {
               options.callback();
             }
             resolve();
           });
         });
       }
     }, {
       key: '_calculateMaxScroll',
       value: function _calculateMaxScroll() {
         var max = this.getCarouselItemCount() * this._getCarouselItemSize() - this._getElementSize();
         return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
       }
     }, {
       key: '_isOverScroll',
       value: function _isOverScroll(scroll) {
         if (scroll < 0 || scroll > this._calculateMaxScroll()) {
           return true;
         }
         return false;
       }
     }, {
       key: '_getOverScrollDirection',
       value: function _getOverScrollDirection() {
         if (this._isVertical()) {
           if (this._scroll <= 0) {
             return 'up';
           } else {
             return 'down';
           }
         } else {
           if (this._scroll <= 0) {
             return 'left';
           } else {
             return 'right';
           }
         }
       }
     }, {
       key: '_scrollToKillOverScroll',
       value: function _scrollToKillOverScroll() {
         var duration = 0.4;

         if (this._scroll < 0) {
           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(0)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .4, .1, 1)'
           }).queue((function (done) {
             done();
             this._tryFirePostChangeEvent();
           }).bind(this)).play();
           this._scroll = 0;
           return;
         }

         var maxScroll = this._calculateMaxScroll();

         if (maxScroll < this._scroll) {
           animit(this._getCarouselItemElements()).queue({
             transform: this._generateScrollTransform(maxScroll)
           }, {
             duration: duration,
             timing: 'cubic-bezier(.1, .4, .1, 1)'
           }).queue((function (done) {
             done();
             this._tryFirePostChangeEvent();
           }).bind(this)).play();
           this._scroll = maxScroll;
           return;
         }

         return;
       }

       /**
        * @method getCarouselItemCount
        * @signature getCarouselItemCount)
        * @return {Number}
        *   [en]The number of carousel items.[/en]
        *   [ja]カルーセル要素の数です。[/ja]
        * @description
        *   [en]Returns the current number of carousel items..[/en]
        *   [ja]現在のカルーセル要素を数を返します。[/ja]
        */

     }, {
       key: 'getCarouselItemCount',
       value: function getCarouselItemCount() {
         return this._getCarouselItemElements().length;
       }

       /**
        * @method refresh
        * @signature refresh()
        * @description
        *   [en]Update the layout of the carousel. Used when adding ons-carousel-items dynamically or to automatically adjust the size.[/en]
        *   [ja]レイアウトや内部の状態を最新のものに更新します。ons-carousel-itemを動的に増やしたり、ons-carouselの大きさを動的に変える際に利用します。[/ja]
       */

     }, {
       key: 'refresh',
       value: function refresh() {
         // Bug fix
         if (this._getCarouselItemSize() === 0) {
           return;
         }

         this._mixin(this._isVertical() ? VerticalModeTrait : HorizontalModeTrait);
         this._setup();

         if (this._lastState && this._lastState.width > 0) {
           var scroll = this._scroll; // - this._offset;

           if (this._isOverScroll(scroll)) {
             this._scrollToKillOverScroll();
           } else {
             if (this.isAutoScrollEnabled()) {
               scroll = this._normalizeScrollPosition(scroll);
             }

             this._scrollTo(scroll);
           }
         }

         this._saveLastState();

         util.triggerElementEvent(this, 'refresh', { carousel: this });
       }

       /**
        * @method first
        * @signature first()
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja][/ja]
        * @description
        *   [en]Show first ons-carousel item.[/en]
        *   [ja]最初のons-carousel-itemを表示します。[/ja]
        */

     }, {
       key: 'first',
       value: function first(options) {
         return this.setActiveCarouselItemIndex(0, options);
       }

       /**
        * @method last
        * @signature last()
        * @return {Promise}
        *   [en]Resolves to the carousel element[/en]
        *   [ja]Resolves to the carousel element[/ja]
        * @description
        *   [en]Show last ons-carousel item.[/en]
        *   [ja]最後のons-carousel-itemを表示します。[/ja]
        */

     }, {
       key: 'last',
       value: function last(options) {
         this.setActiveCarouselItemIndex(Math.max(this.getCarouselItemCount() - 1, 0), options);
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._prepareEventListeners();

         this._setup();
         this._setupInitialIndex();

         this._saveLastState();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'swipeable':
             this._updateSwipeable();
             break;
           case 'direction':
             this._onDirectionChange();
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._removeEventListeners();
       }
     }]);
     return CarouselElement;
   })(BaseElement);

   window.OnsCarouselElement = document.registerElement('ons-carousel', {
     prototype: CarouselElement.prototype
   });

   /**
    * @element ons-col
    * @category grid
    * @description
    *   [en]Represents a column in the grid system. Use with ons-row to layout components.[/en]
    *   [ja]グリッドシステムにて列を定義します。ons-rowとともに使用し、コンポーネントのレイアウトに利用します。[/ja]
    * @note
    *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one align.[/en]
    *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-columnを組み合わせた場合に描画が崩れる場合があります。[/ja]
    * @codepen GgujC {wide}
    * @guide layouting [en]Layouting guide[/en][ja]レイアウト機能[/ja]
    * @seealso ons-row [en]ons-row component[/en][ja]ons-rowコンポーネント[/ja]
    * @example
    * <ons-row>
    *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
    *   <ons-col>Text</ons-col>
    * </ons-row>
    */

   /**
    * @attribute vertical-align
    * @type {String}
    * @description
    *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
    *   [ja]縦の配置を指定する。"top", "center", "bottom"のいずれかを指定します。[/ja]
    */

   /**
    * @attribute width
    * @type {String}
    * @description
    *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
    *   [ja]カラムの横幅を指定する。パーセントもしくはピクセルで指定します（10%や50px）。[/ja]
    */

   var ColumnElement = (function (_BaseElement) {
     babelHelpers.inherits(ColumnElement, _BaseElement);

     function ColumnElement() {
       babelHelpers.classCallCheck(this, ColumnElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ColumnElement).apply(this, arguments));
     }

     babelHelpers.createClass(ColumnElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         if (this.getAttribute('width')) {
           this._updateWidth();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'width') {
           this._updateWidth();
         }
       }
     }, {
       key: '_updateWidth',
       value: function _updateWidth() {
         var width = this.getAttribute('width');
         if (typeof width === 'string') {
           width = ('' + width).trim();
           width = width.match(/^\d+$/) ? width + '%' : width;

           this.style.webkitBoxFlex = '0';
           this.style.webkitFlex = '0 0 ' + width;
           this.style.mozBoxFlex = '0';
           this.style.mozFlex = '0 0 ' + width;
           this.style.msFlex = '0 0 ' + width;
           this.style.flex = '0 0 ' + width;
           this.style.maxWidth = width;
         }
       }
     }]);
     return ColumnElement;
   })(BaseElement);

   window.OnsColElement = document.registerElement('ons-col', {
     prototype: ColumnElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var DialogAnimator = (function () {
     function DialogAnimator() {
       var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref$timing = _ref.timing;
       var timing = _ref$timing === undefined ? 'linear' : _ref$timing;
       var _ref$delay = _ref.delay;
       var delay = _ref$delay === undefined ? 0 : _ref$delay;
       var _ref$duration = _ref.duration;
       var duration = _ref$duration === undefined ? 0.2 : _ref$duration;
       babelHelpers.classCallCheck(this, DialogAnimator);

       this.timing = timing;
       this.delay = delay;
       this.duration = duration;
     }

     /**
      * @param {HTMLElement} dialog
      * @param {Function} done
      */

     babelHelpers.createClass(DialogAnimator, [{
       key: 'show',
       value: function show(dialog, done) {
         done();
       }

       /**
        * @param {HTMLElement} dialog
        * @param {Function} done
        */

     }, {
       key: 'hide',
       value: function hide(dialog, done) {
         done();
       }
     }]);
     return DialogAnimator;
   })();

   /**
    * Android style animator for dialog.
    */
   var AndroidDialogAnimator = (function (_DialogAnimator) {
     babelHelpers.inherits(AndroidDialogAnimator, _DialogAnimator);

     function AndroidDialogAnimator() {
       var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref2$timing = _ref2.timing;
       var timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing;
       var _ref2$delay = _ref2.delay;
       var delay = _ref2$delay === undefined ? 0 : _ref2$delay;
       var _ref2$duration = _ref2.duration;
       var duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;
       babelHelpers.classCallCheck(this, AndroidDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(AndroidDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */

     babelHelpers.createClass(AndroidDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -60%, 0)',
             opacity: 0.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -60%, 0)',
             opacity: 0.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return AndroidDialogAnimator;
   })(DialogAnimator);

   /**
    * iOS style animator for dialog.
    */
   var IOSDialogAnimator = (function (_DialogAnimator2) {
     babelHelpers.inherits(IOSDialogAnimator, _DialogAnimator2);

     function IOSDialogAnimator() {
       var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref3$timing = _ref3.timing;
       var timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing;
       var _ref3$delay = _ref3.delay;
       var delay = _ref3$delay === undefined ? 0 : _ref3$delay;
       var _ref3$duration = _ref3.duration;
       var duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;
       babelHelpers.classCallCheck(this, IOSDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */

     babelHelpers.createClass(IOSDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, 300%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3d(-50%, -50%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3d(-50%, 300%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return IOSDialogAnimator;
   })(DialogAnimator);

   /**
    * Slide animator for dialog.
    */
   var SlideDialogAnimator = (function (_DialogAnimator3) {
     babelHelpers.inherits(SlideDialogAnimator, _DialogAnimator3);

     function SlideDialogAnimator() {
       var _ref4 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

       var _ref4$timing = _ref4.timing;
       var timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing;
       var _ref4$delay = _ref4.delay;
       var delay = _ref4$delay === undefined ? 0 : _ref4$delay;
       var _ref4$duration = _ref4.duration;
       var duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;
       babelHelpers.classCallCheck(this, SlideDialogAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SlideDialogAnimator).call(this, { timing: timing, delay: delay, duration: duration }));
     }

     /**
      * @param {Object} dialog
      * @param {Function} callback
      */

     babelHelpers.createClass(SlideDialogAnimator, [{
       key: 'show',
       value: function show(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3D(-50%, -350%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-50%, -50%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} dialog
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(dialog, callback) {
         callback = callback ? callback : function () {};

         animit.runAll(animit(dialog._mask).queue({
           opacity: 1.0
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }), animit(dialog._dialog).saveStyle().queue({
           css: {
             transform: 'translate3D(-50%, -50%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-50%, -350%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }
     }]);
     return SlideDialogAnimator;
   })(DialogAnimator);

   var scheme$6 = {
     '.dialog': 'dialog--*',
     '.dialog-container': 'dialog-container--*',
     '.dialog-mask': 'dialog-mask--*'
   };

   var templateSource$1 = util.createElement('\n  <div>\n    <div class="dialog-mask"></div>\n    <div class="dialog">\n      <div class="dialog-container"></div>\n    </div>\n  </div>\n');

   var _animatorDict$1 = {
     'default': function _default() {
       return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
     },
     'fade': function fade() {
       return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
     },
     'slide': SlideDialogAnimator,
     'none': DialogAnimator
   };

   /**
    * @element ons-dialog
    * @category dialog
    * @modifier material
    *   [en]Display a Material Design dialog.[/en]
    *   [ja]マテリアルデザインのダイアログを表示します。[/ja]
    * @description
    *  [en]Dialog that is displayed on top of current screen.[/en]
    *  [ja]現在のスクリーンにダイアログを表示します。[/ja]
    * @codepen zxxaGa
    * @guide UsingDialog
    *   [en]Learn how to use the dialog component.[/en]
    *   [ja]ダイアログコンポーネントの使い方[/ja]
    * @seealso ons-alert-dialog
    *   [en]ons-alert-dialog component[/en]
    *   [ja]ons-alert-dialogコンポーネント[/ja]
    * @seealso ons-popover
    *   [en]ons-popover component[/en]
    *   [ja]ons-popoverコンポーネント[/ja]
    * @example
    * <script>
    *   ons.ready(function() {
    *     ons.createDialog('dialog.html').then(function(dialog) {
    *       dialog.show();
    *     });
    *   });
    * </script>
    *
    * <script type="text/ons-template" id="dialog.html">
    *   <ons-dialog cancelable>
    *     ...
    *   </ons-dialog>
    * </script>
    */

   var DialogElement = (function (_BaseElement) {
     babelHelpers.inherits(DialogElement, _BaseElement);

     function DialogElement() {
       babelHelpers.classCallCheck(this, DialogElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(DialogElement).apply(this, arguments));
     }

     babelHelpers.createClass(DialogElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._visible = false;
         this._doorLock = new DoorLock();
         this._boundCancel = this._cancel.bind(this);

         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$1,
           baseClass: DialogAnimator,
           baseClassName: 'DialogAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         var style = this.getAttribute('style');

         this.style.display = 'none';

         var template = templateSource$1.cloneNode(true);
         var dialog = template.children[1];

         if (style) {
           dialog.setAttribute('style', style);
         }

         while (this.firstChild) {
           dialog.children[0].appendChild(this.firstChild);
         }

         while (template.firstChild) {
           this.appendChild(template.firstChild);
         }

         this._dialog.style.zIndex = 20001;
         this._mask.style.zIndex = 20000;

         this.setAttribute('no-status-bar-fill', '');

         ModifierUtil.initModifier(this, scheme$6);

         this.setAttribute('_compiled', '');
       }

       /**
        * @method getDeviceBackButtonHandler
        * @signature getDeviceBackButtonHandler()
        * @return {Object/null}
        *   [en]Device back button handler.[/en]
        *   [ja]デバイスのバックボタンハンドラを返します。[/ja]
        * @description
        *   [en]Retrieve the back button handler for overriding the default behavior.[/en]
        *   [ja]バックボタンハンドラを取得します。デフォルトの挙動を変更することができます。[/ja]
        */

     }, {
       key: 'getDeviceBackButtonHandler',
       value: function getDeviceBackButtonHandler() {
         return this._deviceBackButtonHandler;
       }
     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         if (this.isCancelable()) {
           this._cancel();
         } else {
           event.callParentHandler();
         }
       }
     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this2 = this;

         if (this.isCancelable() && !this._running) {
           this._running = true;
           this.hide({
             callback: function callback() {
               _this2._running = false;
               util.triggerElementEvent(_this2, 'cancel');
             }
           });
         }
       }

       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "none", "fade" and "slide".[/en]
        *   [ja]アニメーション名を指定します。"none", "fade", "slide"のいずれかを指定します。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]This function is called after the dialog has been revealed.[/en]
        *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *  [en]Show the dialog.[/en]
        *  [ja]ダイアログを開きます。[/ja]
        * @return {Promise} Resolves to the displayed element.
        */

     }, {
       key: 'show',
       value: function show() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel2 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'preshow', {
           dialog: this,
           cancel: function cancel() {
             _cancel2 = true;
           }
         });

         if (!_cancel2) {
           var _ret = (function () {
             var tryShow = function tryShow() {
               var unlock = _this3._doorLock.lock();
               var animator = _this3._animatorFactory.newAnimator(options);

               _this3.style.display = 'block';
               _this3._mask.style.opacity = '1';

               return new Promise(function (resolve) {
                 animator.show(_this3, function () {
                   _this3._visible = true;
                   unlock();

                   util.triggerElementEvent(_this3, 'postshow', { dialog: _this3 });

                   callback();
                   resolve(_this3);
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this3._doorLock.waitUnlock(function () {
                   return resolve(tryShow());
                 });
               })
             };
           })();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         } else {
           return Promise.reject('Canceled in preshow event.');
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "none", "fade" and "slide".[/en]
        *   [ja]アニメーション名を指定します。"none", "fade", "slide"のいずれかを指定できます。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]This functions is called after the dialog has been hidden.[/en]
        *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Hide the dialog.[/en]
        *   [ja]ダイアログを閉じます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this4 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var _cancel3 = false;
         var callback = options.callback || function () {};

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         util.triggerElementEvent(this, 'prehide', {
           dialog: this,
           cancel: function cancel() {
             _cancel3 = true;
           }
         });

         if (!_cancel3) {
           var _ret2 = (function () {
             var tryHide = function tryHide() {
               var unlock = _this4._doorLock.lock();
               var animator = _this4._animatorFactory.newAnimator(options);

               return new Promise(function (resolve) {
                 animator.hide(_this4, function () {
                   _this4.style.display = 'none';
                   _this4._visible = false;
                   unlock();

                   util.triggerElementEvent(_this4, 'posthide', { dialog: _this4 });

                   callback();
                   resolve(_this4);
                 });
               });
             };

             return {
               v: new Promise(function (resolve) {
                 _this4._doorLock.waitUnlock(function () {
                   return resolve(tryHide());
                 });
               })
             };
           })();

           if ((typeof _ret2 === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret2)) === "object") return _ret2.v;
         } else {
           return Promise.reject('Canceled in prehide event.');
         }
       }

       /**
        * @method destroy
        * @signature destroy()
        * @description
        *  [en]Destroy the dialog and remove it from the DOM tree.[/en]
        *  [ja]ダイアログを破棄して、DOMツリーから取り除きます。[/ja]
        */

     }, {
       key: 'destroy',
       value: function destroy() {
         if (this.parentElement) {
           this.parentElement.removeChild(this);
         }
       }

       /**
        * @method isShown
        * @signature isShown()
        * @description
        *   [en]Returns whether the dialog is visible or not.[/en]
        *   [ja]ダイアログが表示されているかどうかを返します。[/ja]
        * @return {Boolean}
        *   [en]true if the dialog is visible.[/en]
        *   [ja]ダイアログが表示されている場合にtrueを返します。[/ja]
        */

     }, {
       key: 'isShown',
       value: function isShown() {
         return this._visible;
       }

       /**
        * @method isCancelable
        * @signature isCancelable()
        * @description
        *   [en]Returns whether the dialog is cancelable or not.[/en]
        *   [ja]このダイアログがキャンセル可能かどうかを返します。[/ja]
        * @return {Boolean}
        *   [en]true if the dialog is cancelable.[/en]
        *   [ja]ダイアログがキャンセル可能な場合trueを返します。[/ja]
        */

     }, {
       key: 'isCancelable',
       value: function isCancelable() {
         return this.hasAttribute('cancelable');
       }

       /**
        * @method setDisabled
        * @signature setDisabled(disabled)
        * @description
        *   [en]Disable or enable the dialog.[/en]
        *   [ja]このダイアログをdisabled状態にするかどうかを設定します。[/ja]
        * @param {Boolean} disabled
        *   [en]If true the dialog will be disabled.[/en]
        *   [ja]trueを指定するとダイアログをdisabled状態になります。[/ja]
        */

     }, {
       key: 'setDisabled',
       value: function setDisabled(disabled) {
         if (typeof disabled !== 'boolean') {
           throw new Error('Argument must be a boolean.');
         }

         if (disabled) {
           this.setAttribute('disabled', '');
         } else {
           this.removeAttribute('disabled');
         }
       }

       /**
        * @method isDisabled
        * @signature isDisabled()
        * @description
        *   [en]Returns whether the dialog is disabled or enabled.[/en]
        *   [ja]このダイアログがdisabled状態かどうかを返します。[/ja]
        * @return {Boolean}
        *   [en]true if the dialog is disabled.[/en]
        *   [ja]ダイアログがdisabled状態の場合trueを返します。[/ja]
        */

     }, {
       key: 'isDisabled',
       value: function isDisabled() {
         return this.hasAttribute('disabled');
       }

       /**
        * @method setCancelable
        * @signature setCancelable(cancelable)
        * @param {Boolean} cancelable
        *   [en]If true the dialog will be cancelable.[/en]
        *   [ja]ダイアログをキャンセル可能にする場合trueを指定します。[/ja]
        * @description
        *   [en]Define whether the dialog can be canceled by the user or not.[/en]
        *   [ja]ダイアログを表示した際に、ユーザがそのダイアログをキャンセルできるかどうかを指定します。[/ja]
        */

     }, {
       key: 'setCancelable',
       value: function setCancelable(cancelable) {
         if (typeof cancelable !== 'boolean') {
           throw new Error('Argument must be a boolean.');
         }

         if (cancelable) {
           this.setAttribute('cancelable', '');
         } else {
           this.removeAttribute('cancelable');
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._deviceBackButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._onDeviceBackButton.bind(this));
         this._mask.addEventListener('click', this._boundCancel, false);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._deviceBackButtonHandler.destroy();
         this._deviceBackButtonHandler = null;

         this._mask.removeEventListener('click', this._boundCancel.bind(this), false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$6);
         }
       }
     }, {
       key: '_mask',

       /**
        * @event preshow
        * @description
        * [en]Fired just before the dialog is displayed.[/en]
        * [ja]ダイアログが表示される直前に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        * @param {Function} event.cancel
        *   [en]Execute this function to stop the dialog from being shown.[/en]
        *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
        */

       /**
        * @event postshow
        * @description
        * [en]Fired just after the dialog is displayed.[/en]
        * [ja]ダイアログが表示された直後に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        */

       /**
        * @event prehide
        * @description
        * [en]Fired just before the dialog is hidden.[/en]
        * [ja]ダイアログが隠れる直前に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        * @param {Function} event.cancel
        *   [en]Execute this function to stop the dialog from being hidden.[/en]
        *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
        */

       /**
        * @event posthide
        * @description
        * [en]Fired just after the dialog is hidden.[/en]
        * [ja]ダイアログが隠れた後に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.dialog
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the dialog.[/en]
        *  [ja]ダイアログの表現を指定します。[/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button.[/en]
        *  [ja]この属性があると、ダイアログが表示された時に、背景やバックボタンをタップした時にダイアログを閉じます。[/ja]
        */

       /**
        * @attribute disabled
        * @description
        *  [en]If this attribute is set the dialog is disabled.[/en]
        *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the dialog. Can be either "none" or "default".[/en]
        *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/en]
        *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
        */

       /**
        * @attribute mask-color
        * @type {String}
        * @default rgba(0, 0, 0, 0.2)
        * @description
        *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
        *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
        */

       /**
        * @return {Element}
        */
       get: function get() {
         return util.findChild(this, '.dialog-mask');
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_dialog',
       get: function get() {
         return util.findChild(this, '.dialog');
       }
     }]);
     return DialogElement;
   })(BaseElement);

   var OnsDialogElement = window.OnsDialogElement = document.registerElement('ons-dialog', {
     prototype: DialogElement.prototype
   });

   /**
    * @param {String} name
    * @param {DialogAnimator} Animator
    */
   OnsDialogElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof DialogAnimator)) {
       throw new Error('"Animator" param must inherit OnsDialogElement.DialogAnimator');
     }
     _animatorDict$1[name] = Animator;
   };

   OnsDialogElement.DialogAnimator = DialogAnimator;

   var scheme$7 = {
     '': 'fab--*'
   };

   /**
    * @element ons-fab
    * @category fab
    * @description
    *   [en][/en]
    *   [ja][/ja]
    */

   var FabElement = (function (_BaseElement) {
     babelHelpers.inherits(FabElement, _BaseElement);

     function FabElement() {
       babelHelpers.classCallCheck(this, FabElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(FabElement).apply(this, arguments));
     }

     babelHelpers.createClass(FabElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the button.[/en]
        *  [ja]ボタンの表現を指定します。[/ja]
        */

       /**
        * @attribute position
        * @type {String}
        * @description
        *  [en][/en]
        *  [ja]fabコンポーネントを表示する位置を指定します。 上下位置と左右位置を指定します。 上下位置に指定できるのは`top`か`bottom`です。左右位置で指定できるのは`left`か`right`か`center`です。`top left`と指定すると、左上に表示されます。`bottom center`と指定すると、下部中央に表示されます。[/ja]
        */

       /**
        * @attribute inline
        * @description
        *  [en][/en]
        *  [ja]この属性が設定されると、このコンポーネントはposition属性を無視してインラインに表示されます。[/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja]ボタンを無効化する場合は指定します。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('fab');

         var content = document.createElement('span');
         content.classList.add('fab__icon');

         util.arrayFrom(this.childNodes).forEach(function (element) {
           if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
             content.appendChild(element);
           }
         });

         this.appendChild(content);

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$7);

         this._updatePosition();

         this.hide();

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$7);
             break;
           case 'ripple':
             this._updateRipple();
             break;
           case 'position':
             this._updatePosition();
         }
       }
     }, {
       key: '_show',
       value: function _show() {
         if (!this.isInline()) {
           this.show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (!this.isInline()) {
           this.hide();
         }
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_updatePosition',
       value: function _updatePosition() {
         var position = this.getAttribute('position');
         this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
         switch (position) {
           case 'top right':
           case 'right top':
             this.classList.add('fab--top__right');
             break;
           case 'top left':
           case 'left top':
             this.classList.add('fab--top__left');
             break;
           case 'bottom right':
           case 'right bottom':
             this.classList.add('fab--bottom__right');
             break;
           case 'bottom left':
           case 'left bottom':
             this.classList.add('fab--bottom__left');
             break;
           case 'center top':
           case 'top center':
             this.classList.add('fab--top__center');
             break;
           case 'center bottom':
           case 'bottom center':
             this.classList.add('fab--bottom__center');
             break;
           default:
             break;
         }
       }

       /**
        * @method show
        * @signature show()
        * @description
        *  [en][/en]
        *  [ja][/ja]
        */

     }, {
       key: 'show',
       value: function show() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.style.transform = 'scale(1)';
         this.style.webkitTransform = 'scale(1)';
       }

       /**
        * @method hide
        * @signature hide()
        * @description
        *  [en][/en]
        *  [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.style.transform = 'scale(0)';
         this.style.webkitTransform = 'scale(0)';
       }

       /**
        * @method setDisabled
        * @signature setDisabled(disabled)
        * @param {Boolean} disabled
        * @description
        *  [en]Disabled of enable fab.[/en]
        *  [ja][/ja]
        */

     }, {
       key: 'setDisabled',
       value: function setDisabled(disabled) {
         if (typeof disabled !== 'boolean') {
           throw new Error('Argument must be a boolean.');
         }

         if (disabled) {
           this.setAttribute('disabled', '');
         } else {
           this.removeAttribute('disabled');
         }
       }

       /**
        * @method isDisabled
        * @signature isDisabled()
        * @description
        *   [en]True if fab is disabled.[/en]
        *   [ja]disabled状態であるかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isDisabled',
       value: function isDisabled() {
         return this.hasAttribute('disabled');
       }

       /**
        * True if fab is inline element.
        *
        * @return {Boolean}
        */
       /**
        * @method isInline
        * @signature isInline()
        * @description
        *   [en]True if fab is inline.[/en]
        *   [ja]inline属性があるかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isInline',
       value: function isInline() {
         return this.hasAttribute('inline');
       }

       /**
        * @method isShown
        * @signature isShown()
        * @description
        *   [en]True if fab is shown.[/en]
        *   [ja]このコンポーネントが表示されているかどうかを返します。[/ja]
        * @return {Boolean}
        */

     }, {
       key: 'isShown',
       value: function isShown() {
         return this.style.transform === 'scale(1)' && this.style.display !== 'none';
       }

       /**
        * @method toggle
        * @signature toggle()
        * @description
        *   [en][/en]
        *   [ja][/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         if (this.isShown()) {
           this.hide();
         } else {
           this.show();
         }
       }
     }]);
     return FabElement;
   })(BaseElement);

   window.OnsFabElement = document.registerElement('ons-fab', {
     prototype: FabElement.prototype
   });

   /**
    * @element ons-gesture-detector
    * @category input
    * @description
    *   [en]Component to detect finger gestures within the wrapped element. See the guide for more details.[/en]
    *   [ja]要素内のジェスチャー操作を検知します。詳しくはガイドを参照してください。[/ja]
    * @guide DetectingFingerGestures
    *   [en]Detecting finger gestures[/en]
    *   [ja]ジェスチャー操作の検知[/ja]
    * @example
    * <ons-gesture-detector style="height: 100%; width: 100%;">
    *   ...
    * </ons-gesture-detector>
    */

   var GestureDetectorElement = (function (_BaseElement) {
     babelHelpers.inherits(GestureDetectorElement, _BaseElement);

     function GestureDetectorElement() {
       babelHelpers.classCallCheck(this, GestureDetectorElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(GestureDetectorElement).apply(this, arguments));
     }

     babelHelpers.createClass(GestureDetectorElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this._gestureDetector = new GestureDetector(this);
       }
     }]);
     return GestureDetectorElement;
   })(BaseElement);

   window.OnsGestureDetectorElement = document.registerElement('ons-gesture-detector', {
     prototype: GestureDetectorElement.prototype
   });

   /**
    * @element ons-icon
    * @category icon
    * @description
    *   [en]Displays an icon. Font Awesome(https://fortawesome.github.io/Font-Awesome/) and Ionicon icons(http://ionicons.com) and Material Design Iconic Font(http://zavoloklom.github.io/material-design-iconic-font/) are supported.[/en]
    *   [ja]アイコンを表示するコンポーネントです。Font Awesome(https://fortawesome.github.io/Font-Awesome/)もしくはIonicons(http://ionicons.com)もしくはMaterial Design Iconic Font(http://zavoloklom.github.io/material-design-iconic-font/)から選択できます。[/ja]
    * @codepen xAhvg
    * @guide UsingIcons [en]Using icons[/en][ja]アイコンを使う[/ja]
    * @example
    * <ons-icon
    *   icon="md-car"
    *   size="20px"
    *   fixed-width="false"
    *   style="color: red">
    * </ons-icon>
    */

   var IconElement = (function (_BaseElement) {
     babelHelpers.inherits(IconElement, _BaseElement);

     function IconElement() {
       babelHelpers.classCallCheck(this, IconElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IconElement).apply(this, arguments));
     }

     babelHelpers.createClass(IconElement, [{
       key: 'createdCallback',

       /**
        * @attribute icon
        * @type {String}
        * @description
        *   [en]The icon name. "md-" prefix for Material Icons, "fa-" for Font Awesome and "ion-" prefix for Ionicons icons. See all icons at http://zavoloklom.github.io/material-design-iconic-font/icons.html, http://fontawesome.io/icons/ and http://ionicons.com.[/en]
        *   [ja]アイコン名を指定します。<code>md-</code>で始まるものはMaterial Iconsとして、<code>fa-</code>で始まるものはFont Awesomeとして、<code>ion-</code>で始まるものはIoniconsとして扱われます。使用できるアイコンはこちら: http://zavoloklom.github.io/material-design-iconic-font/icons.html http://fontawesome.io/icons/ http://ionicons.com[/ja]
        */

       /**
        * @attribute size
        * @type {String}
        * @description
        *   [en]The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in pixels.[/en]
        *   [ja]アイコンのサイズを指定します。値は、lg, 2x, 3x, 4x, 5xもしくはピクセル単位で指定できます。[/ja]
        */

       /**
        * @attribute rotate
        * @type {Number}
        * @description
        *   [en]Number of degrees to rotate the icon. Valid values are 90, 180, or 270.[/en]
        *   [ja]アイコンを回転して表示します。90, 180, 270から指定できます。[/ja]
        */

       /**
        * @attribute flip
        * @type {String}
        * @description
        *   [en]Flip the icon. Valid values are "horizontal" and "vertical".[/en]
        *   [ja]アイコンを反転します。horizontalもしくはverticalを指定できます。[/ja]
        */

       /**
        * @attribute fixed-width
        * @type {Boolean}
        * @default false
        * @description
        *  [en]When used in the list, you want the icons to have the same width so that they align vertically by setting the value to true. Valid values are true, false. Default is false.[/en]
        *  [ja]等幅にするかどうかを指定します。trueもしくはfalseを指定できます。デフォルトはfalseです。[/ja]
        */

       /**
        * @attribute spin
        * @type {Boolean}
        * @default false
        * @description
        *   [en]Specify whether the icon should be spinning. Valid values are true and false.[/en]
        *   [ja]アイコンを回転するかどうかを指定します。trueもしくはfalseを指定できます。[/ja]
        */

       value: function createdCallback() {
         this._update();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (['icon', 'size'].indexOf(name) !== -1) {
           this._update();
         }
       }
     }, {
       key: '_update',
       value: function _update() {
         var _this2 = this;

         this._cleanClassAttribute();

         var builded = this._buildClassAndStyle(this);

         for (var key in builded.style) {
           if (builded.style.hasOwnProperty(key)) {
             this.style[key] = builded.style[key];
           }
         }

         builded.classList.forEach(function (className) {
           return _this2.classList.add(className);
         });
       }
     }, {
       key: '_cleanClassAttribute',

       /**
        * Remove unneeded class value.
        */
       value: function _cleanClassAttribute() {
         var _this3 = this;

         util.arrayFrom(this.classList).filter(function (className) {
           return (/^(fa$|fa-|ion-|zmdi-)/.test(className)
           );
         }).forEach(function (className) {
           return _this3.classList.remove(className);
         });

         this.classList.remove('zmdi');
         this.classList.remove('ons-icon--ion');
       }
     }, {
       key: '_buildClassAndStyle',
       value: function _buildClassAndStyle() {
         var classList = ['ons-icon'];
         var style = {};

         // icon
         var iconName = this._iconName;
         if (iconName.indexOf('ion-') === 0) {
           classList.push(iconName);
           classList.push('ons-icon--ion');
         } else if (iconName.indexOf('fa-') === 0) {
           classList.push(iconName);
           classList.push('fa');
         } else if (iconName.indexOf('md-') === 0) {
           classList.push('zmdi');
           classList.push('zmdi-' + iconName.split(/\-(.+)?/)[1]);
         } else {
           classList.push('fa');
           classList.push('fa-' + iconName);
         }

         // size
         var size = '' + this.getAttribute('size');
         if (size.match(/^[1-5]x|lg$/)) {
           classList.push('fa-' + size);
           this.style.removeProperty('font-size');
         } else {
           style.fontSize = size;
         }

         return {
           classList: classList,
           style: style
         };
       }
     }, {
       key: '_iconName',
       get: function get() {
         return '' + this.getAttribute('icon');
       }
     }]);
     return IconElement;
   })(BaseElement);

   window.OnsIconElement = document.registerElement('ons-icon', {
     prototype: IconElement.prototype
   });

   /**
    * @element ons-lazy-repeat
    * @category control
    * @description
    *   [en]
    *     Using this component a list with millions of items can be rendered without a drop in performance.
    *     It does that by "lazily" loading elements into the DOM when they come into view and
    *     removing items from the DOM when they are not visible.
    *   [/en]
    *   [ja]
    *     このコンポーネント内で描画されるアイテムのDOM要素の読み込みは、画面に見えそうになった時まで自動的に遅延され、
    *     画面から見えなくなった場合にはその要素は動的にアンロードされます。
    *     このコンポーネントを使うことで、パフォーマンスを劣化させること無しに巨大な数の要素を描画できます。
    *   [/ja]
    * @codepen QwrGBm
    * @guide UsingLazyRepeat
    *   [en]How to use Lazy Repeat[/en]
    *   [ja]レイジーリピートの使い方[/ja]
    * @example
    * <script>
    *   window.addEventListener('load', function() {
    *     var lazyRepeat = document.querySelector('#list');
    *     lazyRepeat.delegate = {
    *      // calculateItemHeight: function(i) {
    *      //  // specify this if the height depends on the element
    *      //  return Math.floor(42 * Math.random());
    *      // },
    *      createItemContent: function(i, template) {
    *        var dom = template.cloneNode(true);
    *        dom.innerText = i;
    *
    *        return dom;
    *      },
    *      countItems: function() {
    *         // Return number of items.
    *        return 10000000;
    *      },
    *      destroyItem: function(index, item) {
    *        // Optional method that is called when an item is unloaded.
    *        console.log('Destroyed item with index: ' + index);
    *      }
    *     };
    *   });
    * </script>
    *
    * <ons-list id="list">
    *   <ons-lazy-repeat>
    *     <ons-list-item></ons-list-item>
    *   </ons-lazy-repeat>
    * </ons-list>
    */

   var LazyRepeatElement = (function (_BaseElement) {
     babelHelpers.inherits(LazyRepeatElement, _BaseElement);

     function LazyRepeatElement() {
       babelHelpers.classCallCheck(this, LazyRepeatElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(LazyRepeatElement).apply(this, arguments));
     }

     babelHelpers.createClass(LazyRepeatElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this.style.display = 'none';
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         util.updateParentPosition(this);

         // not very good idea
         if (this.hasAttribute('delegate')) {
           this.setDelegate(window[this.getAttribute('delegate')]);
         }
       }

       /**
        * @method setDelegate
        * @signature setDelegate(userDelegate)
        * @param {Object} userDelegate
        * @description
        *  [en]Specify a delegate object to load and unload item elements.[/en]
        *  [ja]要素のロード、アンロードなどの処理を委譲するオブジェクトを指定します。[/ja]
        */

     }, {
       key: 'setDelegate',
       value: function setDelegate(userDelegate) {
         this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();

         if (!this._templateElement && this.children[0]) {
           this._templateElement = this.removeChild(this.children[0]);
         }

         var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
         this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
       }

       /**
        * @property delegate
        * @description
        *  [en]Specify a delegate object to load and unload item elements.[/en]
        *  [ja]要素のロード、アンロードなどの処理を委譲するオブジェクトを指定します。[/ja]
        */

     }, {
       key: 'refresh',

       /**
        * @method refresh
        * @signature refresh()
        * @description
        *   [en][/en]
        *   [ja][/ja]
        */
       value: function refresh() {
         this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         if (this._lazyRepeatProvider) {
           this._lazyRepeatProvider.destroy();
           this._lazyRepeatProvider = null;
         }
       }
     }, {
       key: 'delegate',
       set: function set(userDelegate) {
         this.setDelegate(userDelegate);
       }
     }]);
     return LazyRepeatElement;
   })(BaseElement);

   window.OnsLazyRepeatElement = document.registerElement('ons-lazy-repeat', {
     prototype: LazyRepeatElement.prototype
   });

   var scheme$8 = { '': 'list__header--*' };

   /**
    * @element ons-list-header
    * @category list
    * @description
    *   [en]Header element for list items. Must be put inside ons-list component.[/en]
    *   [ja]リスト要素に使用するヘッダー用コンポーネント。ons-listと共に使用します。[/ja]
    * @seealso ons-list
    *   [en]ons-list component[/en]
    *   [ja]ons-listコンポーネント[/ja]
    * @seealso ons-list-item [en]ons-list-item component[/en][ja]ons-list-itemコンポーネント[/ja]
    * @guide UsingList [en]Using lists[/en][ja]リストを使う[/ja]
    * @codepen yxcCt
    * @example
    * <ons-list>
    *   <ons-list-header>Header Text</ons-list-header>
    *   <ons-list-item>Item</ons-list-item>
    *   <ons-list-item>Item</ons-list-item>
    * </ons-list>
    */

   var ListHeaderElement = (function (_BaseElement) {
     babelHelpers.inherits(ListHeaderElement, _BaseElement);

     function ListHeaderElement() {
       babelHelpers.classCallCheck(this, ListHeaderElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListHeaderElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListHeaderElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list header.[/en]
        *   [ja]ヘッダーの表現を指定します。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('list__header');
         ModifierUtil.initModifier(this, scheme$8);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$8);
         }
       }
     }]);
     return ListHeaderElement;
   })(BaseElement);

   window.OnsListHeaderElement = document.registerElement('ons-list-header', {
     prototype: ListHeaderElement.prototype
   });

   var scheme$9 = {
     '.list__item': 'list__item--*',
     '.list__item__left': 'list__item--*__left',
     '.list__item__center': 'list__item--*__center',
     '.list__item__right': 'list__item--*__right',
     '.list__item__label': 'list__item--*__label',
     '.list__item__title': 'list__item--*__title',
     '.list__item__subtitle': 'list__item--*__subtitle',
     '.list__item__thumbnail': 'list__item--*__thumbnail',
     '.list__item__icon': 'list__item--*__icon'
   };

   /**
    * @element ons-list-item
    * @category list
    * @modifier tight
    *   [en]Remove the space above and below the item content. This is useful for multi-line content.[/en]
    *   [ja]行間のスペースを取り除きます。複数行の内容をリストで扱う場合に便利です。[/ja]
    * @modifier tappable
    *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" attribute for better behavior when scrolling.[/en]
    *   [ja]タップやクリックした時に効果が表示されるようになります。[/ja]
    * @modifier chevron
    *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped.[/en]
    *   [ja]要素の右側に右矢印が表示されます。また、タップやクリックした時に効果が表示されるようになります。[/ja]
    * @description
    *   [en]Component that represents each item in the list. Must be put inside the ons-list component.[/en]
    *   [ja]リストの各要素を表現するためのコンポーネントです。ons-listコンポーネントと共に使用します。[/ja]
    * @seealso ons-list
    *   [en]ons-list component[/en]
    *   [ja]ons-listコンポーネント[/ja]
    * @seealso ons-list-header
    *   [en]ons-list-header component[/en]
    *   [ja]ons-list-headerコンポーネント[/ja]
    * @guide UsingList
    *   [en]Using lists[/en]
    *   [ja]リストを使う[/ja]
    * @codepen yxcCt
    * @example
    * <ons-list>
    *   <ons-list-header>Header Text</ons-list-header>
    *   <ons-list-item>Item</ons-list-item>
    *   <ons-list-item>Item</ons-list-item>
    * </ons-list>
    */

   var ListItemElement = (function (_BaseElement) {
     babelHelpers.inherits(ListItemElement, _BaseElement);

     function ListItemElement() {
       babelHelpers.classCallCheck(this, ListItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListItemElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list item.[/en]
        *   [ja]各要素の表現を指定します。[/ja]
        */

       /**
        * @attribute lock-on-drag
        * @type {String}
        * @description
        *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
        *   [ja]この属性があると、ユーザーがこの要素を横方向にドラッグしている時に、縦方向のスクロールが起きないようになります。[/ja]
        */

       /**
        * @attribute tappable
        * @type {Color}
        * @description
        *   [en]Changes the background color when tapped. An optional color value can be defined. Default color is "#d9d9d9".[/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);
         this.classList.add('list__item');

         var left = undefined,
             center = undefined,
             right = undefined;

         for (var i = 0; i < this.children.length; i++) {
           var el = this.children[i];

           if (el.classList.contains('left')) {
             el.classList.add('list__item__left');
             left = el;
           } else if (el.classList.contains('center')) {
             center = el;
           } else if (el.classList.contains('right')) {
             el.classList.add('list__item__right');
             right = el;
           }
         }

         if (!center) {
           center = document.createElement('div');

           if (!left && !right) {
             center.innerHTML = this.innerHTML;
             this.innerHTML = '';
           } else {

             for (var i = this.childNodes.length - 1; i >= 0; i--) {
               var el = this.childNodes[i];
               if (el !== left && el !== right) {
                 center.insertBefore(el, center.firstChild);
               }
             }
           }

           this.insertBefore(center, right || null);
         }

         center.classList.add('center');
         center.classList.add('list__item__center');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$9);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$9);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('drag', this._onDrag);
         this.addEventListener('touchstart', this._onTouch);
         this.addEventListener('mousedown', this._onTouch);
         this.addEventListener('touchend', this._onRelease);
         this.addEventListener('touchmove', this._onRelease);
         this.addEventListener('touchcancel', this._onRelease);
         this.addEventListener('mouseup', this._onRelease);
         this.addEventListener('mouseout', this._onRelease);
         this.addEventListener('touchleave', this._onRelease);

         this._originalBackgroundColor = this.style.backgroundColor;

         this.tapped = false;
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('drag', this._onDrag);
         this.removeEventListener('touchstart', this._onTouch);
         this.removeEventListener('mousedown', this._onTouch);
         this.removeEventListener('touchend', this._onRelease);
         this.removeEventListener('touchmove', this._onRelease);
         this.removeEventListener('touchcancel', this._onRelease);
         this.removeEventListener('mouseup', this._onRelease);
         this.removeEventListener('mouseout', this._onRelease);
         this.removeEventListener('touchleave', this._onRelease);
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         var gesture = event.gesture;
         // Prevent vertical scrolling if the users pans left or right.
         if (this._shouldLockOnDrag() && ['left', 'right'].indexOf(gesture.direction) > -1) {
           gesture.preventDefault();
         }
       }
     }, {
       key: '_onTouch',
       value: function _onTouch() {
         if (this.tapped) {
           return;
         }

         this.tapped = true;

         this.style.transition = this._transition;
         this.style.webkitTransition = this._transition;
         this.style.MozTransition = this._transition;

         if (this._tappable) {
           if (this.style.backgroundColor) {
             this._originalBackgroundColor = this.style.backgroundColor;
           }

           this.style.backgroundColor = this._tapColor;
         }
       }
     }, {
       key: '_onRelease',
       value: function _onRelease() {
         this.tapped = false;

         this.style.transition = '';
         this.style.webkitTransition = '';
         this.style.MozTransition = '';

         this.style.backgroundColor = this._originalBackgroundColor || '';
       }
     }, {
       key: '_shouldLockOnDrag',
       value: function _shouldLockOnDrag() {
         return this.hasAttribute('lock-on-drag');
       }
     }, {
       key: '_transition',
       get: function get() {
         return 'background-color 0.0s linear 0.02s';
       }
     }, {
       key: '_tappable',
       get: function get() {
         return this.hasAttribute('tappable');
       }
     }, {
       key: '_tapColor',
       get: function get() {
         return this.getAttribute('tappable') || '#d9d9d9';
       }
     }]);
     return ListItemElement;
   })(BaseElement);

   window.OnsListItemElement = document.registerElement('ons-list-item', {
     prototype: ListItemElement.prototype
   });

   var scheme$10 = { '': 'list--*' };

   /**
    * @element ons-list
    * @category list
    * @modifier inset
    *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
    *   [ja]親要素の画面いっぱいに広がらないリストを表示します。[/ja]
    * @modifier noborder
    *   [en]A list with no borders at the top and bottom.[/en]
    *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
    * @description
    *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
    *   [ja]リストを表現するためのコンポーネント。ons-list-itemのコンテナとして使用します。[/ja]
    * @seealso ons-list-item
    *   [en]ons-list-item component[/en]
    *   [ja]ons-list-itemコンポーネント[/ja]
    * @seealso ons-list-header
    *   [en]ons-list-header component[/en]
    *   [ja]ons-list-headerコンポーネント[/ja]
    * @guide UsingList
    *   [en]Using lists[/en]
    *   [ja]リストを使う[/ja]
    * @codepen yxcCt
    * @example
    * <ons-list>
    *   <ons-list-header>Header Text</ons-list-header>
    *   <ons-list-item>Item</ons-list-item>
    *   <ons-list-item>Item</ons-list-item>
    * </ons-list>
    */

   var ListElement = (function (_BaseElement) {
     babelHelpers.inherits(ListElement, _BaseElement);

     function ListElement() {
       babelHelpers.classCallCheck(this, ListElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ListElement).apply(this, arguments));
     }

     babelHelpers.createClass(ListElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the list.[/en]
        *   [ja]リストの表現を指定します。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('list');
         ModifierUtil.initModifier(this, scheme$10);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$10);
         }
       }
     }]);
     return ListElement;
   })(BaseElement);

   window.OnsListElement = document.registerElement('ons-list', {
     prototype: ListElement.prototype
   });

   var scheme$11 = {
     '.text-input': 'text-input--*',
     '.text-input__label': 'text-input--*__label',
     '.radio-button': 'radio-button--*',
     '.radio-button__input': 'radio-button--*__input',
     '.radio-button__checkmark': 'radio-button--*__checkmark',
     '.checkbox': 'checkbox--*',
     '.checkbox__input': 'checkbox--*__input',
     '.checkbox__checkmark': 'checkbox--*__checkmark'
   };

   var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'checked', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'size', 'step', 'type', 'validator', 'value'];

   /**
    * @element ons-material-input
    * @category form
    * @description
    *  [en]Material Design input component.[/en]
    *  [ja]Material Designのinputコンポ―ネントです。[/ja]
    * @codepen ojQxLj
    * @guide UsingFormComponents
    *   [en]Using form components[/en]
    *   [ja]フォームを使う[/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja]イベント処理の使い方[/ja]
    * @example
    * <ons-material-input label="Username"></ons-material-input>
    */

   var MaterialInputElement = (function (_BaseElement) {
     babelHelpers.inherits(MaterialInputElement, _BaseElement);

     function MaterialInputElement() {
       babelHelpers.classCallCheck(this, MaterialInputElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MaterialInputElement).apply(this, arguments));
     }

     babelHelpers.createClass(MaterialInputElement, [{
       key: 'createdCallback',

       /**
        * @attribute label
        * @type {String}
        * @description
        *   [en]Text for animated floating label.[/en]
        *   [ja]アニメーションさせるフローティングラベルのテキストを指定します。[/ja]
        */

       /**
        * @attribute no-float
        * @description
        *  [en]If this attribute is present, the label will not be animated.[/en]
        *  [ja]この属性が設定された時、ラベルはアニメーションしないようになります。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         var helper = document.createElement('span');
         helper.classList.add('_helper');

         var container = document.createElement('label');
         container.appendChild(document.createElement('input'));
         container.appendChild(helper);

         var label = document.createElement('span');
         label.classList.add('input-label');

         util.arrayFrom(this.childNodes).forEach(function (element) {
           return label.appendChild(element);
         });
         this.hasAttribute('content-left') ? container.insertBefore(label, container.firstChild) : container.appendChild(label);

         this.appendChild(container);

         switch (this.getAttribute('type')) {
           case 'checkbox':
             this.classList.add('checkbox');
             this._input.classList.add('checkbox__input');
             this._helper.classList.add('checkbox__checkmark');
             this._updateBoundAttributes();
             break;

           case 'radio':
             this.classList.add('radio-button');
             this._input.classList.add('radio-button__input');
             this._helper.classList.add('radio-button__checkmark');
             this._updateBoundAttributes();
             break;

           default:
             this._input.classList.add('text-input');
             this._helper.classList.add('text-input__label');
             this._input.parentElement.classList.add('text-input__container');

             this._updateLabel();
             this._updateLabelColor();
             this._updateBoundAttributes();
             this._updateLabelClass();

             this._boundOnInput = this._onInput.bind(this);
             this._boundOnFocusin = this._onFocusin.bind(this);
             this._boundOnFocusout = this._onFocusout.bind(this);
             break;
         }

         this._boundDelegateEvent = this._delegateEvent.bind(this);

         if (this.hasAttribute('input-id')) {
           this._input.id = this.getAttribute('input-id');
         }

         ModifierUtil.initModifier(this, scheme$11);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$11);
         } else if (name === 'placeholder') {
           return this._updateLabel();
         }if (name === 'input-id') {
           this._input.id = current;
         } else if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
           return this._updateBoundAttributes();
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         if (this._input.type !== 'checkbox' && this._input.type !== 'radio') {
           this._input.addEventListener('input', this._boundOnInput);
           this._input.addEventListener('focusin', this._boundOnFocusin);
           this._input.addEventListener('focusout', this._boundOnFocusout);
         }

         this._input.addEventListener('focus', this._boundDelegateEvent);
         this._input.addEventListener('blur', this._boundDelegateEvent);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._input.removeEventListener('input', this._boundOnInput);
         this._input.removeEventListener('focusin', this._boundOnFocusin);
         this._input.removeEventListener('focusout', this._boundOnFocusout);
         this._input.removeEventListener('focus', this._boundDelegateEvent);
         this._input.removeEventListener('blur', this._boundDelegateEvent);
       }
     }, {
       key: '_setLabel',
       value: function _setLabel(value) {
         if (typeof this._helper.textContent !== 'undefined') {
           this._helper.textContent = value;
         } else {
           this._helper.innerText = value;
         }
       }
     }, {
       key: '_updateLabel',
       value: function _updateLabel() {
         this._setLabel(this.hasAttribute('placeholder') ? this.getAttribute('placeholder') : '');
       }
     }, {
       key: '_updateBoundAttributes',
       value: function _updateBoundAttributes() {
         var _this2 = this;

         INPUT_ATTRIBUTES.forEach(function (attr) {
           if (_this2.hasAttribute(attr)) {
             _this2._input.setAttribute(attr, _this2.getAttribute(attr));
           } else {
             _this2._input.removeAttribute(attr);
           }
         });
       }
     }, {
       key: '_updateLabelColor',
       value: function _updateLabelColor() {
         if (this.value.length > 0 && this._input === document.activeElement) {
           this._helper.style.color = '';
         } else {
           this._helper.style.color = 'rgba(0, 0, 0, 0.5)';
         }
       }
     }, {
       key: '_updateLabelClass',
       value: function _updateLabelClass() {
         if (this.value === '') {
           this._helper.classList.remove('text-input__label--active');
         } else {
           this._helper.classList.add('text-input__label--active');
         }
       }
     }, {
       key: '_delegateEvent',
       value: function _delegateEvent(event) {
         var e = new CustomEvent(event.type, {
           bubbles: false,
           cancelable: true
         });

         return this.dispatchEvent(e);
       }
     }, {
       key: '_onInput',
       value: function _onInput(event) {
         this._updateLabelClass();
         this._updateLabelColor();
       }
     }, {
       key: '_onFocusin',
       value: function _onFocusin(event) {
         this._updateLabelClass();
         this._updateLabelColor();
       }
     }, {
       key: '_onFocusout',
       value: function _onFocusout(event) {
         this._updateLabelColor();
       }
     }, {
       key: '_input',
       get: function get() {
         return this.querySelector('input');
       }
     }, {
       key: '_helper',
       get: function get() {
         return this.querySelector('._helper');
       }
     }, {
       key: 'value',
       get: function get() {
         return this._input.value;
       },
       set: function set(val) {
         this._input.value = val;
         this._onInput();

         return this._input.val;
       }
     }, {
       key: 'checked',
       get: function get() {
         return this._input.checked;
       },
       set: function set(val) {
         this._input.checked = val;
       }
     }, {
       key: '_isTextInput',
       get: function get() {
         return this._input.classList.contains('text-input');
       }
     }]);
     return MaterialInputElement;
   })(BaseElement);

   window.OnsInputElement = document.registerElement('ons-input', {
     prototype: MaterialInputElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var ModalAnimator = (function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function ModalAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, ModalAnimator);

       this.delay = 0;
       this.duration = 0.2;

       this.timing = options.timing || this.timing;
       this.duration = options.duration !== undefined ? options.duration : this.duration;
       this.delay = options.delay !== undefined ? options.delay : this.delay;
     }

     /**
      * @param {HTMLElement} modal
      * @param {Function} callback
      */

     babelHelpers.createClass(ModalAnimator, [{
       key: "show",
       value: function show(modal, callback) {
         callback();
       }

       /**
        * @param {HTMLElement} modal
        * @param {Function} callback
        */

     }, {
       key: "hide",
       value: function hide(modal, callback) {
         callback();
       }
     }]);
     return ModalAnimator;
   })();

   /**
    * iOS style animator for dialog.
    */

   var FadeModalAnimator = (function (_ModalAnimator) {
     babelHelpers.inherits(FadeModalAnimator, _ModalAnimator);

     function FadeModalAnimator(options) {
       babelHelpers.classCallCheck(this, FadeModalAnimator);

       options.timing = options.timing || 'linear';
       options.duration = options.duration || '0.3';
       options.delay = options.delay || 0;

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(FadeModalAnimator).call(this, options));
     }

     /**
      * @param {HTMLElement} modal
      * @param {Function} callback
      */

     babelHelpers.createClass(FadeModalAnimator, [{
       key: 'show',
       value: function show(modal, callback) {
         callback = callback ? callback : function () {};

         animit(modal).queue({
           opacity: 0
         }).wait(this.delay).queue({
           opacity: 1.0
         }, {
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }).play();
       }

       /**
        * @param {HTMLElement} modal
        * @param {Function} callback
        */

     }, {
       key: 'hide',
       value: function hide(modal, callback) {
         callback = callback ? callback : function () {};

         animit(modal).queue({
           opacity: 1
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }).play();
       }
     }]);
     return FadeModalAnimator;
   })(ModalAnimator);

   var scheme$12 = {
     '': 'modal--*',
     'modal__content': 'modal--*__content'
   };

   var _animatorDict$2 = {
     'default': ModalAnimator,
     'fade': FadeModalAnimator,
     'none': ModalAnimator
   };

   /**
    * @element ons-modal
    * @category modal
    * @description
    *   [en]
    *     Modal component that masks current screen.
    *     Underlying components are not subject to any events while the modal component is shown.
    *   [/en]
    *   [ja]
    *     画面全体をマスクするモーダル用コンポーネントです。下側にあるコンポーネントは、
    *     モーダルが表示されている間はイベント通知が行われません。
    *   [/ja]
    * @guide UsingModal
    *   [en]Using ons-modal component[/en]
    *   [ja]モーダルの使い方[/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using navigator from JavaScript[/en]
    *   [ja]JavaScriptからコンポーネントを呼び出す[/ja]
    * @codepen devIg
    * @example
    * <ons-modal>
    *   ...
    * </ons-modal>
    */

   var ModalElement = (function (_BaseElement) {
     babelHelpers.inherits(ModalElement, _BaseElement);

     function ModalElement() {
       babelHelpers.classCallCheck(this, ModalElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ModalElement).apply(this, arguments));
     }

     babelHelpers.createClass(ModalElement, [{
       key: 'createdCallback',

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]The animation used when showing and hiding the modal. Can be either "none" or "fade".[/en]
        *  [ja]モーダルを表示する際のアニメーション名を指定します。"none"もしくは"fade"を指定できます。[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/en]
        *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._doorLock = new DoorLock();

         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$2,
           baseClass: ModalAnimator,
           baseClassName: 'ModalAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }

       /**
        * @method getDeviceBackButtonHandler
        * @signature getDeviceBackButtonHandler()
        * @return {Object}
        *   [en]Device back button handler.[/en]
        *   [ja]デバイスのバックボタンハンドラを返します。[/ja]
        * @description
        *   [en]Retrieve the back button handler.[/en]
        *   [ja]ons-modalに紐付いているバックボタンハンドラを取得します。[/ja]
        */

     }, {
       key: 'getDeviceBackButtonHandler',
       value: function getDeviceBackButtonHandler() {
         return this._deviceBackButtonHandler;
       }

       /**
        * @method setDeviceBackButtonHandler
        * @signature setDeviceBackButtonHandler(callback)
        * @return {Function} callback
        *   [en][/en]
        *   [ja][/ja]
        * @description
        *   [en][/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setDeviceBackButtonHandler',
       value: function setDeviceBackButtonHandler(callback) {
         if (this._deviceBackButtonHandler) {
           this._deviceBackButtonHandler.destroy();
         }

         this._deviceBackButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
         this._onDeviceBackButton = callback;
       }
     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton() {
         // Do nothing and stop device-backbutton handler chain.
         return;
       }
     }, {
       key: '_compile',
       value: function _compile() {
         this.style.display = 'none';
         this.classList.add('modal');

         var wrapper = document.createElement('div');
         wrapper.classList.add('modal__content');

         while (this.childNodes[0]) {
           var node = this.childNodes[0];
           this.removeChild(node);
           wrapper.insertBefore(node, null);
         }

         this.appendChild(wrapper);

         ModifierUtil.initModifier(this, scheme$12);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         if (this._deviceBackButtonHandler) {
           this._deviceBackButtonHandler.destroy();
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         setImmediate(this._ensureNodePosition.bind(this));
         this._deviceBackButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._onDeviceBackButton.bind(this));
       }
     }, {
       key: '_ensureNodePosition',
       value: function _ensureNodePosition() {
         if (!this.parentNode || this.hasAttribute('inline')) {
           return;
         }

         if (this.parentNode.nodeName.toLowerCase() !== 'ons-page') {
           var page = this;
           for (;;) {
             page = page.parentNode;

             if (!page) {
               return;
             }

             if (page.nodeName.toLowerCase() === 'ons-page') {
               break;
             }
           }
           page._registerExtraElement(this);
         }
       }

       /**
        * @method isShown
        * @signature isShown()
        * @return {Boolean}
        *   [en]true if the modal is visible.[/en]
        *   [ja]モーダルが表示されている場合にtrueとなります。[/ja]
        * @description
        *   [en]Returns whether the modal is visible or not.[/en]
        *   [ja]モーダルが表示されているかどうかを返します。[/ja]
        */

     }, {
       key: 'isShown',
       value: function isShown() {
         return this.style.display !== 'none';
       }

       /**
        * @method show
        * @signature show([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "none" and "fade".[/en]
        *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @description
        *   [en]Show modal.[/en]
        *   [ja]モーダルを表示します。[/ja]
        * @return {Promise}
        *   [en]Resolves to the displayed element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'show',
       value: function show() {
         var _this2 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         var callback = options.callback || function () {};

         var tryShow = function tryShow() {
           var unlock = _this2._doorLock.lock();
           var animator = _this2._animatorFactory.newAnimator(options);

           _this2.style.display = 'table';
           return new Promise(function (resolve) {
             animator.show(_this2, function () {
               unlock();

               callback();
               resolve(_this2);
             });
           });
         };

         return new Promise(function (resolve) {
           _this2._doorLock.waitUnlock(function () {
             return resolve(tryShow());
           });
         });
       }

       /**
        * @method toggle
        * @signature toggle([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "none" and "fade".[/en]
        *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @description
        *   [en]Toggle modal visibility.[/en]
        *   [ja]モーダルの表示を切り替えます。[/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         if (this.isShown()) {
           return this.hide.apply(this, arguments);
         } else {
           return this.show.apply(this, arguments);
         }
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "none" and "fade".[/en]
        *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @description
        *   [en]Hide modal.[/en]
        *   [ja]モーダルを非表示にします。[/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         var callback = options.callback || function () {};

         var tryHide = function tryHide() {
           var unlock = _this3._doorLock.lock();
           var animator = _this3._animatorFactory.newAnimator(options);

           return new Promise(function (resolve) {
             animator.hide(_this3, function () {
               _this3.style.display = 'none';
               unlock();

               callback();
               resolve(_this3);
             });
           });
         };

         return new Promise(function (resolve) {
           _this3._doorLock.waitUnlock(function () {
             return resolve(tryHide());
           });
         });
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$12);
         }
       }
     }]);
     return ModalElement;
   })(BaseElement);

   window.OnsModalElement = document.registerElement('ons-modal', {
     prototype: ModalElement.prototype
   });

   /**
    * @param {String} name
    * @param {Function} Animator
    */
   window.OnsModalElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof ModalAnimator)) {
       throw new Error('"Animator" param must inherit OnsModalElement.ModalAnimator');
     }
     _animatorDict$2[name] = Animator;
   };

   window.OnsModalElement.ModalAnimator = ModalAnimator;

   var NavigatorTransitionAnimator = (function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function NavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, NavigatorTransitionAnimator);

       options = util.extend({
         timing: 'linear',
         duration: '0.4',
         delay: '0'
       }, options || {});

       this.timing = options.timing;
       this.duration = options.duration;
       this.delay = options.delay;
     }

     babelHelpers.createClass(NavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         callback();
       }
     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         callback();
       }
     }]);
     return NavigatorTransitionAnimator;
   })();

   /**
    * Slide animator for navigator transition like iOS's screen slide transition.
    */

   var IOSSlideNavigatorTransitionAnimator = (function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSSlideNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSSlideNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSSlideNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black; opacity: 0; z-index: 2"></div>\n    ');
       return _this;
     }

     babelHelpers.createClass(IOSSlideNavigatorTransitionAnimator, [{
       key: '_decompose',
       value: function _decompose(page) {
         CustomElements.upgrade(page);
         var toolbar = page._getToolbarElement();
         CustomElements.upgrade(toolbar);
         var left = toolbar._getToolbarLeftItemsElement();
         var right = toolbar._getToolbarRightItemsElement();

         var excludeBackButtonLabel = function excludeBackButtonLabel(elements) {
           var result = [];

           for (var i = 0; i < elements.length; i++) {
             if (elements[i].nodeName.toLowerCase() === 'ons-back-button') {
               var iconElement = elements[i].querySelector('.back-button__icon');
               if (iconElement) {
                 result.push(iconElement);
               }
             } else {
               result.push(elements[i]);
             }
           }

           return result;
         };

         var other = [].concat(left.children.length === 0 ? left : excludeBackButtonLabel(left.children)).concat(right.children.length === 0 ? right : excludeBackButtonLabel(right.children));

         var pageLabels = [toolbar._getToolbarCenterItemsElement(), toolbar._getToolbarBackButtonLabelElement()];

         return {
           pageLabels: pageLabels,
           other: other,
           content: page._getContentElement(),
           background: page._getBackgroundElement(),
           toolbar: toolbar,
           bottomToolbar: page._getBottomToolbarElement()
         };
       }
     }, {
       key: '_shouldAnimateToolbar',
       value: function _shouldAnimateToolbar(enterPage, leavePage) {
         var bothPageHasToolbar = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();

         var noMaterialToolbar = !enterPage._getToolbarElement().classList.contains('navigation-bar--material') && !leavePage._getToolbarElement().classList.contains('navigation-bar--material');

         return bothPageHasToolbar && noMaterialToolbar;
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentNode.insertBefore(this.backgroundMask, leavePage.nextSibling);

         var enterPageDecomposition = this._decompose(enterPage);
         var leavePageDecomposition = this._decompose(leavePage);

         var delta = (function () {
           var rect = leavePage.getBoundingClientRect();
           return Math.round((rect.right - rect.left) / 2 * 0.6);
         })();

         var maskClear = animit(this.backgroundMask).saveStyle().queue({
           opacity: 0,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: 0.1
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         });

         var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPage, leavePage);

         if (shouldAnimateToolbar) {
           animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.pageLabels).saveStyle().queue({
             css: {
               transform: 'translate3d(' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
             css: { opacity: 0 },
             duration: 0
           }).wait(this.delay).queue({
             css: { opacity: 1 },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).saveStyle().queue({
             css: {
               transform: 'translate3D(0, 0, 0)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle().queue(function (done) {
             callback();
             done();
           }), animit(leavePageDecomposition.pageLabels).saveStyle().queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(-' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(leavePageDecomposition.other).saveStyle().queue({
             css: { opacity: 1 },
             duration: 0
           }).wait(this.delay).queue({
             css: { opacity: 0 },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle());
         } else {

           animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(leavePage).saveStyle().queue({
             css: {
               transform: 'translate3D(0, 0, 0)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle().queue(function (done) {
             callback();
             done();
           }));
         }
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, done) {
         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

         var enterPageDecomposition = this._decompose(enterPage);
         var leavePageDecomposition = this._decompose(leavePage);

         var delta = (function () {
           var rect = leavePage.getBoundingClientRect();
           return Math.round((rect.right - rect.left) / 2 * 0.6);
         })();

         var maskClear = animit(this.backgroundMask).saveStyle().queue({
           opacity: 0.1,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           done();
         });

         var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPage, leavePage);

         if (shouldAnimateToolbar) {
           animit.runAll(maskClear, animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)',
               opacity: 0.9
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.pageLabels).saveStyle().queue({
             css: {
               transform: 'translate3d(-' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.toolbar).saveStyle().queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(enterPageDecomposition.other).saveStyle().queue({
             css: { opacity: 0 },
             duration: 0
           }).wait(this.delay).queue({
             css: { opacity: 1 },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).wait(0).queue((function (finish) {
             this.backgroundMask.remove();
             done();
             finish();
           }).bind(this)), animit(leavePageDecomposition.other).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 0
             },
             duration: this.duration,
             timing: this.timing
           }), animit(leavePageDecomposition.toolbar).queue({
             css: {
               background: 'none',
               backgroundColor: 'rgba(0, 0, 0, 0)',
               borderColor: 'rgba(0, 0, 0, 0)'
             },
             duration: 0
           }), animit(leavePageDecomposition.pageLabels).queue({
             css: {
               transform: 'translate3d(0, 0, 0)',
               opacity: 1.0
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3d(' + delta + 'px, 0, 0)',
               opacity: 0
             },
             duration: this.duration,
             timing: this.timing
           }));
         } else {
           animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
             css: {
               transform: 'translate3D(-25%, 0px, 0px)',
               opacity: 0.9
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)',
               opacity: 1.0
             },
             duration: this.duration,
             timing: this.timing
           }).restoreStyle(), animit(leavePage).queue({
             css: {
               transform: 'translate3D(0px, 0px, 0px)'
             },
             duration: 0
           }).wait(this.delay).queue({
             css: {
               transform: 'translate3D(100%, 0px, 0px)'
             },
             duration: this.duration,
             timing: this.timing
           }).queue((function (finish) {
             this.backgroundMask.remove();
             done();
             finish();
           }).bind(this)));
         }
       }
     }]);
     return IOSSlideNavigatorTransitionAnimator;
   })(NavigatorTransitionAnimator);

   /**
    * Lift screen transition.
    */

   var IOSLiftNavigatorTransitionAnimator = (function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSLiftNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSLiftNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSLiftNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background: linear-gradient(black, white);"></div>\n    ');
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */

     babelHelpers.createClass(IOSLiftNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

         var maskClear = animit(this.backgroundMask).wait(0.6).queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         });

         animit.runAll(maskClear, animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).wait(0.2).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, -10%, 0)',
             opacity: 0.9
           },
           duration: this.duration,
           timing: this.timing
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

         animit.runAll(animit(this.backgroundMask).wait(0.4).queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage).queue({
           css: {
             transform: 'translate3D(0, -10%, 0)',
             opacity: 0.9
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).wait(0.4).queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return IOSLiftNavigatorTransitionAnimator;
   })(NavigatorTransitionAnimator);

   /**
    * Fade-in screen transition.
    */

   var IOSFadeNavigatorTransitionAnimator = (function (_NavigatorTransitionA) {
     babelHelpers.inherits(IOSFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

     function IOSFadeNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, IOSFadeNavigatorTransitionAnimator);

       options = util.extend({
         timing: 'linear',
         duration: '0.4',
         delay: '0'
       }, options || {});

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSFadeNavigatorTransitionAnimator).call(this, options));
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */

     babelHelpers.createClass(IOSFadeNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {

         animit.runAll(animit([enterPage._getContentElement(), enterPage._getBackgroundElement()]).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(enterPage._getToolbarElement()).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle());
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         animit.runAll(animit([leavePage._getContentElement(), leavePage._getBackgroundElement()]).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage._getToolbarElement()).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return IOSFadeNavigatorTransitionAnimator;
   })(NavigatorTransitionAnimator);

   /**
    * Slide animator for navigator transition.
    */

   var MDSlideNavigatorTransitionAnimator = (function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDSlideNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDSlideNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDSlideNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.3,
         timing: 'cubic-bezier(.1, .7, .4, 1)',
         delay: 0
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDSlideNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%; z-index: 2;\n        background-color: black; opacity: 0;"></div>\n    ');
       _this.blackMaskOpacity = 0.4;
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */

     babelHelpers.createClass(MDSlideNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);

         animit.runAll(animit(this.backgroundMask).saveStyle().queue({
           opacity: 0,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: this.blackMaskOpacity
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         }), animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(100%, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle(), animit(leavePage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(-45%, 0px, 0px)'
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().wait(0.2).queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, done) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

         animit.runAll(animit(this.backgroundMask).saveStyle().queue({
           opacity: this.blackMaskOpacity,
           transform: 'translate3d(0, 0, 0)'
         }).wait(this.delay).queue({
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(-45%, 0px, 0px)',
             opacity: 0.9
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0px, 0px, 0px)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle(), animit(leavePage).queue({
           css: {
             transform: 'translate3D(0px, 0px, 0px)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(100%, 0px, 0px)'
           },
           duration: this.duration,
           timing: this.timing
         }).wait(0.2).queue(function (finish) {
           done();
           finish();
         }));
       }
     }]);
     return MDSlideNavigatorTransitionAnimator;
   })(NavigatorTransitionAnimator);

   /**
    * Lift screen transition.
    */

   var MDLiftNavigatorTransitionAnimator = (function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDLiftNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDLiftNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDLiftNavigatorTransitionAnimator);

       options = util.extend({
         duration: 0.4,
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         delay: 0.05
       }, options || {});

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDLiftNavigatorTransitionAnimator).call(this, options));

       _this.backgroundMask = util.createElement('\n      <div style="position: absolute; width: 100%; height: 100%;\n        background-color: black;"></div>\n    ');
       return _this;
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */

     babelHelpers.createClass(MDLiftNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         var _this2 = this;

         this.backgroundMask.remove();
         leavePage.element.parentNode.insertBefore(this.backgroundMask, leavePage.element);

         var maskClear = animit(this.backgroundMask).wait(0.6).queue(function (done) {
           _this2.backgroundMask.remove();
           done();
         });

         animit.runAll(maskClear, animit(enterPage.element).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).wait(0.5).restoreStyle().queue(function (done) {
           callback();
           done();
         }), animit(leavePage.element).queue({
           css: {
             opacity: 1.0
           },
           duration: 0
         }).wait(0).queue({
           css: {
             opacity: 0.4
           },
           duration: this.duration,
           timing: this.timing
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} callback
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         var _this3 = this;

         this.backgroundMask.remove();
         enterPage.element.parentNode.insertBefore(this.backgroundMask, enterPage.element);

         animit.runAll(animit(this.backgroundMask).wait(0.4).queue(function (done) {
           _this3.backgroundMask.remove();
           done();
         }), animit(enterPage.element).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 0.4
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1.0
           },
           duration: this.duration,
           timing: this.timing
         }).wait(0.4).queue(function (done) {
           callback();
           done();
         }), animit(leavePage.element).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 100%, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return MDLiftNavigatorTransitionAnimator;
   })(NavigatorTransitionAnimator);

   /**
    * Fade-in + Lift screen transition.
    */

   var MDFadeNavigatorTransitionAnimator = (function (_NavigatorTransitionA) {
     babelHelpers.inherits(MDFadeNavigatorTransitionAnimator, _NavigatorTransitionA);

     function MDFadeNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, MDFadeNavigatorTransitionAnimator);

       options = util.extend({
         timing: 'ease-out',
         duration: '0.25',
         delay: '0.20'
       }, options || {});

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDFadeNavigatorTransitionAnimator).call(this, options));
     }

     /**
      * @param {Object} enterPage
      * @param {Object} leavePage
      * @param {Function} callback
      */

     babelHelpers.createClass(MDFadeNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {

         animit.runAll(animit(enterPage).saveStyle().queue({
           css: {
             transform: 'translate3D(0, 42px, 0)',
             opacity: 0
           },
           duration: 0
         }).wait(this.delay).queue({
           css: {
             transform: 'translate3D(0, 0, 0)',
             opacity: 1
           },
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (done) {
           callback();
           done();
         }));
       }

       /**
        * @param {Object} enterPage
        * @param {Object} leavePage
        * @param {Function} done
        */

     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         animit.runAll(animit(leavePage).queue({
           css: {
             transform: 'translate3D(0, 0, 0)'
           },
           duration: 0
         }).wait(0.15).queue({
           css: {
             transform: 'translate3D(0, 38px, 0)'
           },
           duration: this.duration,
           timing: this.timing
         }).queue(function (done) {
           callback();
           done();
         }), animit(leavePage).queue({
           css: {
             opacity: 1
           },
           duration: 0
         }).wait(0.04).queue({
           css: {
             opacity: 0
           },
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return MDFadeNavigatorTransitionAnimator;
   })(NavigatorTransitionAnimator);

   var NoneNavigatorTransitionAnimator = (function (_NavigatorTransitionA) {
     babelHelpers.inherits(NoneNavigatorTransitionAnimator, _NavigatorTransitionA);

     function NoneNavigatorTransitionAnimator(options) {
       babelHelpers.classCallCheck(this, NoneNavigatorTransitionAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(NoneNavigatorTransitionAnimator).call(this, options));
     }

     babelHelpers.createClass(NoneNavigatorTransitionAnimator, [{
       key: 'push',
       value: function push(enterPage, leavePage, callback) {
         callback();
       }
     }, {
       key: 'pop',
       value: function pop(enterPage, leavePage, callback) {
         callback();
       }
     }]);
     return NoneNavigatorTransitionAnimator;
   })(NavigatorTransitionAnimator);

   var NavigatorPage = (function () {

     /**
      * @param {Object} params
      * @param {Object} params.page
      * @param {Object} params.element
      * @param {Object} params.options
      * @param {Object} params.navigator
      * @param {String} params.initialContent
      */

     function NavigatorPage(params) {
       var _this = this;

       babelHelpers.classCallCheck(this, NavigatorPage);

       this.page = params.page;
       this.name = params.page;
       this.element = params.element;
       this.options = params.options;
       this.navigator = params.navigator;
       this.initialContent = params.initialContent;
       this.backButton = util.findChildRecursively(this.element, 'ons-back-button');

       if (this.backButton) {
         CustomElements.upgrade(this.backButton);
       }

       // Block events while page is being animated to stop scrolling, pressing buttons, etc.
       this._blockEvents = function (event) {
         if (_this.navigator._isPopping || _this.navigator._isPushing) {
           event.preventDefault();
           event.stopPropagation();
         }
       };

       this._pointerEvents.forEach(function (event) {
         return _this.element.addEventListener(event, _this._blockEvents);
       }, false);
     }

     babelHelpers.createClass(NavigatorPage, [{
       key: 'getDeviceBackButtonHandler',
       value: function getDeviceBackButtonHandler() {
         return this._deviceBackButtonHandler;
       }

       /**
        * @return {PageView}
        */

     }, {
       key: 'getPageView',
       value: function getPageView() {
         if (!this._page) {
           this._page = util.findParent('ons-page');
           if (!this._page) {
             throw new Error('Fail to fetch ons-page element.');
           }
         }
         return this._page;
       }
     }, {
       key: 'updateBackButton',
       value: function updateBackButton() {
         if (this.backButton) {
           if (this.navigator._pages.length === 1 || this.options._forceHideBackButton) {
             this.backButton.hide();
             this.options._forceHideBackButton = false;
           } else {
             this.backButton.show();
           }
         }
       }
     }, {
       key: 'destroy',
       value: function destroy() {
         var _this2 = this;

         this._pointerEvents.forEach(function (event) {
           return _this2.element.removeEventListener(event, _this2._blockEvents);
         }, false);
         this.element._destroy();

         var index = this.navigator._pages.indexOf(this);
         if (index !== -1) {
           this.navigator._pages.splice(index, 1);
         }

         this.element = this._page = this.options = this.navigator = null;
       }
     }, {
       key: '_pointerEvents',
       get: function get() {
         return ['touchmove'];
       }
     }]);
     return NavigatorPage;
   })();

   var _animatorDict$3 = {
     'default': function _default() {
       return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
     },
     'slide': function slide() {
       return platform.isAndroid() ? MDSlideNavigatorTransitionAnimator : IOSSlideNavigatorTransitionAnimator;
     },
     'lift': function lift() {
       return platform.isAndroid() ? MDLiftNavigatorTransitionAnimator : IOSLiftNavigatorTransitionAnimator;
     },
     'fade': function fade() {
       return platform.isAndroid() ? MDFadeNavigatorTransitionAnimator : IOSFadeNavigatorTransitionAnimator;
     },
     'slide-ios': IOSSlideNavigatorTransitionAnimator,
     'slide-md': MDSlideNavigatorTransitionAnimator,
     'lift-ios': IOSLiftNavigatorTransitionAnimator,
     'lift-md': MDLiftNavigatorTransitionAnimator,
     'fade-ios': IOSFadeNavigatorTransitionAnimator,
     'fade-md': MDFadeNavigatorTransitionAnimator,
     'none': NoneNavigatorTransitionAnimator
   };

   var rewritables = {
     /**
      * @param {Element} navigatorSideElement
      * @param {Function} callback
      */

     ready: function ready(navigatorElement, callback) {
       callback();
     },

     /**
      * @param {Element} navigatorElement
      * @param {Element} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(navigatorElement, target, options, callback) {
       callback(target);
     }
   };

   /**
    * @element ons-navigator
    * @category navigation
    * @description
    *   [en]A component that provides page stack management and navigation. This component does not have a visible content.[/en]
    *   [ja]ページスタックの管理とナビゲーション機能を提供するコンポーネント。画面上への出力はありません。[/ja]
    * @codepen yrhtv
    * @guide PageNavigation
    *   [en]Guide for page navigation[/en]
    *   [ja]ページナビゲーションの概要[/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using navigator from JavaScript[/en]
    *   [ja]JavaScriptからコンポーネントを呼び出す[/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja]イベント処理の使い方[/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]複数のページを1つのHTMLに記述する[/ja]
    * @seealso ons-toolbar
    *   [en]ons-toolbar component[/en]
    *   [ja]ons-toolbarコンポーネント[/ja]
    * @seealso ons-back-button
    *   [en]ons-back-button component[/en]
    *   [ja]ons-back-buttonコンポーネント[/ja]
    * @example
    * <ons-navigator animation="slide" var="app.navi">
    *   <ons-page>
    *     <ons-toolbar>
    *       <div class="center">Title</div>
    *     </ons-toolbar>
    *
    *     <p style="text-align: center">
    *       <ons-button modifier="light" ng-click="app.navi.pushPage('page.html');">Push</ons-button>
    *     </p>
    *   </ons-page>
    * </ons-navigator>
    *
    * <ons-template id="page.html">
    *   <ons-page>
    *     <ons-toolbar>
    *       <div class="center">Title</div>
    *     </ons-toolbar>
    *
    *     <p style="text-align: center">
    *       <ons-button modifier="light" ng-click="app.navi.popPage();">Pop</ons-button>
    *     </p>
    *   </ons-page>
    * </ons-template>
    */

   var NavigatorElement = (function (_BaseElement) {
     babelHelpers.inherits(NavigatorElement, _BaseElement);

     function NavigatorElement() {
       babelHelpers.classCallCheck(this, NavigatorElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(NavigatorElement).apply(this, arguments));
     }

     babelHelpers.createClass(NavigatorElement, [{
       key: 'createdCallback',

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/en]
        *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
        */

       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]First page to show when navigator is initialized.[/en]
        *   [ja]ナビゲーターが初期化された時に表示するページを指定します。[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default default
        * @description
        *  [en]Specify the transition animation. Use one of "slide", "simpleslide", "fade", "lift", "none" and "default".[/en]
        *  [ja]画面遷移する際のアニメーションを指定します。"slide", "simpleslide", "fade", "lift", "none", "default"のいずれかを指定できます。[/ja]
        */

       /**
        * @attribute prepush
        * @description
        *   [en]Fired just before a page is pushed.[/en]
        *   [ja]pageがpushされる直前に発火されます。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        * @param {Object} event.currentPage
        *   [en]Current page object.[/en]
        *   [ja]現在のpageオブジェクト。[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the push.[/en]
        *   [ja]この関数を呼び出すと、push処理がキャンセルされます。[/ja]
        */

       /**
        * @attribute prepop
        * @description
        *   [en]Fired just before a page is popped.[/en]
        *   [ja]pageがpopされる直前に発火されます。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        * @param {Object} event.currentPage
        *   [en]Current page object.[/en]
        *   [ja]現在のpageオブジェクト。[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the pop.[/en]
        *   [ja]この関数を呼び出すと、pageのpopがキャンセルされます。[/ja]
        */

       /**
        * @attribute postpush
        * @description
        *   [en]Fired just after a page is pushed.[/en]
        *   [ja]pageがpushされてアニメーションが終了してから発火されます。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        * @param {Object} event.enterPage
        *   [en]Object of the next page.[/en]
        *   [ja]pushされたpageオブジェクト。[/ja]
        * @param {Object} event.leavePage
        *   [en]Object of the previous page.[/en]
        *   [ja]以前のpageオブジェクト。[/ja]
        */

       /**
        * @event postpop
        * @description
        *   [en]Fired just after a page is popped.[/en]
        *   [ja]pageがpopされてアニメーションが終わった後に発火されます。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.navigator
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        * @param {Object} event.enterPage
        *   [en]Object of the next page.[/en]
        *   [ja]popされて表示されるページのオブジェクト。[/ja]
        * @param {Object} event.leavePage
        *   [en]Object of the previous page.[/en]
        *   [ja]popされて消えるページのオブジェクト。[/ja]
        */
       value: function createdCallback() {
         this._boundOnDeviceBackButton = this._onDeviceBackButton.bind(this);
         this._isRunning = false;

         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$3,
           baseClass: NavigatorTransitionAnimator,
           baseClassName: 'NavigatorTransitionAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }

       /**
        * @property {object} [options]
        * @description
        *   [en]Default options object.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'canPopPage',

       /**
        * @return {Boolean}
        */
       value: function canPopPage() {
         return this.pages.length > 1;
       }

       /**
        * @method replacePage
        * @signature replacePage(pageUrl, [options])
        * @param {String} [pageUrl]
        *   [en]Page URL. Can be either a HTML document or an <code>&lt;ons-template&gt;</code>.[/en]
        *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.page]
        *   [en]PageURL. Only necssary if `page` parameter is omitted.[/en]
        *   [ja][/ja]
        * @param {String} [options.pageHTML]
        *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "slide", "simpleslide", "lift", "fade" and "none".[/en]
        *   [ja]アニメーション名を指定できます。"slide", "simpleslide", "lift", "fade", "none"のいずれかを指定できます。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.onTransitionEnd]
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Replaces the current page with the specified one.[/en]
        *   [ja]現在表示中のページをを指定したページに置き換えます。[/ja]
        */

       /**
        * Replaces the current page with the specified one.
        *
        * @param {String} page
        * @param {Object} [options]
        */

     }, {
       key: 'replacePage',
       value: function replacePage(page) {
         var _this2 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if ((typeof page === 'undefined' ? 'undefined' : babelHelpers.typeof(page)) === 'object' && page !== null) {
           options = page;
         } else {
           options.page = page;
         }

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         var onTransitionEnd = options.onTransitionEnd || function () {};

         options.onTransitionEnd = function () {
           if (_this2.pages.length > 1) {
             _this2.pages[_this2.pages.length - 2]._destroy();
           }

           _this2._updateLastPageBackButton();

           onTransitionEnd();
         };

         return this.pushPage(options.page, options);
       }
     }, {
       key: '_updateLastPageBackButton',
       value: function _updateLastPageBackButton() {
         var index = this.pages.length - 1;
         this.pages[index].updateBackButton(index > 0);
       }

       /**
        * @method popPage
        * @signature popPage([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "slide", "simpleslide", "lift", "fade" and "none".[/en]
        *   [ja]アニメーション名を指定します。"slide", "simpleslide", "lift", "fade", "none"のいずれかを指定できます。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Boolean} [options.refresh]
        *   [en]The previous page will be refreshed (destroyed and created again) before popPage action.[/en]
        *   [ja]popPageする前に、前にあるページを生成しなおして更新する場合にtrueを指定します。[/ja]
        * @param {Function} [options.onTransitionEnd]
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
        *   [ja]現在表示中のページをページスタックから取り除きます。一つ前のページに戻ります。[/ja]
        */

       /**
        * Pops current page from the page stack.
        *
        * @param {Object} [options]
        * @param {String} [options.animation]
        * @param {Object} [options.animationOptions]
        * @param {Boolean} [options.refresh]
        * @param {Function} [options.onTransitionEnd]
        * @param {Boolean} [options.cancelIfRunning]
        * @return {Promise} Resolves to the new top page object.
        */

     }, {
       key: 'popPage',
       value: function popPage() {
         var _this3 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         var lastPage = this.pages[this.pages.length - 1];
         if (options.refresh) {
           var popUpdate;
           var preFun;

           var _ret = (function () {
             var index = _this3.pages.length - 2;

             if (!_this3.pages[index].name) {
               throw new Error('Refresh option cannot be used with pages directly inside the Navigator. Use ons-template instead.');
             }

             popUpdate = function () {
               return new Promise(function (resolve) {
                 _this3.pages[_this3.pages.length - 1]._destroy();
                 resolve();
               });
             };

             preFun = function () {
               return new Promise(function (resolve) {
                 internal.getPageHTMLAsync(_this3.pages[index].name).then(function (templateHTML) {
                   var element = _this3._createPageElement(templateHTML);

                   element.name = _this3.name;
                   element.options = options;

                   rewritables.link(_this3, element, _this3.pages[index].options, function (element) {
                     _this3.insertBefore(element, _this3.pages[index] ? _this3.pages[index] : null);
                     _this3.pages[index + 1]._destroy();
                     resolve();
                   });
                 });
               });
             };

             return {
               v: preFun().then(function () {
                 return _this3._popPage(options, popUpdate);
               })
             };
           })();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         } else {
           var popUpdate = function popUpdate() {
             return new Promise(function (resolve) {
               lastPage._destroy();
               resolve();
             });
           };

           return this._popPage(options, popUpdate);
         }
       }
     }, {
       key: '_popPage',
       value: function _popPage(options) {
         var _this4 = this;

         var update = arguments.length <= 1 || arguments[1] === undefined ? function () {
           return Promise.resolve();
         } : arguments[1];
         var pages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

         if ((typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) !== 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         if (this._isRunning) {
           return Promise.reject('popPage is already running.');
         }

         if (this.pages.length <= 1) {
           return Promise.reject('ons-navigator\'s page stack is empty.');
         }

         options = util.extend({}, this.options || {}, options);

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         var animator = this._animatorFactory.newAnimator(options);
         var l = this.pages.length;

         var tryPopPage = function tryPopPage() {

           _this4._isRunning = true;

           if (_this4._emitPrePopEvent()) {
             return Promise.reject('Canceled in prepop event.');
           }
           _this4.pages[l - 2].updateBackButton(l - 2 > 0);

           return new Promise(function (resolve) {
             var leavePage = _this4.pages[l - 1];
             var enterPage = _this4.pages[l - 2];
             enterPage.style.display = 'block';

             var callback = function callback() {
               enterPage._show();
               leavePage._hide();

               var eventDetail = {
                 leavePage: leavePage,
                 enterPage: enterPage,
                 navigator: _this4
               };

               update(pages, _this4).then(function () {

                 _this4._isRunning = false;

                 var event = util.triggerElementEvent(_this4, 'postpop', eventDetail);

                 if (typeof options.onTransitionEnd === 'function') {
                   options.onTransitionEnd();
                 }

                 resolve(enterPage);
               });
             };

             animator.pop(_this4.pages[l - 2], _this4.pages[l - 1], callback);
           });
         };

         return tryPopPage().catch(function () {
           _this4._isRunning = false;
         });
       }

       /**
        * @method insertPage
        * @signature insertPage(index, pageUrl, [options])
        * @param {Number} index
        *   [en]The index where it should be inserted.[/en]
        *   [ja]スタックに挿入する位置のインデックスを指定します。[/ja]
        * @param {String} pageUrl
        *   [en]Page URL. Can be either a HTML document or a <code>&lt;ons-template&gt;</code>.[/en]
        *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "slide", "simpleslide", "lift", "fade" and "none".[/en]
        *   [ja]アニメーション名を指定します。"slide", "simpleslide", "lift", "fade", "none"のいずれかを指定できます。[/ja]
        * @description
        *   [en]Insert the specified pageUrl into the page stack with specified index.[/en]
        *   [ja]指定したpageUrlをページスタックのindexで指定した位置に追加します。[/ja]
        */

       /**
        * Insert page object that has the specified pageUrl into the page stack and
        * if options object is specified, apply the options.
        *
        * @param {Number} index
        * @param {String} page
        * @param {Object} [options]
        * @param {String/NavigatorTransitionAnimator} [options.animation]
        * @return {Promise} Resolves to the inserted page object
        */

     }, {
       key: 'insertPage',
       value: function insertPage(index, page) {
         var _this5 = this;

         var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

         if ((typeof page === 'undefined' ? 'undefined' : babelHelpers.typeof(page)) === 'object' && page !== null) {
           options = page;
         } else {
           options.page = page;
         }

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         index = this._normalizeIndex(index);

         if (index >= this.pages.length) {
           return this.pushPage.apply(this, [].slice.call(arguments, 1));
         }

         var tryInsertPage = function tryInsertPage() {
           var run = function run(templateHTML) {
             var element = _this5._createPageElement(templateHTML);
             CustomElements.upgrade(element);

             element.name = page;
             element.options = options;

             return new Promise(function (resolve) {
               element.style.display = 'none';
               _this5.insertBefore(element, _this5.pages[index]);
               _this5.getCurrentPage().updateBackButton(true);

               rewritables.link(_this5, element, options, function (element) {
                 setTimeout(function () {
                   element = null;
                   resolve(_this5.pages[index]);
                 }, 1000 / 60);
               });
             });
           };

           if (options.pageHTML) {
             return run(options.pageHTML);
           } else {
             return internal.getPageHTMLAsync(page).then(run);
           }
         };

         return tryInsertPage();
       }
     }, {
       key: '_normalizeIndex',
       value: function _normalizeIndex(index) {
         if (index < 0) {
           index = Math.abs(this.pages.length + index) % this.pages.length;
         }
         return index;
       }

       /**
        * @method getCurrentPage
        * @signature getCurrentPage()
        * @return {Object}
        *   [en]Current page object.[/en]
        *   [ja]現在のpageオブジェクト。[/ja]
        * @description
        *   [en]Get current page's navigator item. Use this method to access options passed by pushPage() or resetToPage() method.[/en]
        *   [ja]現在のページを取得します。pushPage()やresetToPage()メソッドの引数を取得できます。[/ja]
        */

       /**
        * Get current page's navigator item.
        *
        * Use this method to access options passed by pushPage() or resetToPage() method.
        * eg. ons.navigator.getCurrentPage().options
        *
        * @return {Object}
        */

     }, {
       key: 'getCurrentPage',
       value: function getCurrentPage() {
         if (this.pages.length <= 0) {
           throw new Error('Invalid state');
         }
         return this.pages[this.pages.length - 1];
       }
     }, {
       key: '_show',
       value: function _show() {
         if (this.pages[this.pages.length - 1]) {
           this.pages[this.pages.length - 1]._show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (this.pages[this.pages.length - 1]) {
           this.pages[this.pages.length - 1]._hide();
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         // these are children anymore
         for (var i = this.pages.length - 1; i >= 0; i--) {
           this.pages[i]._destroy();
         }

         this.remove();
       }
     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         if (this.pages.length > 1) {
           this.popPage();
         } else {
           event.callParentHandler();
         }
       }

       /**
        * @method resetToPage
        * @signature resetToPage(pageUrl, [options])
        * @param {String/undefined} [pageUrl]
        *   [en]Page URL. Can be either a HTML document or an <code>&lt;ons-template&gt;</code>. If the value is undefined or '', the navigator will be reset to the page that was first displayed.[/en]
        *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。undefinedや''を指定すると、ons-navigatorが最初に表示したページを指定したことになります。[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.page]
        *   [en]PageURL. Only necssary if `page` parameter is omitted.[/en]
        *   [ja][/ja]
        * @param {String} [options.pageHTML]
        *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "slide", "simpleslide", "lift", "fade" and "none".[/en]
        *   [ja]アニメーション名を指定できます。"slide", "simpleslide", "lift", "fade", "none"のいずれかを指定できます。[/ja]
        * @param {Function} [options.onTransitionEnd]
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Clears page stack and adds the specified pageUrl to the page stack.[/en]
        *   [ja]ページスタックをリセットし、指定したページを表示します。[/ja]
        */

       /**
        * Clears page stack and add the specified pageUrl to the page stack.
        * If options object is specified, apply the options.
        * the options object include all the attributes of this navigator.
        *
        * If page is undefined, navigator will push initial page contents instead of.
        *
        * @param {String/undefined} page
        * @param {Object} [options]
        * @return {Promise} Resolves to the new top page object.
        */

     }, {
       key: 'resetToPage',
       value: function resetToPage(page) {
         var _this6 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if ((typeof page === 'undefined' ? 'undefined' : babelHelpers.typeof(page)) === 'object' && page !== null) {
           options = page;
         } else {
           options.page = page;
         }

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         if (!options.animator && !options.animation) {
           options.animation = 'none';
         }

         var onTransitionEnd = options.onTransitionEnd || function () {};

         options.onTransitionEnd = function () {
           while (_this6.pages.length > 1) {
             _this6.pages[0]._destroy();
           }

           _this6.pages[0].updateBackButton(false);
           onTransitionEnd();
         };

         if (!options.pageHTML && (options.page === undefined || page === '')) {
           if (this.hasAttribute('page')) {
             options.page = this.getAttribute('page');
           } else {
             options.pageHTML = this._initialHTML;
             options.page = '';
           }
         }

         return this.pushPage(options.page, options);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this7 = this;

         this._deviceBackButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._boundOnDeviceBackButton);

         rewritables.ready(this, function () {
           if (_this7.pages.length === 0) {
             if (_this7.hasAttribute('page')) {
               _this7.pushPage(_this7.getAttribute('page'), { animation: 'none' });
             }
           } else {
             for (var i = 0; i < _this7.pages.length; i++) {
               if (_this7.pages[i].nodeName !== 'ONS-PAGE') {
                 throw new Error('The children of <ons-navigator> need to be of type <ons-page>');
               }
             }
             _this7._updateLastPageBackButton();
           }
         });
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._deviceBackButtonHandler.destroy();
         this._deviceBackButtonHandler = null;
       }

       /**
        * @method pushPage
        * @signature pushPage(page, [options])
        * @param {String} [page]
        *   [en]Page URL. Can be either a HTML document or a <code>&lt;ons-template&gt;</code>.[/en]
        *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.page]
        *   [en]PageURL. Only necssary if `page` parameter is omitted.[/en]
        *   [ja][/ja]
        * @param {String} [options.pageHTML]
        *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
        *   [ja][/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "slide", "simpleslide", "lift", "fade" and "none".[/en]
        *   [ja]アニメーション名を指定します。"slide", "simpleslide", "lift", "fade", "none"のいずれかを指定できます。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.onTransitionEnd]
        *   [en]Function that is called when the transition has ended.[/en]
        *   [ja]pushPage()による画面遷移が終了した時に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Pushes the specified pageUrl into the page stack.[/en]
        *   [ja]指定したpageUrlを新しいページスタックに追加します。新しいページが表示されます。[/ja]
        */

       /**
        * Pushes the specified pageUrl into the page stack and
        * if options object is specified, apply the options.
        *
        * @param {String} page
        * @param {Object} [options]
        * @param {String/NavigatorTransitionAnimator} [options.animation]
        * @param {Object} [options.animationOptions]
        * @param {Function} [options.onTransitionEnd]
        * @param {Boolean} [options.cancelIfRunning]
        * @param {String} [options.pageHTML]
        * @return {Promise} Resolves to the new top page object.
        */

     }, {
       key: 'pushPage',
       value: function pushPage(page) {
         var _this8 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if ((typeof page === 'undefined' ? 'undefined' : babelHelpers.typeof(page)) === 'object' && page !== null) {
           options = page;
         } else {
           options.page = page;
         }

         var run = function run(templateHTML) {
           return new Promise(function (resolve) {
             var element = _this8._createPageElement(templateHTML);
             CustomElements.upgrade(element);
             _this8.appendChild(element);
             resolve();
           });
         };

         var update = undefined;

         if (options.pageHTML) {
           update = function () {
             return run(options.pageHTML);
           };
         } else {
           update = function () {
             return internal.getPageHTMLAsync(page).then(run);
           };
         }

         return this._pushPage(options, update);
       }
     }, {
       key: '_pushPage',
       value: function _pushPage() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
         var update = arguments.length <= 1 || arguments[1] === undefined ? function () {
           return Promise.resolve();
         } : arguments[1];

         var _this9 = this;

         var pages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
         var page = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

         if ((typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) !== 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         if (this._isRunning) {
           return Promise.reject('pushPage is already running.');
         }

         if (this._emitPrePushEvent()) {
           return Promise.reject('Canceled in prepush event.');
         }

         var tryPushPage = function tryPushPage() {
           options = util.extend({}, _this9.options || {}, options);

           options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(_this9.getAttribute('animation-options')));

           var animator = _this9._animatorFactory.newAnimator(options);

           pages.push(page);

           return update(pages, _this9).then(function () {
             var pageLength = _this9.pages.length;

             var enterPage = _this9.pages[_this9.pages.length - 1];
             var leavePage = _this9.pages[_this9.pages.length - 2];
             enterPage.updateBackButton(_this9.pages.length - 1);

             _this9.pages[pageLength - 1].name = options.page;
             _this9.pages[pageLength - 1].options = options;

             return new Promise(function (resolve) {
               var done = function done() {
                 _this9._isRunning = false;
                 leavePage.style.display = 'none';

                 var eventDetail = {
                   leavePage: leavePage,
                   enterPage: enterPage,
                   navigator: _this9
                 };

                 util.triggerElementEvent(_this9, 'postpush', eventDetail);

                 if (typeof options.onTransitionEnd === 'function') {
                   options.onTransitionEnd();
                 }

                 resolve(enterPage);
               };

               enterPage.style.display = 'none';
               rewritables.link(_this9, enterPage, options, function () {
                 enterPage.style.display = 'block';
                 if (pageLength > 1) {
                   leavePage._hide();
                   enterPage._show();
                   animator.push(enterPage, leavePage, done);
                 } else {
                   enterPage._show();
                   done();
                 }
               });
             });
           });
         };

         this._isRunning = true;

         return tryPushPage().catch(function () {
           _this9._isRunning = false;
         });
       }

       /**
       * @method bringPageTop
       * @signature bringPageTop(item, [options])
       * @param {String|Number} item
       *   [en]Page URL or index of an existing page in navigator's stack.[/en]
       *   [ja]ページのURLかもしくはons-navigatorのページスタックのインデックス値を指定します。[/ja]
       * @param {Object} [options]
       *   [en]Parameter object.[/en]
       *   [ja]オプションを指定するオブジェクト。[/ja]
       * @param {String} [options.animation]
       *   [en]Animation name. Available animations are "slide", "simpleslide", "lift", "fade" and "none".[/en]
       *   [ja]アニメーション名を指定します。"slide", "simpleslide", "lift", "fade", "none"のいずれかを指定できます。[/ja]
       * @param {String} [options.animationOptions]
       *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
       *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
       * @param {Function} [options.onTransitionEnd]
       *   [en]Function that is called when the transition has ended.[/en]
       *   [ja]pushPage()による画面遷移が終了した時に呼び出される関数オブジェクトを指定します。[/ja]
       * @description
       *   [en]Brings the given page to the top of the page-stack if already exists or pushes it into the stack if doesn't.[/en]
       *   [ja]指定したページをページスタックの一番上に移動します。もし指定したページが無かった場合新しくpushされます。[/ja]
       */

       /**
        * Brings the given pageUrl or index to the top of the page stack
        * if already exists or pushes the page into the stack if doesn't.
        * If options object is specified, apply the options.
        *
        * @param {String|Number} item Page name or valid index.
        * @param {Object} options
        * @return {Promise} Resolves to the new top page object.
        */

     }, {
       key: 'bringPageTop',
       value: function bringPageTop(item) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         options = util.extend({}, this.options || {}, options);

         if (this.isRunning) {
           return Promise.reject('pushPage is already running.');
         }

         if (this._emitPrePushEvent()) {
           return Promise.reject('Canceled in prepush event.');
         }

         var index = undefined;
         if (typeof item === 'string') {
           options.page = item;
           index = this._lastIndexOfPage(options.page);
         } else if (typeof item === 'number') {
           index = this._normalizeIndex(item);
           if (item >= this.pages.length) {
             throw new Error('The provided index does not match an existing page.');
           }
           options.page = this.pages[index].name;
         } else {
           throw new Error('First argument must be a page name or the index of an existing page. You supplied ' + item);
         }

         if (index < 0) {
           // Fallback pushPage
           return this.pushPage(options.page, options);
         } else if (index === this.pages.length - 1) {
           // Page is already the top
           return Promise.resolve(this.pages[index]);
         } else {
           // Bring to top
           var selectedPage = this.pages[index];
           selectedPage.style.display = 'block';
           selectedPage.setAttribute('_skipinit', '');

           // move element to the last child
           selectedPage.parentNode.appendChild(selectedPage);
           selectedPage.options = options;
           return this._pushPage(options);
         }
       }

       /**
        * @param {String} page
        * @return {Number} Returns the last index at which the given page
        * is found in the page-stack, or -1 if it is not present.
        */

     }, {
       key: '_lastIndexOfPage',
       value: function _lastIndexOfPage(pageName) {
         var index = undefined;
         for (index = this.pages.length - 1; index >= 0; index--) {
           if (this.pages[index].name === pageName) {
             break;
           }
         }
         return index;
       }

       /**
        * @return {Boolean} Whether if event is canceled.
        */

     }, {
       key: '_emitPrePushEvent',
       value: function _emitPrePushEvent() {
         var isCanceled = false;

         util.triggerElementEvent(this, 'prepush', {
           navigator: this,
           currentPage: this.pages.length > 0 ? this.getCurrentPage() : undefined,
           cancel: function cancel() {
             isCanceled = true;
           }
         });

         return isCanceled;
       }

       /**
        * @return {Boolean} Whether if event is canceled.
        */

     }, {
       key: '_emitPrePopEvent',
       value: function _emitPrePopEvent() {
         var isCanceled = false;

         var leavePage = this.getCurrentPage();
         var enterPage = this.pages[this.pages.length - 2];

         util.triggerElementEvent(this, 'prepop', {
           navigator: this,
           currentPage: leavePage,
           leavePage: leavePage,
           enterPage: enterPage,
           cancel: function cancel() {
             isCanceled = true;
           }
         });

         return isCanceled;
       }

       /**
        * @param {String} page
        * @param {Element} element
        * @param {Object} options
        */

     }, {
       key: '_createPageObject',
       value: function _createPageObject(page, element, options) {

         options.animator = this._animatorFactory.newAnimator(options);

         return new NavigatorPage({
           page: page,
           element: element,
           options: options,
           navigator: this
         });
       }
     }, {
       key: '_createPageElement',
       value: function _createPageElement(templateHTML) {
         var pageElement = util.createElement(internal.normalizePageHTML(templateHTML));

         if (pageElement.nodeName.toLowerCase() !== 'ons-page') {
           throw new Error('You must supply an "ons-page" element to "ons-navigator".');
         }

         return pageElement;
       }
     }, {
       key: 'options',
       get: function get() {
         return this._options;
       },
       set: function set(object) {
         this._options = object;
       }
     }, {
       key: '_isRunning',
       set: function set(value) {
         if (value) {
           this.setAttribute('_is-running', 'true');
         } else {
           this.setAttribute('_is-running', 'false');
         }
       },
       get: function get() {
         return JSON.parse(this.getAttribute('_is-running'));
       }
     }, {
       key: 'pages',
       get: function get() {
         return this.children;
       }
     }]);
     return NavigatorElement;
   })(BaseElement);

   window.OnsNavigatorElement = document.registerElement('ons-navigator', {
     prototype: NavigatorElement.prototype
   });

   /**
    * @param {String} name
    * @param {Function} Animator
    */
   window.OnsNavigatorElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof NavigatorTransitionAnimator)) {
       throw new Error('"Animator" param must inherit OnsNavigatorElement.NavigatorTransitionAnimator');
     }

     _animatorDict$3[name] = Animator;
   };

   window.OnsNavigatorElement.rewritables = rewritables;
   window.OnsNavigatorElement.NavigatorTransitionAnimator = NavigatorTransitionAnimator;

   var scheme$13 = {
     '': 'page--*',
     '.page__content': 'page--*__content',
     '.page__background': 'page--*__background'
   };

   var nullToolbarElement = document.createElement('ons-toolbar');

   /**
    * @element ons-page
    * @category page
    * @description
    *   [en]Should be used as root component of each page. The content inside page component is scrollable.[/en]
    *   [ja]ページ定義のためのコンポーネントです。このコンポーネントの内容はスクロールが許可されます。[/ja]
    * @guide ManagingMultiplePages
    *   [en]Managing multiple pages[/en]
    *   [ja]複数のページを管理する[/ja]
    * @guide Pagelifecycle
    *   [en]Page life cycle events[/en]
    *   [ja]ページライフサイクルイベント[/ja]
    * @guide HandlingBackButton
    *   [en]Handling back button[/en]
    *   [ja]バックボタンに対応する[/ja]
    * @guide OverridingCSSstyles
    *   [en]Overriding CSS styles[/en]
    *   [ja]CSSスタイルのオーバーライド[/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]複数のページを1つのHTMLに記述する[/ja]
    * @example
    * <ons-page>
    *   <ons-toolbar>
    *     <div class="center">Title</div>
    *   </ons-toolbar>
    *
    *   ...
    * </ons-page>
    *
    *
    * // Infinite Scroll handler
    * page.onInfiniteScroll = function(done) {
    *   // load more content and call done
    * };
    */

   var PageElement = (function (_BaseElement) {
     babelHelpers.inherits(PageElement, _BaseElement);

     function PageElement() {
       babelHelpers.classCallCheck(this, PageElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PageElement).apply(this, arguments));
     }

     babelHelpers.createClass(PageElement, [{
       key: 'createdCallback',

       /**
        * @event init
        * @description
        *   [en]Fired right after the page is attached.[/en]
        *   [ja]ページがアタッチされた後に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.page
        *   [en]Page object.[/en]
        *   [ja]ページのオブジェクト。[/ja]
        */

       /**
        * @event show
        * @description
        *   [en]Fired right after the page is shown.[/en]
        *   [ja]ページが表示された後に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.page
        *   [en]Page object.[/en]
        *   [ja]ページのオブジェクト。[/ja]
        */

       /**
        * @event hide
        * @description
        *   [en]Fired right after the page is hidden.[/en]
        *   [ja]ページが隠れた後に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.page
        *   [en]Page object.[/en]
        *   [ja]ページのオブジェクト。[/ja]
        */

       /**
        * @event destroy
        * @description
        *   [en]Fired right before the page is destroyed.[/en]
        *   [ja]ページが破棄される前に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.page
        *   [en]Page object.[/en]
        *   [ja]ページのオブジェクト。[/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Specify modifier name to specify custom styles.[/en]
        *   [ja]スタイル定義をカスタマイズするための名前を指定します。[/ja]
        */

       /**
        * @attribute on[-]infinite[-]scroll
        * @type {String}
        * @description
        *   [en]Path of the function to be executed on infinite scrolling. Example: app.loadData[/en]
        *   [ja]機能スクロール上で実行されている関数のパス。例：app.loadData[/ja]
        */

       /**
        * @property onInfiniteScroll
        * @description
        *  [en]Function to be executed on infinite scroll. [/en]
        *  [ja]機能スクロール上で実行されている関数。[/ja]
        */

       value: function createdCallback() {
         this.classList.add('page');

         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._isShown = false;
         this._contentElement = this._getContentElement();
         this._isMuted = this.hasAttribute('_muted');
         this._skipInit = this.hasAttribute('_skipinit');
         this.eventDetail = {
           page: this
         };
         this.options = {};
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this2 = this;

         if (!this._isMuted) {
           if (this._skipInit) {
             this.removeAttribute('_skipinit');
           } else {
             util.triggerElementEvent(this, 'init', this.eventDetail);
           }
         }

         if (!util.hasAnyComponentAsParent(this)) {
           setImmediate(function () {
             return _this2._show();
           });
         }

         this._tryToFillStatusBar();

         var infiniteScroll = this.getAttribute('on-infinite-scroll') || this.getAttribute('oninfinitescroll');
         this.attributeChangedCallback('oninfinitescroll', null, infiniteScroll);
       }
     }, {
       key: 'updateBackButton',
       value: function updateBackButton(shouldShowButton) {
         if (this.backButton) {
           if (shouldShowButton) {
             this.backButton.show();
           } else {
             this.backButton.hide();
           }
         }
       }
     }, {
       key: '_onScroll',
       value: function _onScroll() {
         var _this3 = this;

         var c = this._contentElement,
             overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;

         if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
           this._loadingContent = true;
           this._onInfiniteScroll(function () {
             return _this3._loadingContent = false;
           });
         }
       }

       /**
        * @method getDeviceBackButtonHandler
        * @signature getDeviceBackButtonHandler()
        * @return {Object/null}
        *   [en]Device back button handler.[/en]
        *   [ja]デバイスのバックボタンハンドラを返します。[/ja]
        * @description
        *   [en]Get the associated back button handler. This method may return null if no handler is assigned.[/en]
        *   [ja]バックボタンハンドラを取得します。このメソッドはnullを返す場合があります。[/ja]
        */

     }, {
       key: 'getDeviceBackButtonHandler',
       value: function getDeviceBackButtonHandler() {
         return this._deviceBackButtonHandler || null;
       }

       /**
        * @param {Function} callback
        */

     }, {
       key: 'setDeviceBackButtonHandler',
       value: function setDeviceBackButtonHandler(callback) {
         if (this._deviceBackButtonHandler) {
           this._deviceBackButtonHandler.destroy();
         }

         this._deviceBackButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getContentElement',
       value: function _getContentElement() {
         var result = util.findChild(this, '.page__content');
         if (result) {
           return result;
         }
         throw Error('fail to get ".page__content" element.');
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_canAnimateToolbar',
       value: function _canAnimateToolbar() {
         if (util.findChild(this, 'ons-toolbar')) {
           return true;
         }
         return !!util.findChild(this._contentElement, function (e) {
           return e.nodeName.toLowerCase() === 'ons-toolbar' && !e.hasAttribute('inline');
         });
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getBackgroundElement',
       value: function _getBackgroundElement() {
         var result = util.findChild(this, '.page__background');
         if (result) {
           return result;
         }
         throw Error('fail to get ".page__background" element.');
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getBottomToolbarElement',
       value: function _getBottomToolbarElement() {
         return util.findChild(this, 'ons-bottom-toolbar') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarElement',
       value: function _getToolbarElement() {
         return util.findChild(this, 'ons-toolbar') || nullToolbarElement;
       }

       /**
        * Register toolbar element to this page.
        *
        * @param {HTMLElement} element
        */

     }, {
       key: '_registerToolbar',
       value: function _registerToolbar(element) {
         this._contentElement.setAttribute('no-status-bar-fill', '');

         if (util.findChild(this, '.page__status-bar-fill')) {
           this.insertBefore(element, this.children[1]);
         } else {
           this.insertBefore(element, this.children[0]);
         }
       }

       /**
        * Register toolbar element to this page.
        *
        * @param {HTMLElement} element
        */

     }, {
       key: '_registerBottomToolbar',
       value: function _registerBottomToolbar(element) {
         this.classList.add('page-with-bottom-toolbar');
         this.appendChild(element);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         var _this4 = this;

         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$13);
         } else if (name === '_muted') {
           this._isMuted = this.hasAttribute('_muted');
         } else if (name === '_skipinit') {
           this._skipInit = this.hasAttribute('_skipinit');
         } else if (name.match(/on-?infinite-?scroll/i)) {
           if (current === null) {
             this.onInfiniteScroll = null;
           } else {
             this.onInfiniteScroll = function (done) {
               var f = util.findFromPath(current);
               _this4.onInfiniteScroll = f;
               f(done);
             };
           }
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         var background = util.create('.page__background');
         var content = util.create('.page__content');

         while (this.firstChild) {
           content.appendChild(this.firstChild);
         }

         this.appendChild(background);
         this.appendChild(content);

         ModifierUtil.initModifier(this, scheme$13);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_registerExtraElement',
       value: function _registerExtraElement(element) {
         var extra = util.findChild(this, '.page__extra');
         if (!extra) {
           extra = util.create('.page__extra', { zIndex: 10001 });
           this.appendChild(extra);
         }

         extra.appendChild(element);
       }
     }, {
       key: '_tryToFillStatusBar',
       value: function _tryToFillStatusBar() {
         var _this5 = this;

         return internal.shouldFillStatusBar(this).then(function () {
           var fill = _this5.querySelector('.page__status-bar-fill');

           if (!fill) {
             fill = util.create('.page__status-bar-fill');

             _this5.insertBefore(fill, _this5.children[0]);
           }

           return fill;
         }).catch(function () {
           var el = _this5.querySelector('.page__status-bar-fill');
           el && el.remove();
         });
       }
     }, {
       key: '_show',
       value: function _show() {
         if (!this.isShown && util.isAttached(this)) {
           this.isShown = true;

           if (!this._isMuted) {
             util.triggerElementEvent(this, 'show', this.eventDetail);
           }

           util.propagateAction(this._contentElement, '_show');
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (this.isShown) {
           this.isShown = false;

           if (!this._isMuted) {
             util.triggerElementEvent(this, 'hide', this.eventDetail);
           }

           util.propagateAction(this._contentElement, '_hide');
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         this._hide();

         if (!this._isMuted) {
           util.triggerElementEvent(this, 'destroy', this.eventDetail);
         }

         if (this.getDeviceBackButtonHandler()) {
           this.getDeviceBackButtonHandler().destroy();
         }

         util.propagateAction(this._contentElement, '_destroy');

         this.remove();
       }
     }, {
       key: 'name',
       set: function set(str) {
         this.setAttribute('name', str);
       },
       get: function get() {
         return this.getAttribute('name');
       }
     }, {
       key: 'backButton',
       get: function get() {
         return util.findChildRecursively(this, 'ons-back-button');
       }

       /**
        * @return {boolean}
        */

     }, {
       key: 'isShown',
       get: function get() {
         return this._isShown;
       }

       /**
        * @param {boolean}
        */
       ,
       set: function set(value) {
         this._isShown = value;
       }
     }, {
       key: 'onInfiniteScroll',
       set: function set(value) {
         if (value === null) {
           this._onInfiniteScroll = null;
           this._contentElement.removeEventListener('scroll', this._boundOnScroll);
           return;
         }
         if (!(value instanceof Function)) {
           throw new Error('onInfiniteScroll must be a function or null');
         }
         if (!this._onInfiniteScroll) {
           this._infiniteScrollLimit = 0.9;
           this._boundOnScroll = this._onScroll.bind(this);
           this._contentElement.addEventListener('scroll', this._boundOnScroll);
         }
         this._onInfiniteScroll = value;
       }
     }]);
     return PageElement;
   })(BaseElement);

   window.OnsPageElement = document.registerElement('ons-page', {
     prototype: PageElement.prototype
   });

   var PopoverAnimator = (function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function PopoverAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, PopoverAnimator);

       this.options = util.extend({
         timing: 'cubic-bezier(.1, .7, .4, 1)',
         duration: 0.2,
         delay: 0
       }, options);
     }

     babelHelpers.createClass(PopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         callback();
       }
     }, {
       key: 'hide',
       value: function hide(popover, callback) {
         callback();
       }
     }, {
       key: '_animate',
       value: function _animate(element, _ref) {
         var from = _ref.from;
         var to = _ref.to;
         var options = _ref.options;
         var callback = _ref.callback;
         var _ref$restore = _ref.restore;
         var restore = _ref$restore === undefined ? false : _ref$restore;
         var animation = _ref.animation;

         options = util.extend({}, this.options, options);

         if (animation) {
           from = animation.from;
           to = animation.to;
         }

         animation = animit(element);
         if (restore) {
           animation = animation.saveStyle();
         }
         animation = animation.queue(from).wait(options.delay).queue({
           css: to,
           duration: options.duration,
           timing: options.timing
         });
         if (restore) {
           animation = animation.restoreStyle();
         }
         if (callback) {
           animation = animation.queue(function (done) {
             callback();
             done();
           });
         }
         return animation;
       }
     }, {
       key: '_animateAll',
       value: function _animateAll(element, animations) {
         var _this = this;

         Object.keys(animations).forEach(function (key) {
           return _this._animate(element[key], animations[key]).play();
         });
       }
     }]);
     return PopoverAnimator;
   })();

   var fade = {
     out: {
       from: { opacity: 1.0 },
       to: { opacity: 0 }
     },
     in: {
       from: { opacity: 0 },
       to: { opacity: 1.0 }
     }
   };

   var MDFadePopoverAnimator = (function (_PopoverAnimator) {
     babelHelpers.inherits(MDFadePopoverAnimator, _PopoverAnimator);

     function MDFadePopoverAnimator() {
       babelHelpers.classCallCheck(this, MDFadePopoverAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MDFadePopoverAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(MDFadePopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.in,
           _popover: { animation: fade.in, restore: true, callback: callback }
         });
       }
     }, {
       key: 'hide',
       value: function hide(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.out,
           _popover: { animation: fade.out, restore: true, callback: callback }
         });
       }
     }]);
     return MDFadePopoverAnimator;
   })(PopoverAnimator);

   var IOSFadePopoverAnimator = (function (_MDFadePopoverAnimato) {
     babelHelpers.inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);

     function IOSFadePopoverAnimator() {
       babelHelpers.classCallCheck(this, IOSFadePopoverAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(IOSFadePopoverAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(IOSFadePopoverAnimator, [{
       key: 'show',
       value: function show(popover, callback) {
         this._animateAll(popover, {
           _mask: fade.in,
           _popover: {
             from: {
               transform: 'scale3d(1.3, 1.3, 1.0)',
               opacity: 0
             },
             to: {
               transform: 'scale3d(1.0, 1.0,  1.0)',
               opacity: 1.0
             },
             restore: true,
             callback: callback
           }
         });
       }
     }]);
     return IOSFadePopoverAnimator;
   })(MDFadePopoverAnimator);

   var animators = { PopoverAnimator: PopoverAnimator, IOSFadePopoverAnimator: IOSFadePopoverAnimator, MDFadePopoverAnimator: MDFadePopoverAnimator };

   var scheme$14 = {
     '.popover': 'popover--*',
     '.popover-mask': 'popover-mask--*',
     '.popover__container': 'popover__container--*',
     '.popover__content': 'popover__content--*',
     '.popover__arrow': 'popover__arrow--*'
   };

   var _animatorDict$4 = {
     'default': function _default() {
       return platform.isAndroid() ? animators.MDFadePopoverAnimator : animators.IOSFadePopoverAnimator;
     },
     'none': animators.PopoverAnimator,
     'fade-ios': animators.IOSFadePopoverAnimator,
     'fade-md': animators.MDFadePopoverAnimator
   };

   var templateSource$2 = util.createFragment('\n  <div class="popover-mask"></div>\n  <div class="popover__container">\n    <div class="popover__content"></div>\n    <div class="popover__arrow"></div>\n  </div>\n');

   var positions = {
     up: 'bottom',
     left: 'right',
     down: 'top',
     right: 'left'
   };

   var directions = Object.keys(positions);
   /**
    * @element ons-popover
    * @category popover
    * @description
    *  [en]A component that displays a popover next to an element.[/en]
    *  [ja]ある要素を対象とするポップオーバーを表示するコンポーネントです。[/ja]
    * @codepen ZYYRKo
    * @example
    * <script>
    * ons.ready(function() {
    *   ons.createPopover('popover.html').then(function(popover) {
    *     popover.show('#mybutton');
    *   });
    * });
    * </script>
    *
    * <script type="text/ons-template" id="popover.html">
    *   <ons-popover cancelable>
    *     <p style="text-align: center; opacity: 0.5;">This popover will choose which side it's displayed on automatically.</p>
    *   </ons-popover>
    * </script>
    */

   var PopoverElement = (function (_BaseElement) {
     babelHelpers.inherits(PopoverElement, _BaseElement);

     function PopoverElement() {
       babelHelpers.classCallCheck(this, PopoverElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PopoverElement).apply(this, arguments));
     }

     babelHelpers.createClass(PopoverElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._doorLock = new DoorLock();
         this._boundOnChange = this._onChange.bind(this);
         this._boundCancel = this._cancel.bind(this);

         this._initAnimatorFactory();
       }
     }, {
       key: '_initAnimatorFactory',
       value: function _initAnimatorFactory() {
         var factory = new AnimatorFactory({
           animators: _animatorDict$4,
           baseClass: animators.PopoverAnimator,
           baseClassName: 'PopoverAnimator',
           defaultAnimation: this.getAttribute('animation') || 'default'
         });
         this._animator = function (options) {
           return factory.newAnimator(options);
         };
       }
     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(event) {
         if (this.isCancelable()) {
           this._cancel();
         } else {
           event.callParentHandler();
         }
       }
     }, {
       key: '_positionPopover',
       value: function _positionPopover(target) {
         var radius = this._radius;
         var el = this._content;
         var margin = this._margin;

         var pos = target.getBoundingClientRect();
         var isMD = util.hasModifier(this, 'material');
         var cover = isMD && this.hasAttribute('cover-target');

         var distance = {
           top: pos.top - margin,
           left: pos.left - margin,
           right: window.innerWidth - pos.right - margin,
           bottom: window.innerHeight - pos.bottom - margin
         };

         var _calculateDirections2 = this._calculateDirections(distance);

         var vertical = _calculateDirections2.vertical;
         var primary = _calculateDirections2.primary;
         var secondary = _calculateDirections2.secondary;

         this._popover.classList.add('popover--' + primary);

         var offset = cover ? 0 : (vertical ? pos.height : pos.width) + (isMD ? 0 : 14);
         this.style[primary] = Math.max(0, distance[primary] + offset) + margin + 'px';
         el.style[primary] = 0;

         var l = vertical ? 'width' : 'height';
         var sizes = (function (style) {
           return {
             width: parseInt(style.getPropertyValue('width')),
             height: parseInt(style.getPropertyValue('height'))
           };
         })(window.getComputedStyle(el));

         el.style[secondary] = Math.max(0, distance[secondary] - (sizes[l] - pos[l]) / 2) + 'px';
         this._arrow.style[secondary] = Math.max(radius, distance[secondary] + pos[l] / 2) + 'px';

         this._setTransformOrigin(distance, sizes, pos, primary);

         // Prevent animit from restoring the style.
         el.removeAttribute('data-animit-orig-style');
       }
     }, {
       key: '_setTransformOrigin',
       value: function _setTransformOrigin(distance, sizes, pos, primary) {
         var calc = function calc(a, o, l) {
           return primary === a ? sizes[l] / 2 : distance[a] + (primary === o ? -sizes[l] : sizes[l] - pos[l]) / 2;
         };
         var x = calc('left', 'right', 'width') + 'px';
         var y = calc('top', 'bottom', 'height') + 'px';

         util.extend(this._popover.style, {
           transformOrigin: x + ' ' + y,
           webkitTransformOriginX: x,
           webkitTransformOriginY: y
         });
       }
     }, {
       key: '_calculateDirections',
       value: function _calculateDirections(distance) {
         var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
           return positions[e];
         });
         var primary = options.sort(function (a, b) {
           return distance[a] - distance[b];
         })[0];
         var vertical = ['top', 'bottom'].indexOf(primary) !== -1;
         var secondary = undefined;

         if (vertical) {
           secondary = distance.left < distance.right ? 'left' : 'right';
         } else {
           secondary = distance.top < distance.bottom ? 'top' : 'bottom';
         }

         return { vertical: vertical, primary: primary, secondary: secondary };
       }
     }, {
       key: '_clearStyles',
       value: function _clearStyles() {
         var _this2 = this;

         ['top', 'bottom', 'left', 'right'].forEach(function (e) {
           _this2._arrow.style[e] = _this2._content.style[e] = _this2.style[e] = '';
           _this2._popover.classList.remove('popover--' + e);
         });
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         var _this3 = this;

         setImmediate(function () {
           if (_this3._currentTarget) {
             _this3._positionPopover(_this3._currentTarget);
           }
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('popover');

         var template = templateSource$2.cloneNode(true);
         var content = template.querySelector('.popover__content');

         while (this.childNodes[0]) {
           content.appendChild(this.childNodes[0]);
         }

         this.appendChild(template);

         if (this.hasAttribute('style')) {
           this._popover.setAttribute('style', this.getAttribute('style'));
           this.removeAttribute('style');
         }

         if (this.hasAttribute('mask-color')) {
           this._mask.style.backgroundColor = this.getAttribute('mask-color');
         }

         ModifierUtil.initModifier(this, scheme$14);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_prepareAnimationOptions',
       value: function _prepareAnimationOptions(options) {
         if (options.animation && !(options.animation in _animatorDict$4)) {
           throw new Error('Animator ' + options.animation + ' is not registered.');
         }

         options.animationOptions = util.extend(AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')), options.animationOptions || {});
       }
     }, {
       key: '_executeAction',
       value: function _executeAction(actions) {
         var _this4 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var callback = options.callback;
         var action = actions.action;
         var before = actions.before;
         var after = actions.after;

         this._prepareAnimationOptions(options);

         var canceled = false;
         util.triggerElementEvent(this, 'pre' + action, { // synchronous
           popover: this,
           cancel: function cancel() {
             return canceled = true;
           }
         });

         if (canceled) {
           return Promise.reject('Canceled in pre' + action + ' event.');
         }

         return new Promise(function (resolve) {
           _this4._doorLock.waitUnlock(function () {
             var unlock = _this4._doorLock.lock();

             before && before();

             _this4._animator(options)[action](_this4, function () {
               after && after();

               unlock();

               util.triggerElementEvent(_this4, 'post' + action, { popover: _this4 });

               callback && callback();
               resolve(_this4);
             });
           });
         });
       }

       /**
        * @method show
        * @signature show(target, [options])
        * @param {String|Event|HTMLElement} target
        *   [en]Target element. Can be either a CSS selector, an event object or a DOM element.[/en]
        *   [ja]ポップオーバーのターゲットとなる要素を指定します。CSSセレクタかeventオブジェクトかDOM要素のいずれかを渡せます。[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name.  Use one of "fade-ios", "fade-md", "none" and "default".[/en]
        *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]This function is called after the popover has been revealed.[/en]
        *   [ja]ポップオーバーが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Open the popover and point it at a target. The target can be either an event, a css selector or a DOM element..[/en]
        *   [ja]対象とする要素にポップオーバーを表示します。target引数には、$eventオブジェクトやDOMエレメントやCSSセレクタを渡すことが出来ます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the displayed element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'show',
       value: function show(target) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (typeof target === 'string') {
           target = document.querySelector(target);
         } else if (target instanceof Event) {
           target = target.target;
         }
         if (!(target instanceof HTMLElement)) {
           throw new Error('Invalid target');
         }

         return this._executeAction({
           action: 'show',
           before: function before() {
             _this5.style.display = 'block';
             _this5._currentTarget = target;
             _this5._positionPopover(target);
           }
         }, options);
       }

       /**
        * @method hide
        * @signature hide([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name.  Use one of "fade-ios", "fade-md", "none" and "default".[/en]
        *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @param {Function} [options.callback]
        *   [en]This functions is called after the popover has been hidden.[/en]
        *   [ja]ポップオーバーが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Close the popover.[/en]
        *   [ja]ポップオーバーを閉じます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the hidden element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this6 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._executeAction({
           action: 'hide',
           after: function after() {
             _this6.style.display = 'none';
             _this6._clearStyles();
           }
         }, options);
       }

       /**
        * @method isShown
        * @signature isShown()
        * @return {Boolean}
        *   [en]true if the popover is visible.[/en]
        *   [ja]ポップオーバーが表示されている場合にtrueとなります。[/ja]
        * @description
        *   [en]Returns whether the popover is visible or not.[/en]
        *   [ja]ポップオーバーが表示されているかどうかを返します。[/ja]
        */

     }, {
       key: 'isShown',
       value: function isShown() {
         return window.getComputedStyle(this).getPropertyValue('display') !== 'none';
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._margin = parseInt(window.getComputedStyle(this).getPropertyValue('top'));
         this._radius = parseInt(window.getComputedStyle(this._content).getPropertyValue('border-radius'));

         this._mask.addEventListener('click', this._boundCancel, false);

         this._deviceBackButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._onDeviceBackButton.bind(this));

         this._popover.addEventListener('DOMNodeInserted', this._boundOnChange, false);
         this._popover.addEventListener('DOMNodeRemoved', this._boundOnChange, false);

         window.addEventListener('resize', this._boundOnChange, false);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._mask.removeEventListener('click', this._boundCancel, false);

         this._deviceBackButtonHandler.destroy();
         this._deviceBackButtonHandler = null;

         this._popover.removeEventListener('DOMNodeInserted', this._boundOnChange, false);
         this._popover.removeEventListener('DOMNodeRemoved', this._boundOnChange, false);

         window.removeEventListener('resize', this._boundOnChange, false);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$14);
         }
         if (name === 'direction') {
           return this._boundOnChange();
         }
         if (name === 'animation') {
           this._initAnimatorFactory();
         }
       }

       /**
        * @method setCancelable
        * @signature setCancelable(cancelable)
        * @param {Boolean} cancelable
        *   [en]If true the popover will be cancelable.[/en]
        *   [ja]ポップオーバーがキャンセル可能にしたい場合にtrueを指定します。[/ja]
        * @description
        *   [en]Set whether the popover can be canceled by the user when it is shown.[/en]
        *   [ja]ポップオーバーを表示した際に、ユーザがそのポップオーバーをキャンセルできるかどうかを指定します。[/ja]
        */

     }, {
       key: 'setCancelable',
       value: function setCancelable(cancelable) {
         if (typeof cancelable !== 'boolean') {
           throw new Error('Argument must be a boolean.');
         }

         if (cancelable) {
           this.setAttribute('cancelable', '');
         } else {
           this.removeAttribute('cancelable');
         }
       }

       /**
        * @method isCancelable
        * @signature isCancelable()
        * @return {Boolean}
        *   [en]true if the popover is cancelable.[/en]
        *   [ja]ポップオーバーがキャンセル可能であればtrueとなります。[/ja]
        * @description
        *   [en]Returns whether the popover is cancelable or not.[/en]
        *   [ja]このポップオーバーがキャンセル可能かどうかを返します。[/ja]
        */

     }, {
       key: 'isCancelable',
       value: function isCancelable() {
         return this.hasAttribute('cancelable');
       }

       /**
        * @method destroy
        * @signature destroy()
        * @description
        *   [en]Destroy the popover and remove it from the DOM tree.[/en]
        *   [ja]ポップオーバーを破棄して、DOMツリーから取り除きます。[/ja]
        */

     }, {
       key: 'destroy',
       value: function destroy() {
         if (this.parentElement) {
           this.parentElement.removeChild(this);
         }
       }
     }, {
       key: '_cancel',
       value: function _cancel() {
         var _this7 = this;

         if (this.isCancelable()) {
           this.hide({
             callback: function callback() {
               util.triggerElementEvent(_this7, 'cancel');
             }
           });
         }
       }
     }, {
       key: '_mask',

       /**
        * @event preshow
        * @description
        *   [en]Fired just before the popover is displayed.[/en]
        *   [ja]ポップオーバーが表示される直前に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to stop the popover from being shown.[/en]
        *   [ja]この関数を呼び出すと、ポップオーバーの表示がキャンセルされます。[/ja]
        */

       /**
        * @event postshow
        * @description
        *   [en]Fired just after the popover is displayed.[/en]
        *   [ja]ポップオーバーが表示された直後に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        */

       /**
        * @event prehide
        * @description
        *   [en]Fired just before the popover is hidden.[/en]
        *   [ja]ポップオーバーが隠れる直前に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to stop the popover from being hidden.[/en]
        *   [ja]この関数を呼び出すと、ポップオーバーが隠れる処理をキャンセルします。[/ja]
        */

       /**
        * @event posthide
        * @description
        *   [en]Fired just after the popover is hidden.[/en]
        *   [ja]ポップオーバーが隠れた後に発火します。[/ja]
        * @param {Object} event [en]Event object.[/en]
        * @param {Object} event.popover
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the popover.[/en]
        *  [ja]ポップオーバーの表現を指定します。[/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *  [en]
        *    A space separated list of directions. If more than one direction is specified,
        *    it will be chosen automatically. Valid directions are "up", "down", "left" and "right".
        *  [/en]
        *  [ja]
        *    ポップオーバーを表示する方向を空白区切りで複数指定できます。
        *    指定できる方向は、"up", "down", "left", "right"の4つです。空白区切りで複数指定することもできます。
        *    複数指定された場合、対象とする要素に合わせて指定した値から自動的に選択されます。
        *  [/ja]
        */

       /**
        * @attribute cancelable
        * @description
        *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
        *   [ja]この属性があると、ポップオーバーが表示された時に、背景やバックボタンをタップした時にをポップオーバー閉じます。[/ja]
        */

       /**
        * @attribute cover-target
        * @description
        *   [en]If set the popover will cover the target on the screen.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @description
        *   [en]The animation used when showing an hiding the popover. Can be either "none" or "fade".[/en]
        *   [ja]ポップオーバーを表示する際のアニメーション名を指定します。[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/en]
        *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
        */

       /**
        * @attribute mask-color
        * @type {Color}
        * @description
        *   [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
        *   [ja]背景のマスクの色を指定します。デフォルトは"rgba(0, 0, 0, 0.2)"です。[/ja]
        */

       get: function get() {
         return this.children[0];
       }
     }, {
       key: '_popover',
       get: function get() {
         return this.children[1];
       }
     }, {
       key: '_content',
       get: function get() {
         return this._popover.children[0];
       }
     }, {
       key: '_arrow',
       get: function get() {
         return this._popover.children[1];
       }
     }]);
     return PopoverElement;
   })(BaseElement);

   window.OnsPopoverElement = document.registerElement('ons-popover', {
     prototype: PopoverElement.prototype
   });

   /**
    * @param {String} name
    * @param {PopoverAnimator} Animator
    */
   window.OnsPopoverElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof animators.PopoverAnimator)) {
       throw new Error('"Animator" param must inherit PopoverAnimator');
     }
     _animatorDict$4[name] = Animator;
   };

   window.OnsPopoverElement.PopoverAnimator = animators.PopoverAnimator;

   var scheme$15 = {
     '.progress-bar': 'progress-bar--*',
     '.progress-bar__primary': 'progress-bar__primary--*',
     '.progress-bar__secondary': 'progress-bar__secondary--*'
   };

   var template = util.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');

   /**
    * @element ons-progress-bar
    * @category progress
    * @description
    *   [en]A material design progress component. It's displayed as a linear progress indicator.[/en]
    *   [ja]マテリアルデザインのprogressコンポーネントです。linearなプログレスインジケータを表示します。[/ja]
    * @codepen zvQbGj
    * @example
    * <ons-progress-bar
    *  value="55"
    *  secondary-value="87">
    * </ons-progress-bar>
    */

   var ProgressBarElement = (function (_BaseElement) {
     babelHelpers.inherits(ProgressBarElement, _BaseElement);

     function ProgressBarElement() {
       babelHelpers.classCallCheck(this, ProgressBarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ProgressBarElement).apply(this, arguments));
     }

     babelHelpers.createClass(ProgressBarElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Change the appearance of the progress indicator.[/en]
        *   [ja]プログレスインジケータの見た目を変更します。[/ja]
        */

       /**
        * @attribute value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
        */

       /**
        * @attribute secondary-value
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
        */

       /**
        * @attribute indeterminate
        * @description
        *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
        *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$15);
         } else if (name === 'value' || name === 'secondary-value') {
           this._updateValue();
         } else if (name === 'indeterminate') {
           this._updateDeterminate();
         }
       }
     }, {
       key: '_updateDeterminate',
       value: function _updateDeterminate() {
         if (this.hasAttribute('indeterminate')) {
           this._template.classList.add('progress-bar--indeterminate');
           this._template.classList.remove('progress-bar--determinate');
         } else {
           this._template.classList.add('progress-bar--determinate');
           this._template.classList.remove('progress-bar--indeterminate');
         }
       }
     }, {
       key: '_updateValue',
       value: function _updateValue() {
         this._primary.style.width = this.hasAttribute('value') ? this.getAttribute('value') + '%' : '0%';
         this._secondary.style.width = this.hasAttribute('secondary-value') ? this.getAttribute('secondary-value') + '%' : '0%';
       }
     }, {
       key: '_compile',
       value: function _compile() {
         this._template = template.cloneNode(true);

         this._primary = this._template.childNodes[3];
         this._secondary = this._template.childNodes[1];

         this._updateDeterminate();
         this._updateValue();

         this.appendChild(this._template);

         ModifierUtil.initModifier(this, scheme$15);

         this.setAttribute('_compiled', '');
       }
     }]);
     return ProgressBarElement;
   })(BaseElement);

   window.OnsProgressBarElement = document.registerElement('ons-progress-bar', {
     prototype: ProgressBarElement.prototype
   });

   var scheme$16 = {
     '.progress-circular': 'progress-circular--*',
     '.progress-circular__primary': 'progress-circular__primary--*',
     '.progress-circular__secondary': 'progress-circular__secondary--*'
   };

   var template$1 = util.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__secondary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n    <circle class="progress-circular__primary" cx="50%" cy="50%" r="40%" fill="none" stroke-width="10%" stroke-miterlimit="10"/>\n  </svg>\n');

   /**
    * @element ons-progress-circular
    * @category progress
    * @description
    *   [en]A material design progress component. It's displayed as a circular progress indicator.[/en]
    *   [ja]マテリアルデザインのprogressコンポーネントです。circularなプログレスインジケータを表示します。[/ja]
    * @codepen EVzMjR
    * @example
    * <ons-progress-circular
    *  value="55"
    *  secondary-value="87">
    * </ons-progress-circular>
    */

   var ProgressCircularElement = (function (_BaseElement) {
     babelHelpers.inherits(ProgressCircularElement, _BaseElement);

     function ProgressCircularElement() {
       babelHelpers.classCallCheck(this, ProgressCircularElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ProgressCircularElement).apply(this, arguments));
     }

     babelHelpers.createClass(ProgressCircularElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]Change the appearance of the progress indicator.[/en]
        *   [ja]プログレスインジケータの見た目を変更します。[/ja]
        */

       /**
        * @attribute value
        * @type {Number}
        * @description
        *   [en]Current progress. Should be a value between 0 and 100.[/en]
        *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
        */

       /**
        * @attribute secondary-value
        * @type {Number}
        * @description
        *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
        *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
        */

       /**
        * @attribute indeterminate
        * @description
        *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
        *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$16);
         } else if (name === 'value' || name === 'secondary-value') {
           this._updateValue();
         } else if (name === 'indeterminate') {
           this._updateDeterminate();
         }
       }
     }, {
       key: '_updateDeterminate',
       value: function _updateDeterminate() {
         if (this.hasAttribute('indeterminate')) {
           this._template.classList.add('progress-circular--indeterminate');
           this._template.classList.remove('progress-circular--determinate');
         } else {
           this._template.classList.add('progress-circular--determinate');
           this._template.classList.remove('progress-circular--indeterminate');
         }
       }
     }, {
       key: '_updateValue',
       value: function _updateValue() {
         if (this.hasAttribute('value')) {
           var per = Math.ceil(this.getAttribute('value') * 251.32 * 0.01);
           this._primary.style['stroke-dasharray'] = per + '%, 251.32%';
         }
         if (this.hasAttribute('secondary-value')) {
           var per = Math.ceil(this.getAttribute('secondary-value') * 251.32 * 0.01);
           this._secondary.style['stroke-dasharray'] = per + '%, 251.32%';
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         this._template = template$1.cloneNode(true);

         this._primary = this._template.childNodes[3];
         this._secondary = this._template.childNodes[1];

         this._updateDeterminate();
         this._updateValue();

         this.appendChild(this._template);

         ModifierUtil.initModifier(this, scheme$16);

         this.setAttribute('_compiled', '');
       }
     }]);
     return ProgressCircularElement;
   })(BaseElement);

   window.OnsProgressCircularElement = document.registerElement('ons-progress-circular', {
     prototype: ProgressCircularElement.prototype
   });

   var STATE_INITIAL = 'initial';
   var STATE_PREACTION = 'preaction';
   var STATE_ACTION = 'action';

   /**
    * @element ons-pull-hook
    * @category control
    * @description
    *   [en]Component that adds "pull-to-refresh" to an <ons-page> element.[/en]
    *   [ja]ons-page要素以下でいわゆるpull to refreshを実装するためのコンポーネントです。[/ja]
    * @codepen WbJogM
    * @guide UsingPullHook
    *   [en]How to use Pull Hook[/en]
    *   [ja]プルフックを使う[/ja]
    * @example
    * <ons-page>
    *   <ons-pull-hook>
    *     Release to refresh
    *   </ons-pull-hook>
    * </ons-page>
    *
    * <script>
    *   var loadStuff = function(done) {
    *     setTimeout(done, 1000);
    *   };
    *
    *   document.querySelector('ons-pull-hook').setActionCallback(loadStuff);
    * </script>
    */

   var PullHookElement = (function (_BaseElement) {
     babelHelpers.inherits(PullHookElement, _BaseElement);

     function PullHookElement() {
       babelHelpers.classCallCheck(this, PullHookElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(PullHookElement).apply(this, arguments));
     }

     babelHelpers.createClass(PullHookElement, [{
       key: 'createdCallback',

       /**
        * @event changestate
        * @description
        *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
        *   [ja]コンポーネントの状態が変わった場合に発火します。状態は、"initial", "preaction", "action"のいずれかです。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクト。[/ja]
        * @param {Object} event.pullHook
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        * @param {String} event.state
        *   [en]Current state.[/en]
        *   [ja]現在の状態名を参照できます。[/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
        *   [ja]この属性がある時、disabled状態になりアクションが実行されなくなります[/ja]
        */

       /**
        * @attribute height
        * @type {String}
        * @description
        *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
        *   [ja]コンポーネントの高さを指定します。この高さ以上にpull downすると"preaction"状態に移行します。デフォルトの値は"64px"です。[/ja]
        */

       /**
        * @attribute threshold-height
        * @type {String}
        * @description
        *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value or a value less than the height will disable this property.[/en]
        *   [ja]閾値となる高さを指定します。この値で指定した高さよりもpull downすると、このコンポーネントは自動的に"action"状態に移行します。[/ja]
        */

       /**
        * @attribute fixed-content
        * @description
        *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
        *   [ja]この属性がある時、プルフックが引き出されている時にもコンテンツは動きません。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._scrollElement = this._createScrollElement();
           this.setAttribute('_compiled', '');
         } else {
           this._scrollElement = this.parentElement;
         }

         this._pageElement = this._scrollElement.parentElement;

         if (!this._pageElement.classList.contains('page__content') && !this._pageElement.classList.contains('ons-scroller__content')) {
           throw new Error('<ons-pull-hook> must be a direct descendant of an <ons-page> or an <ons-scroller> element.');
         }

         this._boundOnDrag = this._onDrag.bind(this);
         this._boundOnDragStart = this._onDragStart.bind(this);
         this._boundOnDragEnd = this._onDragEnd.bind(this);
         this._boundOnScroll = this._onScroll.bind(this);

         this._currentTranslation = 0;

         this._setState(STATE_INITIAL, true);
         this._setStyle();
       }
     }, {
       key: '_createScrollElement',
       value: function _createScrollElement() {
         var scrollElement = util.createElement('<div class="scroll"><div>');

         var pageElement = this.parentElement;

         scrollElement.appendChild(this);
         while (pageElement.firstChild) {
           scrollElement.appendChild(pageElement.firstChild);
         }
         pageElement.appendChild(scrollElement);

         return scrollElement;
       }
     }, {
       key: '_setStyle',
       value: function _setStyle() {
         var height = this.getHeight();

         this.style.top = '-' + height + 'px';
         this.style.height = height + 'px';
         this.style.lineHeight = height + 'px';
       }
     }, {
       key: '_onScroll',
       value: function _onScroll(event) {
         var element = this._pageElement;

         if (element.scrollTop < 0) {
           element.scrollTop = 0;
         }
       }
     }, {
       key: '_generateTranslationTransform',
       value: function _generateTranslationTransform(scroll) {
         return 'translate3d(0px, ' + scroll + 'px, 0px)';
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         var _this2 = this;

         if (this.isDisabled()) {
           return;
         }

         // Ignore when dragging left and right.
         if (event.gesture.direction === 'left' || event.gesture.direction === 'right') {
           return;
         }

         // Hack to make it work on Android 4.4 WebView. Scrolls manually near the top of the page so
         // there will be no inertial scroll when scrolling down. Allowing default scrolling will
         // kill all 'touchmove' events.
         var element = this._pageElement;
         element.scrollTop = this._startScroll - event.gesture.deltaY;
         if (element.scrollTop < window.innerHeight && event.gesture.direction !== 'up') {
           event.gesture.preventDefault();
         }

         if (this._currentTranslation === 0 && this._getCurrentScroll() === 0) {
           this._transitionDragLength = event.gesture.deltaY;

           var direction = event.gesture.interimDirection;
           if (direction === 'down') {
             this._transitionDragLength -= 1;
           } else {
             this._transitionDragLength += 1;
           }
         }

         var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);

         if (this._thresholdHeightEnabled() && scroll >= this.getThresholdHeight()) {
           event.gesture.stopDetect();

           setImmediate(function () {
             _this2._setState(STATE_ACTION);
             _this2._translateTo(_this2.getHeight(), { animate: true });

             _this2._waitForAction(_this2._onDone.bind(_this2));
           });
         } else if (scroll >= this.getHeight()) {
           this._setState(STATE_PREACTION);
         } else {
           this._setState(STATE_INITIAL);
         }

         event.stopPropagation();
         this._translateTo(scroll);
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(event) {
         if (this.isDisabled()) {
           return;
         }

         this._startScroll = this._getCurrentScroll();
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         if (this.isDisabled()) {
           return;
         }

         if (this._currentTranslation > 0) {
           var scroll = this._currentTranslation;

           if (scroll > this.getHeight()) {
             this._setState(STATE_ACTION);

             this._translateTo(this.getHeight(), { animate: true });

             this._waitForAction(this._onDone.bind(this));
           } else {
             this._translateTo(0, { animate: true });
           }
         }
       }

       /**
        * @param {Function} callback
        */

     }, {
       key: 'setActionCallback',
       value: function setActionCallback(callback) {
         this._callback = callback;
       }
     }, {
       key: '_waitForAction',
       value: function _waitForAction(done) {
         if (this._callback instanceof Function) {
           this._callback.call(null, done);
         } else {
           done();
         }
       }
     }, {
       key: '_onDone',
       value: function _onDone(done) {
         // Check if the pull hook still exists.
         this._translateTo(0, { animate: true });
         this._setState(STATE_INITIAL);
       }

       /**
        * @method getHeight
        * @signature getHeight()
        * @return {Number}
        * @description
        *   [en]Returns the height of the pull hook in pixels.[/en]
        *   [ja]プルフックの高さをピクセル数で返します。[/ja]
        */

     }, {
       key: 'getHeight',
       value: function getHeight() {
         return parseInt(this.getAttribute('height') || '64', 10);
       }

       /**
        * @method setHeight
        * @signature setHeight(height)
        * @param {Number} height
        *   [en]Desired height.[/en]
        *   [ja]要素の高さを指定します。[/ja]
        * @description
        *   [en]Specify the height.[/en]
        *   [ja]高さを指定できます。[/ja]
        */

     }, {
       key: 'setHeight',
       value: function setHeight(height) {
         this.setAttribute('height', height + 'px');

         this._setStyle();
       }

       /**
        * @method setThresholdHeight
        * @signature setThresholdHeight(thresholdHeight)
        * @param {Number} thresholdHeight
        *   [en]Desired threshold height.[/en]
        *   [ja]プルフックのアクションを起こす閾値となる高さを指定します。[/ja]
        * @description
        *   [en]Specify the threshold height.[/en]
        *   [ja]閾値となる高さを指定できます。[/ja]
        */

     }, {
       key: 'setThresholdHeight',
       value: function setThresholdHeight(thresholdHeight) {
         this.setAttribute('threshold-height', thresholdHeight + 'px');
       }

       /**
        * @method getThresholdHeight
        * @signature getThresholdHeight()
        * @description
        *   [en]Returns the height of the threshold in pixels.[/en]
        *   [ja]閾値、となる高さをピクセル数で返します。[/ja]
        * @return {Number}
        */

     }, {
       key: 'getThresholdHeight',
       value: function getThresholdHeight() {
         return parseInt(this.getAttribute('threshold-height') || '96', 10);
       }
     }, {
       key: '_thresholdHeightEnabled',
       value: function _thresholdHeightEnabled() {
         var th = this.getThresholdHeight();
         return th > 0 && th >= this.getHeight();
       }
     }, {
       key: '_setState',
       value: function _setState(state, noEvent) {
         var lastState = this._getState();

         this.setAttribute('state', state);

         if (!noEvent && lastState !== this._getState()) {
           util.triggerElementEvent(this, 'changestate', {
             pullHook: this,
             state: state,
             lastState: lastState
           });
         }
       }
     }, {
       key: '_getState',
       value: function _getState() {
         return this.getAttribute('state');
       }

       /**
        * @method getCurrentState
        * @signature getCurrentState()
        * @return {String}
        * @description
        *   [en]Returns the current state of the element.[/en]
        *   [ja]要素の現在の状態を返します。[/ja]
        */

     }, {
       key: 'getCurrentState',
       value: function getCurrentState() {
         return this._getState();
       }
     }, {
       key: '_getCurrentScroll',
       value: function _getCurrentScroll() {
         return this._pageElement.scrollTop;
       }

       /**
        * @method getPullDistance
        * @signature getPullDistance()
        * @return {Number}
        * @description
        *   [en]Returns the current number of pixels the pull hook has moved.[/en]
        *   [ja]現在のプルフックが引き出された距離をピクセル数で返します。[/ja]
        */

     }, {
       key: 'getPullDistance',
       value: function getPullDistance() {
         return this._currentTranslation;
       }

       /**
        * @method isDisabled
        * @signature isDisabled()
        * @return {Boolean}
        *   [en]true if the pull hook is disabled.[/en]
        *   [ja]プルフックがdisabled状態の場合、trueを返します。[/ja]
        * @description
        *   [en]Returns whether the component is disabled or enabled.[/en]
        *   [ja]disabled状態になっているかを得ることが出来ます。[/ja]
        */

     }, {
       key: 'isDisabled',
       value: function isDisabled() {
         return this.hasAttribute('disabled');
       }
     }, {
       key: '_isContentFixed',
       value: function _isContentFixed() {
         return this.hasAttribute('fixed-content');
       }

       /**
        * @method setDisabled
        * @signature setDisabled(disabled)
        * @param {Boolean} disabled
        *   [en]If true the pull hook will be disabled.[/en]
        *   [ja]trueを指定すると、プルフックがdisabled状態になります。[/ja]
        * @description
        *   [en]Disable or enable the component.[/en]
        *   [ja]disabled状態にするかどうかを設定できます。[/ja]
        */

     }, {
       key: 'setDisabled',
       value: function setDisabled(disabled) {
         if (disabled) {
           this.setAttribute('disabled', '');
         } else {
           this.removeAttribute('disabled');
         }
       }
     }, {
       key: '_getScrollableElement',
       value: function _getScrollableElement() {
         if (this._isContentFixed()) {
           return this;
         } else {
           return this._scrollElement;
         }
       }

       /**
        * @param {Number} scroll
        * @param {Object} options
        * @param {Function} [options.callback]
        */

     }, {
       key: '_translateTo',
       value: function _translateTo(scroll) {
         var _this3 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (this._currentTranslation == 0 && scroll == 0) {
           return;
         }

         var done = function done() {
           if (scroll === 0) {
             _this3._getScrollableElement().removeAttribute('style');
           }

           if (options.callback) {
             options.callback();
           }
         };

         this._currentTranslation = scroll;

         if (options.animate) {
           animit(this._getScrollableElement()).queue({
             transform: this._generateTranslationTransform(scroll)
           }, {
             duration: 0.3,
             timing: 'cubic-bezier(.1, .7, .1, 1)'
           }).play(done);
         } else {
           animit(this._getScrollableElement()).queue({
             transform: this._generateTranslationTransform(scroll)
           }).play(done);
         }
       }
     }, {
       key: '_getMinimumScroll',
       value: function _getMinimumScroll() {
         var scrollHeight = this._scrollElement.getBoundingClientRect().height;
         var pageHeight = this._pageElement.getBoundingClientRect().height;

         return scrollHeight > pageHeight ? -(scrollHeight - pageHeight) : 0;
       }
     }, {
       key: '_createEventListeners',
       value: function _createEventListeners() {
         this._gestureDetector = new GestureDetector(this._pageElement, {
           dragMinDistance: 1,
           dragDistanceCorrection: false
         });

         // Bind listeners
         this._gestureDetector.on('drag', this._boundOnDrag);
         this._gestureDetector.on('dragstart', this._boundOnDragStart);
         this._gestureDetector.on('dragend', this._boundOnDragEnd);

         this._scrollElement.parentElement.addEventListener('scroll', this._boundOnScroll, false);
       }
     }, {
       key: '_destroyEventListeners',
       value: function _destroyEventListeners() {
         this._gestureDetector.off('drag', this._boundOnDrag);
         this._gestureDetector.off('dragstart', this._boundOnDragStart);
         this._gestureDetector.off('dragend', this._boundOnDragEnd);

         this._gestureDetector.dispose();
         this._gestureDetector = null;

         this._scrollElement.parentElement.removeEventListener('scroll', this._boundOnScroll, false);
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._createEventListeners();
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._destroyEventListeners();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }]);
     return PullHookElement;
   })(BaseElement);

   window.OnsPullHookElement = document.registerElement('ons-pull-hook', {
     prototype: PullHookElement.prototype
   });

   window.OnsPullHookElement.STATE_ACTION = STATE_ACTION;
   window.OnsPullHookElement.STATE_INITIAL = STATE_INITIAL;
   window.OnsPullHookElement.STATE_PREACTION = STATE_PREACTION;

   /**
    * @class AnimatorCSS - implementation of Animator class using css transitions
    */

   var AnimatorCSS = (function () {
     babelHelpers.createClass(AnimatorCSS, [{
       key: 'animate',

       /**
        * @method animate
        * @desc main animation function
        * @param {Element} element
        * @param {Object} finalCSS
        * @param {number} [duration=200] - duration in milliseconds
        * @return {Object} result
        * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
        * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
        * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
        * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
        * @example
        * ````
        *  var result = animator.animate(el, {opacity: 0.5}, 1000);
        *
        *  el.addEventListener('click', function(e){
        *    result.speed(200).then(function(){
        *      console.log('done');
        *    });
        *  }, 300);
        * ````
        */
       value: function animate(el, final) {
         var duration = arguments.length <= 2 || arguments[2] === undefined ? 200 : arguments[2];

         var start = new Date().getTime(),
             initial = {},
             stopped = false,
             next = false,
             timeout = false,
             properties = Object.keys(final);

         var updateStyles = function updateStyles() {
           var s = window.getComputedStyle(el);
           properties.forEach(s.getPropertyValue.bind(s));
           s = el.offsetHeight;
         };

         var result = {
           stop: function stop() {
             var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

             timeout && clearTimeout(timeout);
             var k = Math.min(1, (new Date().getTime() - start) / duration);
             properties.forEach(function (i) {
               el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
             });
             el.style.transitionDuration = '0s';

             if (options.stopNext) {
               next = false;
             } else if (!stopped) {
               stopped = true;
               next && next();
             }
             return result;
           },
           then: function then(cb) {
             next = cb;
             if (stopped) {
               next && next();
             }
             return result;
           },
           speed: function speed(newDuration) {
             if (internal.config.animationsDisabled) {
               newDuration = 0;
             }
             if (!stopped) {
               (function () {
                 timeout && clearTimeout(timeout);

                 var passed = new Date().getTime() - start;
                 var k = passed / duration;
                 var remaining = newDuration * (1 - k);

                 properties.forEach(function (i) {
                   el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
                 });

                 updateStyles();

                 start = el.speedUpTime;
                 duration = remaining;

                 el.style.transitionDuration = duration / 1000 + 's';

                 properties.forEach(function (i) {
                   el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
                 });

                 timeout = setTimeout(result.stop, remaining);
               })();
             }
             return result;
           },
           finish: function finish() {
             var milliseconds = arguments.length <= 0 || arguments[0] === undefined ? 50 : arguments[0];

             var k = (new Date().getTime() - start) / duration;

             result.speed(milliseconds / (1 - k));
             return result;
           }
         };

         if (el.hasAttribute('disabled') || stopped || internal.config.animationsDisabled) {
           return result;
         }

         var style = window.getComputedStyle(el);
         properties.forEach(function (e) {
           var v = parseFloat(style.getPropertyValue(e));
           initial[e] = isNaN(v) ? 0 : v;
         });

         if (!stopped) {
           el.style.transitionProperty = properties.join(',');
           el.style.transitionDuration = duration / 1000 + 's';

           properties.forEach(function (e) {
             el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
           });
         }

         timeout = setTimeout(result.stop, duration);
         this._onStopAnimations(el, result.stop);

         return result;
       }
     }]);

     function AnimatorCSS() {
       babelHelpers.classCallCheck(this, AnimatorCSS);

       this._queue = [];
       this._index = 0;
     }

     babelHelpers.createClass(AnimatorCSS, [{
       key: '_onStopAnimations',
       value: function _onStopAnimations(el, listener) {
         var queue = this._queue;
         var i = this._index++;
         queue[el] = queue[el] || [];
         queue[el][i] = function (options) {
           delete queue[el][i];
           if (queue[el] && queue[el].length == 0) {
             delete queue[el];
           }
           return listener(options);
         };
       }

       /**
       * @method stopAnimations
       * @desc stops active animations on a specified element
       * @param {Element|Array} element - element or array of elements
       * @param {Object} [options={}]
       * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
       */

     }, {
       key: 'stopAnimations',
       value: function stopAnimations(el) {
         var _this = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (Array.isArray(el)) {
           return el.forEach(function (el) {
             _this.stopAnimations(el, options);
           });
         }

         (this._queue[el] || []).forEach(function (e) {
           e(options || {});
         });
       }

       /**
       * @method stopAll
       * @desc stops all active animations
       * @param {Object} [options={}]
       * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
       */

     }, {
       key: 'stopAll',
       value: function stopAll() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.stopAnimations(Object.keys(this._queue), options);
       }

       /**
       * @method fade
       * @desc fades the element (short version for animate(el, {opacity: 0}))
       * @param {Element} element
       * @param {number} [duration=200]
       */

     }, {
       key: 'fade',
       value: function fade(el) {
         var duration = arguments.length <= 1 || arguments[1] === undefined ? 200 : arguments[1];

         return this.animate(el, { opacity: 0 }, duration);
       }
     }]);
     return AnimatorCSS;
   })();

   /**
    * @element ons-ripple
    * @category form
    * @description
    *   [en]Adds a Material Design "ripple" effect to an element.[/en]
    *   [ja]マテリアルデザインのリップル効果をDOM要素に追加します。[/ja]
    * @codepen wKQWdZ
    * @example
    * <ons-list>
    *   <ons-list-item>
    *    <ons-ripple color="rgba(0, 0, 0, 0.3)"></ons-ripple>
    *    Click me!
    *   </ons-list-item>
    * </ons-list>
    */

   var RippleElement = (function (_BaseElement) {
     babelHelpers.inherits(RippleElement, _BaseElement);

     function RippleElement() {
       babelHelpers.classCallCheck(this, RippleElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(RippleElement).apply(this, arguments));
     }

     babelHelpers.createClass(RippleElement, [{
       key: 'createdCallback',

       /**
        * @attribute color
        * @type {String}
        * @description
        *   [en]Color of the ripple effect.[/en]
        *   [ja]リップルエフェクトの色を指定します。[/ja]
        */

       /**
        * @attribute color
        * @type {String}
        * @description
        *   [en]Color of the ripple effect.[/en]
        *   [ja]リップルエフェクトの色を指定します。[/ja]
        */

       /**
        * @attribute background
        * @description
        *   [en]Color of the background.[/en]
        *   [ja]背景の色を設定します。[/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
        *   [ja]この属性が設定された場合、リップルエフェクトは無効になります。[/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         this.classList.add('ripple');
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         } else {
           this._background = this.getElementsByClassName('ripple__background')[0];
           this._wave = this.getElementsByClassName('ripple__wave')[0];
         }

         this._animator = new AnimatorCSS();

         ['color', 'center', 'start-radius', 'background'].forEach(function (e) {
           _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         var _this3 = this;

         ['_wave', '_background'].forEach(function (e) {
           _this3[e] = document.createElement('div');
           _this3[e].classList.add('ripple_' + e);
           _this3.appendChild(_this3[e]);
         });
         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_calculateCoords',
       value: function _calculateCoords(e) {
         var x, y, h, w, r;
         var b = this.getBoundingClientRect();
         if (this._center) {
           x = b.width / 2;
           y = b.height / 2;
           r = Math.sqrt(x * x + y * y);
         } else {
           x = (e.clientX || e.changedTouches[0].clientX) - b.left;
           y = (e.clientY || e.changedTouches[0].clientY) - b.top;
           h = Math.max(y, b.height - y);
           w = Math.max(x, b.width - x);
           r = Math.sqrt(h * h + w * w);
         }
         return { x: x, y: y, r: r };
       }
     }, {
       key: '_rippleAnimation',
       value: function _rippleAnimation(e) {
         var duration = arguments.length <= 1 || arguments[1] === undefined ? 300 : arguments[1];
         var _animator = this._animator;
         var _wave = this._wave;
         var _background = this._background;

         var _minR = this._minR;

         var _calculateCoords2 = this._calculateCoords(e);

         var x = _calculateCoords2.x;
         var y = _calculateCoords2.y;
         var r = _calculateCoords2.r;

         _animator.stopAll({ stopNext: 1 });
         _animator.animate(_background, { opacity: 1 }, duration);

         util.extend(_wave.style, {
           opacity: 1,
           top: y - _minR + 'px',
           left: x - _minR + 'px',
           width: 2 * _minR + 'px',
           height: 2 * _minR + 'px'
         });

         return _animator.animate(_wave, {
           top: y - r,
           left: x - r,
           height: 2 * r,
           width: 2 * r
         }, duration);
       }
     }, {
       key: '_updateParent',
       value: function _updateParent() {
         if (!this._parentUpdated && this.parentNode) {
           var computedStyle = window.getComputedStyle(this.parentNode);
           if (computedStyle.getPropertyValue('position') === 'static') {
             this.parentNode.style.position = 'relative';
           }
           this._parentUpdated = true;
         }
       }
     }, {
       key: '_onTap',
       value: function _onTap(e) {
         var _this4 = this;

         if (!this.isDisabled()) {
           this._updateParent();
           this._rippleAnimation(e.gesture.srcEvent).then(function () {
             _this4._animator.fade(_this4._wave);
             _this4._animator.fade(_this4._background);
           });
         }
       }
     }, {
       key: '_onHold',
       value: function _onHold(e) {
         if (!this.isDisabled()) {
           this._updateParent();
           this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
           document.addEventListener('release', this._boundOnRelease);
         }
       }
     }, {
       key: '_onRelease',
       value: function _onRelease(e) {
         var _this5 = this;

         if (this._holding) {
           this._holding.speed(300).then(function () {
             _this5._animator.stopAll({ stopNext: true });
             _this5._animator.fade(_this5._wave);
             _this5._animator.fade(_this5._background);
           });

           this._holding = false;
         }

         document.removeEventListener('release', this._boundOnRelease);
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(e) {
         if (this._holding) {
           return this._onRelease(e);
         }
         if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
           this._onTap(e);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._parentNode = this.parentNode;
         this._boundOnTap = this._onTap.bind(this);
         this._boundOnHold = this._onHold.bind(this);
         this._boundOnDragStart = this._onDragStart.bind(this);
         this._boundOnRelease = this._onRelease.bind(this);

         if (internal.config.animationsDisabled) {
           this.setDisabled(true);
         } else {
           this._parentNode.addEventListener('tap', this._boundOnTap);
           this._parentNode.addEventListener('hold', this._boundOnHold);
           this._parentNode.addEventListener('dragstart', this._boundOnDragStart);
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._parentNode.removeEventListener('tap', this._boundOnTap);
         this._parentNode.removeEventListener('hold', this._boundOnHold);
         this._parentNode.removeEventListener('dragstart', this._boundOnDragStart);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'start-radius') {
           this._minR = Math.max(0, parseFloat(current) || 0);
         }
         if (name === 'color' && current) {
           this._wave.style.background = current;
           if (!this.hasAttribute('background')) {
             this._background.style.background = current;
           }
         }
         if (name === 'background' && (current || last)) {
           if (current === 'none') {
             this._background.setAttribute('disabled', 'disabled');
             this._background.style.background = 'transparent';
           } else {
             if (this._background.hasAttribute('disabled')) {
               this._background.removeAttribute('disabled');
             }
             this._background.style.background = current;
           }
         }
         if (name === 'center') {
           this._center = current != null && current != 'false';
         }
       }

       /**
       * Disable or enable ripple-effect.
       *
       * @param {Boolean}
       */

     }, {
       key: 'setDisabled',
       value: function setDisabled(disabled) {
         if (typeof disabled !== 'boolean') {
           throw new Error('Argument must be a boolean.');
         }
         if (disabled) {
           this.setAttribute('disabled', '');
         } else {
           this.removeAttribute('disabled');
         }
       }

       /**
        * True if ripple-effect is disabled.
        *
        * @return {Boolean}
        */

     }, {
       key: 'isDisabled',
       value: function isDisabled() {
         return this.hasAttribute('disabled'); // || this.parentNode.hasAttribute('disabled');
       }
     }]);
     return RippleElement;
   })(BaseElement);

   window.OnsRippleElement = document.registerElement('ons-ripple', {
     prototype: RippleElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   /**
    * @element ons-row
    * @category grid
    * @description
    *   [en]Represents a row in the grid system. Use with ons-col to layout components.[/en]
    *   [ja]グリッドシステムにて行を定義します。ons-colとともに使用し、コンポーネントの配置に使用します。[/ja]
    * @codepen GgujC {wide}
    * @guide Layouting
    *   [en]Layouting guide[/en]
    *   [ja]レイアウト調整[/ja]
    * @seealso ons-col
    *   [en]ons-col component[/en]
    *   [ja]ons-colコンポーネント[/ja]
    * @note
    *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
    *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-colを組み合わせてそれぞれのons-col要素のvertical-align属性の値に別々の値を指定すると、描画が崩れる場合があります。vertical-align属性の値には一つの値だけを指定できます。[/ja]
    * @example
    * <ons-row>
    *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
    *   <ons-col>Text</ons-col>
    * </ons-row>
    */

   /**
    * @attribute vertical-align
    * @type {String}
    * @description
    *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
    *   [ja]縦に整列するために指定します。top、bottom、centerのいずれかを指定できます。[/ja]
    */
   window.OnsRowElement = window.OnsRowElement ? window.OnsRowElement : document.registerElement('ons-row');

   // TODO: Add codepen example.

   /**
    * @element ons-ripple
    * @category control
    * @description
    *   [en]Adds scrollbar to the parent element. NOTE: the parent should have a fixed size.[/en]
    *   [ja][/ja]
    * @example
    * <div>
    *   Lorem ipsum dolor sit amet...
    *   <ons-scrollbar draggable></ons-scrollbar>
    * </div>
    *
    * <div>
    *   Lorem ipsum dolor sit amet...
    *   <ons-scrollbar autohide></ons-scrollbar>
    * </div>
    */

   var ScrollbarElement = (function (_BaseElement) {
     babelHelpers.inherits(ScrollbarElement, _BaseElement);

     function ScrollbarElement() {
       babelHelpers.classCallCheck(this, ScrollbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ScrollbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(ScrollbarElement, [{
       key: 'createdCallback',

       /**
        * @attribute height
        * @type {Number}
        * @description
        *   [en]If set then the height of the scrollbar will be fixed to this value. Otherwise it will be a dynamic value based on the visible proportion of the content. The value can only be in px and is ignored if it's zero.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute draggable
        * @description
        *   [en]If this attribute is set then the scrollbar will be draggable.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute autohide
        * @type {String}
        * @description
        *   [en]If this attribute is set then the scrollbar will disappear shortly after scrolling.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute autohide-delay
        * @type {Number}
        * @description
        *   [en]Delay (in ms) after which the scrollbar will disappear if autohide is set.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute hidden
        * @type {String}
        * @description
        *   [en]If this attribute is set then the scrollbar will be hidden with `display: none`.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute native
        * @type {String}
        * @initonly
        * @description
        *   [en]If this attribute is set then native scrollbar will be used instead of the javascript one.[/en]
        *   [ja][/ja]
        */

       /**
        * @attribute update-on-scroll
        * @description
        *   [en]If this attribute is set then the scrollbar will update it's size and container on every scroll event. Useful if the size of the content changes frequently. Otherwise `updateScrollbar` method should be called manually when the content size changes. [/en]
        *   [ja][/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         if (!this.hasAttribute('_compiled')) {
           this._compile();
         } else {
           this._scroll = util.findChild(this, '.scrollbar');
         }
         this._timeout = false;

         this._boundOnDragStart = this._onDragStart.bind(this);
         this._boundOnScroll = this._onScroll.bind(this);
         this._boundOnResize = this._onResize.bind(this);

         ['height', 'draggable', 'autohide', 'autohide-delay', 'hidden', 'native', 'update-on-scroll'].forEach(function (e) {
           _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         this.classList.add('scrollbar-container');
         this._scroll = util.createElement('<div class="scrollbar"><div class="scrollbar-touch"></div></div>');
         this.appendChild(this._scroll);
         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_attach',
       value: function _attach() {
         var _this3 = this;

         var styles = window.getComputedStyle(this.parentNode);
         if (styles.getPropertyValue('position') === 'static') {
           this.parentNode.style.position = 'relative';
         }

         this._content = util.createElement('<div class="scrollbar-content"></div>');
         Array.prototype.slice.call(this.parentNode.childNodes).forEach(function (e) {
           if (e != _this3) {
             _this3._content.appendChild(e);
           }
         });
         this.parentNode.insertBefore(this._content, this);
         this.setAttribute('_attached', '');
       }
     }, {
       key: '_onScroll',
       value: function _onScroll(e) {
         if (this._updateOnScroll) {
           this.updateScrollbar();
         } else {
           this._updateScrollbarLocation();
         }

         if (this._autohide) {
           this._updateAutohide();
         }
       }
     }, {
       key: '_onResize',
       value: function _onResize(e) {
         this.updateScrollbar();
       }
     }, {
       key: '_updateAutohide',
       value: function _updateAutohide() {
         var _this4 = this;

         if (!this._scrolling) {
           this._scrolling = true;
           this.classList.add('scrollbar-autohide-visible');
         }
         clearTimeout(this._timeout);
         this._timeout = setTimeout(function () {
           _this4._scrolling = false;
           _this4.classList.remove('scrollbar-autohide-visible');
         }, this._autohideDelay);
       }

       /**
        * @method updateScrollbar
        * @signature updateScrollbar()
        * @description
        *   [en]Updates the scrollbar size and location. Should be called if the size of the content changes. Automatically called when onInfiniteScroll handler is finished.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'updateScrollbar',
       value: function updateScrollbar() {
         var content = this._content;
         var scroll = this._scroll;
         var container = this;

         if (!this._hidden && !this._native) {
           scroll.style.display = content.clientHeight >= content.scrollHeight ? 'none' : 'block';
           scroll.style.height = Math.round(this._height || container.clientHeight * content.clientHeight / content.scrollHeight) + 'px';
           this._contentMax = content.scrollHeight - content.clientHeight;
           this._scrollMax = container.clientHeight - scroll.clientHeight;
           this._updateScrollbarLocation();
         }
       }
     }, {
       key: '_updateScrollbarLocation',
       value: function _updateScrollbarLocation() {
         this._scroll.style.top = Math.round(this._scrollMax * this._content.scrollTop / this._contentMax) + 'px';
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(e) {
         var _this5 = this;

         var startY = this._scroll.offsetTop;
         var onMove = function onMove(e) {
           _this5.classList.add('scrollbar-dragging');
           var progress = Math.min(1, Math.max(0, (startY + e.gesture.deltaY) / _this5._scrollMax));
           _this5._content.scrollTop = _this5._contentMax * progress;
         };
         document.addEventListener('drag', onMove);
         document.addEventListener('release', function () {
           _this5.classList.remove('scrollbar-dragging');
           document.removeEventListener('drag', onMove);
         });
       }
     }, {
       key: '_onTouchStart',
       value: function _onTouchStart(e) {
         e.preventDefault();
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         if (!this.hasAttribute('_attached')) {
           this._attach();
         } else {
           this._content = this.parentNode.getElementsByClassName('scrollbar-content')[0];
         }

         if (this._native) {
           this._content.classList.add('scrollbar-native');
         }

         this._content.addEventListener('scroll', this._boundOnScroll);
         window.addEventListener('resize', this._boundOnResize);
         this.updateScrollbar();

         if (this._draggable) {
           this._scroll.addEventListener('dragstart', this._boundOnDragStart);
           this._scroll.addEventListener('touchstart', this._onTouchStart);
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._content.removeEventListener('scroll', this._boundOnScroll);
         this._scroll.removeEventListener('dragstart', this._boundOnDragStart);
         this._scroll.removeEventListener('touchstart', this._onTouchStart);
         this._timeout && clearTimeout(this._timeout);
         window.removeEventListener('resize', this._boundOnResize);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'update-on-scroll') {
           this._updateOnScroll = current !== null;
         }
         if (name === 'autohide-delay') {
           this._autohideDelay = parseInt(current) || 500;
         }
         if (name === 'height') {
           this._height = parseInt(current) || 0;
         }
         if (['draggable', 'autohide', 'hidden', 'native'].indexOf(name) !== -1) {
           this['_' + name] = current !== null;
         }
         this._content && this.updateScrollbar();
       }
     }]);
     return ScrollbarElement;
   })(BaseElement);

   window.OnsScrollbarElement = document.registerElement('ons-scrollbar', {
     prototype: ScrollbarElement.prototype
   });

   var scheme$17 = {
     '': 'speed-dial__item--*'
   };

   /**
    * @element ons-speed-dial-item
    * @category speeddial
    * @description
    *   [en]This component displays the child elements of the Material Design Speed dial component.[/en]
    *   [ja]Material DesignのSpeed dialの子要素を表現する要素です。[/ja]
    * @codepen dYQYLg
    * @seealso ons-speed-dial
    *   [en]ons-speed-dial component[/en]
    *   [ja]ons-speed-dialコンポーネント[/ja]
    * @example
    * <ons-speed-dial position="left bottom">
    *   <ons-icon
    *     icon="fa-twitter"
    *     size="26px"
    *     fixed-width="false"
    *     style="vertical-align:middle;">
    *   </ons-icon>
    *   <ons-speed-dial-item><ons-ripple></ons-ripple>C</ons-speed-dial-item>
    *   <ons-speed-dial-item><ons-ripple></ons-ripple>B</ons-speed-dial-item>
    *   <ons-speed-dial-item><ons-ripple></ons-ripple>A</ons-speed-dial-item>
    * </ons-speed-dial>
    */

   var SpeedDialItemElement = (function (_BaseElement) {
     babelHelpers.inherits(SpeedDialItemElement, _BaseElement);

     function SpeedDialItemElement() {
       babelHelpers.classCallCheck(this, SpeedDialItemElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SpeedDialItemElement).apply(this, arguments));
     }

     babelHelpers.createClass(SpeedDialItemElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the component.[/en]
        *   [ja]このコンポーネントの表現を指定します。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$17);
             break;
           case 'ripple':
             this._updateRipple();
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_onClick',
       value: function _onClick(e) {
         e.stopPropagation();
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('fab');
         this.classList.add('fab--mini');
         this.classList.add('speed-dial__item');

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$17);

         this.setAttribute('_compiled', '');
       }
     }]);
     return SpeedDialItemElement;
   })(BaseElement);

   window.OnsSpeedDialItemElement = document.registerElement('ons-speed-dial-item', {
     prototype: SpeedDialItemElement.prototype
   });

   var scheme$18 = {
     '': 'speed-dial--*'
   };

   /**
    * @element ons-speed-dial
    * @category speeddial
    * @description
    *   [en]Element that displays a Material Design Speed Dialog component.[/en]
    *   [ja]Material DesignのSpeed dialコンポーネントを表現する要素です。[/ja]
    * @codepen dYQYLg
    * @seealso ons-speed-dial-item
    *   [en]ons-speed-dial-item component[/en]
    *   [ja]ons-speed-dial-itemコンポーネント[/ja]
    * @example
    * <ons-speed-dial position="left bottom">
    *   <ons-icon
    *     icon="fa-twitter"
    *     size="26px"
    *     fixed-width="false"
    *     style="vertical-align:middle;">
    *   </ons-icon>
    *   <ons-speed-dial-item><ons-ripple></ons-ripple>C</ons-speed-dial-item>
    *   <ons-speed-dial-item><ons-ripple></ons-ripple>B</ons-speed-dial-item>
    *   <ons-speed-dial-item><ons-ripple></ons-ripple>A</ons-speed-dial-item>
    * </ons-speed-dial>
    */

   var SpeedDialElement = (function (_BaseElement) {
     babelHelpers.inherits(SpeedDialElement, _BaseElement);

     function SpeedDialElement() {
       babelHelpers.classCallCheck(this, SpeedDialElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SpeedDialElement).apply(this, arguments));
     }

     babelHelpers.createClass(SpeedDialElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the component.[/en]
        *   [ja]このコンポーネントの表現を指定します。[/ja]
        */

       /**
        * @attribute position
        * @type {String}
        * @description
        *   [en]
        *     Specify the vertical and horizontal position of the component.
        *     I.e. to display it in the top right corner specify "right top".
        *     Choose from "right", "left", "top" and "bottom".
        *   [/en]
        *   [ja]
        *     この要素を表示する左右と上下の位置を指定します。
        *     例えば、右上に表示する場合には"right top"を指定します。
        *     左右と上下の位置の指定には、rightとleft、topとbottomがそれぞれ指定できます。
        *   [/ja]
        */

       /**
        * @attribute direction
        * @type {String}
        * @description
        *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
        *   [ja]
        *     要素が表示する方向を指定します。up, down, left, rightが指定できます。
        *   [/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja]無効化する場合に指定します。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();

           this.classList.add('speed__dial');

           if (this.hasAttribute('direction')) {
             this._updateDirection(this.getAttribute('direction'));
           } else {
             this._updateDirection('up');
           }
           this._updatePosition();

           if (this.hasAttribute('disabled')) {
             this.setDisabled(true);
           }
         }

         this._shown = true;
         this._itemShown = false;
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         var content = document.createElement('ons-fab');

         util.arrayFrom(this.childNodes).forEach(function (node) {
           if (node.nodeType == 8 || node.nodeType === 3 && !/\S/.test(node.nodeValue)) {
             node.remove();
           } else if (node.nodeName.toLowerCase() !== 'ons-speed-dial-item') {
             util.findChild(content, 'span').appendChild(node);
           }
         });

         this.insertBefore(content, this.firstChild);

         this._updateRipple();

         ModifierUtil.initModifier(this, scheme$18);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$18);
             break;
           case 'ripple':
             this._updateRipple();
             break;
           case 'direction':
             this._updateDirection(current);
             break;
           case 'position':
             this._updatePosition();
             break;
           case 'disabled':
             this.setDisabled(current !== null);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: '_onClick',
       value: function _onClick(e) {
         if (!this.isDisabled()) {
           this.toggleItems();
         }
       }
     }, {
       key: '_show',
       value: function _show() {
         if (!this.isInline()) {
           this.show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         if (!this.isInline()) {
           this.hide();
         }
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         var fab = util.findChild(this, 'ons-fab');
         this.hasAttribute('ripple') ? fab.setAttribute('ripple', '') : fab.removeAttribute('ripple');
       }
     }, {
       key: '_updateDirection',
       value: function _updateDirection(direction) {
         var children = this.items;
         for (var i = 0; i < children.length; i++) {
           children[i].style.transitionDelay = 25 * i + 'ms';
           children[i].style.webkitTransitionDelay = 25 * i + 'ms';
           children[i].style.bottom = 'auto';
           children[i].style.right = 'auto';
           children[i].style.top = 'auto';
           children[i].style.left = 'auto';
         }
         switch (direction) {
           case 'up':
             for (var i = 0; i < children.length; i++) {
               children[i].style.bottom = 72 + 56 * i + 'px';
               children[i].style.right = '8px';
             }
             break;
           case 'down':
             for (var i = 0; i < children.length; i++) {
               children[i].style.top = 72 + 56 * i + 'px';
               children[i].style.left = '8px';
             }
             break;
           case 'left':
             for (var i = 0; i < children.length; i++) {
               children[i].style.top = '8px';
               children[i].style.right = 72 + 56 * i + 'px';
             }
             break;
           case 'right':
             for (var i = 0; i < children.length; i++) {
               children[i].style.top = '8px';
               children[i].style.left = 72 + 56 * i + 'px';
             }
             break;
           default:
             throw new Error('Argument must be one of up, down, left or right.');
         }
       }
     }, {
       key: '_updatePosition',
       value: function _updatePosition() {
         var position = this.getAttribute('position');
         this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
         switch (position) {
           case 'top right':
           case 'right top':
             this.classList.add('fab--top__right');
             break;
           case 'top left':
           case 'left top':
             this.classList.add('fab--top__left');
             break;
           case 'bottom right':
           case 'right bottom':
             this.classList.add('fab--bottom__right');
             break;
           case 'bottom left':
           case 'left bottom':
             this.classList.add('fab--bottom__left');
             break;
           case 'center top':
           case 'top center':
             this.classList.add('fab--top__center');
             break;
           case 'center bottom':
           case 'bottom center':
             this.classList.add('fab--bottom__center');
             break;
           default:
             break;
         }
       }

       /**
        * @method show
        * @signature show()
        * @description
        *   [en]Show the speed dial.[/en]
        *   [ja]Speed dialを表示します。[/ja]
        */

     }, {
       key: 'show',
       value: function show() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.querySelector('ons-fab').show();
         this._shown = true;
       }

       /**
        * @method hide
        * @signature hide()
        * @description
        *   [en]Hide the speed dial.[/en]
        *   [ja]Speed dialを非表示にします。[/ja]
        */

     }, {
       key: 'hide',
       value: function hide() {
         var _this2 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         this.hideItems();
         setTimeout(function () {
           _this2.querySelector('ons-fab').hide();
         }, 200);
         this._shown = false;
       }

       /**
        * @method showItems
        * @signature showItems()
        * @description
        *   [en]Show the speed dial items.[/en]
        *   [ja]Speed dialの子要素を表示します。[/ja]
        */

     }, {
       key: 'showItems',
       value: function showItems() {
         if (!this._itemShown) {
           var children = this.items;
           for (var i = 0; i < children.length; i++) {
             children[i].style.transform = 'scale(1)';
             children[i].style.webkitTransform = 'scale(1)';
             children[i].style.transitionDelay = 25 * i + 'ms';
             children[i].style.webkitTransitionDelay = 25 * i + 'ms';
           }
         }
         this._itemShown = true;
       }

       /**
        * @method hideItems
        * @signature hideItems()
        * @description
        *   [en]Hide the speed dial items.[/en]
        *   [ja]Speed dialの子要素を非表示にします。[/ja]
        */

     }, {
       key: 'hideItems',
       value: function hideItems() {
         if (this._itemShown) {
           var children = this.items;
           for (var i = 0; i < children.length; i++) {
             children[i].style.transform = 'scale(0)';
             children[i].style.webkitTransform = 'scale(0)';
             children[i].style.transitionDelay = 25 * (children.length - i) + 'ms';
             children[i].style.webkitTransitionDelay = 25 * (children.length - i) + 'ms';
           }
         }
         this._itemShown = false;
       }

       /**
        * @method setDisabled
        * @signature setDisabled(disabled)
        * @param {Boolean}
        * @description
        *   [en]Disable or enable the element.[/en]
        *   [ja]disabled状態にするかどうかを設定します。[/ja]
        */

     }, {
       key: 'setDisabled',
       value: function setDisabled(disabled) {
         if (typeof disabled !== 'boolean') {
           throw new Error('Argument must be a boolean.');
         }

         if (disabled) {
           this.hideItems();
           this.setAttribute('disabled', '');
           util.arrayFrom(this.childNodes).forEach(function (element) {
             return element.classList.contains('fab') ? element.setAttribute('disabled', '') : true;
           });
         } else {
           this.removeAttribute('disabled');
           util.arrayFrom(this.childNodes).forEach(function (element) {
             return element.classList.contains('fab') ? element.removeAttribute('disabled') : true;
           });
         }
       }

       /**
        * @method isDisabled
        * @signature isDisabled()
        * @return {Boolean}
        *   [en]true if the element is disabled.[/en]
        *   [ja]disabled状態になっているかどうかを返します。[/ja]
        * @description
        *   [en]Returns whether the component is enabled or not.[/en]
        *   [ja]この要素を無効化するかどうかを指定します。[/ja]
        */

     }, {
       key: 'isDisabled',
       value: function isDisabled() {
         return this.hasAttribute('disabled');
       }

       /**
        * @method isInline
        * @signature isInline()
        * @return {Boolean}
        * @description
        *   [en]Returns whether the component is inline or not.[/en]
        *   [ja]この要素がインライン要素かどうかを返します。[/ja]
        */

     }, {
       key: 'isInline',
       value: function isInline() {
         return this.hasAttribute('inline');
       }

       /**
        * @method isShown
        * @signature isShown()
        * @return {Boolean}
        *   [en]True if the component is visible.[/en]
        *   [ja]表示されているかどうかを返します。[/ja]
        * @description
        *   [en]Return whether the component is visible or not.[/en]
        *   [ja]表示されているかどうかを返します。[/ja]
        */

     }, {
       key: 'isShown',
       value: function isShown() {
         return this._shown && this.style.display !== 'none';
       }
     }, {
       key: 'isItemShown',
       value: function isItemShown() {
         return this._itemShown;
       }

       /**
        * @method toggle
        * @signature toggle()
        * @description
        *   [en]Toggle visibility.[/en]
        *   [ja]Speed dialの表示非表示を切り替えます。[/ja]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         if (this.isShown()) {
           this.hide();
         } else {
           this.show();
         }
       }

       /**
        * @method toggleItems
        * @signature toggleItems()
        * @description
        *   [en]Toggle item visibility.[/en]
        *   [ja]Speed dialの子要素の表示非表示を切り替えます。[/ja]
        */

     }, {
       key: 'toggleItems',
       value: function toggleItems() {
         if (this.isItemShown()) {
           this.hideItems();
         } else {
           this.showItems();
         }
       }
     }, {
       key: 'items',
       get: function get() {
         return util.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
       }
     }]);
     return SpeedDialElement;
   })(BaseElement);

   window.OnsSpeedDialElement = document.registerElement('ons-speed-dial', {
     prototype: SpeedDialElement.prototype
   });

   var rewritables$1 = {
     /**
      * @param {Element} splitterSideElement
      * @param {Function} callback
      */

     ready: function ready(splitterSideElement, callback) {
       setImmediate(callback);
     },

     /**
      * @param {Element} splitterSideElement
      * @param {HTMLFragment} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(splitterSideElement, target, options, callback) {
       callback(target);
     }
   };

   /**
    * @element ons-splitter-content
    * @category control
    * @description
    *  [en]The "ons-splitter-content" element is used as a child element of "ons-splitter".[/en]
    *  [ja]ons-splitter-content要素は、ons-splitter要素の子要素として利用します。[/ja]
    * @codepen rOQOML
    * @seealso ons-splitter
    *  [en]ons-splitter component[/en]
    *  [ja]ons-splitterコンポーネント[/ja]
    * @seealso ons-splitter-side
    *  [en]ons-splitter-side component[/en]
    *  [ja]ons-splitter-sideコンポーネント[/ja]
    * @example
    * <ons-splitter>
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    */

   var SplitterContentElement = (function (_BaseElement) {
     babelHelpers.inherits(SplitterContentElement, _BaseElement);

     function SplitterContentElement() {
       babelHelpers.classCallCheck(this, SplitterContentElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterContentElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterContentElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this._page = null;
       }

       /**
        * @method load
        * @signature load(pageUrl)
        * @param {String} pageUrl
        *   [en]Page URL. Can be either an HTML document or an <ons-template>.[/en]
        *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @description
        *   [en]Show the page specified in pageUrl in the right section[/en]
        *   [ja]指定したURLをメインページを読み込みます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'load',
       value: function load(page) {
         var _this2 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         this._page = page;

         options.callback = options.callback instanceof Function ? options.callback : function () {};
         return internal.getPageHTMLAsync(page).then(function (html) {
           return new Promise(function (resolve) {
             rewritables$1.link(_this2, util.createFragment(html), options, function (fragment) {
               util.propagateAction(_this2, '_hide');
               _this2.innerHTML = '';

               _this2.appendChild(fragment);

               util.propagateAction(_this2, '_show');

               options.callback();
               resolve(_this2.firstChild);
             });
           });
         });
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this3 = this;

         this._assertParent();

         if (this.hasAttribute('page')) {
           setImmediate(function () {
             return rewritables$1.ready(_this3, function () {
               return _this3.load(_this3.getAttribute('page'));
             });
           });
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {}
     }, {
       key: '_show',
       value: function _show() {
         util.propagateAction(this, '_show');
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.propagateAction(this, '_hide');
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.propagateAction(this, '_destroy');
         this.remove();
       }
     }, {
       key: '_assertParent',
       value: function _assertParent() {
         var parentElementName = this.parentElement.nodeName.toLowerCase();
         if (parentElementName !== 'ons-splitter') {
           throw new Error('"' + parentElementName + '" element is not allowed as parent element.');
         }
       }
     }, {
       key: 'page',

       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]The url of the menu page.[/en]
        *   [ja]ons-splitter-side要素に表示するページのURLを指定します。[/ja]
        */

       get: function get() {
         return this._page;
       }
     }]);
     return SplitterContentElement;
   })(BaseElement);

   window.OnsSplitterContentElement = document.registerElement('ons-splitter-content', {
     prototype: SplitterContentElement.prototype
   });

   window.OnsSplitterContentElement.rewritables = rewritables$1;

   var SplitterMaskElement = (function (_BaseElement) {
     babelHelpers.inherits(SplitterMaskElement, _BaseElement);

     function SplitterMaskElement() {
       babelHelpers.classCallCheck(this, SplitterMaskElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterMaskElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterMaskElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_onClick',
       value: function _onClick(event) {
         if (this.parentElement && this.parentElement.nodeName.toLowerCase() === 'ons-splitter') {
           // close side menus
           this.parentElement.closeRight().catch(function () {});
           this.parentElement.closeLeft().catch(function () {});
         }
         event.stopPropagation();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('click', this._boundOnClick);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick);
       }
     }]);
     return SplitterMaskElement;
   })(BaseElement);

   window.OnsSplitterMaskElement = document.registerElement('ons-splitter-mask', {
     prototype: SplitterMaskElement.prototype
   });

   var SplitterAnimator = (function () {
     function SplitterAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, SplitterAnimator);

       options = util.extend({
         timing: 'linear',
         duration: '0.3',
         delay: '0'
       }, options || {});

       this._timing = options.timing;
       this._duration = options.duration;
       this._delay = options.delay;
     }

     babelHelpers.createClass(SplitterAnimator, [{
       key: 'layoutOnOpen',
       value: function layoutOnOpen() {}
     }, {
       key: 'layoutOnClose',
       value: function layoutOnClose() {}
     }, {
       key: 'translate',
       value: function translate(distance) {}
     }, {
       key: 'open',
       value: function open(done) {
         done();
       }
     }, {
       key: 'close',
       value: function close(done) {
         done();
       }
     }, {
       key: 'activate',
       value: function activate(contentElement, sideElement, maskElement) {}
     }, {
       key: 'inactivate',
       value: function inactivate() {}
     }, {
       key: 'isActivated',
       value: function isActivated() {
         throw new Error();
       }
     }]);
     return SplitterAnimator;
   })();

   var SPLIT_MODE = 'split';
   var COLLAPSE_MODE = 'collapse';

   var CollapseDetection = (function () {
     function CollapseDetection() {
       babelHelpers.classCallCheck(this, CollapseDetection);
     }

     babelHelpers.createClass(CollapseDetection, [{
       key: 'activate',
       value: function activate(element) {}
     }, {
       key: 'inactivate',
       value: function inactivate() {}
     }]);
     return CollapseDetection;
   })();

   var rewritables$2 = {
     /**
      * @param {Element} splitterSideElement
      * @param {Function} callback
      */

     ready: function ready(splitterSideElement, callback) {
       setImmediate(callback);
     },

     /**
      * @param {Element} splitterSideElement
      * @param {HTMLFragment} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(splitterSideElement, target, options, callback) {
       callback(target);
     }
   };

   var OrientationCollapseDetection = (function (_CollapseDetection) {
     babelHelpers.inherits(OrientationCollapseDetection, _CollapseDetection);

     /**
      * @param {String} orientation
      */

     function OrientationCollapseDetection(newOrientation) {
       babelHelpers.classCallCheck(this, OrientationCollapseDetection);

       var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(OrientationCollapseDetection).call(this));

       if (newOrientation !== 'portrait' && newOrientation !== 'landscape') {
         throw new Error('Invalid orientation: ' + newOrientation);
       }

       _this._boundOnOrientationChange = _this._onOrientationChange.bind(_this);
       _this._targetOrientation = newOrientation;
       return _this;
     }

     babelHelpers.createClass(OrientationCollapseDetection, [{
       key: 'activate',
       value: function activate(element) {
         this._element = element;
         orientation.on('change', this._boundOnOrientationChange);
         this._update(orientation.isPortrait());
       }
     }, {
       key: '_onOrientationChange',
       value: function _onOrientationChange(info) {
         this._update(info.isPortrait);
       }
     }, {
       key: '_update',
       value: function _update(isPortrait) {
         if (isPortrait && this._targetOrientation === 'portrait') {
           this._element._updateMode(COLLAPSE_MODE);
         } else if (!isPortrait && this._targetOrientation === 'landscape') {
           this._element._updateMode(COLLAPSE_MODE);
         } else {
           this._element._updateMode(SPLIT_MODE);
         }
       }
     }, {
       key: 'inactivate',
       value: function inactivate() {
         this._element = null;
         orientation.off('change', this._boundOnOrientationChange);
       }
     }]);
     return OrientationCollapseDetection;
   })(CollapseDetection);

   var StaticCollapseDetection = (function (_CollapseDetection2) {
     babelHelpers.inherits(StaticCollapseDetection, _CollapseDetection2);

     function StaticCollapseDetection() {
       babelHelpers.classCallCheck(this, StaticCollapseDetection);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(StaticCollapseDetection).apply(this, arguments));
     }

     babelHelpers.createClass(StaticCollapseDetection, [{
       key: 'activate',
       value: function activate(element) {
         element._updateMode(COLLAPSE_MODE);
       }
     }]);
     return StaticCollapseDetection;
   })(CollapseDetection);

   var MediaQueryCollapseDetection = (function (_CollapseDetection3) {
     babelHelpers.inherits(MediaQueryCollapseDetection, _CollapseDetection3);

     /**
      * @param {String} query
      */

     function MediaQueryCollapseDetection(query) {
       babelHelpers.classCallCheck(this, MediaQueryCollapseDetection);

       var _this3 = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MediaQueryCollapseDetection).call(this));

       _this3._mediaQueryString = query;
       _this3._boundOnChange = _this3._onChange.bind(_this3);
       return _this3;
     }

     babelHelpers.createClass(MediaQueryCollapseDetection, [{
       key: '_onChange',
       value: function _onChange(queryList) {
         this._element._updateMode(queryList.matches ? COLLAPSE_MODE : SPLIT_MODE);
       }
     }, {
       key: 'activate',
       value: function activate(element) {
         this._element = element;
         this._queryResult = window.matchMedia(this._mediaQueryString);
         this._queryResult.addListener(this._boundOnChange);
         this._onChange(this._queryResult);
       }
     }, {
       key: 'inactivate',
       value: function inactivate() {
         this._element = null;
         this._queryResult.removeListener(this._boundOnChange);
         this._queryResult = null;
       }
     }]);
     return MediaQueryCollapseDetection;
   })(CollapseDetection);

   var BaseMode = (function () {
     function BaseMode() {
       babelHelpers.classCallCheck(this, BaseMode);
     }

     babelHelpers.createClass(BaseMode, [{
       key: 'isOpen',
       value: function isOpen() {
         return false;
       }
     }, {
       key: 'openMenu',
       value: function openMenu() {
         return false;
       }
     }, {
       key: 'closeMenu',
       value: function closeMenu() {
         return false;
       }
     }, {
       key: 'enterMode',
       value: function enterMode() {}
     }, {
       key: 'exitMode',
       value: function exitMode() {}
     }, {
       key: 'handleGesture',
       value: function handleGesture() {}
     }]);
     return BaseMode;
   })();

   var SplitMode = (function (_BaseMode) {
     babelHelpers.inherits(SplitMode, _BaseMode);

     function SplitMode(element) {
       babelHelpers.classCallCheck(this, SplitMode);

       var _this4 = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitMode).call(this));

       _this4._element = element;
       return _this4;
     }

     babelHelpers.createClass(SplitMode, [{
       key: 'isOpen',
       value: function isOpen() {
         return false;
       }
     }, {
       key: 'openMenu',
       value: function openMenu() {
         return Promise.resolve();
       }
     }, {
       key: 'closeMenu',
       value: function closeMenu() {
         return Promise.resolve();
       }

       /**
        * @param {Element} element
        */

     }, {
       key: 'layout',
       value: function layout() {
         var element = this._element;
         element.style.width = element._getWidth();

         if (element._isLeftSide()) {
           element.style.left = '0';
           element.style.right = 'auto';
         } else {
           element.style.left = 'auto';
           element.style.right = '0';
         }
       }
     }, {
       key: 'enterMode',
       value: function enterMode() {
         this.layout();
       }
     }, {
       key: 'exitMode',
       value: function exitMode() {
         var element = this._element;

         element.style.left = '';
         element.style.right = '';
         element.style.width = '';
         element.style.zIndex = '';
       }
     }]);
     return SplitMode;
   })(BaseMode);

   var CollapseMode = (function (_BaseMode2) {
     babelHelpers.inherits(CollapseMode, _BaseMode2);
     babelHelpers.createClass(CollapseMode, [{
       key: '_animator',
       get: function get() {
         return this._element._getAnimator();
       }
     }], [{
       key: 'CLOSED_STATE',
       get: function get() {
         return 'closed';
       }
     }, {
       key: 'OPEN_STATE',
       get: function get() {
         return 'open';
       }
     }, {
       key: 'CHANGING_STATE',
       get: function get() {
         return 'changing';
       }
     }]);

     function CollapseMode(element) {
       babelHelpers.classCallCheck(this, CollapseMode);

       var _this5 = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(CollapseMode).call(this));

       _this5._state = CollapseMode.CLOSED_STATE;
       _this5._distance = 0;
       _this5._element = element;
       _this5._lock = new DoorLock();
       return _this5;
     }

     babelHelpers.createClass(CollapseMode, [{
       key: '_isLocked',
       value: function _isLocked() {
         return this._lock.isLocked();
       }
     }, {
       key: 'isOpen',
       value: function isOpen() {
         return this._state !== CollapseMode.CLOSED_STATE;
       }
     }, {
       key: 'isClosed',
       value: function isClosed() {
         return this._state === CollapseMode.CLOSED_STATE;
       }
     }, {
       key: 'handleGesture',
       value: function handleGesture(event) {
         if (this._isLocked()) {
           return;
         }

         if (this._isOpenOtherSideMenu()) {
           return;
         }

         if (event.type === 'dragstart') {
           this._onDragStart(event);
         } else if (event.type === 'dragleft' || event.type === 'dragright') {
           if (!this._ignoreDrag) {
             this._onDrag(event);
           }
         } else if (event.type === 'dragend') {
           if (!this._ignoreDrag) {
             this._onDragEnd(event);
           }
         } else {
           throw new Error('Invalid state');
         }
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(event) {
         this._ignoreDrag = ['left', 'right'].indexOf(event.gesture.direction) === -1;

         if (!this.isOpen() && this._isOpenOtherSideMenu()) {
           this._ignoreDrag = true;
         } else if (this._element._swipeTargetWidth > 0) {
           var distance = this._element._isLeftSide() ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
           if (!this.isOpen() && distance > this._element._swipeTargetWidth) {
             this._ignoreDrag = true;
           }
         }
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(event) {
         event.gesture.preventDefault();

         var deltaX = event.gesture.deltaX;
         var deltaDistance = this._element._isLeftSide() ? deltaX : -deltaX;

         var startEvent = event.gesture.startEvent;

         if (!('isOpen' in startEvent)) {
           startEvent.isOpen = this.isOpen();
           startEvent.distance = startEvent.isOpen ? this._element._getWidthInPixel() : 0;
           startEvent.width = this._element._getWidthInPixel();
         }

         var width = this._element._getWidthInPixel();

         if (deltaDistance < 0 && startEvent.distance <= 0) {
           return;
         }

         if (deltaDistance > 0 && startEvent.distance >= width) {
           return;
         }

         var distance = startEvent.isOpen ? deltaDistance + width : deltaDistance;
         var normalizedDistance = Math.max(0, Math.min(width, distance));

         startEvent.distance = normalizedDistance;

         this._state = CollapseMode.CHANGING_STATE;
         this._animator.translate(normalizedDistance);
       }
     }, {
       key: '_onDragEnd',
       value: function _onDragEnd(event) {
         var deltaX = event.gesture.deltaX;
         var deltaDistance = this._element._isLeftSide() ? deltaX : -deltaX;
         var width = event.gesture.startEvent.width;
         var distance = event.gesture.startEvent.isOpen ? deltaDistance + width : deltaDistance;
         var direction = event.gesture.interimDirection;
         var shouldOpen = this._element._isLeftSide() && direction === 'right' && distance > width * this._element._getThresholdRatioIfShouldOpen() || !this._element._isLeftSide() && direction === 'left' && distance > width * this._element._getThresholdRatioIfShouldOpen();

         if (shouldOpen) {
           this._openMenu();
         } else {
           this._closeMenu();
         }
       }
     }, {
       key: 'layout',
       value: function layout() {

         if (this._state === CollapseMode.CHANGING_STATE) {
           return;
         }

         if (this._state === CollapseMode.CLOSED_STATE) {
           if (this._animator.isActivated()) {
             this._animator.layoutOnClose();
           }
         } else if (this._state === CollapseMode.OPEN_STATE) {
           if (this._animator.isActivated()) {
             this._animator.layoutOnOpen();
           }
         } else {
           throw new Error('Invalid state');
         }
       }

       // enter collapse mode

     }, {
       key: 'enterMode',
       value: function enterMode() {
         this._animator.activate(this._element._getContentElement(), this._element, this._element._getMaskElement());

         this.layout();
       }

       // exit collapse mode

     }, {
       key: 'exitMode',
       value: function exitMode() {
         this._animator.inactivate();
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: '_isOpenOtherSideMenu',
       value: function _isOpenOtherSideMenu() {
         var _this6 = this;

         return util.arrayFrom(this._element.parentElement.children).filter(function (child) {
           return child.nodeName.toLowerCase() === 'ons-splitter-side' && _this6._element !== child;
         }).filter(function (side) {
           return side.isOpen();
         }).length > 0;
       }

       /**
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @param {Boolean} [options.withoutAnimation]
        * @return {Promise} Resolves to the splitter side element
        */

     }, {
       key: 'openMenu',
       value: function openMenu() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         if (this._state !== CollapseMode.CLOSED_STATE) {
           return Promise.resolve();
         }

         return this._openMenu(options);
       }

       /**
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @param {Boolean} [options.withoutAnimation]
        * @return {Promise} Resolves to the splitter side element
        */

     }, {
       key: '_openMenu',
       value: function _openMenu() {
         var _this7 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         if (this._isLocked()) {
           return Promise.resolve();
         }

         if (this._isOpenOtherSideMenu()) {
           return Promise.resolve();
         }

         if (this._element._emitPreOpenEvent()) {
           return Promise.resolve();
         }

         options.callback = options.callback instanceof Function ? options.callback : function () {};

         var unlock = this._lock.lock();
         var done = function done() {
           unlock();
           _this7._element._emitPostOpenEvent();
           options.callback();
         };

         if (options.withoutAnimation) {
           this._state = CollapseMode.OPEN_STATE;
           this.layout();
           done();
           return Promise.resolve(this._element);
         } else {
           this._state = CollapseMode.CHANGING_STATE;
           return new Promise(function (resolve) {
             _this7._animator.open(function () {
               _this7._state = CollapseMode.OPEN_STATE;
               _this7.layout();
               done();
               resolve(_this7._element);
             });
           });
         }
       }

       /**
        * @param {Object} [options]
        * @return {Promise} Resolves to the splitter side element
        */

     }, {
       key: 'closeMenu',
       value: function closeMenu() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         if (this._state !== CollapseMode.OPEN_STATE) {
           return Promise.resolve();
         }

         return this._closeMenu(options);
       }

       /**
        * @param {Object} [options]
        * @return {Promise} Resolves to the splitter side element
        */

     }, {
       key: '_closeMenu',
       value: function _closeMenu() {
         var _this8 = this;

         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         if (this._isLocked()) {
           return Promise.resolve();
         }

         if (this._element._emitPreCloseEvent()) {
           return Promise.resolve();
         }

         options.callback = options.callback instanceof Function ? options.callback : function () {};

         var unlock = this._lock.lock();
         var done = function done() {
           unlock();
           _this8._element._emitPostCloseEvent();
           setImmediate(options.callback);
         };

         if (options.withoutAnimation) {
           this._state = CollapseMode.CLOSED_STATE;
           this.layout();
           done();
           return Promise.resolve(this._element);
         } else {
           this._state = CollapseMode.CHANGING_STATE;
           return new Promise(function (resolve) {
             _this8._animator.close(function () {
               _this8._state = CollapseMode.CLOSED_STATE;
               _this8.layout();
               done();
               resolve(_this8._element);
             });
           });
         }
       }
     }]);
     return CollapseMode;
   })(BaseMode);

   /**
    * @element ons-splitter-side
    * @category control
    * @description
    *  [en]The "ons-splitter-side" element is used as a child element of "ons-splitter".[/en]
    *  [ja]ons-splitter-side要素は、ons-splitter要素の子要素として利用します。[/ja]
    * @codepen rOQOML
    * @seealso ons-splitter
    *  [en]ons-splitter component[/en]
    *  [ja]ons-splitterコンポーネント[/ja]
    * @seealso ons-splitter-content
    *  [en]ons-splitter-content component[/en]
    *  [ja]ons-splitter-contentコンポーネント[/ja]
    * @example
    * <ons-splitter>
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    */

   var SplitterSideElement = (function (_BaseElement) {
     babelHelpers.inherits(SplitterSideElement, _BaseElement);

     function SplitterSideElement() {
       babelHelpers.classCallCheck(this, SplitterSideElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterSideElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterSideElement, [{
       key: '_updateForAnimationOptionsAttribute',
       value: function _updateForAnimationOptionsAttribute() {
         this._animationOptions = util.parseJSONObjectSafely(this.getAttribute('animation-options'), {});
       }
     }, {
       key: '_getMaskElement',
       value: function _getMaskElement() {
         return util.findChild(this.parentElement, 'ons-splitter-mask');
       }
     }, {
       key: '_getContentElement',
       value: function _getContentElement() {
         return util.findChild(this.parentElement, 'ons-splitter-content');
       }
     }, {
       key: '_getModeStrategy',
       value: function _getModeStrategy() {
         if (this._mode === COLLAPSE_MODE) {
           return this._collapseMode;
         } else if (this._mode === SPLIT_MODE) {
           return this._splitMode;
         }
       }
     }, {
       key: 'createdCallback',
       value: function createdCallback() {
         this._mode = null;
         this._page = null;
         this._isAttached = false;

         this._collapseStrategy = new CollapseDetection();
         this._animatorFactory = new AnimatorFactory({
           animators: window.OnsSplitterElement._animatorDict,
           baseClass: SplitterAnimator,
           baseClassName: 'SplitterAnimator',
           defaultAnimation: this.getAttribute('animation')
         });

         this._collapseMode = new CollapseMode(this);
         this._splitMode = new SplitMode(this);

         this._boundHandleGesture = this._handleGesture.bind(this);

         this._cancelModeDetection = function () {};

         this._updateMode(SPLIT_MODE);

         this._updateForAnimationAttribute();
         this._updateForWidthAttribute();
         this.hasAttribute('side') ? this._updateForSideAttribute() : this.setAttribute('side', 'left');
         this._updateForCollapseAttribute();
         this._updateForSwipeableAttribute();
         this._updateForSwipeTargetWidthAttribute();
         this._updateForAnimationOptionsAttribute();
       }
     }, {
       key: '_getAnimator',
       value: function _getAnimator() {
         return this._animator;
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isSwipeable',
       value: function isSwipeable() {
         return this.hasAttribute('swipeable');
       }
     }, {
       key: '_emitPostOpenEvent',
       value: function _emitPostOpenEvent() {
         util.triggerElementEvent(this, 'postopen', { side: this });
       }
     }, {
       key: '_emitPostCloseEvent',
       value: function _emitPostCloseEvent() {
         util.triggerElementEvent(this, 'postclose', { side: this });
       }

       /**
        * @return {boolean} canceled or not
        */

     }, {
       key: '_emitPreOpenEvent',
       value: function _emitPreOpenEvent() {
         return this._emitCancelableEvent('preopen');
       }
     }, {
       key: '_emitCancelableEvent',
       value: function _emitCancelableEvent(name) {
         var isCanceled = false;

         util.triggerElementEvent(this, name, {
           side: this,
           cancel: function cancel() {
             return isCanceled = true;
           }
         });

         return isCanceled;
       }

       /**
        * @return {boolean}
        */

     }, {
       key: '_emitPreCloseEvent',
       value: function _emitPreCloseEvent() {
         return this._emitCancelableEvent('preclose');
       }
     }, {
       key: '_updateForCollapseAttribute',
       value: function _updateForCollapseAttribute() {
         if (!this.hasAttribute('collapse')) {
           this._updateMode(SPLIT_MODE);
           return;
         }

         var collapse = ('' + this.getAttribute('collapse')).trim();

         if (collapse === '' || collapse === 'true') {
           this._updateCollapseStrategy(new StaticCollapseDetection());
         } else if (collapse === 'portrait' || collapse === 'landscape') {
           this._updateCollapseStrategy(new OrientationCollapseDetection(collapse));
         } else {
           this._updateCollapseStrategy(new MediaQueryCollapseDetection(collapse));
         }
       }

       /**
        * @param {CollapseDetection} strategy
        */

     }, {
       key: '_updateCollapseStrategy',
       value: function _updateCollapseStrategy(strategy) {
         if (this._isAttached) {
           this._collapseStrategy.inactivate();
           strategy.activate(this);
         }

         this._collapseStrategy = strategy;
       }

       /**
        * @param {String} mode
        */

     }, {
       key: '_updateMode',
       value: function _updateMode(mode) {

         if (mode !== COLLAPSE_MODE && mode !== SPLIT_MODE) {
           throw new Error('invalid mode: ' + mode);
         }

         if (mode === this._mode) {
           return;
         }

         var lastMode = this._getModeStrategy();

         if (lastMode) {
           lastMode.exitMode();
         }

         this._mode = mode;
         var currentMode = this._getModeStrategy();

         currentMode.enterMode();
         this.setAttribute('mode', mode);

         util.triggerElementEvent(this, 'modechange', {
           side: this,
           mode: mode
         });
       }
     }, {
       key: '_getThresholdRatioIfShouldOpen',
       value: function _getThresholdRatioIfShouldOpen() {
         if (this.hasAttribute('threshold-ratio-should-open')) {
           var value = parseFloat(this.getAttribute('threshold-ratio-should-open'));
           return Math.max(0.0, Math.min(1.0, value));
         } else {
           // default value
           return 0.3;
         }
       }
     }, {
       key: '_layout',
       value: function _layout() {
         this._getModeStrategy().layout();
       }
     }, {
       key: '_updateForSwipeTargetWidthAttribute',
       value: function _updateForSwipeTargetWidthAttribute() {
         if (this.hasAttribute('swipe-target-width')) {
           this._swipeTargetWidth = Math.max(0, parseInt(this.getAttribute('swipe-target-width'), 10));
         } else {
           this._swipeTargetWidth = -1;
         }
       }

       /**
        * @return {String} \d+(px|%)
        */

     }, {
       key: '_getWidth',
       value: function _getWidth() {
         return this.hasAttribute('width') ? normalize(this.getAttribute('width')) : '80%';

         function normalize(width) {
           width = width.trim();

           if (width.match(/^\d+(px|%)$/)) {
             return width;
           }

           return '80%';
         }
       }
     }, {
       key: '_getWidthInPixel',
       value: function _getWidthInPixel() {
         var width = this._getWidth();

         var _width$match = width.match(/^(\d+)(px|%)$/);

         var _width$match2 = babelHelpers.slicedToArray(_width$match, 3);

         var num = _width$match2[1];
         var unit = _width$match2[2];

         if (unit === 'px') {
           return parseInt(num, 10);
         }

         if (unit === '%') {
           var percent = parseInt(num, 10);

           return Math.round(this.parentElement.offsetWidth * percent / 100);
         }

         throw new Error('Invalid state');
       }

       /**
        * @return {String} 'left' or 'right'.
        */

     }, {
       key: '_getSide',
       value: function _getSide() {
         return normalize(this.getAttribute('side'));

         function normalize(side) {
           side = ('' + side).trim();
           return side === 'left' || side === 'right' ? side : 'left';
         }
       }
     }, {
       key: '_isLeftSide',
       value: function _isLeftSide() {
         return this._getSide() === 'left';
       }
     }, {
       key: '_updateForWidthAttribute',
       value: function _updateForWidthAttribute() {
         this._getModeStrategy().layout();
       }
     }, {
       key: '_updateForSideAttribute',
       value: function _updateForSideAttribute() {
         this._getModeStrategy().layout();
       }

       /**
        * @method getCurrentMode
        * @signature getCurrentMode()
        * @return {String}
        *   [en]Get current mode. Possible values are "collapse" or "split".[/en]
        *   [ja]このons-splitter-side要素の現在のモードを返します。"split"かもしくは"collapse"のどちらかです。[/ja]
        */

     }, {
       key: 'getCurrentMode',
       value: function getCurrentMode() {
         return this._mode;
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isOpen',
       value: function isOpen() {
         return this._getModeStrategy().isOpen();
       }

       /**
        * @method open
        * @signature open([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been opened.[/en]
        *   [ja]メニューが開いた後に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Open menu in collapse mode.[/en]
        *   [ja]collapseモードになっているons-splitterside要素を開きます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'open',
       value: function open() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._getModeStrategy().openMenu(options);
       }

       /**
        * @method close
        * @signature close([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been closed.[/en]
        *   [ja]メニューが閉じた後に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Close menu in collapse mode.[/en]
        *   [ja]collapseモードになっているons-splitter-side要素を閉じます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'close',
       value: function close() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._getModeStrategy().closeMenu(options);
       }

       /**
        * @method load
        * @signature load(page, [options])
        * @param {String} page
        *   [en]Page URL. Can be either an HTML document or an <ons-template>.[/en]
        *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]
        * @param {Object} [options]
        * @param {Function} [options.callback]
        * @description
        *   [en]Show the page specified in pageUrl in the right section[/en]
        *   [ja]指定したURLをメインページを読み込みます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'load',
       value: function load(page) {
         var _this10 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         this._page = page;

         options.callback = options.callback instanceof Function ? options.callback : function () {};
         return internal.getPageHTMLAsync(page).then(function (html) {
           return new Promise(function (resolve) {
             rewritables$2.link(_this10, util.createFragment(html), options, function (fragment) {
               util.propagateAction(_this10, '_hide');
               _this10.innerHTML = '';

               _this10.appendChild(fragment);

               util.propagateAction(_this10, '_show');

               options.callback();
               resolve(_this10.firstChild);
             });
           });
         });
       }

       /**
        * @param {Object} [options]
        */

     }, {
       key: 'toggle',
       value: function toggle() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this.isOpen() ? this.close(options) : this.open(options);
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'width') {
           this._updateForWidthAttribute();
         } else if (name === 'side') {
           this._updateForSideAttribute();
         } else if (name === 'collapse') {
           this._updateForCollapseAttribute();
         } else if (name === 'swipeable') {
           this._updateForSwipeableAttribute();
         } else if (name === 'swipe-target-width') {
           this._updateForSwipeTargetWidthAttribute();
         } else if (name === 'animation-options') {
           this._updateForAnimationOptionsAttribute();
         } else if (name === 'animation') {
           this._updateForAnimationAttribute();
         }
       }
     }, {
       key: '_updateForAnimationAttribute',
       value: function _updateForAnimationAttribute() {
         var isActivated = this._animator && this._animator.isActivated();

         if (isActivated) {
           this._animator.inactivate();
         }

         this._animator = this._createAnimator();

         if (isActivated) {
           this._animator.activate(this._getContentElement(), this, this._getMaskElement());
         }
       }
     }, {
       key: '_updateForSwipeableAttribute',
       value: function _updateForSwipeableAttribute() {
         if (this._gestureDetector) {
           if (this.isSwipeable()) {
             this._gestureDetector.on('dragstart dragleft dragright dragend', this._boundHandleGesture);
           } else {
             this._gestureDetector.off('dragstart dragleft dragright dragend', this._boundHandleGesture);
           }
         }
       }
     }, {
       key: '_assertParent',
       value: function _assertParent() {
         var parentElementName = this.parentElement.nodeName.toLowerCase();
         if (parentElementName !== 'ons-splitter') {
           throw new Error('"' + parentElementName + '" element is not allowed as parent element.');
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this11 = this;

         this._isAttached = true;
         this._collapseStrategy.activate(this);
         this._assertParent();

         this._gestureDetector = new GestureDetector(this.parentElement, { dragMinDistance: 1 });
         this._updateForSwipeableAttribute();

         if (this.hasAttribute('page')) {
           setImmediate(function () {
             return rewritables$2.ready(_this11, function () {
               return _this11.load(_this11.getAttribute('page'));
             });
           });
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._isAttached = false;
         this._collapseStrategy.inactivate();

         this._gestureDetector.dispose();
         this._gestureDetector = null;

         this._updateForSwipeableAttribute();
       }
     }, {
       key: '_handleGesture',
       value: function _handleGesture(event) {
         return this._getModeStrategy().handleGesture(event);
       }
     }, {
       key: '_show',
       value: function _show() {
         util.propagateAction(this, '_show');
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.propagateAction(this, '_hide');
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.propagateAction(this, '_destroy');
         this.remove();
       }
     }, {
       key: '_createAnimator',
       value: function _createAnimator() {
         return this._animatorFactory.newAnimator({
           animation: this.getAttribute('animation'),
           animationOptions: AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'))
         });
       }
     }, {
       key: 'page',

       /**
        * @event modechange
        * @description
        *   [en]Fired just after the component's mode changes.[/en]
        *   [ja]この要素のモードが変化した際に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクトです。[/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        * @param {String} event.mode
        *   [en]Returns the current mode. Can be either "collapse" or "split".[/en]
        *   [ja]現在のモードを返します。[/ja]
        */

       /**
        * @event preopen
        * @description
        *   [en]Fired just before the sliding menu is opened.[/en]
        *   [ja]スライディングメニューが開く前に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクトです。[/ja]
        * @param {Function} event.cancel
        *   [en]Call to cancel opening sliding menu.[/en]
        *   [ja]スライディングメニューが開くのをキャンセルします。[/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        */

       /**
        * @event postopen
        * @description
        *   [en]Fired just after the sliding menu is opened.[/en]
        *   [ja]スライディングメニューが開いた後に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクトです。[/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        */

       /**
        * @event preclose
        * @description
        *   [en]Fired just before the sliding menu is closed.[/en]
        *   [ja]スライディングメニューが閉じる前に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクトです。[/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        * @param {Function} event.cancel
        *   [en]Call to cancel opening sliding-menu.[/en]
        *   [ja]スライディングメニューが閉じるのをキャンセルします。[/ja]
        */

       /**
        * @event postclose
        * @description
        *   [en]Fired just after the sliding menu is closed.[/en]
        *   [ja]スライディングメニューが閉じた後に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクトです。[/ja]
        * @param {Object} event.side
        *   [en]Component object.[/en]
        *   [ja]コンポーネントのオブジェクト。[/ja]
        */

       /**
        * @attribute animation
        * @initonly
        * @type {String}
        * @description
        *  [en]Specify the animation. Use one of "overlay", and "default".[/en]
        *  [ja]アニメーションを指定します。"overlay", "default"のいずれかを指定できます。[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/en]
        *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
        */

       /**
        * @attribute threshold-ratio-should-open
        * @type {Number}
        * @description
        *  [en]Specify how much the menu needs to be swiped before opening. A value between 0 and 1. Default is 0.3.[/en]
        *  [ja]どのくらいスワイプすればスライディングメニューを開くかどうかの割合を指定します。0から1の間の数値を指定します。スワイプの距離がここで指定した数値掛けるこの要素の幅よりも大きければ、スワイプが終わった時にこの要素を開きます。デフォルトは0.3です。[/ja]
        */

       /**
        * @attribute collapse
        * @type {String}
        * @description
        *   [en]
        *     Specify the collapse behavior. Valid values are "portrait", "landscape" or a media query.
        *     "portrait" or "landscape" means the view will collapse when device is in landscape or portrait orientation.
        *     If the value is a media query, the view will collapse when the media query is true.
        *     If the value is not defined, the view always be in "collapse" mode.
        *   [/en]
        *   [ja]
        *     左側のページを非表示にする条件を指定します。portrait, landscape、width #pxもしくはメディアクエリの指定が可能です。
        *     portraitもしくはlandscapeを指定すると、デバイスの画面が縦向きもしくは横向きになった時に適用されます。
        *     メディアクエリを指定すると、指定したクエリに適合している場合に適用されます。
        *     値に何も指定しない場合には、常にcollapseモードになります。
        *   [/ja]
        */

       /**
        * @attribute swipe-target-width
        * @type {String}
        * @description
        *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
        *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
        */

       /**
        * @attribute width
        * @type {String}
        * @description
        *   [en]Can be specified in either pixels or as a percentage, e.g. "90%" or "200px".[/en]
        *   [ja]この要素の横幅を指定します。pxと%での指定が可能です。eg. 90%, 200px[/ja]
        */

       /**
        * @attribute side
        * @type {String}
        * @description
        *   [en]Specify which side of the screen the ons-splitter-side element is located on. Possible values are "left" (default) and "right".[/en]
        *   [ja]この要素が左か右かを指定します。指定できる値は"left"か"right"のみです。[/ja]
        */

       /**
        * @attribute mode
        * @type {String}
        * @description
        *   [en]Current mode. Possible values are "collapse" or "split". This attribute is read only.[/en]
        *   [ja]現在のモードが設定されます。"collapse"もしくは"split"が指定されます。この属性は読み込み専用です。[/ja]
        */

       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]The url of the menu page.[/en]
        *   [ja]ons-splitter-side要素に表示するページのURLを指定します。[/ja]
        */

       /**
        * @attribute swipeable
        * @type {Boolean}
        * @description
        *   [en]Whether to enable swipe interaction on collapse mode.[/en]
        *   [ja]collapseモード時にスワイプ操作を有効にする場合に指定します。[/ja]
        */

       get: function get() {
         return this._page;
       }
     }, {
       key: 'mode',
       get: function get() {
         this._mode;
       }
     }]);
     return SplitterSideElement;
   })(BaseElement);

   window.OnsSplitterSideElement = document.registerElement('ons-splitter-side', {
     prototype: SplitterSideElement.prototype
   });

   window.OnsSplitterSideElement.rewritables = rewritables$2;

   var OverlaySplitterAnimator = (function (_SplitterAnimator) {
     babelHelpers.inherits(OverlaySplitterAnimator, _SplitterAnimator);

     function OverlaySplitterAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, OverlaySplitterAnimator);

       options = util.extend({
         timing: 'cubic-bezier(.1, .7, .1, 1)',
         duration: '0.3',
         delay: '0'
       }, options || {});

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(OverlaySplitterAnimator).call(this, options));
     }

     babelHelpers.createClass(OverlaySplitterAnimator, [{
       key: 'isActivated',
       value: function isActivated() {
         return this._isActivated;
       }
     }, {
       key: 'layoutOnClose',
       value: function layoutOnClose() {
         animit(this._side).queue({
           transform: 'translateX(0%)',
           width: this._side._getWidth()
         }).play();

         this._mask.style.display = 'none';
       }
     }, {
       key: 'layoutOnOpen',
       value: function layoutOnOpen() {
         animit(this._side).queue({
           transform: 'translate3d(' + (this._side._isLeftSide() ? '' : '-') + '100%, 0px, 0px)',
           width: this._side._getWidth()
         }).play();

         this._mask.style.display = 'block';
       }

       /**
        * @param {Element} contentElement
        * @param {Element} sideElement
        * @param {Element} maskElement
        */

     }, {
       key: 'activate',
       value: function activate(contentElement, sideElement, maskElement) {
         this._isActivated = true;
         this._content = contentElement;
         this._side = sideElement;
         this._mask = maskElement;

         this._setupLayout();
       }
     }, {
       key: 'inactivate',
       value: function inactivate() {
         this._isActivated = false;
         this._clearLayout();
         this._content = this._side = this._mask = null;
       }

       /**
        * @param {Number} distance
        */

     }, {
       key: 'translate',
       value: function translate(distance) {
         animit(this._side).queue({
           transform: 'translate3d(' + (this._side._isLeftSide() ? '' : '-') + distance + 'px, 0px, 0px)'
         }).play();
       }
     }, {
       key: '_clearLayout',
       value: function _clearLayout() {
         var side = this._side;
         var mask = this._mask;

         side.style.zIndex = '';
         side.style.right = '';
         side.style.left = '';
         side.style.transform = side.style.webkitTransform = '';
         side.style.transition = side.style.webkitTransition = '';
         side.style.width = '';
         side.style.display = '';

         mask.style.display = 'none';
       }
     }, {
       key: '_setupLayout',
       value: function _setupLayout() {
         var side = this._side;

         side.style.zIndex = 3;
         side.style.display = 'block';

         if (side._isLeftSide()) {
           side.style.left = 'auto';
           side.style.right = '100%';
         } else {
           side.style.left = '100%';
           side.style.right = 'auto';
         }
       }

       /**
        * @param {Function} done
        */

     }, {
       key: 'open',
       value: function open(done) {
         var transform = this._side._isLeftSide() ? 'translate3d(100%, 0px, 0px)' : 'translate3d(-100%, 0px, 0px)';

         animit.runAll(animit(this._side).wait(this._delay).queue({
           transform: transform
         }, {
           duration: this._duration,
           timing: this._timing
         }).queue(function (callback) {
           callback();
           done();
         }), animit(this._mask).wait(this._delay).queue({
           display: 'block'
         }).queue({
           opacity: '1'
         }, {
           duration: this._duration,
           timing: 'linear'
         }));
       }

       /**
        * @param {Function} done
        */

     }, {
       key: 'close',
       value: function close(done) {
         var _this2 = this;

         animit.runAll(animit(this._side).wait(this._delay).queue({
           transform: 'translate3d(0px, 0px, 0px)'
         }, {
           duration: this._duration,
           timing: this._timing
         }).queue(function (callback) {
           _this2._side.style.webkitTransition = '';
           done();
           callback();
         }), animit(this._mask).wait(this._delay).queue({
           opacity: '0'
         }, {
           duration: this._duration,
           timing: 'linear'
         }).queue({
           display: 'none'
         }));
       }
     }]);
     return OverlaySplitterAnimator;
   })(SplitterAnimator);

   /**
    * @element ons-splitter
    * @category control
    * @description
    *  [en]A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.[/en]
    *  [ja]sliding-menuとsplit-view両方の機能を持つレイアウトです。[/ja]
    * @codepen rOQOML
    * @seealso ons-splitter-content
    *  [en]ons-splitter-content component[/en]
    *  [ja]ons-splitter-contentコンポーネント[/ja]
    * @seealso ons-splitter-side
    *  [en]ons-splitter-side component[/en]
    *  [ja]ons-splitter-sideコンポーネント[/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using components from JavaScript[/en]
    *   [ja]JavaScriptからコンポーネントを呼び出す[/ja]
    * @example
    * <ons-splitter>
    *   <ons-splitter-content>
    *     ...
    *   </ons-splitter-content>
    *
    *   <ons-splitter-side side="left" width="80%" collapse>
    *     ...
    *   </ons-splitter-side>
    * </ons-splitter>
    */

   var SplitterElement = (function (_BaseElement) {
     babelHelpers.inherits(SplitterElement, _BaseElement);

     function SplitterElement() {
       babelHelpers.classCallCheck(this, SplitterElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SplitterElement).apply(this, arguments));
     }

     babelHelpers.createClass(SplitterElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         this._boundOnDeviceBackButton = this._onDeviceBackButton.bind(this);
         this._boundOnModeChange = this._onModeChange.bind(this);
       }
     }, {
       key: '_onModeChange',
       value: function _onModeChange(event) {
         if (event.target.parentElement === this) {
           this._layout();
         }
       }

       /**
        * @param {String} side 'left' or 'right'.
        * @return {Element}
        */

     }, {
       key: '_getSideElement',
       value: function _getSideElement(side) {
         var result = util.findChild(this, function (element) {
           return element.nodeName.toLowerCase() === 'ons-splitter-side' && element.getAttribute('side') === side;
         });

         if (result) {
           CustomElements.upgrade(result);
         }

         return result;
       }
     }, {
       key: '_layout',
       value: function _layout() {
         var content = this._getContentElement();
         var left = this._getSideElement('left');
         var right = this._getSideElement('right');

         if (content) {
           if (left && left.getCurrentMode && left.getCurrentMode() === 'split') {
             content.style.left = left._getWidth();
           } else {
             content.style.left = '0px';
           }

           if (right && right.getCurrentMode && right.getCurrentMode() === 'split') {
             content.style.right = right._getWidth();
           } else {
             content.style.right = '0px';
           }
         }
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_getContentElement',
       value: function _getContentElement() {
         return util.findChild(this, 'ons-splitter-content');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {}

       /**
        * @method openRight
        * @signature openRight([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been opened.[/en]
        *   [ja]メニューが開いた後に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Open right ons-splitter-side menu on collapse mode.[/en]
        *   [ja]右のcollapseモードになっているons-splitter-side要素を開きます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'openRight',
       value: function openRight() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._open('right', options);
       }
     }, {
       key: '_getMaskElement',
       value: function _getMaskElement() {
         var mask = util.findChild(this, 'ons-splitter-mask');
         return mask || this.appendChild(document.createElement('ons-splitter-mask'));
       }

       /**
        * @method openLeft
        * @signature openLeft([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been opened.[/en]
        *   [ja]メニューが開いた後に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Open left ons-splitter-side menu on collapse mode.[/en]
        *   [ja]左のcollapseモードになっているons-splitter-side要素を開きます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'openLeft',
       value: function openLeft() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._open('left', options);
       }

       /**
        * @param {String} side
        * @param {Object} [options]
        * @return {Promise} Resolves to the splitter side element
        */

     }, {
       key: '_open',
       value: function _open(side) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var menu = this._getSideElement(side);

         return menu ? menu.open(options) : Promise.reject('child "ons-splitter-side" element is not found in this element.');
       }

       /**
        * @method closeRight
        * @signature closeRight([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been closed.[/en]
        *   [ja]メニューが閉じた後に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Close right ons-splitter-side menu on collapse mode.[/en]
        *   [ja]右のcollapseモードになっているons-splitter-side要素を閉じます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'closeRight',
       value: function closeRight() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._close('right', options);
       }

       /**
        * @method closeLeft
        * @signature closeLeft([options])
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {Function} [options.callback]
        *   [en]This function will be called after the menu has been closed.[/en]
        *   [ja]メニューが閉じた後に呼び出される関数オブジェクトを指定します。[/ja]
        * @description
        *   [en]Close left ons-splitter-side menu on collapse mode.[/en]
        *   [ja]左のcollapseモードになっているons-splitter-side要素を閉じます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the splitter side element[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'closeLeft',
       value: function closeLeft() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._close('left', options);
       }

       /**
        * @param {String} side
        * @param {Object} [options]
        * @return {Promise} Resolves to the splitter side element
        */

     }, {
       key: '_close',
       value: function _close(side) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var menu = this._getSideElement(side);

         return menu ? menu.close(options) : Promise.reject('child "ons-splitter-side" element is not found in this element.');
       }

       /**
        * @param {Object} [options]
        * @return {Promise} Resolves to the splitter side element
        */

     }, {
       key: 'toggleLeft',
       value: function toggleLeft() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._toggle('left', options);
       }

       /**
        * @param {Object} [options]
        * @return {Promise} Resolves to the splitter side element
        */

     }, {
       key: 'toggleRight',
       value: function toggleRight() {
         var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

         return this._toggle('right', options);
       }

       /**
        * @param {String} side
        * @param {Object} [options]
        * @return {Promise} Resolves to the splitter side element
        */

     }, {
       key: '_toggle',
       value: function _toggle(side) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var menu = this._getSideElement(side);

         return menu ? menu.toggle(options) : Promise.reject('child "ons-splitter-side" element is not found in this element.');
       }

       /**
        * @method leftIsOpen
        * @signature leftIsOpen()
        * @return {Boolean}
        *   [en]Whether the left ons-splitter-side on collapse mode is opened.[/en]
        *   [ja]左のons-splitter-sideが開いているかどうかを返します。[/ja]
        * @description
        *   [en]Determines whether the left ons-splitter-side on collapse mode is opened.[/en]
        *   [ja]左のons-splitter-side要素が開いているかどうかを返します。[/ja]
        */

     }, {
       key: 'leftIsOpen',
       value: function leftIsOpen() {
         return this._isOpen('left');
       }

       /**
        * @method rightIsOpen
        * @signature rightIsOpen()
        * @return {Boolean}
        *   [en]Whether the right ons-splitter-side on collapse mode is opened.[/en]
        *   [ja]右のons-splitter-sideが開いているかどうかを返します。[/ja]
        * @description
        *   [en]Determines whether the right ons-splitter-side on collapse mode is opened.[/en]
        *   [ja]右のons-splitter-side要素が開いているかどうかを返します。[/ja]
        */

     }, {
       key: 'rightIsOpen',
       value: function rightIsOpen() {
         return this._isOpen('right');
       }

       /**
        * @param {String} side
        * @return {Boolean}
        */

     }, {
       key: '_isOpen',
       value: function _isOpen(side) {
         var menu = this._getSideElement(side);

         if (menu) {
           return menu.isOpen();
         }

         return false;
       }

       /**
        * @method loadContentPage
        * @signature loadContentPage(pageUrl)
        * @param {String} pageUrl
        *   [en]Page URL. Can be either an HTML document or an <code>&lt;ons-template&gt;</code>.[/en]
        *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]
        * @description
        *   [en]Show the page specified in pageUrl in the ons-splitter-content pane.[/en]
        *   [ja]ons-splitter-content要素に表示されるページをpageUrlに指定します。[/ja]
        */

     }, {
       key: 'loadContentPage',
       value: function loadContentPage(page) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         var content = this._getContentElement();

         return content ? content.load(page, options) : Promise.reject('child "ons-splitter-content" element is not found in this element.');
       }
     }, {
       key: '_onDeviceBackButton',
       value: function _onDeviceBackButton(handler) {
         var left = this._getSideElement('left');
         var right = this._getSideElement('right');

         if (left && left.isOpen()) {
           left.close();
           return;
         }

         if (right && right.isOpen()) {
           right.close();
           return;
         }

         handler.callParentHandler();
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this2 = this;

         this._deviceBackButtonHandler = deviceBackButtonDispatcher.createHandler(this, this._boundOnDeviceBackButton);
         this._assertChildren();

         this.addEventListener('modechange', this._boundOnModeChange, false);

         setImmediate(function () {
           return _this2._layout();
         });
       }

       /**
        * @method getDeviceBackButtonHandler
        * @signature getDeviceBackButtonHandler()
        * @return {Object}
        *   [en]Device back-button handler.[/en]
        *   [ja]デバイスのバックボタンハンドラを返します。[/ja]
        * @description
        *   [en]Retrieve the back-button handler.[/en]
        *   [ja]ons-splitter要素に紐付いているバックボタンハンドラを取得します。[/ja]
        */

     }, {
       key: 'getDeviceBackButtonHandler',
       value: function getDeviceBackButtonHandler() {
         return this._deviceBackButtonHandler;
       }
     }, {
       key: '_assertChildren',
       value: function _assertChildren() {
         var names = ['ons-splitter-content', 'ons-splitter-side', 'ons-splitter-mask'];
         var contentCount = 0;
         var sideCount = 0;
         var maskCount = 0;

         util.arrayFrom(this.children).forEach(function (element) {
           var name = element.nodeName.toLowerCase();
           if (names.indexOf(name) === -1) {
             throw new Error('"' + name + '" element is not allowed in "ons-splitter" element.');
           }

           if (name === 'ons-splitter-content') {
             contentCount++;
           } else if (name === 'ons-splitter-content') {
             sideCount++;
           } else if (name === 'ons-splitter-mask') {
             maskCount++;
           }
         });

         if (contentCount > 1) {
           throw new Error('too many <ons-splitter-content> elements.');
         }

         if (sideCount > 2) {
           throw new Error('too many <ons-splitter-side> elements.');
         }

         if (maskCount > 1) {
           throw new Error('too many <ons-splitter-mask> elements.');
         }

         if (maskCount === 0) {
           this.appendChild(document.createElement('ons-splitter-mask'));
         }
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._deviceBackButtonHandler.destroy();
         this._deviceBackButtonHandler = null;

         this.removeEventListener('modechange', this._boundOnModeChange, false);
       }
     }, {
       key: '_show',
       value: function _show() {
         util.arrayFrom(this.children).forEach(function (child) {
           if (child._show instanceof Function) {
             child._show();
           }
         });
       }
     }, {
       key: '_hide',
       value: function _hide() {
         util.arrayFrom(this.children).forEach(function (child) {
           if (child._hide instanceof Function) {
             child._hide();
           }
         });
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         util.arrayFrom(this.children).forEach(function (child) {
           if (child._destroy instanceof Function) {
             child._destroy();
           }
         });
         this.remove();
       }
     }]);
     return SplitterElement;
   })(BaseElement);

   window.OnsSplitterElement = document.registerElement('ons-splitter', {
     prototype: SplitterElement.prototype
   });

   window.OnsSplitterElement._animatorDict = {
     default: OverlaySplitterAnimator,
     overlay: OverlaySplitterAnimator
   };

   window.OnsSplitterElement.registerAnimator = function (name, Animator) {
     if (!(Animator instanceof SplitterAnimator)) {
       throw new Error('Animator parameter must be an instance of SplitterAnimator.');
     }
     window.OnsSplitterElement._animatorDict[name] = Animator;
   };

   window.OnsSplitterElement.SplitterAnimator = SplitterAnimator;

   var scheme$19 = {
     '': 'switch--*',
     '.switch__input': 'switch--*__input',
     '.switch__handle': 'switch--*__handle',
     '.switch__toggle': 'switch--*__toggle'
   };

   var template$2 = util.createFragment('\n  <input type="checkbox" class="switch__input">\n  <div class="switch__toggle">\n    <div class="switch__handle">\n      <div class="switch__touch"></div>\n    </div>\n  </div>\n');

   var locations = {
     ios: [1, 21],
     material: [0, 16]
   };

   /**
    * @element ons-switch
    * @category form
    * @description
    *  [en]Switch component. Can display either an iOS flat switch or a Material Design switch.[/en]
    *  [ja]スイッチを表示するコンポーネントです。[/ja]
    * @codepen LpXZQQ
    * @guide UsingFormComponents
    *   [en]Using form components[/en]
    *   [ja]フォームを使う[/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja]イベント処理の使い方[/ja]
    * @seealso ons-button
    *   [en]ons-button component[/en]
    *   [ja]ons-buttonコンポーネント[/ja]
    * @example
    * <ons-switch checked></ons-switch>
    * <ons-switch modifier="material"></ons-switch>
    */

   var SwitchElement = (function (_BaseElement) {
     babelHelpers.inherits(SwitchElement, _BaseElement);

     function SwitchElement() {
       babelHelpers.classCallCheck(this, SwitchElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(SwitchElement).apply(this, arguments));
     }

     babelHelpers.createClass(SwitchElement, [{
       key: 'isChecked',

       /**
        * @method isChecked
        * @signature isChecked()
        * @return {Boolean}
        *   [en]true if the switch is on.[/en]
        *   [ja]ONになっている場合にはtrueになります。[/ja]
        * @description
        *   [en]Returns true if the switch is ON.[/en]
        *   [ja]スイッチがONの場合にtrueを返します。[/ja]
        */
       value: function isChecked() {
         return this.checked;
       }

       /**
        * @method setChecked
        * @signature setChecked(checked)
        * @param {Boolean} checked
        *   [en]If true the switch will be set to on.[/en]
        *   [ja]ONにしたい場合にはtrueを指定します。[/ja]
        * @description
        *   [en]Set the value of the switch. isChecked can be either true or false.[/en]
        *   [ja]スイッチの値を指定します。isCheckedにはtrueもしくはfalseを指定します。[/ja]
        */

     }, {
       key: 'setChecked',
       value: function setChecked(isChecked) {
         this.checked = !!isChecked;
       }

       /**
        * @method getCheckboxElement
        * @signature getCheckboxElement()
        * @return {HTMLElement}
        *   [en]The underlying checkbox element.[/en]
        *   [ja]コンポーネント内部のcheckbox要素になります。[/ja]
        * @description
        *   [en]Get inner input[type=checkbox] element.[/en]
        *   [ja]スイッチが内包する、input[type=checkbox]の要素を取得します。[/ja]
        */

     }, {
       key: 'getCheckboxElement',
       value: function getCheckboxElement() {
         return this._checkbox;
       }
     }, {
       key: 'createdCallback',
       value: function createdCallback() {
         var _this2 = this;

         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._checkbox = this.querySelector('.switch__input');
         this._handle = this.querySelector('.switch__handle');

         ['checked', 'disabled', 'modifier', 'name', 'input-id'].forEach(function (e) {
           _this2.attributeChangedCallback(e, null, _this2.getAttribute(e));
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('switch');

         this.appendChild(template$2.cloneNode(true));

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this._checkbox.removeEventListener('change', this._onChange);
         this.removeEventListener('dragstart', this._onDragStart);
         this.removeEventListener('hold', this._onHold);
         this.removeEventListener('tap', this.click);
         this.removeEventListener('click', this._onClick);
         this._gestureDetector.dispose();
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this._checkbox.addEventListener('change', this._onChange);
         this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1, holdTimeout: 251 });
         this.addEventListener('dragstart', this._onDragStart);
         this.addEventListener('hold', this._onHold);
         this.addEventListener('tap', this.click);
         this._boundOnRelease = this._onRelease.bind(this);
         this.addEventListener('click', this._onClick);
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         if (this.checked) {
           this.parentNode.setAttribute('checked', '');
         } else {
           this.parentNode.removeAttribute('checked');
         }
       }
     }, {
       key: '_onClick',
       value: function _onClick(ev) {
         if (ev.target.classList.contains('switch__touch')) {
           ev.preventDefault();
         }
       }
     }, {
       key: 'click',
       value: function click() {
         if (!this.disabled) {
           this.checked = !this.checked;
           util.triggerElementEvent(this.getCheckboxElement(), 'change');
         }
       }
     }, {
       key: '_getPosition',
       value: function _getPosition(e) {
         var l = this._locations;
         return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
       }
     }, {
       key: '_onHold',
       value: function _onHold(e) {
         if (!this.disabled) {
           this.classList.add('switch--active');
           document.addEventListener('release', this._boundOnRelease);
         }
       }
     }, {
       key: '_onDragStart',
       value: function _onDragStart(e) {
         if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
           this.classList.remove('switch--active');
           return;
         }
         this.classList.add('switch--active');
         this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;

         this.addEventListener('drag', this._onDrag);
         document.addEventListener('release', this._boundOnRelease);
       }
     }, {
       key: '_onDrag',
       value: function _onDrag(e) {
         e.gesture.srcEvent.preventDefault();
         this._handle.style.left = this._getPosition(e) + 'px';
       }
     }, {
       key: '_onRelease',
       value: function _onRelease(e) {
         var l = this._locations;
         var position = this._getPosition(e);

         this.checked = position >= (l[0] + l[1]) / 2;

         this.removeEventListener('drag', this._onDrag);
         document.removeEventListener('release', this._boundOnRelease);

         this._handle.style.left = '';
         this.classList.remove('switch--active');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             this._isMaterial = (current || '').indexOf('material') !== -1;
             this._locations = locations[this._isMaterial ? 'material' : 'ios'];
             ModifierUtil.onModifierChanged(last, current, this, scheme$19);
             break;
           case 'input-id':
             this._checkbox.id = current;
             break;
           case 'checked':
             // eslint-disable-line no-fallthrough
             this._checkbox.checked = current !== null;
           case 'disabled':
             if (current !== null) {
               this._checkbox.setAttribute(name, '');
             } else {
               this._checkbox.removeAttribute(name);
             }
         }
       }
     }, {
       key: 'checked',

       /**
        * @event change
        * @description
        *   [en]Fired when the value is changed.[/en]
        *   [ja]ON/OFFが変わった時に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクト。[/ja]
        * @param {Object} event.switch
        *   [en]Switch object.[/en]
        *   [ja]イベントが発火したSwitchオブジェクトを返します。[/ja]
        * @param {Boolean} event.value
        *   [en]Current value.[/en]
        *   [ja]現在の値を返します。[/ja]
        * @param {Boolean} event.isInteractive
        *   [en]True if the change was triggered by the user clicking on the switch.[/en]
        *   [ja]タップやクリックなどのユーザの操作によって変わった場合にはtrueを返します。[/ja]
        */

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *  [en]The appearance of the switch.[/en]
        *  [ja]スイッチの表現を指定します。[/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Whether the switch should be disabled.[/en]
        *   [ja]スイッチを無効の状態にする場合に指定します。[/ja]
        */

       /**
        * @attribute checked
        * @description
        *   [en]Whether the switch is checked.[/en]
        *   [ja]スイッチがONの状態にするときに指定します。[/ja]
        */

       get: function get() {
         return this._checkbox.checked;
       },
       set: function set(value) {
         if (!!value !== this._checkbox.checked) {
           this._checkbox.click();
           this._checkbox.checked = !!value;
           if (this.checked) {
             this.setAttribute('checked', '');
           } else {
             this.removeAttribute('checked');
           }
         }
       }
     }, {
       key: 'disabled',
       get: function get() {
         return this._checkbox.disabled;
       },
       set: function set(value) {
         this._checkbox.disabled = value;
         if (this.disabled) {
           this.setAttribute('disabled', '');
         } else {
           this.removeAttribute('disabled');
         }
       }
     }]);
     return SwitchElement;
   })(BaseElement);

   window.OnsSwitchElement = document.registerElement('ons-switch', {
     prototype: SwitchElement.prototype
   });

   /*
   Copyright 2013-2015 ASIAL CORPORATION

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   */

   var TabbarAnimator = (function () {

     /**
      * @param {Object} options
      * @param {String} options.timing
      * @param {Number} options.duration
      * @param {Number} options.delay
      */

     function TabbarAnimator() {
       var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
       babelHelpers.classCallCheck(this, TabbarAnimator);

       this.timing = options.timing || 'linear';
       this.duration = options.duration !== undefined ? options.duration : '0.4';
       this.delay = options.delay !== undefined ? options.delay : '0';
     }

     /**
      * @param {Element} enterPage ons-page element
      * @param {Element} leavePage ons-page element
      * @param {Number} enterPageIndex
      * @param {Number} leavePageIndex
      * @param {Function} done
      */

     babelHelpers.createClass(TabbarAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
         throw new Error('This method must be implemented.');
       }
     }]);
     return TabbarAnimator;
   })();

   var TabbarNoneAnimator = (function (_TabbarAnimator) {
     babelHelpers.inherits(TabbarNoneAnimator, _TabbarAnimator);

     function TabbarNoneAnimator() {
       babelHelpers.classCallCheck(this, TabbarNoneAnimator);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarNoneAnimator).apply(this, arguments));
     }

     babelHelpers.createClass(TabbarNoneAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
         setTimeout(done, 1000 / 60);
       }
     }]);
     return TabbarNoneAnimator;
   })(TabbarAnimator);

   var TabbarFadeAnimator = (function (_TabbarAnimator2) {
     babelHelpers.inherits(TabbarFadeAnimator, _TabbarAnimator2);

     function TabbarFadeAnimator(options) {
       babelHelpers.classCallCheck(this, TabbarFadeAnimator);

       options.timing = options.timing !== undefined ? options.timing : 'linear';
       options.duration = options.duration !== undefined ? options.duration : '0.4';
       options.delay = options.delay !== undefined ? options.delay : '0';

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarFadeAnimator).call(this, options));
     }

     babelHelpers.createClass(TabbarFadeAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterPageIndex, leavePageIndex, done) {
         animit.runAll(animit(enterPage).saveStyle().queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 0
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 1
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (callback) {
           done();
           callback();
         }), animit(leavePage).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 1
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)',
           opacity: 0
         }, {
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return TabbarFadeAnimator;
   })(TabbarAnimator);

   var TabbarSlideAnimator = (function (_TabbarAnimator3) {
     babelHelpers.inherits(TabbarSlideAnimator, _TabbarAnimator3);

     function TabbarSlideAnimator(options) {
       babelHelpers.classCallCheck(this, TabbarSlideAnimator);

       options.timing = options.timing !== undefined ? options.timing : 'ease-in';
       options.duration = options.duration !== undefined ? options.duration : '0.15';
       options.delay = options.delay !== undefined ? options.delay : '0';

       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarSlideAnimator).call(this, options));
     }

     /**
      * @param {jqLite} enterPage
      * @param {jqLite} leavePage
      */

     babelHelpers.createClass(TabbarSlideAnimator, [{
       key: 'apply',
       value: function apply(enterPage, leavePage, enterIndex, leaveIndex, done) {
         var sgn = enterIndex > leaveIndex;

         animit.runAll(animit(enterPage).saveStyle().queue({
           transform: 'translate3D(' + (sgn ? '' : '-') + '100%, 0, 0)'
         }).wait(this.delay).queue({
           transform: 'translate3D(0, 0, 0)'
         }, {
           duration: this.duration,
           timing: this.timing
         }).restoreStyle().queue(function (callback) {
           done();
           callback();
         }), animit(leavePage).queue({
           transform: 'translate3D(0, 0, 0)'
         }).wait(this.delay).queue({
           transform: 'translate3D(' + (sgn ? '-' : '') + '100%, 0, 0)'
         }, {
           duration: this.duration,
           timing: this.timing
         }));
       }
     }]);
     return TabbarSlideAnimator;
   })(TabbarAnimator);

   var scheme$21 = {
     '.tab-bar__content': 'tab-bar--*__content',
     '.tab-bar': 'tab-bar--*'
   };

   var _animatorDict$5 = {
     'default': TabbarNoneAnimator,
     'fade': TabbarFadeAnimator,
     'slide': TabbarSlideAnimator,
     'none': TabbarNoneAnimator
   };

   var rewritables$3 = {
     /**
      * @param {Element} tabbarElement
      * @param {Function} callback
      */

     ready: function ready(tabbarElement, callback) {
       callback();
     },

     /**
      * @param {Element} tabbarElement
      * @param {Element} target
      * @param {Object} options
      * @param {Function} callback
      */
     link: function link(tabbarElement, target, options, callback) {
       callback(target);
     },

     /**
      * @param {Element} tabbarElement
      * @param {Element} target
      * @param {Function} callback
      */
     unlink: function unlink(tabbarElement, target, callback) {
       callback(target);
     }
   };

   var generateId$1 = (function () {
     var i = 0;
     return function () {
       return 'ons-tabbar-gen-' + i++;
     };
   })();

   /**
    * @element ons-tabbar
    * @category navigation
    * @description
    *   [en]A component to display a tab bar on the bottom of a page. Used with ons-tab to manage pages using tabs.[/en]
    *   [ja]タブバーをページ下部に表示するためのコンポーネントです。ons-tabと組み合わせて使うことで、ページを管理できます。[/ja]
    * @codepen pGuDL
    * @guide UsingTabBar
    *   [en]Using tab bar[/en]
    *   [ja]タブバーを使う[/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja]イベント処理の使い方[/ja]
    * @guide CallingComponentAPIsfromJavaScript
    *   [en]Using navigator from JavaScript[/en]
    *   [ja]JavaScriptからコンポーネントを呼び出す[/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]複数のページを1つのHTMLに記述する[/ja]
    * @seealso ons-tab
    *   [en]ons-tab component[/en]
    *   [ja]ons-tabコンポーネント[/ja]
    * @seealso ons-page
    *   [en]ons-page component[/en]
    *   [ja]ons-pageコンポーネント[/ja]
    * @example
    * <ons-tabbar>
    *   <ons-tab page="home.html" active="true">
    *     <ons-icon icon="ion-home"></ons-icon>
    *     <span style="font-size: 14px">Home</span>
    *   </ons-tab>
    *   <ons-tab page="fav.html" active="true">
    *     <ons-icon icon="ion-star"></ons-icon>
    *     <span style="font-size: 14px">Favorites</span>
    *   </ons-tab>
    *   <ons-tab page="settings.html" active="true">
    *     <ons-icon icon="ion-gear-a"></ons-icon>
    *     <span style="font-size: 14px">Settings</span>
    *   </ons-tab>
    * </ons-tabbar>
    *
    * <ons-template id="home.html">
    *   ...
    * </ons-template>
    *
    * <ons-template id="fav.html">
    *   ...
    * </ons-template>
    *
    * <ons-template id="settings.html">
    *   ...
    * </ons-template>
    */

   var TabbarElement = (function (_BaseElement) {
     babelHelpers.inherits(TabbarElement, _BaseElement);

     function TabbarElement() {
       babelHelpers.classCallCheck(this, TabbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(TabbarElement, [{
       key: 'createdCallback',

       /**
        * @event prechange
        * @description
        *   [en]Fires just before the tab is changed.[/en]
        *   [ja]アクティブなタブが変わる前に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクト。[/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItemオブジェクト。[/ja]
        * @param {Function} event.cancel
        *   [en]Call this function to cancel the change event.[/en]
        *   [ja]この関数を呼び出すと、アクティブなタブの変更がキャンセルされます。[/ja]
        */

       /**
        * @event postchange
        * @description
        *   [en]Fires just after the tab is changed.[/en]
        *   [ja]アクティブなタブが変わった後に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクト。[/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItemオブジェクト。[/ja]
        */

       /**
        * @event reactive
        * @description
        *   [en]Fires if the already open tab is tapped again.[/en]
        *   [ja]すでにアクティブになっているタブがもう一度タップやクリックされた場合に発火します。[/ja]
        * @param {Object} event
        *   [en]Event object.[/en]
        *   [ja]イベントオブジェクト。[/ja]
        * @param {Number} event.index
        *   [en]Current index.[/en]
        *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
        * @param {Object} event.tabItem
        *   [en]Tab item object.[/en]
        *   [ja]tabItemオブジェクト。[/ja]
        */

       /**
        * @attribute animation
        * @type {String}
        * @default none
        * @description
        *   [en]Animation name. Preset values are "none", "slide" and "fade". Default is "none".[/en]
        *   [ja]ページ読み込み時のアニメーションを指定します。"none"、"fade"、"slide"のいずれかを選択できます。デフォルトは"none"です。[/ja]
        */

       /**
        * @attribute animation-options
        * @type {Expression}
        * @description
        *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/en]
        *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
        */

       /**
        * @attribute position
        * @initonly
        * @type {String}
        * @default bottom
        * @description
        *   [en]Tabbar's position. Preset values are "bottom" and "top". Default is "bottom".[/en]
        *   [ja]タブバーの位置を指定します。"bottom"もしくは"top"を選択できます。デフォルトは"bottom"です。[/ja]
        */

       value: function createdCallback() {
         this._tabbarId = generateId$1();

         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         for (var i = 0; i < this.firstChild.children.length; i++) {
           this.firstChild.children[i].style.display = 'none';
         }

         var activeIndex = this.getAttribute('activeIndex');

         if (activeIndex && this.children[1].children.length > activeIndex) {
           this.children[1].children[activeIndex].setAttribute('active', 'true');
         }

         autoStyle.prepare(this);
         ModifierUtil.initModifier(this, scheme$21);

         this._animatorFactory = new AnimatorFactory({
           animators: _animatorDict$5,
           baseClass: TabbarAnimator,
           baseClassName: 'TabbarAnimator',
           defaultAnimation: this.getAttribute('animation')
         });
       }
     }, {
       key: '_compile',
       value: function _compile() {
         if (this.getAttribute('position') === 'auto') {
           this.setAttribute('position', platform.isAndroid() ? 'top' : 'bottom');
         }

         var wrapper = document.createDocumentFragment();

         var content = document.createElement('div');
         content.classList.add('ons-tab-bar__content');
         content.classList.add('tab-bar__content');

         var tabbar = document.createElement('div');
         tabbar.classList.add('tab-bar');
         tabbar.classList.add('ons-tab-bar__footer');
         tabbar.classList.add('ons-tabbar-inner');

         wrapper.appendChild(content);
         wrapper.appendChild(tabbar);

         while (this.childNodes[0]) {
           tabbar.appendChild(this.removeChild(this.childNodes[0]));
         }

         this.appendChild(wrapper);

         if (this._hasTopTabbar()) {
           this._prepareForTopTabbar();
         }

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_hasTopTabbar',
       value: function _hasTopTabbar() {
         return this.getAttribute('position') === 'top';
       }
     }, {
       key: '_prepareForTopTabbar',
       value: function _prepareForTopTabbar() {
         var _this2 = this;

         var content = util.findChild(this, '.tab-bar__content');
         var tabbar = util.findChild(this, '.tab-bar');

         content.setAttribute('no-status-bar-fill', '');

         content.classList.add('tab-bar--top__content');
         tabbar.classList.add('tab-bar--top');

         var page = util.findParent(this, 'ons-page');
         if (page) {
           this.style.top = window.getComputedStyle(page._getContentElement(), null).getPropertyValue('padding-top');

           if (page.firstChild.tagName.toLowerCase() === 'ons-toolbar') {
             util.addModifier(page.firstChild, 'noshadow');
           }
         }

         internal.shouldFillStatusBar(this).then(function () {
           var fill = _this2.querySelector('.tab-bar__status-bar-fill');

           if (fill instanceof HTMLElement) {
             return fill;
           }

           fill = document.createElement('div');
           fill.classList.add('tab-bar__status-bar-fill');
           fill.style.width = '0px';
           fill.style.height = '0px';

           _this2.insertBefore(fill, _this2.children[0]);

           return fill;
         }).catch(function () {
           var el = _this2.querySelector('.tab-bar__status-bar-fill');
           if (el instanceof HTMLElement) {
             el.remove();
           }
         });
       }
     }, {
       key: '_getTabbarElement',
       value: function _getTabbarElement() {
         return util.findChild(this, '.tab-bar');
       }

       /**
        * @method loadPage
        * @signature loadPage(url, [options])
        * @param {String} url
        *   [en]Page URL. Can be either an HTML document or an <code>&lt;ons-template&gt;</code>.[/en]
        *   [ja]pageのURLか、もしくは<code>&lt;ons-template&gt;</code>で宣言したid属性の値を利用できます。[/ja]
        * @description
        *   [en]Displays a new page without changing the active index.[/en]
        *   [ja]現在のアクティブなインデックスを変更せずに、新しいページを表示します。[/ja]
        * @param {Object} [options]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Object} [options.animation]
        *   [en][/en]
        *   [ja][/ja]
        * @param {Object} [options.callback]
        *   [en][/en]
        *   [ja][/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'loadPage',
       value: function loadPage(page) {
         var _this3 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         return new Promise(function (resolve) {
           OnsTabElement.prototype._createPageElement(page, function (pageElement) {
             resolve(_this3._loadPageDOMAsync(pageElement, options));
           });
         });
       }

       /**
        * @param {Element} pageElement
        * @param {Object} [options]
        * @param {Object} [options.animation]
        * @param {Object} [options.callback]
        * @return {Promise} Resolves to the new page element.
        */

     }, {
       key: '_loadPageDOMAsync',
       value: function _loadPageDOMAsync(pageElement) {
         var _this4 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         return new Promise(function (resolve) {
           rewritables$3.link(_this4, pageElement, options, function (pageElement) {
             _this4._contentElement.appendChild(pageElement);

             if (_this4.getActiveTabIndex() !== -1) {
               resolve(_this4._switchPage(pageElement, options));
             } else {
               if (options.callback instanceof Function) {
                 options.callback();
               }

               _this4._oldPageElement = pageElement;
               resolve(pageElement);
             }
           });
         });
       }

       /**
        * @return {String}
        */

     }, {
       key: 'getTabbarId',
       value: function getTabbarId() {
         return this._tabbarId;
       }

       /**
        * @return {Element/null}
        */

     }, {
       key: '_getCurrentPageElement',
       value: function _getCurrentPageElement() {
         var pages = this._contentElement.children;
         var page = null;
         for (var i = 0; i < pages.length; i++) {
           if (pages[i].style.display !== 'none') {
             page = pages[i];
             break;
           }
         }

         if (page && page.nodeName.toLowerCase() !== 'ons-page') {
           throw new Error('Invalid state: page element must be a "ons-page" element.');
         }

         return page;
       }
     }, {
       key: '_switchPage',

       /**
        * @param {Element} element
        * @param {Object} options
        * @param {String} [options.animation]
        * @param {Function} [options.callback]
        * @param {Object} [options.animationOptions]
        * @param {Number} options.selectedTabIndex
        * @param {Number} options.previousTabIndex
        * @return {Promise} Resolves to the new page element.
        */
       value: function _switchPage(element, options) {
         var oldPageElement = this._oldPageElement || internal.nullElement;
         this._oldPageElement = element;
         var animator = this._animatorFactory.newAnimator(options);

         return new Promise(function (resolve) {
           if (oldPageElement !== internal.nullElement) {
             oldPageElement._hide();
           }

           animator.apply(element, oldPageElement, options.selectedTabIndex, options.previousTabIndex, function () {
             if (oldPageElement !== internal.nullElement) {
               oldPageElement.style.display = 'none';
             }

             element.style.display = 'block';
             element._show();

             if (options.callback instanceof Function) {
               options.callback();
             }

             resolve(element);
           });
         });
       }

       /**
        * @method setActiveTab
        * @signature setActiveTab(index, [options])
        * @param {Number} index
        *   [en]Tab index.[/en]
        *   [ja]タブのインデックスを指定します。[/ja]
        * @param {Object} [options]
        *   [en]Parameter object.[/en]
        *   [ja]オプションを指定するオブジェクト。[/ja]
        * @param {Boolean} [options.keepPage]
        *   [en]If true the page will not be changed.[/en]
        *   [ja]タブバーが現在表示しているpageを変えない場合にはtrueを指定します。[/ja]
        * @param {String} [options.animation]
        *   [en]Animation name. Available animations are "fade", "slide" and "none".[/en]
        *   [ja]アニメーション名を指定します。"fade"、"slide"、"none"のいずれかを指定できます。[/ja]
        * @param {String} [options.animationOptions]
        *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
        *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
        * @description
        *   [en]Show specified tab page. Animations and other options can be specified by the second parameter.[/en]
        *   [ja]指定したインデックスのタブを表示します。アニメーションなどのオプションを指定できます。[/ja]
        * @return {Promise}
        *   [en]Resolves to the new page element.[/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setActiveTab',
       value: function setActiveTab(index) {
         var _this5 = this;

         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (options && (typeof options === 'undefined' ? 'undefined' : babelHelpers.typeof(options)) != 'object') {
           throw new Error('options must be an object. You supplied ' + options);
         }

         options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

         if (!options.animation && this.hasAttribute('animation')) {
           options.animation = this.getAttribute('animation');
         }

         var previousTab = this._getActiveTabElement(),
             selectedTab = this._getTabElement(index),
             previousTabIndex = this.getActiveTabIndex(),
             selectedTabIndex = index,
             previousPageElement = this._getCurrentPageElement();

         if (!selectedTab) {
           return Promise.reject('Specified index does not match any tab.');
         }

         if (selectedTabIndex === previousTabIndex) {
           util.triggerElementEvent(this, 'reactive', {
             index: selectedTabIndex,
             tabItem: selectedTab
           });

           return Promise.resolve(previousPageElement);
         }

         var canceled = false;

         util.triggerElementEvent(this, 'prechange', {
           index: selectedTabIndex,
           tabItem: selectedTab,
           cancel: function cancel() {
             return canceled = true;
           }
         });

         if (canceled) {
           selectedTab.setInactive();
           if (previousTab) {
             previousTab.setActive();
           }
           return Promise.reject('Canceled in prechange event.');
         }

         selectedTab.setActive();

         var needLoad = !selectedTab.isLoaded() && !options.keepPage;

         util.arrayFrom(this._getTabbarElement().children).forEach(function (tab) {
           if (tab != selectedTab) {
             tab.setInactive();
           } else {
             if (!needLoad) {
               util.triggerElementEvent(_this5, 'postchange', {
                 index: selectedTabIndex,
                 tabItem: selectedTab
               });
             }
           }
         });

         if (needLoad) {
           var removeElement;
           var params;

           var _ret = (function () {
             removeElement = false;

             if (!previousTab && previousPageElement || previousTab && previousTab._pageElement !== previousPageElement) {
               removeElement = true;
             }

             params = {
               callback: function callback() {
                 util.triggerElementEvent(_this5, 'postchange', {
                   index: selectedTabIndex,
                   tabItem: selectedTab
                 });

                 if (options.callback instanceof Function) {
                   options.callback();
                 }
               },
               previousTabIndex: previousTabIndex,
               selectedTabIndex: selectedTabIndex
             };

             if (options.animation) {
               params.animation = options.animation;
             }

             params.animationOptions = options.animationOptions || {};

             var link = function link(element, callback) {
               rewritables$3.link(_this5, element, options, callback);
             };

             return {
               v: new Promise(function (resolve) {
                 selectedTab._loadPageElement(function (pageElement) {
                   resolve(_this5._loadPersistentPageDOM(pageElement, params));
                 }, link);
               })
             };
           })();

           if ((typeof _ret === 'undefined' ? 'undefined' : babelHelpers.typeof(_ret)) === "object") return _ret.v;
         }

         return Promise.resolve(previousPageElement);
       }

       /**
        * @param {Element} element
        * @param {Object} options
        * @param {Object} options.animation
        */

     }, {
       key: '_loadPersistentPageDOM',
       value: function _loadPersistentPageDOM(element) {
         var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

         if (!util.isAttached(element)) {
           this._contentElement.appendChild(element);
         }

         element.removeAttribute('style');
         return this._switchPage(element, options);
       }

       /**
        * @method setTabbarVisibility
        * @signature setTabbarVisibility(visible)
        * @param {Boolean} visible
        * @description
        *   [en][/en]
        *   [ja][/ja]
        */

     }, {
       key: 'setTabbarVisibility',
       value: function setTabbarVisibility(visible) {
         this._contentElement.style[this._hasTopTabbar() ? 'top' : 'bottom'] = visible ? '' : '0px';
         this._getTabbarElement().style.display = visible ? '' : 'none';
       }

       /**
        * @method getActiveTabIndex
        * @signature getActiveTabIndex()
        * @return {Number}
        *   [en]The index of the currently active tab.[/en]
        *   [ja]現在アクティブになっているタブのインデックスを返します。[/ja]
        * @description
        *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
        *   [ja]現在アクティブになっているタブのインデックスを返します。現在アクティブなタブがない場合には-1を返します。[/ja]
        */

     }, {
       key: 'getActiveTabIndex',
       value: function getActiveTabIndex() {
         var tabs = this._getTabbarElement().children;

         for (var i = 0; i < tabs.length; i++) {
           if (tabs[i] instanceof window.OnsTabElement && tabs[i].isActive && tabs[i].isActive()) {
             return i;
           }
         }

         return -1;
       }

       /**
        * @return {Number} When active tab is not found, returns -1.
        */

     }, {
       key: '_getActiveTabElement',
       value: function _getActiveTabElement() {
         return this._getTabElement(this.getActiveTabIndex());
       }

       /**
        * @return {Element}
        */

     }, {
       key: '_getTabElement',
       value: function _getTabElement(index) {
         return this._getTabbarElement().children[index];
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {}
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {}
     }, {
       key: '_show',
       value: function _show() {
         var currentPageElement = this._getCurrentPageElement();
         if (currentPageElement) {
           currentPageElement._show();
         }
       }
     }, {
       key: '_hide',
       value: function _hide() {
         var currentPageElement = this._getCurrentPageElement();
         if (currentPageElement) {
           currentPageElement._hide();
         }
       }
     }, {
       key: '_destroy',
       value: function _destroy() {
         var pages = this._contentElement.children;
         for (var i = pages.length - 1; i >= 0; i--) {
           pages[i]._destroy();
         }
         this.remove();
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$21);
         }
       }
     }, {
       key: '_contentElement',
       get: function get() {
         return util.findChild(this, '.tab-bar__content');
       }
     }, {
       key: 'pages',
       get: function get() {
         return util.arrayFrom(this._contentElement.children);
       }
     }]);
     return TabbarElement;
   })(BaseElement);

   window.OnsTabbarElement = document.registerElement('ons-tabbar', {
     prototype: TabbarElement.prototype
   });

   /**
    * @param {String} name
    * @param {Function} Animator
    */
   window.OnsTabbarElement.registerAnimator = function (name, Animator) {
     if (!(Animator.prototype instanceof TabbarAnimator)) {
       throw new Error('"Animator" param must inherit OnsTabbarElement.TabbarAnimator');
     }
     _animatorDict$5[name] = Animator;
   };

   window.OnsTabbarElement.rewritables = rewritables$3;
   window.OnsTabbarElement.TabbarAnimator = TabbarAnimator;

   var OnsTabbarElement$1 = OnsTabbarElement;

   var scheme$20 = {
     '': 'tab-bar--*__item',
     '.tab-bar__button': 'tab-bar--*__button'
   };
   var templateSource$3 = util.createElement('\n  <div>\n    <input type="radio" style="display: none">\n    <button class="tab-bar__button tab-bar-inner"></button>\n  </div>\n');
   var defaultInnerTemplateSource = util.createElement('\n  <div>\n    <div class="tab-bar__icon">\n      <ons-icon icon="ion-cloud" style="font-size: 28px; line-height: 34px; vertical-align: top;"></ons-icon>\n    </div>\n    <div class="tab-bar__label">label</div>\n  </div>\n');

   /**
    * @element ons-tab
    * @category navigation
    * @description
    *   [en]Represents a tab inside tabbar. Each ons-tab represents a page.[/en]
    *   [ja]
    *     タブバーに配置される各アイテムのコンポーネントです。それぞれのons-tabはページを表します。
    *     ons-tab要素の中には、タブに表示されるコンテンツを直接記述することが出来ます。
    *   [/ja]
    * @codepen pGuDL
    * @guide UsingTabBar
    *   [en]Using tab bar[/en]
    *   [ja]タブバーを使う[/ja]
    * @guide DefiningMultiplePagesinSingleHTML
    *   [en]Defining multiple pages in single html[/en]
    *   [ja]複数のページを1つのHTMLに記述する[/ja]
    * @seealso ons-tabbar
    *   [en]ons-tabbar component[/en]
    *   [ja]ons-tabbarコンポーネント[/ja]
    * @seealso ons-page
    *   [en]ons-page component[/en]
    *   [ja]ons-pageコンポーネント[/ja]
    * @seealso ons-icon
    *   [en]ons-icon component[/en]
    *   [ja]ons-iconコンポーネント[/ja]
    * @example
    * <ons-tabbar>
    *   <ons-tab page="home.html" active="true">
    *     <ons-icon icon="ion-home"></ons-icon>
    *     <span style="font-size: 14px">Home</span>
    *   </ons-tab>
    *   <ons-tab page="fav.html" active="true">
    *     <ons-icon icon="ion-star"></ons-icon>
    *     <span style="font-size: 14px">Favorites</span>
    *   </ons-tab>
    *   <ons-tab page="settings.html" active="true">
    *     <ons-icon icon="ion-gear-a"></ons-icon>
    *     <span style="font-size: 14px">Settings</span>
    *   </ons-tab>
    * </ons-tabbar>
    *
    * <ons-template id="home.html">
    *   ...
    * </ons-template>
    *
    * <ons-template id="fav.html">
    *   ...
    * </ons-template>
    *
    * <ons-template id="settings.html">
    *   ...
    * </ons-template>
    */

   var TabElement = (function (_BaseElement) {
     babelHelpers.inherits(TabElement, _BaseElement);

     function TabElement() {
       babelHelpers.classCallCheck(this, TabElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(TabElement).apply(this, arguments));
     }

     babelHelpers.createClass(TabElement, [{
       key: 'createdCallback',

       /**
        * @attribute page
        * @initonly
        * @type {String}
        * @description
        *   [en]The page that this <code>&lt;ons-tab&gt;</code> points to.[/en]
        *   [ja]<code>&lt;ons-tab&gt;</code>が参照するページへのURLを指定します。[/ja]
        */

       /**
        * @attribute icon
        * @type {String}
        * @description
        *   [en]
        *     The icon name for the tab. Can specify the same icon name as <code>&lt;ons-icon&gt;</code>.
        *     If you need to use your own icon, create a css class with background-image or any css properties and specify the name of your css class here.
        *   [/en]
        *   [ja]
        *     アイコン名を指定します。<code>&lt;ons-icon&gt;</code>と同じアイコン名を指定できます。
        *     個別にアイコンをカスタマイズする場合は、background-imageなどのCSSスタイルを用いて指定できます。
        *   [/ja]
        */

       /**
        * @attribute active-icon
        * @type {String}
        * @description
        *   [en]The name of the icon when the tab is active.[/en]
        *   [ja]アクティブの際のアイコン名を指定します。[/ja]
        */

       /**
        * @attribute label
        * @type {String}
        * @description
        *   [en]The label of the tab item.[/en]
        *   [ja]アイコン下に表示されるラベルを指定します。[/ja]
        */

       /**
        * @attribute active
        * @type {Boolean}
        * @default false
        * @description
        *   [en]Set whether this item should be active or not. Valid values are true and false.[/en]
        *   [ja]このタブアイテムをアクティブ状態にするかどうかを指定します。trueもしくはfalseを指定できます。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._boundOnClick = this._onClick.bind(this);
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         var fragment = document.createDocumentFragment();
         var hasChildren = false;

         while (this.childNodes[0]) {
           var node = this.childNodes[0];
           this.removeChild(node);
           fragment.appendChild(node);

           if (node.nodeType == Node.ELEMENT_NODE) {
             hasChildren = true;
           }
         }

         var template = templateSource$3.cloneNode(true);
         while (template.children[0]) {
           this.appendChild(template.children[0]);
         }
         this.classList.add('tab-bar__item');

         var button = util.findChild(this, '.tab-bar__button');

         if (hasChildren) {
           button.appendChild(fragment);
           this._hasDefaultTemplate = false;
         } else {
           this._hasDefaultTemplate = true;
           this._updateDefaultTemplate();
         }

         this._updateRipple();

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_updateRipple',
       value: function _updateRipple() {
         util.updateRipple(this);
       }
     }, {
       key: '_updateDefaultTemplate',
       value: function _updateDefaultTemplate() {
         if (!this._hasDefaultTemplate) {
           return;
         }

         var button = util.findChild(this, '.tab-bar__button');

         var template = defaultInnerTemplateSource.cloneNode(true);
         while (template.children[0]) {
           button.appendChild(template.children[0]);
         }

         var self = this;
         var icon = this.getAttribute('icon');
         var label = this.getAttribute('label');

         if (typeof icon === 'string') {
           getIconElement().setAttribute('icon', icon);
         } else {
           var wrapper = button.querySelector('.tab-bar__icon');
           wrapper.parentNode.removeChild(wrapper);
         }

         if (typeof label === 'string') {
           getLabelElement().textContent = label;
         } else {
           getLabelElement().parentNode.removeChild(getLabelElement());
         }

         function getLabelElement() {
           return self.querySelector('.tab-bar__label');
         }

         function getIconElement() {
           return self.querySelector('ons-icon');
         }
       }
     }, {
       key: '_onClick',
       value: function _onClick() {
         var tabbar = this._findTabbarElement();
         if (tabbar) {
           tabbar.setActiveTab(this._findTabIndex());
         }
       }
     }, {
       key: 'setActive',
       value: function setActive() {
         var radio = util.findChild(this, 'input');
         radio.checked = true;
         this.classList.add('active');

         util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
           return element.style.display = 'none';
         });
         util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
           return element.style.display = 'inherit';
         });
       }
     }, {
       key: 'setInactive',
       value: function setInactive() {
         var radio = util.findChild(this, 'input');
         radio.checked = false;
         this.classList.remove('active');

         util.arrayFrom(this.querySelectorAll('[ons-tab-inactive], ons-tab-inactive')).forEach(function (element) {
           return element.style.display = 'inherit';
         });
         util.arrayFrom(this.querySelectorAll('[ons-tab-active], ons-tab-active')).forEach(function (element) {
           return element.style.display = 'none';
         });
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isLoaded',
       value: function isLoaded() {
         return false;
       }

       /**
        * @param {Function} callback
        * @param {Function} link
        */

     }, {
       key: '_loadPageElement',
       value: function _loadPageElement(callback, link) {
         var _this2 = this;

         if (!this.pageElement) {
           this._createPageElement(this.getAttribute('page'), function (element) {
             link(element, function (element) {
               _this2.pageElement = element;
               callback(element);
             });
           });
         } else {
           callback(this.pageElement);
         }
       }
     }, {
       key: '_createPageElement',

       /**
        * @param {String} page
        * @param {Function} callback
        */
       value: function _createPageElement(page, callback) {
         internal.getPageHTMLAsync(page).then(function (html) {
           callback(util.createElement(html.trim()));
         });
       }

       /**
        * @return {Boolean}
        */

     }, {
       key: 'isActive',
       value: function isActive() {
         return this.classList.contains('active');
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this3 = this;

         this._ensureElementPosition();

         var tabbar = this._findTabbarElement();

         if (tabbar.hasAttribute('modifier')) {
           var prefix = this.hasAttribute('modifier') ? this.getAttribute('modifier') + ' ' : '';
           this.setAttribute('modifier', prefix + tabbar.getAttribute('modifier'));
         }

         if (this.hasAttribute('active')) {
           (function () {
             var tabIndex = _this3._findTabIndex();

             OnsTabbarElement$1.rewritables.ready(tabbar, function () {
               setImmediate(function () {
                 return tabbar.setActiveTab(tabIndex, { animation: 'none' });
               });
             });
           })();
         } else {
           OnsTabbarElement$1.rewritables.ready(tabbar, function () {
             setImmediate(function () {
               if (_this3.hasAttribute('page')) {
                 _this3._createPageElement(_this3.getAttribute('page'), function (pageElement) {
                   OnsTabbarElement$1.rewritables.link(tabbar, pageElement, {}, function (pageElement) {
                     _this3.pageElement = pageElement;
                     _this3.pageElement.style.display = 'none';
                     tabbar._contentElement.appendChild(_this3.pageElement);
                   });
                 });
               }
             });
           });
         }

         this.addEventListener('click', this._boundOnClick, false);
       }
     }, {
       key: '_findTabbarElement',
       value: function _findTabbarElement() {
         if (this.parentNode && this.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
           return this.parentNode;
         }

         if (this.parentNode.parentNode && this.parentNode.parentNode.nodeName.toLowerCase() === 'ons-tabbar') {
           return this.parentNode.parentNode;
         }

         return null;
       }
     }, {
       key: '_findTabIndex',
       value: function _findTabIndex() {
         var elements = this.parentNode.children;
         for (var i = 0; i < elements.length; i++) {
           if (this === elements[i]) {
             return i;
           }
         }
       }
     }, {
       key: '_ensureElementPosition',
       value: function _ensureElementPosition() {
         if (!this._findTabbarElement()) {
           throw new Error('This ons-tab element is must be child of ons-tabbar element.');
         }
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         switch (name) {
           case 'modifier':
             ModifierUtil.onModifierChanged(last, current, this, scheme$20);
             break;
           case 'ripple':
             this._updateRipple();
             break;
           case 'icon':
           case 'label':
             this._updateDefaultTemplate();
         }
       }
     }, {
       key: 'pageElement',
       set: function set(el) {
         this._pageElement = el;
       },
       get: function get() {
         if (typeof this._pageElement !== 'undefined') {
           return this._pageElement;
         }

         var tabbar = this._findTabbarElement();
         var index = this._findTabIndex();

         return tabbar._contentElement.children[index];
       }
     }]);
     return TabElement;
   })(BaseElement);

   window.OnsTabElement = document.registerElement('ons-tab', {
     prototype: TabElement.prototype
   });

   document.registerElement('ons-tabbar-item', {
     prototype: Object.create(TabElement.prototype)
   });

   var scheme$22 = { '': 'toolbar-button--*' };

   /**
    * @element ons-toolbar-button
    * @category page
    * @modifier outline
    *   [en]A button with an outline.[/en]
    *   [ja]アウトラインをもったボタンを表示します。[/ja]
    * @description
    *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
    *   [ja]ons-toolbarあるいはons-bottom-toolbarに設置できるボタン用コンポーネントです。[/ja]
    * @codepen aHmGL
    * @guide Addingatoolbar
    *   [en]Adding a toolbar[/en]
    *   [ja]ツールバーの追加[/ja]
    * @seealso ons-toolbar
    *   [en]ons-toolbar component[/en]
    *   [ja]ons-toolbarコンポーネント[/ja]
    * @seealso ons-back-button
    *   [en]ons-back-button component[/en]
    *   [ja]ons-back-buttonコンポーネント[/ja]
    * @seealso ons-toolbar-button
    *   [en]ons-toolbar-button component[/en]
    *   [ja]ons-toolbar-buttonコンポーネント[/ja]
    * @example
    * <ons-toolbar>
    *   <div class="left"><ons-toolbar-button>Button</ons-toolbar-button></div>
    *   <div class="center">Title</div>
    *   <div class="right"><ons-toolbar-button><ons-icon icon="ion-navicon" size="28px"></ons-icon></ons-toolbar-button></div>
    * </ons-toolbar>
    */

   var ToolbarButtonElement = (function (_BaseElement) {
     babelHelpers.inherits(ToolbarButtonElement, _BaseElement);

     function ToolbarButtonElement() {
       babelHelpers.classCallCheck(this, ToolbarButtonElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarButtonElement).apply(this, arguments));
     }

     babelHelpers.createClass(ToolbarButtonElement, [{
       key: 'createdCallback',

       /**
        * @attribute modifier
        * @type {String}
        * @description
        *   [en]The appearance of the button.[/en]
        *   [ja]ボタンの表現を指定します。[/ja]
        */

       /**
        * @attribute disabled
        * @description
        *   [en]Specify if button should be disabled.[/en]
        *   [ja]ボタンを無効化する場合は指定してください。[/ja]
        */

       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('toolbar-button');

         ModifierUtil.initModifier(this, scheme$22);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$22);
         }
       }
     }]);
     return ToolbarButtonElement;
   })(BaseElement);

   window.OnsToolbarButton = document.registerElement('ons-toolbar-button', {
     prototype: ToolbarButtonElement.prototype
   });

   var scheme$23 = {
     '': 'navigation-bar--*',
     '.navigation-bar__left': 'navigation-bar--*__left',
     '.navigation-bar__center': 'navigation-bar--*__center',
     '.navigation-bar__right': 'navigation-bar--*__right'
   };

   /**
    * @element ons-toolbar
    * @category page
    * @modifier transparent
    *   [en]Transparent toolbar[/en]
    *   [ja]透明な背景を持つツールバーを表示します。[/ja]
    * @description
    *   [en]Toolbar component that can be used with navigation. Left, center and right container can be specified by class names.[/en]
    *   [ja]ナビゲーションで使用するツールバー用コンポーネントです。クラス名により、左、中央、右のコンテナを指定できます。[/ja]
    * @codepen aHmGL
    * @guide Addingatoolbar [en]Adding a toolbar[/en][ja]ツールバーの追加[/ja]
    * @seealso ons-bottom-toolbar
    *   [en]ons-bottom-toolbar component[/en]
    *   [ja]ons-bottom-toolbarコンポーネント[/ja]
    * @seealso ons-back-button
    *   [en]ons-back-button component[/en]
    *   [ja]ons-back-buttonコンポーネント[/ja]
    * @seealso ons-toolbar-button
    *   [en]ons-toolbar-button component[/en]
    *   [ja]ons-toolbar-buttonコンポーネント[/ja]
    * @example
    * <ons-page>
    *   <ons-toolbar>
    *     <div class="left"><ons-back-button>Back</ons-back-button></div>
    *     <div class="center">Title</div>
    *     <div class="right">Label</div>
    *   </ons-toolbar>
    * </ons-page>
    */

   var ToolbarElement = (function (_BaseElement) {
     babelHelpers.inherits(ToolbarElement, _BaseElement);

     function ToolbarElement() {
       babelHelpers.classCallCheck(this, ToolbarElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(ToolbarElement).apply(this, arguments));
     }

     babelHelpers.createClass(ToolbarElement, [{
       key: 'createdCallback',

       /**
        * @attribute inline
        * @initonly
        * @description
        *   [en]Display the toolbar as an inline element.[/en]
        *   [ja]ツールバーをインラインに置きます。スクロール領域内にそのまま表示されます。[/ja]
        */

       /**
        * @attribute modifier
        * @description
        *   [en]The appearance of the toolbar.[/en]
        *   [ja]ツールバーの表現を指定します。[/ja]
        */

       value: function createdCallback() {
         var _this2 = this;

         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._tryToEnsureNodePosition();
         setImmediate(function () {
           return _this2._tryToEnsureNodePosition();
         });
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           return ModifierUtil.onModifierChanged(last, current, this, scheme$23);
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         var _this3 = this;

         this._tryToEnsureNodePosition();
         setImmediate(function () {
           return _this3._tryToEnsureNodePosition();
         });
       }
     }, {
       key: '_tryToEnsureNodePosition',
       value: function _tryToEnsureNodePosition() {
         if (!this.parentNode || this.hasAttribute('inline')) {
           return;
         }
         var page = util.findParent(this, 'ons-page');

         if (page && page !== this.parentNode) {
           page._registerToolbar(this);
         }
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarLeftItemsElement',
       value: function _getToolbarLeftItemsElement() {
         return this.querySelector('.left') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarCenterItemsElement',
       value: function _getToolbarCenterItemsElement() {
         return this.querySelector('.center') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarRightItemsElement',
       value: function _getToolbarRightItemsElement() {
         return this.querySelector('.right') || internal.nullElement;
       }

       /**
        * @return {HTMLElement}
        */

     }, {
       key: '_getToolbarBackButtonLabelElement',
       value: function _getToolbarBackButtonLabelElement() {
         return this.querySelector('ons-back-button .back-button__label') || internal.nullElement;
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.classList.add('navigation-bar');

         this._ensureToolbarItemElements();

         ModifierUtil.initModifier(this, scheme$23);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_ensureToolbarItemElements',
       value: function _ensureToolbarItemElements() {

         var hasCenterClassElementOnly = this.children.length === 1 && this.children[0].classList.contains('center');

         for (var i = 0; i < this.childNodes.length; i++) {
           // case of not element
           if (this.childNodes[i].nodeType != 1) {
             this.removeChild(this.childNodes[i]);
           }
         }

         var center = this._ensureToolbarElement('center');
         center.classList.add('navigation-bar__title');

         if (!hasCenterClassElementOnly) {
           var left = this._ensureToolbarElement('left');
           var right = this._ensureToolbarElement('right');

           if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
             if (left.parentNode) {
               this.removeChild(left);
             }
             if (center.parentNode) {
               this.removeChild(center);
             }
             if (right.parentNode) {
               this.removeChild(right);
             }

             this.appendChild(left);
             this.appendChild(center);
             this.appendChild(right);
           }
         }
       }
     }, {
       key: '_ensureToolbarElement',
       value: function _ensureToolbarElement(name) {
         var element = util.findChild(this, '.' + name) || util.create('.' + name);

         element.classList.add('navigation-bar__' + name);

         return element;
       }
     }]);
     return ToolbarElement;
   })(BaseElement);

   window.OnsToolbarElement = document.registerElement('ons-toolbar', {
     prototype: ToolbarElement.prototype
   });

   var scheme$24 = {
     '.range': 'range--*',
     '.range__left': 'range--*__left'
   };

   var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'inputmode', 'max', 'min', 'name', 'placeholder', 'readonly', 'size', 'step', 'validator', 'value'];

   /**
    * @element ons-range
    * @category form
    * @description
    *   [en]Range input component.[/en]
    *   [ja][/ja]
    * @codepen xZQomM
    * @guide UsingFormComponents
    *   [en]Using form components[/en]
    *   [ja]フォームを使う[/ja]
    * @guide EventHandling
    *   [en]Event handling descriptions[/en]
    *   [ja]イベント処理の使い方[/ja]
    * @example
    * <ons-range value="20"></ons-range>
    * <ons-range modifier="material" value="10"></range>
    */

   var MaterialInputElement$1 = (function (_BaseElement) {
     babelHelpers.inherits(MaterialInputElement, _BaseElement);

     function MaterialInputElement() {
       babelHelpers.classCallCheck(this, MaterialInputElement);
       return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(MaterialInputElement).apply(this, arguments));
     }

     babelHelpers.createClass(MaterialInputElement, [{
       key: 'createdCallback',
       value: function createdCallback() {
         if (!this.hasAttribute('_compiled')) {
           this._compile();
         }

         this._updateBoundAttributes();
         this._onChange();
       }
     }, {
       key: '_compile',
       value: function _compile() {
         autoStyle.prepare(this);

         this.innerHTML = '\n      <input type="range" class="range">\n      <div class="range__left"></div>\n    ';

         ModifierUtil.initModifier(this, scheme$24);

         this.setAttribute('_compiled', '');
       }
     }, {
       key: '_onChange',
       value: function _onChange() {
         this._left.style.width = 100 * this._ratio + '%';
       }
     }, {
       key: 'attributeChangedCallback',
       value: function attributeChangedCallback(name, last, current) {
         if (name === 'modifier') {
           ModifierUtil.onModifierChanged(last, current, this, scheme$24);
         } else if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
           this._updateBoundAttributes();

           if (name === 'min' || name === 'max') {
             this._onChange();
           }
         }
       }
     }, {
       key: 'attachedCallback',
       value: function attachedCallback() {
         this.addEventListener('input', this._onChange);
       }
     }, {
       key: 'detachedCallback',
       value: function detachedCallback() {
         this.removeEventListener('input', this._onChange);
       }
     }, {
       key: '_updateBoundAttributes',
       value: function _updateBoundAttributes() {
         var _this2 = this;

         INPUT_ATTRIBUTES$1.forEach(function (attr) {
           if (_this2.hasAttribute(attr)) {
             _this2._input.setAttribute(attr, _this2.getAttribute(attr));
           } else {
             _this2._input.removeAttribute(attr);
           }
         });
       }
     }, {
       key: '_ratio',
       get: function get() {
         // Returns the current ratio.
         var min = this._input.min === '' ? 0 : parseInt(this._input.min);
         var max = this._input.max === '' ? 100 : parseInt(this._input.max);

         return (this.value - min) / (max - min);
       }
     }, {
       key: '_input',
       get: function get() {
         return this.querySelector('input');
       }
     }, {
       key: '_left',
       get: function get() {
         return this.querySelector('.range__left');
       }
     }, {
       key: 'value',
       get: function get() {
         return this._input.value;
       },
       set: function set(val) {
         this._input.value = val;
         this._onChange();
         return this._input.val;
       }
     }]);
     return MaterialInputElement;
   })(BaseElement);

   window.OnsRangeElement = document.registerElement('ons-range', {
     prototype: MaterialInputElement$1.prototype
   });

   // fastclick
   window.addEventListener('load', function () {
     return FastClick.attach(document.body);
   }, false);

   // ons._defaultDeviceBackButtonHandler
   window.addEventListener('DOMContentLoaded', function () {
     ons._deviceBackButtonDispatcher.enable();
     ons._defaultDeviceBackButtonHandler = ons._deviceBackButtonDispatcher.createHandler(window.document.body, function () {
       navigator.app.exitApp();
     });
     document.body._gestureDetector = new ons.GestureDetector(document.body);
   }, false);

   // setup loading placeholder
   ons.ready(function () {
     ons._setupLoadingPlaceHolders();
   });

   // viewport.js
   new Viewport().setup();

   // modernize
   Modernizr.testStyles('#modernizr { -webkit-overflow-scrolling:touch }', function (elem, rule) {
     Modernizr.addTest('overflowtouch', window.getComputedStyle && window.getComputedStyle(elem).getPropertyValue('-webkit-overflow-scrolling') == 'touch');
   });

   return ons;

}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkN1c3RvbUVsZW1lbnRzLmpzIiwiQ3VzdG9tRXZlbnQuanMiLCJhbmltaXQuanMiLCJjaGlsZE5vZGVSZW1vdmUuanMiLCJjbGFzc0xpc3QuanMiLCJmYXN0Y2xpY2stcGF0Y2hlZC5qcyIsIm1pY3JvZXZlbnQuanMiLCJtb2Rlcm5penItY3VzdG9tLmpzIiwicHJvbWlzZS03LjAuNC5taW4uanMiLCJzZXRJbW1lZGlhdGUuanMiLCJ2aWV3cG9ydC5qcyIsIndpbnN0b3JlLWpzY29tcGF0LmpzIiwic2V0dXAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNTdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xFQTtBQUNBO0FBQ0E7QUNGQTtBQUNBO0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJvbnNlbnVpLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vLyBAdmVyc2lvbiAwLjcuM1xuaWYgKHR5cGVvZiBXZWFrTWFwID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgdmFyIGNvdW50ZXIgPSBEYXRlLm5vdygpICUgMWU5O1xuICAgIHZhciBXZWFrTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5hbWUgPSBcIl9fc3RcIiArIChNYXRoLnJhbmRvbSgpICogMWU5ID4+PiAwKSArIChjb3VudGVyKysgKyBcIl9fXCIpO1xuICAgIH07XG4gICAgV2Vha01hcC5wcm90b3R5cGUgPSB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5KSBlbnRyeVsxXSA9IHZhbHVlOyBlbHNlIGRlZmluZVByb3BlcnR5KGtleSwgdGhpcy5uYW1lLCB7XG4gICAgICAgICAgdmFsdWU6IFsga2V5LCB2YWx1ZSBdLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHJldHVybiAoZW50cnkgPSBrZXlbdGhpcy5uYW1lXSkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdIDogdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKCFlbnRyeSB8fCBlbnRyeVswXSAhPT0ga2V5KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGVudHJ5WzBdID0gZW50cnlbMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGhhczogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoIWVudHJ5KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBlbnRyeVswXSA9PT0ga2V5O1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LldlYWtNYXAgPSBXZWFrTWFwO1xuICB9KSgpO1xufVxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIHZhciByZWdpc3RyYXRpb25zVGFibGUgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgc2V0SW1tZWRpYXRlO1xuICBpZiAoL1RyaWRlbnR8RWRnZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgIHNldEltbWVkaWF0ZSA9IHNldFRpbWVvdXQ7XG4gIH0gZWxzZSBpZiAod2luZG93LnNldEltbWVkaWF0ZSkge1xuICAgIHNldEltbWVkaWF0ZSA9IHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgdmFyIHNlbnRpbmVsID0gU3RyaW5nKE1hdGgucmFuZG9tKCkpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5kYXRhID09PSBzZW50aW5lbCkge1xuICAgICAgICB2YXIgcXVldWUgPSBzZXRJbW1lZGlhdGVRdWV1ZTtcbiAgICAgICAgc2V0SW1tZWRpYXRlUXVldWUgPSBbXTtcbiAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgZnVuYygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICBzZXRJbW1lZGlhdGVRdWV1ZS5wdXNoKGZ1bmMpO1xuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKHNlbnRpbmVsLCBcIipcIik7XG4gICAgfTtcbiAgfVxuICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIHNjaGVkdWxlZE9ic2VydmVycyA9IFtdO1xuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrKG9ic2VydmVyKSB7XG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldEltbWVkaWF0ZShkaXNwYXRjaENhbGxiYWNrcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHdyYXBJZk5lZWRlZChub2RlKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbCAmJiB3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwud3JhcElmTmVlZGVkKG5vZGUpIHx8IG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcGF0Y2hDYWxsYmFja3MoKSB7XG4gICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gc2NoZWR1bGVkT2JzZXJ2ZXJzO1xuICAgIHNjaGVkdWxlZE9ic2VydmVycyA9IFtdO1xuICAgIG9ic2VydmVycy5zb3J0KGZ1bmN0aW9uKG8xLCBvMikge1xuICAgICAgcmV0dXJuIG8xLnVpZF8gLSBvMi51aWRfO1xuICAgIH0pO1xuICAgIHZhciBhbnlOb25FbXB0eSA9IGZhbHNlO1xuICAgIG9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICB2YXIgcXVldWUgPSBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yKG9ic2VydmVyKTtcbiAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2tfKHF1ZXVlLCBvYnNlcnZlcik7XG4gICAgICAgIGFueU5vbkVtcHR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoYW55Tm9uRW1wdHkpIGRpc3BhdGNoQ2FsbGJhY2tzKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIubm9kZXNfLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZXR1cm47XG4gICAgICByZWdpc3RyYXRpb25zLmZvckVhY2goZnVuY3Rpb24ocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIGlmIChyZWdpc3RyYXRpb24ub2JzZXJ2ZXIgPT09IG9ic2VydmVyKSByZWdpc3RyYXRpb24ucmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIG5vZGUgPSB0YXJnZXQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2pdO1xuICAgICAgICAgIHZhciBvcHRpb25zID0gcmVnaXN0cmF0aW9uLm9wdGlvbnM7XG4gICAgICAgICAgaWYgKG5vZGUgIT09IHRhcmdldCAmJiAhb3B0aW9ucy5zdWJ0cmVlKSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gY2FsbGJhY2sob3B0aW9ucyk7XG4gICAgICAgICAgaWYgKHJlY29yZCkgcmVnaXN0cmF0aW9uLmVucXVldWUocmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgdWlkQ291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIEpzTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XG4gICAgdGhpcy5ub2Rlc18gPSBbXTtcbiAgICB0aGlzLnJlY29yZHNfID0gW107XG4gICAgdGhpcy51aWRfID0gKyt1aWRDb3VudGVyO1xuICB9XG4gIEpzTXV0YXRpb25PYnNlcnZlci5wcm90b3R5cGUgPSB7XG4gICAgb2JzZXJ2ZTogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICB0YXJnZXQgPSB3cmFwSWZOZWVkZWQodGFyZ2V0KTtcbiAgICAgIGlmICghb3B0aW9ucy5jaGlsZExpc3QgJiYgIW9wdGlvbnMuYXR0cmlidXRlcyAmJiAhb3B0aW9ucy5jaGFyYWN0ZXJEYXRhIHx8IG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUgJiYgIW9wdGlvbnMuYXR0cmlidXRlcyB8fCBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlciAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5sZW5ndGggJiYgIW9wdGlvbnMuYXR0cmlidXRlcyB8fCBvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSAmJiAhb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KHRhcmdldCk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJlZ2lzdHJhdGlvbnNUYWJsZS5zZXQodGFyZ2V0LCByZWdpc3RyYXRpb25zID0gW10pO1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uc1tpXS5vYnNlcnZlciA9PT0gdGhpcykge1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgcmVnaXN0cmF0aW9uID0gbmV3IFJlZ2lzdHJhdGlvbih0aGlzLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICByZWdpc3RyYXRpb25zLnB1c2gocmVnaXN0cmF0aW9uKTtcbiAgICAgICAgdGhpcy5ub2Rlc18ucHVzaCh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgcmVnaXN0cmF0aW9uLmFkZExpc3RlbmVycygpO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5vZGVzXy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tpXTtcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICByZWdpc3RyYXRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLnJlY29yZHNfID0gW107XG4gICAgfSxcbiAgICB0YWtlUmVjb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weU9mUmVjb3JkcyA9IHRoaXMucmVjb3Jkc187XG4gICAgICB0aGlzLnJlY29yZHNfID0gW107XG4gICAgICByZXR1cm4gY29weU9mUmVjb3JkcztcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIE11dGF0aW9uUmVjb3JkKHR5cGUsIHRhcmdldCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5hZGRlZE5vZGVzID0gW107XG4gICAgdGhpcy5yZW1vdmVkTm9kZXMgPSBbXTtcbiAgICB0aGlzLnByZXZpb3VzU2libGluZyA9IG51bGw7XG4gICAgdGhpcy5uZXh0U2libGluZyA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG51bGw7XG4gICAgdGhpcy5vbGRWYWx1ZSA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY29weU11dGF0aW9uUmVjb3JkKG9yaWdpbmFsKSB7XG4gICAgdmFyIHJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZChvcmlnaW5hbC50eXBlLCBvcmlnaW5hbC50YXJnZXQpO1xuICAgIHJlY29yZC5hZGRlZE5vZGVzID0gb3JpZ2luYWwuYWRkZWROb2Rlcy5zbGljZSgpO1xuICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSBvcmlnaW5hbC5yZW1vdmVkTm9kZXMuc2xpY2UoKTtcbiAgICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gb3JpZ2luYWwucHJldmlvdXNTaWJsaW5nO1xuICAgIHJlY29yZC5uZXh0U2libGluZyA9IG9yaWdpbmFsLm5leHRTaWJsaW5nO1xuICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gb3JpZ2luYWwuYXR0cmlidXRlTmFtZTtcbiAgICByZWNvcmQuYXR0cmlidXRlTmFtZXNwYWNlID0gb3JpZ2luYWwuYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgIHJlY29yZC5vbGRWYWx1ZSA9IG9yaWdpbmFsLm9sZFZhbHVlO1xuICAgIHJldHVybiByZWNvcmQ7XG4gIH1cbiAgdmFyIGN1cnJlbnRSZWNvcmQsIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgZnVuY3Rpb24gZ2V0UmVjb3JkKHR5cGUsIHRhcmdldCkge1xuICAgIHJldHVybiBjdXJyZW50UmVjb3JkID0gbmV3IE11dGF0aW9uUmVjb3JkKHR5cGUsIHRhcmdldCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKSB7XG4gICAgaWYgKHJlY29yZFdpdGhPbGRWYWx1ZSkgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUgPSBjb3B5TXV0YXRpb25SZWNvcmQoY3VycmVudFJlY29yZCk7XG4gICAgcmVjb3JkV2l0aE9sZFZhbHVlLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhclJlY29yZHMoKSB7XG4gICAgY3VycmVudFJlY29yZCA9IHJlY29yZFdpdGhPbGRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiByZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uKHJlY29yZCkge1xuICAgIHJldHVybiByZWNvcmQgPT09IHJlY29yZFdpdGhPbGRWYWx1ZSB8fCByZWNvcmQgPT09IGN1cnJlbnRSZWNvcmQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0UmVjb3JkKGxhc3RSZWNvcmQsIG5ld1JlY29yZCkge1xuICAgIGlmIChsYXN0UmVjb3JkID09PSBuZXdSZWNvcmQpIHJldHVybiBsYXN0UmVjb3JkO1xuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUgJiYgcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihsYXN0UmVjb3JkKSkgcmV0dXJuIHJlY29yZFdpdGhPbGRWYWx1ZTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBSZWdpc3RyYXRpb24ob2JzZXJ2ZXIsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IFtdO1xuICB9XG4gIFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgZW5xdWV1ZTogZnVuY3Rpb24ocmVjb3JkKSB7XG4gICAgICB2YXIgcmVjb3JkcyA9IHRoaXMub2JzZXJ2ZXIucmVjb3Jkc187XG4gICAgICB2YXIgbGVuZ3RoID0gcmVjb3Jkcy5sZW5ndGg7XG4gICAgICBpZiAocmVjb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBsYXN0UmVjb3JkID0gcmVjb3Jkc1tsZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJlY29yZFRvUmVwbGFjZUxhc3QgPSBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgcmVjb3JkKTtcbiAgICAgICAgaWYgKHJlY29yZFRvUmVwbGFjZUxhc3QpIHtcbiAgICAgICAgICByZWNvcmRzW2xlbmd0aCAtIDFdID0gcmVjb3JkVG9SZXBsYWNlTGFzdDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2sodGhpcy5vYnNlcnZlcik7XG4gICAgICB9XG4gICAgICByZWNvcmRzW2xlbmd0aF0gPSByZWNvcmQ7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hZGRMaXN0ZW5lcnNfKHRoaXMudGFyZ2V0KTtcbiAgICB9LFxuICAgIGFkZExpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQXR0ck1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Ob2RlSW5zZXJ0ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18odGhpcy50YXJnZXQpO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01BdHRyTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVSZW1vdmVkXCIsIHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgYWRkVHJhbnNpZW50T2JzZXJ2ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlID09PSB0aGlzLnRhcmdldCkgcmV0dXJuO1xuICAgICAgdGhpcy5hZGRMaXN0ZW5lcnNfKG5vZGUpO1xuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJlZ2lzdHJhdGlvbnNUYWJsZS5zZXQobm9kZSwgcmVnaXN0cmF0aW9ucyA9IFtdKTtcbiAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaCh0aGlzKTtcbiAgICB9LFxuICAgIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcztcbiAgICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IFtdO1xuICAgICAgdHJhbnNpZW50T2JzZXJ2ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKG5vZGUpO1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZWdpc3RyYXRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcbiAgICBoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgY2FzZSBcIkRPTUF0dHJNb2RpZmllZFwiOlxuICAgICAgICB2YXIgbmFtZSA9IGUuYXR0ck5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBlLnJlbGF0ZWROb2RlLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgcmVjb3JkID0gbmV3IGdldFJlY29yZChcImF0dHJpYnV0ZXNcIiwgdGFyZ2V0KTtcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBuYW1lO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlTmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBlLmF0dHJDaGFuZ2UgPT09IE11dGF0aW9uRXZlbnQuQURESVRJT04gPyBudWxsIDogZS5wcmV2VmFsdWU7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuYXR0cmlidXRlcykgcmV0dXJuO1xuICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZUZpbHRlciAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5sZW5ndGggJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIuaW5kZXhPZihuYW1lKSA9PT0gLTEgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIuaW5kZXhPZihuYW1lc3BhY2UpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSkgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiOlxuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoXCJjaGFyYWN0ZXJEYXRhXCIsIHRhcmdldCk7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGUucHJldlZhbHVlO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmNoYXJhY3RlckRhdGEpIHJldHVybjtcbiAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUpIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJET01Ob2RlUmVtb3ZlZFwiOlxuICAgICAgICB0aGlzLmFkZFRyYW5zaWVudE9ic2VydmVyKGUudGFyZ2V0KTtcblxuICAgICAgIGNhc2UgXCJET01Ob2RlSW5zZXJ0ZWRcIjpcbiAgICAgICAgdmFyIGNoYW5nZWROb2RlID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBhZGRlZE5vZGVzLCByZW1vdmVkTm9kZXM7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwiRE9NTm9kZUluc2VydGVkXCIpIHtcbiAgICAgICAgICBhZGRlZE5vZGVzID0gWyBjaGFuZ2VkTm9kZSBdO1xuICAgICAgICAgIHJlbW92ZWROb2RlcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbXTtcbiAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbIGNoYW5nZWROb2RlIF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IGNoYW5nZWROb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY2hhbmdlZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoXCJjaGlsZExpc3RcIiwgZS50YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAgIHJlY29yZC5hZGRlZE5vZGVzID0gYWRkZWROb2RlcztcbiAgICAgICAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IHJlbW92ZWROb2RlcztcbiAgICAgICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgcmVjb3JkLm5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmc7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZChlLnJlbGF0ZWROb2RlLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCkgcmV0dXJuO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2xlYXJSZWNvcmRzKCk7XG4gICAgfVxuICB9O1xuICBnbG9iYWwuSnNNdXRhdGlvbk9ic2VydmVyID0gSnNNdXRhdGlvbk9ic2VydmVyO1xuICBpZiAoIWdsb2JhbC5NdXRhdGlvbk9ic2VydmVyKSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbn0pKHRoaXMpO1xuXG53aW5kb3cuQ3VzdG9tRWxlbWVudHMgPSB3aW5kb3cuQ3VzdG9tRWxlbWVudHMgfHwge1xuICBmbGFnczoge31cbn07XG5cbihmdW5jdGlvbihzY29wZSkge1xuICB2YXIgZmxhZ3MgPSBzY29wZS5mbGFncztcbiAgdmFyIG1vZHVsZXMgPSBbXTtcbiAgdmFyIGFkZE1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIG1vZHVsZXMucHVzaChtb2R1bGUpO1xuICB9O1xuICB2YXIgaW5pdGlhbGl6ZU1vZHVsZXMgPSBmdW5jdGlvbigpIHtcbiAgICBtb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICBtb2R1bGUoc2NvcGUpO1xuICAgIH0pO1xuICB9O1xuICBzY29wZS5hZGRNb2R1bGUgPSBhZGRNb2R1bGU7XG4gIHNjb3BlLmluaXRpYWxpemVNb2R1bGVzID0gaW5pdGlhbGl6ZU1vZHVsZXM7XG4gIHNjb3BlLmhhc05hdGl2ZSA9IEJvb2xlYW4oZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KTtcbiAgc2NvcGUudXNlTmF0aXZlID0gIWZsYWdzLnJlZ2lzdGVyICYmIHNjb3BlLmhhc05hdGl2ZSAmJiAhd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmICghd2luZG93LkhUTUxJbXBvcnRzIHx8IEhUTUxJbXBvcnRzLnVzZU5hdGl2ZSk7XG59KSh3aW5kb3cuQ3VzdG9tRWxlbWVudHMpO1xuXG53aW5kb3cuQ3VzdG9tRWxlbWVudHMuYWRkTW9kdWxlKGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHZhciBJTVBPUlRfTElOS19UWVBFID0gd2luZG93LkhUTUxJbXBvcnRzID8gSFRNTEltcG9ydHMuSU1QT1JUX0xJTktfVFlQRSA6IFwibm9uZVwiO1xuICBmdW5jdGlvbiBmb3JTdWJ0cmVlKG5vZGUsIGNiKSB7XG4gICAgZmluZEFsbEVsZW1lbnRzKG5vZGUsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChjYihlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvclJvb3RzKGUsIGNiKTtcbiAgICB9KTtcbiAgICBmb3JSb290cyhub2RlLCBjYik7XG4gIH1cbiAgZnVuY3Rpb24gZmluZEFsbEVsZW1lbnRzKG5vZGUsIGZpbmQsIGRhdGEpIHtcbiAgICB2YXIgZSA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgaWYgKCFlKSB7XG4gICAgICBlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGUgJiYgZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgZSA9IGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChlKSB7XG4gICAgICBpZiAoZmluZChlLCBkYXRhKSAhPT0gdHJ1ZSkge1xuICAgICAgICBmaW5kQWxsRWxlbWVudHMoZSwgZmluZCwgZGF0YSk7XG4gICAgICB9XG4gICAgICBlID0gZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGZvclJvb3RzKG5vZGUsIGNiKSB7XG4gICAgdmFyIHJvb3QgPSBub2RlLnNoYWRvd1Jvb3Q7XG4gICAgd2hpbGUgKHJvb3QpIHtcbiAgICAgIGZvclN1YnRyZWUocm9vdCwgY2IpO1xuICAgICAgcm9vdCA9IHJvb3Qub2xkZXJTaGFkb3dSb290O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmb3JEb2N1bWVudFRyZWUoZG9jLCBjYikge1xuICAgIF9mb3JEb2N1bWVudFRyZWUoZG9jLCBjYiwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIF9mb3JEb2N1bWVudFRyZWUoZG9jLCBjYiwgcHJvY2Vzc2luZ0RvY3VtZW50cykge1xuICAgIGRvYyA9IHdyYXAoZG9jKTtcbiAgICBpZiAocHJvY2Vzc2luZ0RvY3VtZW50cy5pbmRleE9mKGRvYykgPj0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcm9jZXNzaW5nRG9jdW1lbnRzLnB1c2goZG9jKTtcbiAgICB2YXIgaW1wb3J0cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tyZWw9XCIgKyBJTVBPUlRfTElOS19UWVBFICsgXCJdXCIpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW1wb3J0cy5sZW5ndGgsIG47IGkgPCBsICYmIChuID0gaW1wb3J0c1tpXSk7IGkrKykge1xuICAgICAgaWYgKG4uaW1wb3J0KSB7XG4gICAgICAgIF9mb3JEb2N1bWVudFRyZWUobi5pbXBvcnQsIGNiLCBwcm9jZXNzaW5nRG9jdW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2IoZG9jKTtcbiAgfVxuICBzY29wZS5mb3JEb2N1bWVudFRyZWUgPSBmb3JEb2N1bWVudFRyZWU7XG4gIHNjb3BlLmZvclN1YnRyZWUgPSBmb3JTdWJ0cmVlO1xufSk7XG5cbndpbmRvdy5DdXN0b21FbGVtZW50cy5hZGRNb2R1bGUoZnVuY3Rpb24oc2NvcGUpIHtcbiAgdmFyIGZsYWdzID0gc2NvcGUuZmxhZ3M7XG4gIHZhciBmb3JTdWJ0cmVlID0gc2NvcGUuZm9yU3VidHJlZTtcbiAgdmFyIGZvckRvY3VtZW50VHJlZSA9IHNjb3BlLmZvckRvY3VtZW50VHJlZTtcbiAgZnVuY3Rpb24gYWRkZWROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gYWRkZWQobm9kZSkgfHwgYWRkZWRTdWJ0cmVlKG5vZGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZGVkKG5vZGUpIHtcbiAgICBpZiAoc2NvcGUudXBncmFkZShub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGF0dGFjaGVkKG5vZGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZGVkU3VidHJlZShub2RlKSB7XG4gICAgZm9yU3VidHJlZShub2RlLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoYWRkZWQoZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYXR0YWNoZWROb2RlKG5vZGUpIHtcbiAgICBhdHRhY2hlZChub2RlKTtcbiAgICBpZiAoaW5Eb2N1bWVudChub2RlKSkge1xuICAgICAgZm9yU3VidHJlZShub2RlLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGF0dGFjaGVkKGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHZhciBoYXNQb2x5ZmlsbE11dGF0aW9ucyA9ICF3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciA9PT0gd2luZG93LkpzTXV0YXRpb25PYnNlcnZlcjtcbiAgc2NvcGUuaGFzUG9seWZpbGxNdXRhdGlvbnMgPSBoYXNQb2x5ZmlsbE11dGF0aW9ucztcbiAgdmFyIGlzUGVuZGluZ011dGF0aW9ucyA9IGZhbHNlO1xuICB2YXIgcGVuZGluZ011dGF0aW9ucyA9IFtdO1xuICBmdW5jdGlvbiBkZWZlck11dGF0aW9uKGZuKSB7XG4gICAgcGVuZGluZ011dGF0aW9ucy5wdXNoKGZuKTtcbiAgICBpZiAoIWlzUGVuZGluZ011dGF0aW9ucykge1xuICAgICAgaXNQZW5kaW5nTXV0YXRpb25zID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQodGFrZU11dGF0aW9ucyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRha2VNdXRhdGlvbnMoKSB7XG4gICAgaXNQZW5kaW5nTXV0YXRpb25zID0gZmFsc2U7XG4gICAgdmFyICRwID0gcGVuZGluZ011dGF0aW9ucztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9ICRwLmxlbmd0aCwgcDsgaSA8IGwgJiYgKHAgPSAkcFtpXSk7IGkrKykge1xuICAgICAgcCgpO1xuICAgIH1cbiAgICBwZW5kaW5nTXV0YXRpb25zID0gW107XG4gIH1cbiAgZnVuY3Rpb24gYXR0YWNoZWQoZWxlbWVudCkge1xuICAgIGlmIChoYXNQb2x5ZmlsbE11dGF0aW9ucykge1xuICAgICAgZGVmZXJNdXRhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgX2F0dGFjaGVkKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hdHRhY2hlZChlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2F0dGFjaGVkKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5fX3VwZ3JhZGVkX18gJiYgKGVsZW1lbnQuYXR0YWNoZWRDYWxsYmFjayB8fCBlbGVtZW50LmRldGFjaGVkQ2FsbGJhY2spKSB7XG4gICAgICBpZiAoIWVsZW1lbnQuX19hdHRhY2hlZCAmJiBpbkRvY3VtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnQuX19hdHRhY2hlZCA9IHRydWU7XG4gICAgICAgIGlmIChlbGVtZW50LmF0dGFjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICBlbGVtZW50LmF0dGFjaGVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZXRhY2hlZE5vZGUobm9kZSkge1xuICAgIGRldGFjaGVkKG5vZGUpO1xuICAgIGZvclN1YnRyZWUobm9kZSwgZnVuY3Rpb24oZSkge1xuICAgICAgZGV0YWNoZWQoZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGV0YWNoZWQoZWxlbWVudCkge1xuICAgIGlmIChoYXNQb2x5ZmlsbE11dGF0aW9ucykge1xuICAgICAgZGVmZXJNdXRhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgX2RldGFjaGVkKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9kZXRhY2hlZChlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2RldGFjaGVkKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5fX3VwZ3JhZGVkX18gJiYgKGVsZW1lbnQuYXR0YWNoZWRDYWxsYmFjayB8fCBlbGVtZW50LmRldGFjaGVkQ2FsbGJhY2spKSB7XG4gICAgICBpZiAoZWxlbWVudC5fX2F0dGFjaGVkICYmICFpbkRvY3VtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIGVsZW1lbnQuX19hdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoZWxlbWVudC5kZXRhY2hlZENhbGxiYWNrKSB7XG4gICAgICAgICAgZWxlbWVudC5kZXRhY2hlZENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW5Eb2N1bWVudChlbGVtZW50KSB7XG4gICAgdmFyIHAgPSBlbGVtZW50O1xuICAgIHZhciBkb2MgPSB3cmFwKGRvY3VtZW50KTtcbiAgICB3aGlsZSAocCkge1xuICAgICAgaWYgKHAgPT0gZG9jKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcCA9IHAucGFyZW50Tm9kZSB8fCBwLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiYgcC5ob3N0O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3YXRjaFNoYWRvdyhub2RlKSB7XG4gICAgaWYgKG5vZGUuc2hhZG93Um9vdCAmJiAhbm9kZS5zaGFkb3dSb290Ll9fd2F0Y2hlZCkge1xuICAgICAgZmxhZ3MuZG9tICYmIGNvbnNvbGUubG9nKFwid2F0Y2hpbmcgc2hhZG93LXJvb3QgZm9yOiBcIiwgbm9kZS5sb2NhbE5hbWUpO1xuICAgICAgdmFyIHJvb3QgPSBub2RlLnNoYWRvd1Jvb3Q7XG4gICAgICB3aGlsZSAocm9vdCkge1xuICAgICAgICBvYnNlcnZlKHJvb3QpO1xuICAgICAgICByb290ID0gcm9vdC5vbGRlclNoYWRvd1Jvb3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZXIobXV0YXRpb25zKSB7XG4gICAgaWYgKGZsYWdzLmRvbSkge1xuICAgICAgdmFyIG14ID0gbXV0YXRpb25zWzBdO1xuICAgICAgaWYgKG14ICYmIG14LnR5cGUgPT09IFwiY2hpbGRMaXN0XCIgJiYgbXguYWRkZWROb2Rlcykge1xuICAgICAgICBpZiAobXguYWRkZWROb2Rlcykge1xuICAgICAgICAgIHZhciBkID0gbXguYWRkZWROb2Rlc1swXTtcbiAgICAgICAgICB3aGlsZSAoZCAmJiBkICE9PSBkb2N1bWVudCAmJiAhZC5ob3N0KSB7XG4gICAgICAgICAgICBkID0gZC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdSA9IGQgJiYgKGQuVVJMIHx8IGQuX1VSTCB8fCBkLmhvc3QgJiYgZC5ob3N0LmxvY2FsTmFtZSkgfHwgXCJcIjtcbiAgICAgICAgICB1ID0gdS5zcGxpdChcIi8/XCIpLnNoaWZ0KCkuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zb2xlLmdyb3VwKFwibXV0YXRpb25zICglZCkgWyVzXVwiLCBtdXRhdGlvbnMubGVuZ3RoLCB1IHx8IFwiXCIpO1xuICAgIH1cbiAgICBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihteCkge1xuICAgICAgaWYgKG14LnR5cGUgPT09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgZm9yRWFjaChteC5hZGRlZE5vZGVzLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgaWYgKCFuLmxvY2FsTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRlZE5vZGUobik7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3JFYWNoKG14LnJlbW92ZWROb2RlcywgZnVuY3Rpb24obikge1xuICAgICAgICAgIGlmICghbi5sb2NhbE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGV0YWNoZWROb2RlKG4pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmbGFncy5kb20gJiYgY29uc29sZS5ncm91cEVuZCgpO1xuICB9XG4gIGZ1bmN0aW9uIHRha2VSZWNvcmRzKG5vZGUpIHtcbiAgICBub2RlID0gd3JhcChub2RlKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIG5vZGUgPSB3cmFwKGRvY3VtZW50KTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgdmFyIG9ic2VydmVyID0gbm9kZS5fX29ic2VydmVyO1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgaGFuZGxlcihvYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICAgIHRha2VNdXRhdGlvbnMoKTtcbiAgICB9XG4gIH1cbiAgdmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpO1xuICBmdW5jdGlvbiBvYnNlcnZlKGluUm9vdCkge1xuICAgIGlmIChpblJvb3QuX19vYnNlcnZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVyKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGluUm9vdCwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pO1xuICAgIGluUm9vdC5fX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gIH1cbiAgZnVuY3Rpb24gdXBncmFkZURvY3VtZW50KGRvYykge1xuICAgIGRvYyA9IHdyYXAoZG9jKTtcbiAgICBmbGFncy5kb20gJiYgY29uc29sZS5ncm91cChcInVwZ3JhZGVEb2N1bWVudDogXCIsIGRvYy5iYXNlVVJJLnNwbGl0KFwiL1wiKS5wb3AoKSk7XG4gICAgYWRkZWROb2RlKGRvYyk7XG4gICAgb2JzZXJ2ZShkb2MpO1xuICAgIGZsYWdzLmRvbSAmJiBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbiAgZnVuY3Rpb24gdXBncmFkZURvY3VtZW50VHJlZShkb2MpIHtcbiAgICBmb3JEb2N1bWVudFRyZWUoZG9jLCB1cGdyYWRlRG9jdW1lbnQpO1xuICB9XG4gIHZhciBvcmlnaW5hbENyZWF0ZVNoYWRvd1Jvb3QgPSBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFkb3dSb290O1xuICBpZiAob3JpZ2luYWxDcmVhdGVTaGFkb3dSb290KSB7XG4gICAgRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU2hhZG93Um9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJvb3QgPSBvcmlnaW5hbENyZWF0ZVNoYWRvd1Jvb3QuY2FsbCh0aGlzKTtcbiAgICAgIEN1c3RvbUVsZW1lbnRzLndhdGNoU2hhZG93KHRoaXMpO1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcbiAgfVxuICBzY29wZS53YXRjaFNoYWRvdyA9IHdhdGNoU2hhZG93O1xuICBzY29wZS51cGdyYWRlRG9jdW1lbnRUcmVlID0gdXBncmFkZURvY3VtZW50VHJlZTtcbiAgc2NvcGUudXBncmFkZVN1YnRyZWUgPSBhZGRlZFN1YnRyZWU7XG4gIHNjb3BlLnVwZ3JhZGVBbGwgPSBhZGRlZE5vZGU7XG4gIHNjb3BlLmF0dGFjaGVkTm9kZSA9IGF0dGFjaGVkTm9kZTtcbiAgc2NvcGUudGFrZVJlY29yZHMgPSB0YWtlUmVjb3Jkcztcbn0pO1xuXG53aW5kb3cuQ3VzdG9tRWxlbWVudHMuYWRkTW9kdWxlKGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHZhciBmbGFncyA9IHNjb3BlLmZsYWdzO1xuICBmdW5jdGlvbiB1cGdyYWRlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuX191cGdyYWRlZF9fICYmIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgaXMgPSBub2RlLmdldEF0dHJpYnV0ZShcImlzXCIpO1xuICAgICAgdmFyIGRlZmluaXRpb24gPSBzY29wZS5nZXRSZWdpc3RlcmVkRGVmaW5pdGlvbihpcyB8fCBub2RlLmxvY2FsTmFtZSk7XG4gICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoaXMgJiYgZGVmaW5pdGlvbi50YWcgPT0gbm9kZS5sb2NhbE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdXBncmFkZVdpdGhEZWZpbml0aW9uKG5vZGUsIGRlZmluaXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKCFpcyAmJiAhZGVmaW5pdGlvbi5leHRlbmRzKSB7XG4gICAgICAgICAgcmV0dXJuIHVwZ3JhZGVXaXRoRGVmaW5pdGlvbihub2RlLCBkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGdyYWRlV2l0aERlZmluaXRpb24oZWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIGZsYWdzLnVwZ3JhZGUgJiYgY29uc29sZS5ncm91cChcInVwZ3JhZGU6XCIsIGVsZW1lbnQubG9jYWxOYW1lKTtcbiAgICBpZiAoZGVmaW5pdGlvbi5pcykge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpc1wiLCBkZWZpbml0aW9uLmlzKTtcbiAgICB9XG4gICAgaW1wbGVtZW50UHJvdG90eXBlKGVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIGVsZW1lbnQuX191cGdyYWRlZF9fID0gdHJ1ZTtcbiAgICBjcmVhdGVkKGVsZW1lbnQpO1xuICAgIHNjb3BlLmF0dGFjaGVkTm9kZShlbGVtZW50KTtcbiAgICBzY29wZS51cGdyYWRlU3VidHJlZShlbGVtZW50KTtcbiAgICBmbGFncy51cGdyYWRlICYmIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBmdW5jdGlvbiBpbXBsZW1lbnRQcm90b3R5cGUoZWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIGlmIChPYmplY3QuX19wcm90b19fKSB7XG4gICAgICBlbGVtZW50Ll9fcHJvdG9fXyA9IGRlZmluaXRpb24ucHJvdG90eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXN0b21NaXhpbihlbGVtZW50LCBkZWZpbml0aW9uLnByb3RvdHlwZSwgZGVmaW5pdGlvbi5uYXRpdmUpO1xuICAgICAgZWxlbWVudC5fX3Byb3RvX18gPSBkZWZpbml0aW9uLnByb3RvdHlwZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3VzdG9tTWl4aW4oaW5UYXJnZXQsIGluU3JjLCBpbk5hdGl2ZSkge1xuICAgIHZhciB1c2VkID0ge307XG4gICAgdmFyIHAgPSBpblNyYztcbiAgICB3aGlsZSAocCAhPT0gaW5OYXRpdmUgJiYgcCAhPT0gSFRNTEVsZW1lbnQucHJvdG90eXBlKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHApO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGs7IGsgPSBrZXlzW2ldOyBpKyspIHtcbiAgICAgICAgaWYgKCF1c2VkW2tdKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluVGFyZ2V0LCBrLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAsIGspKTtcbiAgICAgICAgICB1c2VkW2tdID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlZChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuY3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICBlbGVtZW50LmNyZWF0ZWRDYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICBzY29wZS51cGdyYWRlID0gdXBncmFkZTtcbiAgc2NvcGUudXBncmFkZVdpdGhEZWZpbml0aW9uID0gdXBncmFkZVdpdGhEZWZpbml0aW9uO1xuICBzY29wZS5pbXBsZW1lbnRQcm90b3R5cGUgPSBpbXBsZW1lbnRQcm90b3R5cGU7XG59KTtcblxud2luZG93LkN1c3RvbUVsZW1lbnRzLmFkZE1vZHVsZShmdW5jdGlvbihzY29wZSkge1xuICB2YXIgaXNJRTExT3JPbGRlciA9IHNjb3BlLmlzSUUxMU9yT2xkZXI7XG4gIHZhciB1cGdyYWRlRG9jdW1lbnRUcmVlID0gc2NvcGUudXBncmFkZURvY3VtZW50VHJlZTtcbiAgdmFyIHVwZ3JhZGVBbGwgPSBzY29wZS51cGdyYWRlQWxsO1xuICB2YXIgdXBncmFkZVdpdGhEZWZpbml0aW9uID0gc2NvcGUudXBncmFkZVdpdGhEZWZpbml0aW9uO1xuICB2YXIgaW1wbGVtZW50UHJvdG90eXBlID0gc2NvcGUuaW1wbGVtZW50UHJvdG90eXBlO1xuICB2YXIgdXNlTmF0aXZlID0gc2NvcGUudXNlTmF0aXZlO1xuICBmdW5jdGlvbiByZWdpc3RlcihuYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIGRlZmluaXRpb24gPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50OiBmaXJzdCBhcmd1bWVudCBgbmFtZWAgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICAgIGlmIChuYW1lLmluZGV4T2YoXCItXCIpIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50OiBmaXJzdCBhcmd1bWVudCAoJ25hbWUnKSBtdXN0IGNvbnRhaW4gYSBkYXNoICgnLScpLiBBcmd1bWVudCBwcm92aWRlZCB3YXMgJ1wiICsgU3RyaW5nKG5hbWUpICsgXCInLlwiKTtcbiAgICB9XG4gICAgaWYgKGlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdyZWdpc3RlckVsZW1lbnQnIG9uICdEb2N1bWVudCc6IFJlZ2lzdHJhdGlvbiBmYWlsZWQgZm9yIHR5cGUgJ1wiICsgU3RyaW5nKG5hbWUpICsgXCInLiBUaGUgdHlwZSBuYW1lIGlzIGludmFsaWQuXCIpO1xuICAgIH1cbiAgICBpZiAoZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24obmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZURlZmluaXRpb25FcnJvcjogYSB0eXBlIHdpdGggbmFtZSAnXCIgKyBTdHJpbmcobmFtZSkgKyBcIicgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO1xuICAgIH1cbiAgICBpZiAoIWRlZmluaXRpb24ucHJvdG90eXBlKSB7XG4gICAgICBkZWZpbml0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcbiAgICB9XG4gICAgZGVmaW5pdGlvbi5fX25hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgZGVmaW5pdGlvbi5saWZlY3ljbGUgPSBkZWZpbml0aW9uLmxpZmVjeWNsZSB8fCB7fTtcbiAgICBkZWZpbml0aW9uLmFuY2VzdHJ5ID0gYW5jZXN0cnkoZGVmaW5pdGlvbi5leHRlbmRzKTtcbiAgICByZXNvbHZlVGFnTmFtZShkZWZpbml0aW9uKTtcbiAgICByZXNvbHZlUHJvdG90eXBlQ2hhaW4oZGVmaW5pdGlvbik7XG4gICAgb3ZlcnJpZGVBdHRyaWJ1dGVBcGkoZGVmaW5pdGlvbi5wcm90b3R5cGUpO1xuICAgIHJlZ2lzdGVyRGVmaW5pdGlvbihkZWZpbml0aW9uLl9fbmFtZSwgZGVmaW5pdGlvbik7XG4gICAgZGVmaW5pdGlvbi5jdG9yID0gZ2VuZXJhdGVDb25zdHJ1Y3RvcihkZWZpbml0aW9uKTtcbiAgICBkZWZpbml0aW9uLmN0b3IucHJvdG90eXBlID0gZGVmaW5pdGlvbi5wcm90b3R5cGU7XG4gICAgZGVmaW5pdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBkZWZpbml0aW9uLmN0b3I7XG4gICAgaWYgKHNjb3BlLnJlYWR5KSB7XG4gICAgICB1cGdyYWRlRG9jdW1lbnRUcmVlKGRvY3VtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb24uY3RvcjtcbiAgfVxuICBmdW5jdGlvbiBvdmVycmlkZUF0dHJpYnV0ZUFwaShwcm90b3R5cGUpIHtcbiAgICBpZiAocHJvdG90eXBlLnNldEF0dHJpYnV0ZS5fcG9seWZpbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2V0QXR0cmlidXRlID0gcHJvdG90eXBlLnNldEF0dHJpYnV0ZTtcbiAgICBwcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIGNoYW5nZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlLCBzZXRBdHRyaWJ1dGUpO1xuICAgIH07XG4gICAgdmFyIHJlbW92ZUF0dHJpYnV0ZSA9IHByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGU7XG4gICAgcHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGNoYW5nZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIG51bGwsIHJlbW92ZUF0dHJpYnV0ZSk7XG4gICAgfTtcbiAgICBwcm90b3R5cGUuc2V0QXR0cmlidXRlLl9wb2x5ZmlsbGVkID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjaGFuZ2VBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG9wZXJhdGlvbikge1xuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgb3BlcmF0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrICYmIG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNSZXNlcnZlZFRhZyhuYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNlcnZlZFRhZ0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChuYW1lID09PSByZXNlcnZlZFRhZ0xpc3RbaV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXNlcnZlZFRhZ0xpc3QgPSBbIFwiYW5ub3RhdGlvbi14bWxcIiwgXCJjb2xvci1wcm9maWxlXCIsIFwiZm9udC1mYWNlXCIsIFwiZm9udC1mYWNlLXNyY1wiLCBcImZvbnQtZmFjZS11cmlcIiwgXCJmb250LWZhY2UtZm9ybWF0XCIsIFwiZm9udC1mYWNlLW5hbWVcIiwgXCJtaXNzaW5nLWdseXBoXCIgXTtcbiAgZnVuY3Rpb24gYW5jZXN0cnkoZXh0bmRzKSB7XG4gICAgdmFyIGV4dGVuZGVlID0gZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24oZXh0bmRzKTtcbiAgICBpZiAoZXh0ZW5kZWUpIHtcbiAgICAgIHJldHVybiBhbmNlc3RyeShleHRlbmRlZS5leHRlbmRzKS5jb25jYXQoWyBleHRlbmRlZSBdKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVUYWdOYW1lKGRlZmluaXRpb24pIHtcbiAgICB2YXIgYmFzZVRhZyA9IGRlZmluaXRpb24uZXh0ZW5kcztcbiAgICBmb3IgKHZhciBpID0gMCwgYTsgYSA9IGRlZmluaXRpb24uYW5jZXN0cnlbaV07IGkrKykge1xuICAgICAgYmFzZVRhZyA9IGEuaXMgJiYgYS50YWc7XG4gICAgfVxuICAgIGRlZmluaXRpb24udGFnID0gYmFzZVRhZyB8fCBkZWZpbml0aW9uLl9fbmFtZTtcbiAgICBpZiAoYmFzZVRhZykge1xuICAgICAgZGVmaW5pdGlvbi5pcyA9IGRlZmluaXRpb24uX19uYW1lO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlUHJvdG90eXBlQ2hhaW4oZGVmaW5pdGlvbikge1xuICAgIGlmICghT2JqZWN0Ll9fcHJvdG9fXykge1xuICAgICAgdmFyIG5hdGl2ZVByb3RvdHlwZSA9IEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbiAgICAgIGlmIChkZWZpbml0aW9uLmlzKSB7XG4gICAgICAgIHZhciBpbnN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkZWZpbml0aW9uLnRhZyk7XG4gICAgICAgIHZhciBleHBlY3RlZFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkUHJvdG90eXBlID09PSBkZWZpbml0aW9uLnByb3RvdHlwZSkge1xuICAgICAgICAgIG5hdGl2ZVByb3RvdHlwZSA9IGV4cGVjdGVkUHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSBkZWZpbml0aW9uLnByb3RvdHlwZSwgYW5jZXN0b3I7XG4gICAgICB3aGlsZSAocHJvdG8gJiYgcHJvdG8gIT09IG5hdGl2ZVByb3RvdHlwZSkge1xuICAgICAgICBhbmNlc3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgICAgIHByb3RvLl9fcHJvdG9fXyA9IGFuY2VzdG9yO1xuICAgICAgICBwcm90byA9IGFuY2VzdG9yO1xuICAgICAgfVxuICAgICAgZGVmaW5pdGlvbi5uYXRpdmUgPSBuYXRpdmVQcm90b3R5cGU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluc3RhbnRpYXRlKGRlZmluaXRpb24pIHtcbiAgICByZXR1cm4gdXBncmFkZVdpdGhEZWZpbml0aW9uKGRvbUNyZWF0ZUVsZW1lbnQoZGVmaW5pdGlvbi50YWcpLCBkZWZpbml0aW9uKTtcbiAgfVxuICB2YXIgcmVnaXN0cnkgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24obmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gcmVnaXN0cnlbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJEZWZpbml0aW9uKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICByZWdpc3RyeVtuYW1lXSA9IGRlZmluaXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVDb25zdHJ1Y3RvcihkZWZpbml0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGluc3RhbnRpYXRlKGRlZmluaXRpb24pO1xuICAgIH07XG4gIH1cbiAgdmFyIEhUTUxfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZywgdHlwZUV4dGVuc2lvbikge1xuICAgIGlmIChuYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWcsIHR5cGVFeHRlbnNpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZG9tQ3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIHR5cGVFeHRlbnNpb24pIHtcbiAgICBpZiAodGFnKSB7XG4gICAgICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVFeHRlbnNpb24pIHtcbiAgICAgIHR5cGVFeHRlbnNpb24gPSB0eXBlRXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHZhciBkZWZpbml0aW9uID0gZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24odHlwZUV4dGVuc2lvbiB8fCB0YWcpO1xuICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICBpZiAodGFnID09IGRlZmluaXRpb24udGFnICYmIHR5cGVFeHRlbnNpb24gPT0gZGVmaW5pdGlvbi5pcykge1xuICAgICAgICByZXR1cm4gbmV3IGRlZmluaXRpb24uY3RvcigpO1xuICAgICAgfVxuICAgICAgaWYgKCF0eXBlRXh0ZW5zaW9uICYmICFkZWZpbml0aW9uLmlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgZGVmaW5pdGlvbi5jdG9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBlbGVtZW50O1xuICAgIGlmICh0eXBlRXh0ZW5zaW9uKSB7XG4gICAgICBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpc1wiLCB0eXBlRXh0ZW5zaW9uKTtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBlbGVtZW50ID0gZG9tQ3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0YWcuaW5kZXhPZihcIi1cIikgPj0gMCkge1xuICAgICAgaW1wbGVtZW50UHJvdG90eXBlKGVsZW1lbnQsIEhUTUxFbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdmFyIGRvbUNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmJpbmQoZG9jdW1lbnQpO1xuICB2YXIgZG9tQ3JlYXRlRWxlbWVudE5TID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TLmJpbmQoZG9jdW1lbnQpO1xuICB2YXIgaXNJbnN0YW5jZTtcbiAgaWYgKCFPYmplY3QuX19wcm90b19fICYmICF1c2VOYXRpdmUpIHtcbiAgICBpc0luc3RhbmNlID0gZnVuY3Rpb24ob2JqLCBjdG9yKSB7XG4gICAgICB2YXIgcCA9IG9iajtcbiAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgIGlmIChwID09PSBjdG9yLnByb3RvdHlwZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLl9fcHJvdG9fXztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGlzSW5zdGFuY2UgPSBmdW5jdGlvbihvYmosIGJhc2UpIHtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBiYXNlO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gd3JhcERvbU1ldGhvZFRvRm9yY2VVcGdyYWRlKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBvcmlnID0gb2JqW21ldGhvZE5hbWVdO1xuICAgIG9ialttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG4gPSBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB1cGdyYWRlQWxsKG4pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfTtcbiAgfVxuICB3cmFwRG9tTWV0aG9kVG9Gb3JjZVVwZ3JhZGUoTm9kZS5wcm90b3R5cGUsIFwiY2xvbmVOb2RlXCIpO1xuICB3cmFwRG9tTWV0aG9kVG9Gb3JjZVVwZ3JhZGUoZG9jdW1lbnQsIFwiaW1wb3J0Tm9kZVwiKTtcbiAgaWYgKGlzSUUxMU9yT2xkZXIpIHtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1wb3J0Tm9kZSA9IGRvY3VtZW50LmltcG9ydE5vZGU7XG4gICAgICBkb2N1bWVudC5pbXBvcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuID0gaW1wb3J0Tm9kZS5hcHBseShkb2N1bWVudCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT0gbi5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdmFyIGYgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgZi5hcHBlbmRDaGlsZChuKTtcbiAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuICB9XG4gIGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCA9IHJlZ2lzdGVyO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TID0gY3JlYXRlRWxlbWVudE5TO1xuICBzY29wZS5yZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICBzY29wZS5pbnN0YW5jZW9mID0gaXNJbnN0YW5jZTtcbiAgc2NvcGUucmVzZXJ2ZWRUYWdMaXN0ID0gcmVzZXJ2ZWRUYWdMaXN0O1xuICBzY29wZS5nZXRSZWdpc3RlcmVkRGVmaW5pdGlvbiA9IGdldFJlZ2lzdGVyZWREZWZpbml0aW9uO1xuICBkb2N1bWVudC5yZWdpc3RlciA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudDtcbn0pO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgdmFyIHVzZU5hdGl2ZSA9IHNjb3BlLnVzZU5hdGl2ZTtcbiAgdmFyIGluaXRpYWxpemVNb2R1bGVzID0gc2NvcGUuaW5pdGlhbGl6ZU1vZHVsZXM7XG4gIHZhciBpc0lFMTFPck9sZGVyID0gL1RyaWRlbnQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIGlmICh1c2VOYXRpdmUpIHtcbiAgICB2YXIgbm9wID0gZnVuY3Rpb24oKSB7fTtcbiAgICBzY29wZS53YXRjaFNoYWRvdyA9IG5vcDtcbiAgICBzY29wZS51cGdyYWRlID0gbm9wO1xuICAgIHNjb3BlLnVwZ3JhZGVBbGwgPSBub3A7XG4gICAgc2NvcGUudXBncmFkZURvY3VtZW50VHJlZSA9IG5vcDtcbiAgICBzY29wZS51cGdyYWRlU3VidHJlZSA9IG5vcDtcbiAgICBzY29wZS50YWtlUmVjb3JkcyA9IG5vcDtcbiAgICBzY29wZS5pbnN0YW5jZW9mID0gZnVuY3Rpb24ob2JqLCBiYXNlKSB7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgYmFzZTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGluaXRpYWxpemVNb2R1bGVzKCk7XG4gIH1cbiAgdmFyIHVwZ3JhZGVEb2N1bWVudFRyZWUgPSBzY29wZS51cGdyYWRlRG9jdW1lbnRUcmVlO1xuICBpZiAoIXdpbmRvdy53cmFwKSB7XG4gICAgaWYgKHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbCkge1xuICAgICAgd2luZG93LndyYXAgPSBTaGFkb3dET01Qb2x5ZmlsbC53cmFwSWZOZWVkZWQ7XG4gICAgICB3aW5kb3cudW53cmFwID0gU2hhZG93RE9NUG9seWZpbGwudW53cmFwSWZOZWVkZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy53cmFwID0gd2luZG93LnVud3JhcCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBib290c3RyYXAoKSB7XG4gICAgdXBncmFkZURvY3VtZW50VHJlZSh3cmFwKGRvY3VtZW50KSk7XG4gICAgaWYgKHdpbmRvdy5IVE1MSW1wb3J0cykge1xuICAgICAgSFRNTEltcG9ydHMuX19pbXBvcnRzUGFyc2luZ0hvb2sgPSBmdW5jdGlvbihlbHQpIHtcbiAgICAgICAgdXBncmFkZURvY3VtZW50VHJlZSh3cmFwKGVsdC5pbXBvcnQpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIEN1c3RvbUVsZW1lbnRzLnJlYWR5ID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgQ3VzdG9tRWxlbWVudHMucmVhZHlUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmICh3aW5kb3cuSFRNTEltcG9ydHMpIHtcbiAgICAgICAgQ3VzdG9tRWxlbWVudHMuZWxhcHNlZCA9IEN1c3RvbUVsZW1lbnRzLnJlYWR5VGltZSAtIEhUTUxJbXBvcnRzLnJlYWR5VGltZTtcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiV2ViQ29tcG9uZW50c1JlYWR5XCIsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGlmIChpc0lFMTFPck9sZGVyICYmIHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IGZ1bmN0aW9uKGluVHlwZSwgcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICBlLmluaXRDdXN0b21FdmVudChpblR5cGUsIEJvb2xlYW4ocGFyYW1zLmJ1YmJsZXMpLCBCb29sZWFuKHBhcmFtcy5jYW5jZWxhYmxlKSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIHdpbmRvdy5DdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICB9XG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHwgc2NvcGUuZmxhZ3MuZWFnZXIpIHtcbiAgICBib290c3RyYXAoKTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImludGVyYWN0aXZlXCIgJiYgIXdpbmRvdy5hdHRhY2hFdmVudCAmJiAoIXdpbmRvdy5IVE1MSW1wb3J0cyB8fCB3aW5kb3cuSFRNTEltcG9ydHMucmVhZHkpKSB7XG4gICAgYm9vdHN0cmFwKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxvYWRFdmVudCA9IHdpbmRvdy5IVE1MSW1wb3J0cyAmJiAhSFRNTEltcG9ydHMucmVhZHkgPyBcIkhUTUxJbXBvcnRzTG9hZGVkXCIgOiBcIkRPTUNvbnRlbnRMb2FkZWRcIjtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihsb2FkRXZlbnQsIGJvb3RzdHJhcCk7XG4gIH1cbiAgc2NvcGUuaXNJRTExT3JPbGRlciA9IGlzSUUxMU9yT2xkZXI7XG59KSh3aW5kb3cuQ3VzdG9tRWxlbWVudHMpO1xuIiwiaWYgKCF3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBDdXN0b21FdmVudDtcblxuICAgIEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIHBhcmFtcykge1xuICAgICAgdmFyIGV2dDtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7XG4gICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgICAgZGV0YWlsOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfTtcblxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG5cbiAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbiAgfSkoKTtcbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cblxuLyoqXG4gKiBNaW5pbWFsIGFuaW1hdGlvbiBsaWJyYXJ5IGZvciBtYW5hZ2luZyBjc3MgdHJhbnNpdGlvbiBvbiBtb2JpbGUgYnJvd3NlcnMuXG4gKi9cbndpbmRvdy5hbmltaXQgPSAoZnVuY3Rpb24oKXtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBUSU1FT1VUX1JBVElPID0gMS40O1xuXG4gIHZhciB1dGlsID0ge1xuICB9O1xuXG4gIC8vIGNhcGl0YWxpemUgc3RyaW5nXG4gIHV0aWwuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gIH07XG5cbiAgLyoqXG4gICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucHJvcGVydHlcbiAgKiBAcGFyYW0ge0Zsb2F0fSBwYXJhbXMuZHVyYXRpb25cbiAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnRpbWluZ1xuICAqL1xuICB1dGlsLmJ1aWxkVHJhbnNpdGlvblZhbHVlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgcGFyYW1zLnByb3BlcnR5ID0gcGFyYW1zLnByb3BlcnR5IHx8ICdhbGwnO1xuICAgIHBhcmFtcy5kdXJhdGlvbiA9IHBhcmFtcy5kdXJhdGlvbiB8fCAwLjQ7XG4gICAgcGFyYW1zLnRpbWluZyA9IHBhcmFtcy50aW1pbmcgfHwgJ2xpbmVhcic7XG5cbiAgICB2YXIgcHJvcHMgPSBwYXJhbXMucHJvcGVydHkuc3BsaXQoLyArLyk7XG5cbiAgICByZXR1cm4gcHJvcHMubWFwKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wICsgJyAnICsgcGFyYW1zLmR1cmF0aW9uICsgJ3MgJyArIHBhcmFtcy50aW1pbmc7XG4gICAgfSkuam9pbignLCAnKTtcbiAgfTtcblxuICAvKipcbiAgKiBBZGQgYW4gZXZlbnQgaGFuZGxlciBvbiBcInRyYW5zaXRpb25lbmRcIiBldmVudC5cbiAgKi9cbiAgdXRpbC5vbmNlT25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cblxuICAgIHZhciBmbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoZWxlbWVudCA9PSBldmVudC50YXJnZXQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB1dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVycztcbiAgfTtcblxuICB1dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKCdvbnRyYW5zaXRpb25lbmQnIGluIHdpbmRvdykge1xuICAgICAgcmV0dXJuIFsndHJhbnNpdGlvbmVuZCddO1xuICAgIH1cblxuICAgIGlmICgnb253ZWJraXR0cmFuc2l0aW9uZW5kJyBpbiB3aW5kb3cpIHtcbiAgICAgIHJldHVybiBbJ3dlYmtpdFRyYW5zaXRpb25FbmQnXTtcbiAgICB9XG5cbiAgICBpZiAodXRpbC52ZW5kb3JQcmVmaXggPT09ICd3ZWJraXQnIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbycgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdtb3onIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbXMnKSB7XG4gICAgICByZXR1cm4gW3V0aWwudmVuZG9yUHJlZml4ICsgJ1RyYW5zaXRpb25FbmQnLCAndHJhbnNpdGlvbmVuZCddO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfSkoKTtcblxuICB1dGlsLl9jc3NQcm9wZXJ0eURpY3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpO1xuICAgIHZhciBkaWN0ID0ge307XG4gICAgdmFyIGEgPSAnQScuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgeiA9ICd6Jy5jaGFyQ29kZUF0KDApO1xuXG4gICAgdmFyIHVwcGVyID0gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHMuc3Vic3RyKDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIHZhciBrZXkgPSBzdHlsZXNbaV1cbiAgICAgICAgLnJlcGxhY2UoL15bXFwtXSsvLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL1tcXC1dW2Etel0vZywgdXBwZXIpXG4gICAgICAgIC5yZXBsYWNlKC9ebW96LywgJ01veicpO1xuXG4gICAgICBpZiAoYSA8PSBrZXkuY2hhckNvZGVBdCgwKSAmJiB6ID49IGtleS5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIGlmIChrZXkgIT09ICdjc3NUZXh0JyAmJiBrZXkgIT09ICdwYXJlbnRUZXh0Jykge1xuICAgICAgICAgIGRpY3Rba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGljdDtcbiAgfSkoKTtcblxuICB1dGlsLmhhc0Nzc1Byb3BlcnR5ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBuYW1lIGluIHV0aWwuX2Nzc1Byb3BlcnR5RGljdDtcbiAgfTtcblxuICAvKipcbiAgICogVmVuZG9yIHByZWZpeCBmb3IgY3NzIHByb3BlcnR5LlxuICAgKi9cbiAgdXRpbC52ZW5kb3JQcmVmaXggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpLFxuICAgIHByZSA9IChBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgIC5jYWxsKHN0eWxlcylcbiAgICAgIC5qb2luKCcnKVxuICAgICAgLm1hdGNoKC8tKG1venx3ZWJraXR8bXMpLS8pIHx8IChzdHlsZXMuT0xpbmsgPT09ICcnICYmIFsnJywgJ28nXSlcbiAgICApWzFdO1xuICAgIHJldHVybiBwcmU7XG4gIH0pKCk7XG5cbiAgdXRpbC5mb3JjZUxheW91dEF0T25jZSA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmF0Y2hJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gZm9yY2UgbGF5b3V0XG4gICAgICAgIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgfSk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICB9O1xuXG4gIHV0aWwuYmF0Y2hJbW1lZGlhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGNvbmNyZWF0ZUNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgICBjYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICBjb25jcmVhdGVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIHV0aWwuYmF0Y2hBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG5cbiAgICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGNvbmNyZWF0ZUNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgICBjYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICBjb25jcmVhdGVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIHV0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZSA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSgndHJhbnNpdGlvbkR1cmF0aW9uJykpIHtcbiAgICAgIHJldHVybiAndHJhbnNpdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkodXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkR1cmF0aW9uJykpIHtcbiAgICAgIHJldHVybiB1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uJztcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfSkoKTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICB2YXIgQW5pbWl0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBbmltaXQpKSB7XG4gICAgICByZXR1cm4gbmV3IEFuaW1pdChlbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gW2VsZW1lbnRdO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsZW1lbnQpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkgb3IgYW4gaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy50cmFuc2l0aW9uUXVldWUgPSBbXTtcbiAgICB0aGlzLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3QgPSBbXTtcbiAgfTtcblxuICBBbmltaXQucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX1cbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uUXVldWU6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9XG4gICAgICovXG4gICAgZWxlbWVudHM6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGFuaW1hdGlvbiBzZXF1ZW5jZSB3aXRoIHBhc3NlZCBhbmltYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBwbGF5OiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1ZXVlIHRyYW5zaXRpb24gYW5pbWF0aW9ucyBvciBvdGhlciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2NvbG9yOiAncmVkJ30pXG4gICAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y29sb3I6ICdyZWQnfSwge2R1cmF0aW9uOiAwLjR9KVxuICAgICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2Nzczoge2NvbG9yOiAncmVkJ30sIGR1cmF0aW9uOiAwLjJ9KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8QW5pbWl0LlRyYW5zaXRpb258RnVuY3Rpb259IHRyYW5zaXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICovXG4gICAgcXVldWU6IGZ1bmN0aW9uKHRyYW5zaXRpb24sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBxdWV1ZSA9IHRoaXMudHJhbnNpdGlvblF1ZXVlO1xuXG4gICAgICBpZiAodHJhbnNpdGlvbiAmJiBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMuY3NzID0gdHJhbnNpdGlvbjtcbiAgICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbihvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IHRyYW5zaXRpb24gaW5zdGFuY2VvZiBBbmltaXQuVHJhbnNpdGlvbikpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24uY3NzKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKHtcbiAgICAgICAgICAgIGNzczogdHJhbnNpdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSB7XG4gICAgICAgIHF1ZXVlLnB1c2godHJhbnNpdGlvbi5idWlsZCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1ZXVlIHRyYW5zaXRpb24gYW5pbWF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXR9IHNlY29uZHNcbiAgICAgKi9cbiAgICB3YWl0OiBmdW5jdGlvbihzZWNvbmRzKSB7XG4gICAgICBpZiAoc2Vjb25kcyA+IDApIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgc2V0VGltZW91dChkb25lLCAxMDAwICogc2Vjb25kcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2F2ZVN0eWxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgIHZhciBjc3MgPSB0aGlzLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9IGVsZW1lbnQuc3R5bGVbZWxlbWVudC5zdHlsZVtpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZSBlbGVtZW50J3Mgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuZHVyYXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpbWluZ11cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHJhbnNpdGlvbl1cbiAgICAgKi9cbiAgICByZXN0b3JlU3R5bGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uICYmICFvcHRpb25zLmR1cmF0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJvcHRpb25zLmR1cmF0aW9uXCIgaXMgcmVxdWlyZWQgd2hlbiBcIm9wdGlvbnMudHJhbnNpdGlvblwiIGlzIGVuYWJsZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IHV0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZTtcblxuICAgICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbiB8fCAob3B0aW9ucy5kdXJhdGlvbiAmJiBvcHRpb25zLmR1cmF0aW9uID4gMCkpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IG9wdGlvbnMudHJhbnNpdGlvbiB8fCAoJ2FsbCAnICsgb3B0aW9ucy5kdXJhdGlvbiArICdzICcgKyAob3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcicpKTtcblxuICAgICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICAgIHZhciB0aW1lb3V0SWQ7XG5cbiAgICAgICAgICB2YXIgY2xlYXJUcmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBhZGQgXCJ0cmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlclxuICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSB1dGlsLm9uY2VPblRyYW5zaXRpb25FbmQoZWxlbWVudHNbMF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBjbGVhclRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGZvciBmYWlsIHNhZmUuXG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgY2xlYXJUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSwgb3B0aW9ucy5kdXJhdGlvbiAqIDEwMDAgKiBUSU1FT1VUX1JBVElPKTtcblxuICAgICAgICAgIC8vIHRyYW5zaXRpb24gYW5kIHN0eWxlIHNldHRpbmdzXG4gICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXG4gICAgICAgICAgICB2YXIgY3NzID0gc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXN0b3JlU3R5bGUoKTogVGhlIHN0eWxlIGlzIG5vdCBzYXZlZC4gSW52b2tlIHNhdmVTdHlsZSgpIGJlZm9yZS4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICBuYW1lID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICAgICAgaWYgKGNzc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY3NzW25hbWVdID0gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKGtleSAhPT0gdHJhbnNpdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gdHJhbnNpdGlvblZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAvLyBDbGVhciB0cmFuc2l0aW9uIGFuaW1hdGlvbiBzZXR0aW5ncy5cbiAgICAgICAgc2VsZi5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSAnbm9uZSc7XG5cbiAgICAgICAgICB2YXIgY3NzID0gc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XTtcblxuICAgICAgICAgIGlmICghY3NzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbmFtZSA9ICcnOyBpIDwgZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IGVsZW1lbnQuc3R5bGVbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gY3NzW2tleV07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGFuaW1hdGlvbiBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBzdGFydEFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9kZXF1ZXVlVHJhbnNpdGlvbigpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2RlcXVldWVUcmFuc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uUXVldWUuc2hpZnQoKTtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnJlbnQgdHJhbnNpdGlvbiBleGlzdHMuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgICAgIHZhciBkb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLl9jdXJyZW50VHJhbnNpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzZWxmLl9kZXF1ZXVlVHJhbnNpdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgdHdpY2UuJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRyYW5zaXRpb24uY2FsbCh0aGlzLCBkb25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBbmltaXR9IGFyZ3VtZW50c1xuICAgKi9cbiAgQW5pbWl0LnJ1bkFsbCA9IGZ1bmN0aW9uKC8qIGFyZ3VtZW50cy4uLiAqLykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmd1bWVudHNbaV0ucGxheSgpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kdXJhdGlvbl1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb3BlcnR5XVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxuICAgKi9cbiAgQW5pbWl0LlRyYW5zaXRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLm9wdGlvbnMuZHVyYXRpb24gPSB0aGlzLm9wdGlvbnMuZHVyYXRpb24gfHwgMDtcbiAgICB0aGlzLm9wdGlvbnMudGltaW5nID0gdGhpcy5vcHRpb25zLnRpbWluZyB8fCAnbGluZWFyJztcbiAgICB0aGlzLm9wdGlvbnMuY3NzID0gdGhpcy5vcHRpb25zLmNzcyB8fCB7fTtcbiAgICB0aGlzLm9wdGlvbnMucHJvcGVydHkgPSB0aGlzLm9wdGlvbnMucHJvcGVydHkgfHwgJ2FsbCc7XG4gIH07XG5cbiAgQW5pbWl0LlRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGJ1aWxkOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5jc3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuY3NzIGlzIHJlcXVpcmVkLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3NzID0gY3JlYXRlQWN0dWFsQ3NzUHJvcHModGhpcy5vcHRpb25zLmNzcyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24gPiAwKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uVmFsdWUgPSB1dGlsLmJ1aWxkVHJhbnNpdGlvblZhbHVlKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2VsZi5vcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU87XG4gICAgICAgICAgdmFyIHRpbWVvdXRJZDtcblxuICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSB1dGlsLm9uY2VPblRyYW5zaXRpb25FbmQoZWxlbWVudHNbMF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWVdID0gdHJhbnNpdGlvblZhbHVlO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gY3NzW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbiA8PSAwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lXSA9ICcnO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gY3NzW25hbWVdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdXRpbC5mb3JjZUxheW91dEF0T25jZShlbGVtZW50cywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHV0aWwuYmF0Y2hBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdHVhbENzc1Byb3BzKGNzcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjc3NbbmFtZV07XG5cbiAgICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByZWZpeGVkID0gdXRpbC52ZW5kb3JQcmVmaXggKyB1dGlsLmNhcGl0YWxpemUobmFtZSk7XG4gICAgICAgICAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkocHJlZml4ZWQpKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlZml4ZWRdID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVmaXhlZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgIH1cbiAgfTtcblxuXG4gIHJldHVybiBBbmltaXQ7XG59KSgpO1xuIiwiLypcclxuICogY2hpbGROb2RlLnJlbW92ZSBtZXRob2QgcG9seWZpbGwgZm9yIElFLlxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2hpbGROb2RlL3JlbW92ZVxyXG4gKi9cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHRpZiAoISgncmVtb3ZlJyBpbiBFbGVtZW50LnByb3RvdHlwZSkpIHtcclxuXHQgIEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdCAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcblx0ICAgIFx0dGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdH1cclxufSkoKTtcclxuIiwiLypcclxuICogY2xhc3NMaXN0LmpzOiBDcm9zcy1icm93c2VyIGZ1bGwgZWxlbWVudC5jbGFzc0xpc3QgaW1wbGVtZW50YXRpb24uXHJcbiAqIDEuMS4yMDE1MDMxMlxyXG4gKlxyXG4gKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXHJcbiAqIExpY2Vuc2U6IERlZGljYXRlZCB0byB0aGUgcHVibGljIGRvbWFpbi5cclxuICogICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcclxuICovXHJcblxyXG4vKmdsb2JhbCBzZWxmLCBkb2N1bWVudCwgRE9NRXhjZXB0aW9uICovXHJcblxyXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvY2xhc3NMaXN0LmpzL2Jsb2IvbWFzdGVyL2NsYXNzTGlzdC5qcyAqL1xyXG5cclxuaWYgKFwiZG9jdW1lbnRcIiBpbiBzZWxmKSB7XHJcblxyXG4vLyBGdWxsIHBvbHlmaWxsIGZvciBicm93c2VycyB3aXRoIG5vIGNsYXNzTGlzdCBzdXBwb3J0XHJcbi8vIEluY2x1ZGluZyBJRSA8IEVkZ2UgbWlzc2luZyBTVkdFbGVtZW50LmNsYXNzTGlzdFxyXG5pZiAoIShcImNsYXNzTGlzdFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpKVxyXG4gIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiAhKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcImdcIikpKSB7XHJcblxyXG4oZnVuY3Rpb24gKHZpZXcpIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuaWYgKCEoJ0VsZW1lbnQnIGluIHZpZXcpKSByZXR1cm47XHJcblxyXG52YXJcclxuICAgIGNsYXNzTGlzdFByb3AgPSBcImNsYXNzTGlzdFwiXHJcbiAgLCBwcm90b1Byb3AgPSBcInByb3RvdHlwZVwiXHJcbiAgLCBlbGVtQ3RyUHJvdG8gPSB2aWV3LkVsZW1lbnRbcHJvdG9Qcm9wXVxyXG4gICwgb2JqQ3RyID0gT2JqZWN0XHJcbiAgLCBzdHJUcmltID0gU3RyaW5nW3Byb3RvUHJvcF0udHJpbSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKTtcclxuICB9XHJcbiAgLCBhcnJJbmRleE9mID0gQXJyYXlbcHJvdG9Qcm9wXS5pbmRleE9mIHx8IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICB2YXJcclxuICAgICAgICBpID0gMFxyXG4gICAgICAsIGxlbiA9IHRoaXMubGVuZ3RoXHJcbiAgICA7XHJcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG4gIC8vIFZlbmRvcnM6IHBsZWFzZSBhbGxvdyBjb250ZW50IGNvZGUgdG8gaW5zdGFudGlhdGUgRE9NRXhjZXB0aW9uc1xyXG4gICwgRE9NRXggPSBmdW5jdGlvbiAodHlwZSwgbWVzc2FnZSkge1xyXG4gICAgdGhpcy5uYW1lID0gdHlwZTtcclxuICAgIHRoaXMuY29kZSA9IERPTUV4Y2VwdGlvblt0eXBlXTtcclxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgfVxyXG4gICwgY2hlY2tUb2tlbkFuZEdldEluZGV4ID0gZnVuY3Rpb24gKGNsYXNzTGlzdCwgdG9rZW4pIHtcclxuICAgIGlmICh0b2tlbiA9PT0gXCJcIikge1xyXG4gICAgICB0aHJvdyBuZXcgRE9NRXgoXHJcbiAgICAgICAgICBcIlNZTlRBWF9FUlJcIlxyXG4gICAgICAgICwgXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWRcIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgaWYgKC9cXHMvLnRlc3QodG9rZW4pKSB7XHJcbiAgICAgIHRocm93IG5ldyBET01FeChcclxuICAgICAgICAgIFwiSU5WQUxJRF9DSEFSQUNURVJfRVJSXCJcclxuICAgICAgICAsIFwiU3RyaW5nIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcmFjdGVyXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJJbmRleE9mLmNhbGwoY2xhc3NMaXN0LCB0b2tlbik7XHJcbiAgfVxyXG4gICwgQ2xhc3NMaXN0ID0gZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgIHZhclxyXG4gICAgICAgIHRyaW1tZWRDbGFzc2VzID0gc3RyVHJpbS5jYWxsKGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIilcclxuICAgICAgLCBjbGFzc2VzID0gdHJpbW1lZENsYXNzZXMgPyB0cmltbWVkQ2xhc3Nlcy5zcGxpdCgvXFxzKy8pIDogW11cclxuICAgICAgLCBpID0gMFxyXG4gICAgICAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoXHJcbiAgICA7XHJcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIHRoaXMucHVzaChjbGFzc2VzW2ldKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLnRvU3RyaW5nKCkpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgLCBjbGFzc0xpc3RQcm90byA9IENsYXNzTGlzdFtwcm90b1Byb3BdID0gW11cclxuICAsIGNsYXNzTGlzdEdldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuZXcgQ2xhc3NMaXN0KHRoaXMpO1xyXG4gIH1cclxuO1xyXG4vLyBNb3N0IERPTUV4Y2VwdGlvbiBpbXBsZW1lbnRhdGlvbnMgZG9uJ3QgYWxsb3cgY2FsbGluZyBET01FeGNlcHRpb24ncyB0b1N0cmluZygpXHJcbi8vIG9uIG5vbi1ET01FeGNlcHRpb25zLiBFcnJvcidzIHRvU3RyaW5nKCkgaXMgc3VmZmljaWVudCBoZXJlLlxyXG5ET01FeFtwcm90b1Byb3BdID0gRXJyb3JbcHJvdG9Qcm9wXTtcclxuY2xhc3NMaXN0UHJvdG8uaXRlbSA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgcmV0dXJuIHRoaXNbaV0gfHwgbnVsbDtcclxufTtcclxuY2xhc3NMaXN0UHJvdG8uY29udGFpbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICB0b2tlbiArPSBcIlwiO1xyXG4gIHJldHVybiBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pICE9PSAtMTtcclxufTtcclxuY2xhc3NMaXN0UHJvdG8uYWRkID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhclxyXG4gICAgICB0b2tlbnMgPSBhcmd1bWVudHNcclxuICAgICwgaSA9IDBcclxuICAgICwgbCA9IHRva2Vucy5sZW5ndGhcclxuICAgICwgdG9rZW5cclxuICAgICwgdXBkYXRlZCA9IGZhbHNlXHJcbiAgO1xyXG4gIGRvIHtcclxuICAgIHRva2VuID0gdG9rZW5zW2ldICsgXCJcIjtcclxuICAgIGlmIChjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pID09PSAtMSkge1xyXG4gICAgICB0aGlzLnB1c2godG9rZW4pO1xyXG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgd2hpbGUgKCsraSA8IGwpO1xyXG5cclxuICBpZiAodXBkYXRlZCkge1xyXG4gICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XHJcbiAgfVxyXG59O1xyXG5jbGFzc0xpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyXHJcbiAgICAgIHRva2VucyA9IGFyZ3VtZW50c1xyXG4gICAgLCBpID0gMFxyXG4gICAgLCBsID0gdG9rZW5zLmxlbmd0aFxyXG4gICAgLCB0b2tlblxyXG4gICAgLCB1cGRhdGVkID0gZmFsc2VcclxuICAgICwgaW5kZXhcclxuICA7XHJcbiAgZG8ge1xyXG4gICAgdG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xyXG4gICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xyXG4gICAgd2hpbGUgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICB0aGlzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHdoaWxlICgrK2kgPCBsKTtcclxuXHJcbiAgaWYgKHVwZGF0ZWQpIHtcclxuICAgIHRoaXMuX3VwZGF0ZUNsYXNzTmFtZSgpO1xyXG4gIH1cclxufTtcclxuY2xhc3NMaXN0UHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gKHRva2VuLCBmb3JjZSkge1xyXG4gIHRva2VuICs9IFwiXCI7XHJcblxyXG4gIHZhclxyXG4gICAgICByZXN1bHQgPSB0aGlzLmNvbnRhaW5zKHRva2VuKVxyXG4gICAgLCBtZXRob2QgPSByZXN1bHQgP1xyXG4gICAgICBmb3JjZSAhPT0gdHJ1ZSAmJiBcInJlbW92ZVwiXHJcbiAgICA6XHJcbiAgICAgIGZvcmNlICE9PSBmYWxzZSAmJiBcImFkZFwiXHJcbiAgO1xyXG5cclxuICBpZiAobWV0aG9kKSB7XHJcbiAgICB0aGlzW21ldGhvZF0odG9rZW4pO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZvcmNlID09PSB0cnVlIHx8IGZvcmNlID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZvcmNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gIXJlc3VsdDtcclxuICB9XHJcbn07XHJcbmNsYXNzTGlzdFByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLmpvaW4oXCIgXCIpO1xyXG59O1xyXG5cclxuaWYgKG9iakN0ci5kZWZpbmVQcm9wZXJ0eSkge1xyXG4gIHZhciBjbGFzc0xpc3RQcm9wRGVzYyA9IHtcclxuICAgICAgZ2V0OiBjbGFzc0xpc3RHZXR0ZXJcclxuICAgICwgZW51bWVyYWJsZTogdHJ1ZVxyXG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcclxuICB9O1xyXG4gIHRyeSB7XHJcbiAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XHJcbiAgfSBjYXRjaCAoZXgpIHsgLy8gSUUgOCBkb2Vzbid0IHN1cHBvcnQgZW51bWVyYWJsZTp0cnVlXHJcbiAgICBpZiAoZXgubnVtYmVyID09PSAtMHg3RkY1RUM1NCkge1xyXG4gICAgICBjbGFzc0xpc3RQcm9wRGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcclxuICAgIH1cclxuICB9XHJcbn0gZWxzZSBpZiAob2JqQ3RyW3Byb3RvUHJvcF0uX19kZWZpbmVHZXR0ZXJfXykge1xyXG4gIGVsZW1DdHJQcm90by5fX2RlZmluZUdldHRlcl9fKGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdEdldHRlcik7XHJcbn1cclxuXHJcbn0oc2VsZikpO1xyXG5cclxufSBlbHNlIHtcclxuLy8gVGhlcmUgaXMgZnVsbCBvciBwYXJ0aWFsIG5hdGl2ZSBjbGFzc0xpc3Qgc3VwcG9ydCwgc28ganVzdCBjaGVjayBpZiB3ZSBuZWVkXHJcbi8vIHRvIG5vcm1hbGl6ZSB0aGUgYWRkL3JlbW92ZSBhbmQgdG9nZ2xlIEFQSXMuXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiX1wiKTtcclxuXHJcbiAgdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImMxXCIsIFwiYzJcIik7XHJcblxyXG4gIC8vIFBvbHlmaWxsIGZvciBJRSAxMC8xMSBhbmQgRmlyZWZveCA8MjYsIHdoZXJlIGNsYXNzTGlzdC5hZGQgYW5kXHJcbiAgLy8gY2xhc3NMaXN0LnJlbW92ZSBleGlzdCBidXQgc3VwcG9ydCBvbmx5IG9uZSBhcmd1bWVudCBhdCBhIHRpbWUuXHJcbiAgaWYgKCF0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjMlwiKSkge1xyXG4gICAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCkge1xyXG4gICAgICB2YXIgb3JpZ2luYWwgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF07XHJcblxyXG4gICAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih0b2tlbikge1xyXG4gICAgICAgIHZhciBpLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIHRva2VuID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgb3JpZ2luYWwuY2FsbCh0aGlzLCB0b2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIGNyZWF0ZU1ldGhvZCgnYWRkJyk7XHJcbiAgICBjcmVhdGVNZXRob2QoJ3JlbW92ZScpO1xyXG4gIH1cclxuXHJcbiAgdGVzdEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcImMzXCIsIGZhbHNlKTtcclxuXHJcbiAgLy8gUG9seWZpbGwgZm9yIElFIDEwIGFuZCBGaXJlZm94IDwyNCwgd2hlcmUgY2xhc3NMaXN0LnRvZ2dsZSBkb2VzIG5vdFxyXG4gIC8vIHN1cHBvcnQgdGhlIHNlY29uZCBhcmd1bWVudC5cclxuICBpZiAodGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYzNcIikpIHtcclxuICAgIHZhciBfdG9nZ2xlID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGU7XHJcblxyXG4gICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbih0b2tlbiwgZm9yY2UpIHtcclxuICAgICAgaWYgKDEgaW4gYXJndW1lbnRzICYmICF0aGlzLmNvbnRhaW5zKHRva2VuKSA9PT0gIWZvcmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcmNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBfdG9nZ2xlLmNhbGwodGhpcywgdG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICB9XHJcblxyXG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcclxufSgpKTtcclxuXHJcbn1cclxuXHJcbn1cclxuXHJcbiIsIjsoZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIEBwcmVzZXJ2ZSBGYXN0Q2xpY2s6IHBvbHlmaWxsIHRvIHJlbW92ZSBjbGljayBkZWxheXMgb24gYnJvd3NlcnMgd2l0aCB0b3VjaCBVSXMuXG5cdCAqXG5cdCAqIEBjb2RpbmdzdGFuZGFyZCBmdGxhYnMtanN2MlxuXHQgKiBAY29weXJpZ2h0IFRoZSBGaW5hbmNpYWwgVGltZXMgTGltaXRlZCBbQWxsIFJpZ2h0cyBSZXNlcnZlZF1cblx0ICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcblx0ICovXG5cblx0Lypqc2xpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xuXHQvKmdsb2JhbCBkZWZpbmUsIEV2ZW50LCBOb2RlKi9cblxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBmYXN0LWNsaWNraW5nIGxpc3RlbmVycyBvbiB0aGUgc3BlY2lmaWVkIGxheWVyLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdCAqL1xuXHRmdW5jdGlvbiBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpIHtcblx0XHR2YXIgb2xkT25DbGljaztcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBhIGNsaWNrIGlzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaW1lc3RhbXAgZm9yIHdoZW4gY2xpY2sgdHJhY2tpbmcgc3RhcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVsZW1lbnQgYmVpbmcgdHJhY2tlZCBmb3IgYSBjbGljay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIEV2ZW50VGFyZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogWC1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFktY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBJRCBvZiB0aGUgbGFzdCB0b3VjaCwgcmV0cmlldmVkIGZyb20gVG91Y2guaWRlbnRpZmllci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRvdWNobW92ZSBib3VuZGFyeSwgYmV5b25kIHdoaWNoIGEgY2xpY2sgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoQm91bmRhcnkgPSBvcHRpb25zLnRvdWNoQm91bmRhcnkgfHwgMTA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBGYXN0Q2xpY2sgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIHRhcCh0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCkgZXZlbnRzXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRhcERlbGF5ID0gb3B0aW9ucy50YXBEZWxheSB8fCAyMDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBhIHRhcFxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBUaW1lb3V0ID0gb3B0aW9ucy50YXBUaW1lb3V0IHx8IDcwMDtcblxuXHRcdGlmIChGYXN0Q2xpY2subm90TmVlZGVkKGxheWVyKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIEFuZHJvaWQgZG9uJ3QgaGF2ZSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXHRcdGZ1bmN0aW9uIGJpbmQobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTsgfTtcblx0XHR9XG5cblxuXHRcdHZhciBtZXRob2RzID0gWydvbk1vdXNlJywgJ29uQ2xpY2snLCAnb25Ub3VjaFN0YXJ0JywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaENhbmNlbCddO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb250ZXh0W21ldGhvZHNbaV1dID0gYmluZChjb250ZXh0W21ldGhvZHNbaV1dLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnMgYXMgcmVxdWlyZWRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXG5cdFx0Ly8gSGFjayBpcyByZXF1aXJlZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoZS5nLiBBbmRyb2lkIDIpXG5cdFx0Ly8gd2hpY2ggaXMgaG93IEZhc3RDbGljayBub3JtYWxseSBzdG9wcyBjbGljayBldmVudHMgYnViYmxpbmcgdG8gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgb24gdGhlIEZhc3RDbGlja1xuXHRcdC8vIGxheWVyIHdoZW4gdGhleSBhcmUgY2FuY2VsbGVkLlxuXHRcdGlmICghRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBybXYgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm12LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBhZHYgPSBOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCAoY2FsbGJhY2suaGlqYWNrZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLCBjYXB0dXJlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmIGEgaGFuZGxlciBpcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoZSBlbGVtZW50J3Mgb25jbGljayBhdHRyaWJ1dGUsIGl0IHdpbGwgYmUgZmlyZWQgYmVmb3JlXG5cdFx0Ly8gRmFzdENsaWNrJ3Mgb25DbGljayBoYW5kbGVyLiBGaXggdGhpcyBieSBwdWxsaW5nIG91dCB0aGUgdXNlci1kZWZpbmVkIGhhbmRsZXIgZnVuY3Rpb24gYW5kXG5cdFx0Ly8gYWRkaW5nIGl0IGFzIGxpc3RlbmVyLlxuXHRcdGlmICh0eXBlb2YgbGF5ZXIub25jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXG5cdFx0XHQvLyBBbmRyb2lkIGJyb3dzZXIgb24gYXQgbGVhc3QgMy4yIHJlcXVpcmVzIGEgbmV3IHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gaW4gbGF5ZXIub25jbGlja1xuXHRcdFx0Ly8gLSB0aGUgb2xkIG9uZSB3b24ndCB3b3JrIGlmIHBhc3NlZCB0byBhZGRFdmVudExpc3RlbmVyIGRpcmVjdGx5LlxuXHRcdFx0b2xkT25DbGljayA9IGxheWVyLm9uY2xpY2s7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdG9sZE9uQ2xpY2soZXZlbnQpO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0bGF5ZXIub25jbGljayA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogV2luZG93cyBQaG9uZSA4LjEgZmFrZXMgdXNlciBhZ2VudCBzdHJpbmcgdG8gbG9vayBsaWtlIEFuZHJvaWQgYW5kIGlQaG9uZS5cblx0KlxuXHQqIEB0eXBlIGJvb2xlYW5cblx0Ki9cblx0dmFyIGRldmljZUlzV2luZG93c1Bob25lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+PSAwO1xuXG5cdC8qKlxuXHQgKiBBbmRyb2lkIHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA+IDAgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1MgPSAvaVAoYWR8aG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA0IHJlcXVpcmVzIGFuIGV4Y2VwdGlvbiBmb3Igc2VsZWN0IGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1M0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyA0X1xcZChfXFxkKT8vKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA2LjAtNy4qIHJlcXVpcmVzIHRoZSB0YXJnZXQgZWxlbWVudCB0byBiZSBtYW51YWxseSBkZXJpdmVkXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQgPSBkZXZpY2VJc0lPUyAmJiAoL09TIFs2LTddX1xcZC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0LyoqXG5cdCAqIEJsYWNrQmVycnkgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzQmxhY2tCZXJyeTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdCQjEwJykgPiAwO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBuYXRpdmUgY2xpY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IG5lZWRzIGEgbmF0aXZlIGNsaWNrXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cblx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIHRvIGRpc2FibGVkIGlucHV0cyAoaXNzdWUgIzYyKVxuXHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRjYXNlICd0ZXh0YXJlYSc6XG5cdFx0XHRpZiAodGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdC8vIEZpbGUgaW5wdXRzIG5lZWQgcmVhbCBjbGlja3Mgb24gaU9TIDYgZHVlIHRvIGEgYnJvd3NlciBidWcgKGlzc3VlICM2OClcblx0XHRcdGlmICgoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0LnR5cGUgPT09ICdmaWxlJykgfHwgdGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbCc6XG5cdFx0Y2FzZSAnaWZyYW1lJzogLy8gaU9TOCBob21lc2NyZWVuIGFwcHMgY2FuIHByZXZlbnQgZXZlbnRzIGJ1YmJsaW5nIGludG8gZnJhbWVzXG5cdFx0Y2FzZSAndmlkZW8nOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvXFxibmVlZHNjbGlja1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBjbGljayBpbnRvIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBuYXRpdmUgY2xpY2suXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzRm9jdXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRcdHJldHVybiAhZGV2aWNlSXNBbmRyb2lkO1xuXHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0XHRjYXNlICdjaGVja2JveCc6XG5cdFx0XHRjYXNlICdmaWxlJzpcblx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdGNhc2UgJ3JhZGlvJzpcblx0XHRcdGNhc2UgJ3N1Ym1pdCc6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gcG9pbnQgaW4gYXR0ZW1wdGluZyB0byBmb2N1cyBkaXNhYmxlZCBpbnB1dHNcblx0XHRcdHJldHVybiAhdGFyZ2V0LmRpc2FibGVkICYmICF0YXJnZXQucmVhZE9ubHk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAoL1xcYm5lZWRzZm9jdXNcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuc2VuZENsaWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnQpIHtcblx0XHR2YXIgY2xpY2tFdmVudCwgdG91Y2g7XG5cblx0XHQvLyBPbiBzb21lIEFuZHJvaWQgZGV2aWNlcyBhY3RpdmVFbGVtZW50IG5lZWRzIHRvIGJlIGJsdXJyZWQgb3RoZXJ3aXNlIHRoZSBzeW50aGV0aWMgY2xpY2sgd2lsbCBoYXZlIG5vIGVmZmVjdCAoIzI0KVxuXHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldEVsZW1lbnQpIHtcblx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcdH1cblxuXHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHQvLyBTeW50aGVzaXplIGEgY2xpY2sgZXZlbnQsIHdpdGggYW4gZXh0cmEgYXR0cmlidXRlIHNvIGl0IGNhbiBiZSB0cmFja2VkXG5cdFx0Y2xpY2tFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdGNsaWNrRXZlbnQuaW5pdE1vdXNlRXZlbnQodGhpcy5kZXRlcm1pbmVFdmVudFR5cGUodGFyZ2V0RWxlbWVudCksIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHRcdGNsaWNrRXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCA9IHRydWU7XG5cdFx0dGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuXHR9O1xuXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGV0ZXJtaW5lRXZlbnRUeXBlID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXG5cdFx0Ly9Jc3N1ZSAjMTU5OiBBbmRyb2lkIENocm9tZSBTZWxlY3QgQm94IGRvZXMgbm90IG9wZW4gd2l0aCBhIHN5bnRoZXRpYyBjbGljayBldmVudFxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQgJiYgdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRyZXR1cm4gJ21vdXNlZG93bic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdjbGljayc7XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHZhciBsZW5ndGg7XG5cblx0XHQvLyBJc3N1ZSAjMTYwOiBvbiBpT1MgNywgc29tZSBpbnB1dCBlbGVtZW50cyAoZS5nLiBkYXRlIGRhdGV0aW1lIG1vbnRoKSB0aHJvdyBhIHZhZ3VlIFR5cGVFcnJvciBvbiBzZXRTZWxlY3Rpb25SYW5nZS4gVGhlc2UgZWxlbWVudHMgZG9uJ3QgaGF2ZSBhbiBpbnRlZ2VyIHZhbHVlIGZvciB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBwcm9wZXJ0aWVzLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0IGNhbid0IGJlIHVzZWQgZm9yIGRldGVjdGlvbiBiZWNhdXNlIGFjY2Vzc2luZyB0aGUgcHJvcGVydGllcyBhbHNvIHRocm93cyBhIFR5cGVFcnJvci4gSnVzdCBjaGVjayB0aGUgdHlwZSBpbnN0ZWFkLiBGaWxlZCBhcyBBcHBsZSBidWcgIzE1MTIyNzI0LlxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiB0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlICYmIHRhcmdldEVsZW1lbnQudHlwZS5pbmRleE9mKCdkYXRlJykgIT09IDAgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAndGltZScgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAnbW9udGgnKSB7XG5cdFx0XHRsZW5ndGggPSB0YXJnZXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcblx0XHRcdHRhcmdldEVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyIGFuZCBpZiBzbywgc2V0IGEgZmxhZyBvbiBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnVwZGF0ZVNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50LCBwYXJlbnRFbGVtZW50O1xuXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cblx0XHQvLyBBdHRlbXB0IHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxhYmxlIGxheWVyLiBSZS1jaGVjayBpZiB0aGVcblx0XHQvLyB0YXJnZXQgZWxlbWVudCB3YXMgbW92ZWQgdG8gYW5vdGhlciBwYXJlbnQuXG5cdFx0aWYgKCFzY3JvbGxQYXJlbnQgfHwgIXNjcm9sbFBhcmVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0cGFyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChwYXJlbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcblx0XHRcdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fSB3aGlsZSAocGFyZW50RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgc2Nyb2xsIHRvcCB0cmFja2VyIGlmIHBvc3NpYmxlLlxuXHRcdGlmIChzY3JvbGxQYXJlbnQpIHtcblx0XHRcdHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0RWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxFdmVudFRhcmdldH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50VGFyZ2V0KSB7XG5cblx0XHQvLyBPbiBzb21lIG9sZGVyIGJyb3dzZXJzIChub3RhYmx5IFNhZmFyaSBvbiBpT1MgNC4xIC0gc2VlIGlzc3VlICM1NikgdGhlIGV2ZW50IHRhcmdldCBtYXkgYmUgYSB0ZXh0IG5vZGUuXG5cdFx0aWYgKGV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0cmV0dXJuIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50VGFyZ2V0O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIHN0YXJ0LCByZWNvcmQgdGhlIHBvc2l0aW9uIGFuZCBzY3JvbGwgb2Zmc2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0RWxlbWVudCwgdG91Y2gsIHNlbGVjdGlvbjtcblxuXHRcdC8vIElnbm9yZSBtdWx0aXBsZSB0b3VjaGVzLCBvdGhlcndpc2UgcGluY2gtdG8tem9vbSBpcyBwcmV2ZW50ZWQgaWYgYm90aCBmaW5nZXJzIGFyZSBvbiB0aGUgRmFzdENsaWNrIGVsZW1lbnQgKGlzc3VlICMxMTEpLlxuXHRcdGlmIChldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KTtcblx0XHR0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MpIHtcblxuXHRcdFx0Ly8gT25seSB0cnVzdGVkIGV2ZW50cyB3aWxsIGRlc2VsZWN0IHRleHQgb24gaU9TIChpc3N1ZSAjNDkpXG5cdFx0XHRzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgJiYgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZXZpY2VJc0lPUzQpIHtcblxuXHRcdFx0XHQvLyBXZWlyZCB0aGluZ3MgaGFwcGVuIG9uIGlPUyB3aGVuIGFuIGFsZXJ0IG9yIGNvbmZpcm0gZGlhbG9nIGlzIG9wZW5lZCBmcm9tIGEgY2xpY2sgZXZlbnQgY2FsbGJhY2sgKGlzc3VlICMyMyk6XG5cdFx0XHRcdC8vIHdoZW4gdGhlIHVzZXIgbmV4dCB0YXBzIGFueXdoZXJlIGVsc2Ugb24gdGhlIHBhZ2UsIG5ldyB0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCBldmVudHMgYXJlIGRpc3BhdGNoZWRcblx0XHRcdFx0Ly8gd2l0aCB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIHRoZSB0b3VjaCBldmVudCB0aGF0IHByZXZpb3VzbHkgdHJpZ2dlcmVkIHRoZSBjbGljayB0aGF0IHRyaWdnZXJlZCB0aGUgYWxlcnQuXG5cdFx0XHRcdC8vIFNhZGx5LCB0aGVyZSBpcyBhbiBpc3N1ZSBvbiBpT1MgNCB0aGF0IGNhdXNlcyBzb21lIG5vcm1hbCB0b3VjaCBldmVudHMgdG8gaGF2ZSB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIGFuXG5cdFx0XHRcdC8vIGltbWVkaWF0ZWx5IHByZWNlZGluZyB0b3VjaCBldmVudCAoaXNzdWUgIzUyKSwgc28gdGhpcyBmaXggaXMgdW5hdmFpbGFibGUgb24gdGhhdCBwbGF0Zm9ybS5cblx0XHRcdFx0Ly8gSXNzdWUgMTIwOiB0b3VjaC5pZGVudGlmaWVyIGlzIDAgd2hlbiBDaHJvbWUgZGV2IHRvb2xzICdFbXVsYXRlIHRvdWNoIGV2ZW50cycgaXMgc2V0IHdpdGggYW4gaU9TIGRldmljZSBVQSBzdHJpbmcsXG5cdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBhbGwgdG91Y2ggZXZlbnRzIHRvIGJlIGlnbm9yZWQuIEFzIHRoaXMgYmxvY2sgb25seSBhcHBsaWVzIHRvIGlPUywgYW5kIGlPUyBpZGVudGlmaWVycyBhcmUgYWx3YXlzIGxvbmcsXG5cdFx0XHRcdC8vIHJhbmRvbSBpbnRlZ2VycywgaXQncyBzYWZlIHRvIHRvIGNvbnRpbnVlIGlmIHRoZSBpZGVudGlmaWVyIGlzIDAgaGVyZS5cblx0XHRcdFx0aWYgKHRvdWNoLmlkZW50aWZpZXIgJiYgdG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuXG5cdFx0XHRcdC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIGEgc2Nyb2xsYWJsZSBsYXllciAodXNpbmcgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoKSBhbmQ6XG5cdFx0XHRcdC8vIDEpIHRoZSB1c2VyIGRvZXMgYSBmbGluZyBzY3JvbGwgb24gdGhlIHNjcm9sbGFibGUgbGF5ZXJcblx0XHRcdFx0Ly8gMikgdGhlIHVzZXIgc3RvcHMgdGhlIGZsaW5nIHNjcm9sbCB3aXRoIGFub3RoZXIgdGFwXG5cdFx0XHRcdC8vIHRoZW4gdGhlIGV2ZW50LnRhcmdldCBvZiB0aGUgbGFzdCAndG91Y2hlbmQnIGV2ZW50IHdpbGwgYmUgdGhlIGVsZW1lbnQgdGhhdCB3YXMgdW5kZXIgdGhlIHVzZXIncyBmaW5nZXJcblx0XHRcdFx0Ly8gd2hlbiB0aGUgZmxpbmcgc2Nyb2xsIHdhcyBzdGFydGVkLCBjYXVzaW5nIEZhc3RDbGljayB0byBzZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhhdCBsYXllciAtIHVubGVzcyBhIGNoZWNrXG5cdFx0XHRcdC8vIGlzIG1hZGUgdG8gZW5zdXJlIHRoYXQgYSBwYXJlbnQgbGF5ZXIgd2FzIG5vdCBzY3JvbGxlZCBiZWZvcmUgc2VuZGluZyBhIHN5bnRoZXRpYyBjbGljayAoaXNzdWUgIzQyKS5cblx0XHRcdFx0dGhpcy51cGRhdGVTY3JvbGxQYXJlbnQodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gdHJ1ZTtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IGV2ZW50LnRpbWVTdGFtcDtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IHRvdWNoLnBhZ2VYO1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSB0b3VjaC5wYWdlWTtcblxuXHRcdC8vIFByZXZlbnQgcGhhbnRvbSBjbGlja3Mgb24gZmFzdCBkb3VibGUtdGFwIChpc3N1ZSAjMzYpXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpIDwgdGhpcy50YXBEZWxheSAmJiAoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA+IC0xKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEJhc2VkIG9uIGEgdG91Y2htb3ZlIGV2ZW50IG9iamVjdCwgY2hlY2sgd2hldGhlciB0aGUgdG91Y2ggaGFzIG1vdmVkIHBhc3QgYSBib3VuZGFyeSBzaW5jZSBpdCBzdGFydGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUudG91Y2hIYXNNb3ZlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0sIGJvdW5kYXJ5ID0gdGhpcy50b3VjaEJvdW5kYXJ5O1xuXG5cdFx0aWYgKE1hdGguYWJzKHRvdWNoLnBhZ2VYIC0gdGhpcy50b3VjaFN0YXJ0WCkgPiBib3VuZGFyeSB8fCBNYXRoLmFicyh0b3VjaC5wYWdlWSAtIHRoaXMudG91Y2hTdGFydFkpID4gYm91bmRhcnkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGxhc3QgcG9zaXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLnRyYWNraW5nQ2xpY2spIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSB0b3VjaCBoYXMgbW92ZWQsIGNhbmNlbCB0aGUgY2xpY2sgdHJhY2tpbmdcblx0XHRpZiAodGhpcy50YXJnZXRFbGVtZW50ICE9PSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KSB8fCB0aGlzLnRvdWNoSGFzTW92ZWQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBmaW5kIHRoZSBsYWJlbGxlZCBjb250cm9sIGZvciB0aGUgZ2l2ZW4gbGFiZWwgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxIVE1MTGFiZWxFbGVtZW50fSBsYWJlbEVsZW1lbnRcblx0ICogQHJldHVybnMge0VsZW1lbnR8bnVsbH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZmluZENvbnRyb2wgPSBmdW5jdGlvbihsYWJlbEVsZW1lbnQpIHtcblxuXHRcdC8vIEZhc3QgcGF0aCBmb3IgbmV3ZXIgYnJvd3NlcnMgc3VwcG9ydGluZyB0aGUgSFRNTDUgY29udHJvbCBhdHRyaWJ1dGVcblx0XHRpZiAobGFiZWxFbGVtZW50LmNvbnRyb2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGxhYmVsRWxlbWVudC5jb250cm9sO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBicm93c2VycyB1bmRlciB0ZXN0IHRoYXQgc3VwcG9ydCB0b3VjaCBldmVudHMgYWxzbyBzdXBwb3J0IHRoZSBIVE1MNSBodG1sRm9yIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuaHRtbEZvcikge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxhYmVsRWxlbWVudC5odG1sRm9yKTtcblx0XHR9XG5cblx0XHQvLyBJZiBubyBmb3IgYXR0cmlidXRlIGV4aXN0cywgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgZmlyc3QgbGFiZWxsYWJsZSBkZXNjZW5kYW50IGVsZW1lbnRcblx0XHQvLyB0aGUgbGlzdCBvZiB3aGljaCBpcyBkZWZpbmVkIGhlcmU6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGFiZWxcblx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbiwgaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pLCBrZXlnZW4sIG1ldGVyLCBvdXRwdXQsIHByb2dyZXNzLCBzZWxlY3QsIHRleHRhcmVhJyk7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggZW5kLCBkZXRlcm1pbmUgd2hldGhlciB0byBzZW5kIGEgY2xpY2sgZXZlbnQgYXQgb25jZS5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBmb3JFbGVtZW50LCB0cmFja2luZ0NsaWNrU3RhcnQsIHRhcmdldFRhZ05hbWUsIHNjcm9sbFBhcmVudCwgdG91Y2gsIHRhcmdldEVsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQ7XG5cblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCBwaGFudG9tIGNsaWNrcyBvbiBmYXN0IGRvdWJsZS10YXAgKGlzc3VlICMzNilcblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPCB0aGlzLnRhcERlbGF5ICYmIChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpID4gLTEpIHtcblx0XHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQpID4gdGhpcy50YXBUaW1lb3V0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBSZXNldCB0byBwcmV2ZW50IHdyb25nIGNsaWNrIGNhbmNlbCBvbiBpbnB1dCAoaXNzdWUgIzE1NikuXG5cdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSBmYWxzZTtcblxuXHRcdHRoaXMubGFzdENsaWNrVGltZSA9IGV2ZW50LnRpbWVTdGFtcDtcblxuXHRcdHRyYWNraW5nQ2xpY2tTdGFydCA9IHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0O1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXHRcdC8vIE9uIHNvbWUgaU9TIGRldmljZXMsIHRoZSB0YXJnZXRFbGVtZW50IHN1cHBsaWVkIHdpdGggdGhlIGV2ZW50IGlzIGludmFsaWQgaWYgdGhlIGxheWVyXG5cdFx0Ly8gaXMgcGVyZm9ybWluZyBhIHRyYW5zaXRpb24gb3Igc2Nyb2xsLCBhbmQgaGFzIHRvIGJlIHJlLWRldGVjdGVkIG1hbnVhbGx5LiBOb3RlIHRoYXRcblx0XHQvLyBmb3IgdGhpcyB0byBmdW5jdGlvbiBjb3JyZWN0bHksIGl0IG11c3QgYmUgY2FsbGVkICphZnRlciogdGhlIGV2ZW50IHRhcmdldCBpcyBjaGVja2VkIVxuXHRcdC8vIFNlZSBpc3N1ZSAjNTc7IGFsc28gZmlsZWQgYXMgcmRhcjovLzEzMDQ4NTg5IC5cblx0XHRpZiAoZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0KSB7XG5cdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0XHQvLyBJbiBjZXJ0YWluIGNhc2VzIGFyZ3VtZW50cyBvZiBlbGVtZW50RnJvbVBvaW50IGNhbiBiZSBuZWdhdGl2ZSwgc28gcHJldmVudCBzZXR0aW5nIHRhcmdldEVsZW1lbnQgdG8gbnVsbFxuXHRcdFx0dGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2gucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIHRvdWNoLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSB8fCB0YXJnZXRFbGVtZW50O1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXHRcdH1cblxuXHRcdHRhcmdldFRhZ05hbWUgPSB0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodGFyZ2V0VGFnTmFtZSA9PT0gJ2xhYmVsJykge1xuXHRcdFx0Zm9yRWxlbWVudCA9IHRoaXMuZmluZENvbnRyb2wodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRpZiAoZm9yRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0RWxlbWVudCA9IGZvckVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm5lZWRzRm9jdXModGFyZ2V0RWxlbWVudCkpIHtcblxuXHRcdFx0Ly8gQ2FzZSAxOiBJZiB0aGUgdG91Y2ggc3RhcnRlZCBhIHdoaWxlIGFnbyAoYmVzdCBndWVzcyBpcyAxMDBtcyBiYXNlZCBvbiB0ZXN0cyBmb3IgaXNzdWUgIzM2KSB0aGVuIGZvY3VzIHdpbGwgYmUgdHJpZ2dlcmVkIGFueXdheS4gUmV0dXJuIGVhcmx5IGFuZCB1bnNldCB0aGUgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlIHNvIHRoYXQgdGhlIHN1YnNlcXVlbnQgY2xpY2sgd2lsbCBiZSBhbGxvd2VkIHRocm91Z2guXG5cdFx0XHQvLyBDYXNlIDI6IFdpdGhvdXQgdGhpcyBleGNlcHRpb24gZm9yIGlucHV0IGVsZW1lbnRzIHRhcHBlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBjb250YWluZWQgaW4gYW4gaWZyYW1lLCB0aGVuIGFueSBpbnB1dHRlZCB0ZXh0IHdvbid0IGJlIHZpc2libGUgZXZlbiB0aG91Z2ggdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyB1cGRhdGVkIGFzIHRoZSB1c2VyIHR5cGVzIChpc3N1ZSAjMzcpLlxuXHRcdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0cmFja2luZ0NsaWNrU3RhcnQpID4gMTAwIHx8IChkZXZpY2VJc0lPUyAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cgJiYgdGFyZ2V0VGFnTmFtZSA9PT0gJ2lucHV0JykpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5zZW5kQ2xpY2sodGFyZ2V0RWxlbWVudCwgZXZlbnQpO1xuXG5cdFx0XHQvLyBTZWxlY3QgZWxlbWVudHMgbmVlZCB0aGUgZXZlbnQgdG8gZ28gdGhyb3VnaCBvbiBpT1MgNCwgb3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBtZW51IHdvbid0IG9wZW4uXG5cdFx0XHQvLyBBbHNvIHRoaXMgYnJlYWtzIG9wZW5pbmcgc2VsZWN0cyB3aGVuIFZvaWNlT3ZlciBpcyBhY3RpdmUgb24gaU9TNiwgaU9TNyAoYW5kIHBvc3NpYmx5IG90aGVycylcblx0XHRcdGlmICghZGV2aWNlSXNJT1MgfHwgdGFyZ2V0VGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiAhZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGF5ZXIgdGhhdCB3YXMgc2Nyb2xsZWRcblx0XHRcdC8vIGFuZCB0aGlzIHRhcCBpcyBiZWluZyB1c2VkIHRvIHN0b3AgdGhlIHNjcm9sbGluZyAodXN1YWxseSBpbml0aWF0ZWQgYnkgYSBmbGluZyAtIGlzc3VlICM0MikuXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHRcdGlmIChzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgIT09IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCB0aGUgYWN0dWFsIGNsaWNrIGZyb20gZ29pbmcgdGhvdWdoIC0gdW5sZXNzIHRoZSB0YXJnZXQgbm9kZSBpcyBtYXJrZWQgYXMgcmVxdWlyaW5nXG5cdFx0Ly8gcmVhbCBjbGlja3Mgb3IgaWYgaXQgaXMgaW4gdGhlIHdoaXRlbGlzdCBpbiB3aGljaCBjYXNlIG9ubHkgbm9uLXByb2dyYW1tYXRpYyBjbGlja3MgYXJlIHBlcm1pdHRlZC5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggY2FuY2VsLCBzdG9wIHRyYWNraW5nIHRoZSBjbGljay5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hDYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSBtb3VzZSBldmVudHMgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gSWYgYSB0YXJnZXQgZWxlbWVudCB3YXMgbmV2ZXIgc2V0IChiZWNhdXNlIGEgdG91Y2ggZXZlbnQgd2FzIG5ldmVyIGZpcmVkKSBhbGxvdyB0aGUgZXZlbnRcblx0XHRpZiAoIXRoaXMudGFyZ2V0RWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByb2dyYW1tYXRpY2FsbHkgZ2VuZXJhdGVkIGV2ZW50cyB0YXJnZXRpbmcgYSBzcGVjaWZpYyBlbGVtZW50IHNob3VsZCBiZSBwZXJtaXR0ZWRcblx0XHRpZiAoIWV2ZW50LmNhbmNlbGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIERlcml2ZSBhbmQgY2hlY2sgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNlZSB3aGV0aGVyIHRoZSBtb3VzZSBldmVudCBuZWVkcyB0byBiZSBwZXJtaXR0ZWQ7XG5cdFx0Ly8gdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCwgcHJldmVudCBub24tdG91Y2ggY2xpY2sgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBhY3Rpb25zLFxuXHRcdC8vIHRvIHByZXZlbnQgZ2hvc3QvZG91YmxlY2xpY2tzLlxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRoaXMudGFyZ2V0RWxlbWVudCkgfHwgdGhpcy5jYW5jZWxOZXh0Q2xpY2spIHtcblxuXHRcdFx0Ly8gUHJldmVudCBhbnkgdXNlci1hZGRlZCBsaXN0ZW5lcnMgZGVjbGFyZWQgb24gRmFzdENsaWNrIGVsZW1lbnQgZnJvbSBiZWluZyBmaXJlZC5cblx0XHRcdGlmIChldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnQgb2YgdGhlIGhhY2sgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdFx0XHRldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYW5jZWwgdGhlIGV2ZW50XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgZXZlbnQgaXMgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIGFjdHVhbCBjbGlja3MsIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSB0b3VjaC1nZW5lcmF0ZWQgY2xpY2ssIGEgY2xpY2sgYWN0aW9uIG9jY3VycmluZ1xuXHQgKiBuYXR1cmFsbHkgYWZ0ZXIgYSBkZWxheSBhZnRlciBhIHRvdWNoICh3aGljaCBuZWVkcyB0byBiZSBjYW5jZWxsZWQgdG8gYXZvaWQgZHVwbGljYXRpb24pLCBvclxuXHQgKiBhbiBhY3R1YWwgY2xpY2sgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwZXJtaXR0ZWQ7XG5cblx0XHQvLyBJdCdzIHBvc3NpYmxlIGZvciBhbm90aGVyIEZhc3RDbGljay1saWtlIGxpYnJhcnkgZGVsaXZlcmVkIHdpdGggdGhpcmQtcGFydHkgY29kZSB0byBmaXJlIGEgY2xpY2sgZXZlbnQgYmVmb3JlIEZhc3RDbGljayBkb2VzIChpc3N1ZSAjNDQpLiBJbiB0aGF0IGNhc2UsIHNldCB0aGUgY2xpY2stdHJhY2tpbmcgZmxhZyBiYWNrIHRvIGZhbHNlIGFuZCByZXR1cm4gZWFybHkuIFRoaXMgd2lsbCBjYXVzZSBvblRvdWNoRW5kIHRvIHJldHVybiBlYXJseS5cblx0XHRpZiAodGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBWZXJ5IG9kZCBiZWhhdmlvciBvbiBpT1MgKGlzc3VlICMxOCk6IGlmIGEgc3VibWl0IGVsZW1lbnQgaXMgcHJlc2VudCBpbnNpZGUgYSBmb3JtIGFuZCB0aGUgdXNlciBoaXRzIGVudGVyIGluIHRoZSBpT1Mgc2ltdWxhdG9yIG9yIGNsaWNrcyB0aGUgR28gYnV0dG9uIG9uIHRoZSBwb3AtdXAgT1Mga2V5Ym9hcmQgdGhlIGEga2luZCBvZiAnZmFrZScgY2xpY2sgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCB0aGUgc3VibWl0LXR5cGUgaW5wdXQgZWxlbWVudCBhcyB0aGUgdGFyZ2V0LlxuXHRcdGlmIChldmVudC50YXJnZXQudHlwZSA9PT0gJ3N1Ym1pdCcgJiYgZXZlbnQuZGV0YWlsID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRwZXJtaXR0ZWQgPSB0aGlzLm9uTW91c2UoZXZlbnQpO1xuXG5cdFx0Ly8gT25seSB1bnNldCB0YXJnZXRFbGVtZW50IGlmIHRoZSBjbGljayBpcyBub3QgcGVybWl0dGVkLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgdGhlIGNoZWNrIGZvciAhdGFyZ2V0RWxlbWVudCBpbiBvbk1vdXNlIGZhaWxzIGFuZCB0aGUgYnJvd3NlcidzIGNsaWNrIGRvZXNuJ3QgZ28gdGhyb3VnaC5cblx0XHRpZiAoIXBlcm1pdHRlZCkge1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBJZiBjbGlja3MgYXJlIHBlcm1pdHRlZCwgcmV0dXJuIHRydWUgZm9yIHRoZSBhY3Rpb24gdG8gZ28gdGhyb3VnaC5cblx0XHRyZXR1cm4gcGVybWl0dGVkO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgRmFzdENsaWNrJ3MgZXZlbnQgbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXllciA9IHRoaXMubGF5ZXI7XG5cblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgRmFzdENsaWNrIGlzIG5lZWRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqL1xuXHRGYXN0Q2xpY2subm90TmVlZGVkID0gZnVuY3Rpb24obGF5ZXIpIHtcblx0XHR2YXIgbWV0YVZpZXdwb3J0O1xuXHRcdHZhciBjaHJvbWVWZXJzaW9uO1xuXHRcdHZhciBibGFja2JlcnJ5VmVyc2lvbjtcblx0XHR2YXIgZmlyZWZveFZlcnNpb247XG5cblx0XHQvLyBEZXZpY2VzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0b3VjaCBkb24ndCBuZWVkIEZhc3RDbGlja1xuXHRcdGlmICh0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIENocm9tZSB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRjaHJvbWVWZXJzaW9uID0gKygvQ2hyb21lXFwvKFswLTldKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWywwXSlbMV07XG5cblx0XHRpZiAoY2hyb21lVmVyc2lvbikge1xuXG5cdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblxuXHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0KSB7XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIG9uIEFuZHJvaWQgd2l0aCB1c2VyLXNjYWxhYmxlPVwibm9cIiBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjODkpXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBDaHJvbWUgMzIgYW5kIGFib3ZlIHdpdGggd2lkdGg9ZGV2aWNlLXdpZHRoIG9yIGxlc3MgZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRcdFx0XHRpZiAoY2hyb21lVmVyc2lvbiA+IDMxICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIENocm9tZSBkZXNrdG9wIGRvZXNuJ3QgbmVlZCBGYXN0Q2xpY2sgKGlzc3VlICMxNSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0JsYWNrQmVycnkxMCkge1xuXHRcdFx0YmxhY2tiZXJyeVZlcnNpb24gPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFswLTldKilcXC4oWzAtOV0qKS8pO1xuXG5cdFx0XHQvLyBCbGFja0JlcnJ5IDEwLjMrIGRvZXMgbm90IHJlcXVpcmUgRmFzdGNsaWNrIGxpYnJhcnkuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZnRsYWJzL2Zhc3RjbGljay9pc3N1ZXMvMjUxXG5cdFx0XHRpZiAoYmxhY2tiZXJyeVZlcnNpb25bMV0gPj0gMTAgJiYgYmxhY2tiZXJyeVZlcnNpb25bMl0gPj0gMykge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIHVzZXItc2NhbGFibGU9bm8gZWxpbWluYXRlcyBjbGljayBkZWxheS5cblx0XHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHdpZHRoPWRldmljZS13aWR0aCAob3IgbGVzcyB0aGFuIGRldmljZS13aWR0aCkgZWxpbWluYXRlcyBjbGljayBkZWxheS5cblx0XHRcdFx0XHRpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTEwIHdpdGggLW1zLXRvdWNoLWFjdGlvbjogbm9uZSBvciBtYW5pcHVsYXRpb24sIHdoaWNoIGRpc2FibGVzIGRvdWJsZS10YXAtdG8tem9vbSAoaXNzdWUgIzk3KVxuXHRcdGlmIChsYXllci5zdHlsZS5tc1RvdWNoQWN0aW9uID09PSAnbm9uZScgfHwgbGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdtYW5pcHVsYXRpb24nKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBGaXJlZm94IHZlcnNpb24gLSB6ZXJvIGZvciBvdGhlciBicm93c2Vyc1xuXHRcdGZpcmVmb3hWZXJzaW9uID0gKygvRmlyZWZveFxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGZpcmVmb3hWZXJzaW9uID49IDI3KSB7XG5cdFx0XHQvLyBGaXJlZm94IDI3KyBkb2VzIG5vdCBoYXZlIHRhcCBkZWxheSBpZiB0aGUgY29udGVudCBpcyBub3Qgem9vbWFibGUgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MjI4OTZcblxuXHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXHRcdFx0aWYgKG1ldGFWaWV3cG9ydCAmJiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElFMTE6IHByZWZpeGVkIC1tcy10b3VjaC1hY3Rpb24gaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgaXQncyByZWNvbW1lbmRlZCB0byB1c2Ugbm9uLXByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9hcHBzL0hoNzY3MzEzLmFzcHhcblx0XHRpZiAobGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBGYXN0Q2xpY2sgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0RmFzdENsaWNrLmF0dGFjaCA9IGZ1bmN0aW9uKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpO1xuXHR9O1xuXG4gIHdpbmRvdy5GYXN0Q2xpY2sgPSBGYXN0Q2xpY2s7XG59KCkpO1xuIiwiLyoqXG4gKiBNaWNyb0V2ZW50IC0gdG8gbWFrZSBhbnkganMgb2JqZWN0IGFuIGV2ZW50IGVtaXR0ZXIgKHNlcnZlciBvciBicm93c2VyKVxuICogXG4gKiAtIHB1cmUgamF2YXNjcmlwdCAtIHNlcnZlciBjb21wYXRpYmxlLCBicm93c2VyIGNvbXBhdGlibGVcbiAqIC0gZG9udCByZWx5IG9uIHRoZSBicm93c2VyIGRvbXNcbiAqIC0gc3VwZXIgc2ltcGxlIC0geW91IGdldCBpdCBpbW1lZGlhdGVseSwgbm8gbXlzdGVyeSwgbm8gbWFnaWMgaW52b2x2ZWRcbiAqXG4gKiAtIGNyZWF0ZSBhIE1pY3JvRXZlbnREZWJ1ZyB3aXRoIGdvb2RpZXMgdG8gZGVidWdcbiAqICAgLSBtYWtlIGl0IHNhZmVyIHRvIHVzZVxuKi9cblxuLyoqIE5PVEU6IFRoaXMgbGlicmFyeSBpcyBjdXN0b21pemVkIGZvciBPbnNlbiBVSS4gKi9cblxudmFyIE1pY3JvRXZlbnQgID0gZnVuY3Rpb24oKXt9O1xuTWljcm9FdmVudC5wcm90b3R5cGUgID0ge1xuICBvbiAgOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IHRoaXMuX2V2ZW50c1tldmVudF0gfHwgW107XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5wdXNoKGZjdCk7XG4gIH0sXG4gIG9uY2UgOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYub2ZmKGV2ZW50LCB3cmFwcGVyKTtcbiAgICAgIHJldHVybiBmY3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHRoaXMub24oZXZlbnQsIHdyYXBwZXIpO1xuICB9LFxuICBvZmYgIDogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG4gICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgIGlmKCBldmVudCBpbiB0aGlzLl9ldmVudHMgPT09IGZhbHNlICApICByZXR1cm47XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5zcGxpY2UodGhpcy5fZXZlbnRzW2V2ZW50XS5pbmRleE9mKGZjdCksIDEpO1xuICB9LFxuICBlbWl0IDogZnVuY3Rpb24oZXZlbnQgLyogLCBhcmdzLi4uICovKXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgaWYoIGV2ZW50IGluIHRoaXMuX2V2ZW50cyA9PT0gZmFsc2UgICkgIHJldHVybjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRzW2V2ZW50XS5sZW5ndGg7IGkrKyl7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnRdW2ldLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBtaXhpbiB3aWxsIGRlbGVnYXRlIGFsbCBNaWNyb0V2ZW50LmpzIGZ1bmN0aW9uIGluIHRoZSBkZXN0aW5hdGlvbiBvYmplY3RcbiAqXG4gKiAtIHJlcXVpcmUoJ01pY3JvRXZlbnQnKS5taXhpbihGb29iYXIpIHdpbGwgbWFrZSBGb29iYXIgYWJsZSB0byB1c2UgTWljcm9FdmVudFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGUgb2JqZWN0IHdoaWNoIHdpbGwgc3VwcG9ydCBNaWNyb0V2ZW50XG4qL1xuTWljcm9FdmVudC5taXhpbiAgPSBmdW5jdGlvbihkZXN0T2JqZWN0KXtcbiAgdmFyIHByb3BzID0gWydvbicsICdvbmNlJywgJ29mZicsICdlbWl0J107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKyspe1xuICAgIGlmKCB0eXBlb2YgZGVzdE9iamVjdCA9PT0gJ2Z1bmN0aW9uJyApe1xuICAgICAgZGVzdE9iamVjdC5wcm90b3R5cGVbcHJvcHNbaV1dICA9IE1pY3JvRXZlbnQucHJvdG90eXBlW3Byb3BzW2ldXTtcbiAgICB9ZWxzZXtcbiAgICAgIGRlc3RPYmplY3RbcHJvcHNbaV1dID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xuICAgIH1cbiAgfVxufVxuXG4vLyBleHBvcnQgaW4gY29tbW9uIGpzXG5pZiggdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoJ2V4cG9ydHMnIGluIG1vZHVsZSkpe1xuICBtb2R1bGUuZXhwb3J0cyAgPSBNaWNyb0V2ZW50O1xufVxuXG53aW5kb3cuTWljcm9FdmVudCA9IE1pY3JvRXZlbnQ7XG4iLCIvKiEgbW9kZXJuaXpyIDMuMS4wIChDdXN0b20gQnVpbGQpIHwgTUlUICpcbiAqIGh0dHA6Ly9tb2Rlcm5penIuY29tL2Rvd25sb2FkLz8tYm9yZGVycmFkaXVzLWJveHNoYWRvdy1jYW52YXMtY3NzYW5pbWF0aW9ucy1jc3N0cmFuc2Zvcm1zLWNzc3RyYW5zZm9ybXMzZC1jc3N0cmFuc2l0aW9ucy1zdmctYWRkdGVzdC1kb21wcmVmaXhlcy1wcmVmaXhlcy1zaGl2LXRlc3RhbGxwcm9wcy10ZXN0cHJvcC10ZXN0c3R5bGVzICEqL1xuIWZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUsdCl7cmV0dXJuIHR5cGVvZiBlPT09dH1mdW5jdGlvbiBvKCl7dmFyIGUsdCxuLG8saSxzLGE7Zm9yKHZhciBsIGluIFMpaWYoUy5oYXNPd25Qcm9wZXJ0eShsKSl7aWYoZT1bXSx0PVNbbF0sdC5uYW1lJiYoZS5wdXNoKHQubmFtZS50b0xvd2VyQ2FzZSgpKSx0Lm9wdGlvbnMmJnQub3B0aW9ucy5hbGlhc2VzJiZ0Lm9wdGlvbnMuYWxpYXNlcy5sZW5ndGgpKWZvcihuPTA7bjx0Lm9wdGlvbnMuYWxpYXNlcy5sZW5ndGg7bisrKWUucHVzaCh0Lm9wdGlvbnMuYWxpYXNlc1tuXS50b0xvd2VyQ2FzZSgpKTtmb3Iobz1yKHQuZm4sXCJmdW5jdGlvblwiKT90LmZuKCk6dC5mbixpPTA7aTxlLmxlbmd0aDtpKyspcz1lW2ldLGE9cy5zcGxpdChcIi5cIiksMT09PWEubGVuZ3RoP01vZGVybml6clthWzBdXT1vOighTW9kZXJuaXpyW2FbMF1dfHxNb2Rlcm5penJbYVswXV1pbnN0YW5jZW9mIEJvb2xlYW58fChNb2Rlcm5penJbYVswXV09bmV3IEJvb2xlYW4oTW9kZXJuaXpyW2FbMF1dKSksTW9kZXJuaXpyW2FbMF1dW2FbMV1dPW8pLEMucHVzaCgobz9cIlwiOlwibm8tXCIpK2Euam9pbihcIi1cIikpfX1mdW5jdGlvbiBpKGUpe3ZhciB0PXcuY2xhc3NOYW1lLG49TW9kZXJuaXpyLl9jb25maWcuY2xhc3NQcmVmaXh8fFwiXCI7aWYoXyYmKHQ9dC5iYXNlVmFsKSxNb2Rlcm5penIuX2NvbmZpZy5lbmFibGVKU0NsYXNzKXt2YXIgcj1uZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIrbitcIm5vLWpzKFxcXFxzfCQpXCIpO3Q9dC5yZXBsYWNlKHIsXCIkMVwiK24rXCJqcyQyXCIpfU1vZGVybml6ci5fY29uZmlnLmVuYWJsZUNsYXNzZXMmJih0Kz1cIiBcIituK2Uuam9pbihcIiBcIituKSxfP3cuY2xhc3NOYW1lLmJhc2VWYWw9dDp3LmNsYXNzTmFtZT10KX1mdW5jdGlvbiBzKGUsdCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUpZm9yKHZhciBuIGluIGUpTihlLG4pJiZzKG4sZVtuXSk7ZWxzZXtlPWUudG9Mb3dlckNhc2UoKTt2YXIgcj1lLnNwbGl0KFwiLlwiKSxvPU1vZGVybml6cltyWzBdXTtpZigyPT1yLmxlbmd0aCYmKG89b1tyWzFdXSksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG8pcmV0dXJuIE1vZGVybml6cjt0PVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dCgpOnQsMT09ci5sZW5ndGg/TW9kZXJuaXpyW3JbMF1dPXQ6KCFNb2Rlcm5penJbclswXV18fE1vZGVybml6cltyWzBdXWluc3RhbmNlb2YgQm9vbGVhbnx8KE1vZGVybml6cltyWzBdXT1uZXcgQm9vbGVhbihNb2Rlcm5penJbclswXV0pKSxNb2Rlcm5penJbclswXV1bclsxXV09dCksaShbKHQmJjAhPXQ/XCJcIjpcIm5vLVwiKStyLmpvaW4oXCItXCIpXSksTW9kZXJuaXpyLl90cmlnZ2VyKGUsdCl9cmV0dXJuIE1vZGVybml6cn1mdW5jdGlvbiBhKCl7cmV0dXJuXCJmdW5jdGlvblwiIT10eXBlb2YgdC5jcmVhdGVFbGVtZW50P3QuY3JlYXRlRWxlbWVudChhcmd1bWVudHNbMF0pOl8/dC5jcmVhdGVFbGVtZW50TlMuY2FsbCh0LFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixhcmd1bWVudHNbMF0pOnQuY3JlYXRlRWxlbWVudC5hcHBseSh0LGFyZ3VtZW50cyl9ZnVuY3Rpb24gbChlLHQpe3JldHVybiEhfihcIlwiK2UpLmluZGV4T2YodCl9ZnVuY3Rpb24gdSgpe3ZhciBlPXQuYm9keTtyZXR1cm4gZXx8KGU9YShfP1wic3ZnXCI6XCJib2R5XCIpLGUuZmFrZT0hMCksZX1mdW5jdGlvbiBmKGUsbixyLG8pe3ZhciBpLHMsbCxmLGM9XCJtb2Rlcm5penJcIixkPWEoXCJkaXZcIikscD11KCk7aWYocGFyc2VJbnQociwxMCkpZm9yKDtyLS07KWw9YShcImRpdlwiKSxsLmlkPW8/b1tyXTpjKyhyKzEpLGQuYXBwZW5kQ2hpbGQobCk7cmV0dXJuIGk9YShcInN0eWxlXCIpLGkudHlwZT1cInRleHQvY3NzXCIsaS5pZD1cInNcIitjLChwLmZha2U/cDpkKS5hcHBlbmRDaGlsZChpKSxwLmFwcGVuZENoaWxkKGQpLGkuc3R5bGVTaGVldD9pLnN0eWxlU2hlZXQuY3NzVGV4dD1lOmkuYXBwZW5kQ2hpbGQodC5jcmVhdGVUZXh0Tm9kZShlKSksZC5pZD1jLHAuZmFrZSYmKHAuc3R5bGUuYmFja2dyb3VuZD1cIlwiLHAuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIixmPXcuc3R5bGUub3ZlcmZsb3csdy5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwiLHcuYXBwZW5kQ2hpbGQocCkpLHM9bihkLGUpLHAuZmFrZT8ocC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHApLHcuc3R5bGUub3ZlcmZsb3c9Zix3Lm9mZnNldEhlaWdodCk6ZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpLCEhc31mdW5jdGlvbiBjKGUpe3JldHVybiBlLnJlcGxhY2UoLyhbYS16XSktKFthLXpdKS9nLGZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdCtuLnRvVXBwZXJDYXNlKCl9KS5yZXBsYWNlKC9eLS8sXCJcIil9ZnVuY3Rpb24gZChlLHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHQsYXJndW1lbnRzKX19ZnVuY3Rpb24gcChlLHQsbil7dmFyIG87Zm9yKHZhciBpIGluIGUpaWYoZVtpXWluIHQpcmV0dXJuIG49PT0hMT9lW2ldOihvPXRbZVtpXV0scihvLFwiZnVuY3Rpb25cIik/ZChvLG58fHQpOm8pO3JldHVybiExfWZ1bmN0aW9uIG0oZSl7cmV0dXJuIGUucmVwbGFjZSgvKFtBLVpdKS9nLGZ1bmN0aW9uKGUsdCl7cmV0dXJuXCItXCIrdC50b0xvd2VyQ2FzZSgpfSkucmVwbGFjZSgvXm1zLS8sXCItbXMtXCIpfWZ1bmN0aW9uIGgodCxyKXt2YXIgbz10Lmxlbmd0aDtpZihcIkNTU1wiaW4gZSYmXCJzdXBwb3J0c1wiaW4gZS5DU1Mpe2Zvcig7by0tOylpZihlLkNTUy5zdXBwb3J0cyhtKHRbb10pLHIpKXJldHVybiEwO3JldHVybiExfWlmKFwiQ1NTU3VwcG9ydHNSdWxlXCJpbiBlKXtmb3IodmFyIGk9W107by0tOylpLnB1c2goXCIoXCIrbSh0W29dKStcIjpcIityK1wiKVwiKTtyZXR1cm4gaT1pLmpvaW4oXCIgb3IgXCIpLGYoXCJAc3VwcG9ydHMgKFwiK2krXCIpIHsgI21vZGVybml6ciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgfSB9XCIsZnVuY3Rpb24oZSl7cmV0dXJuXCJhYnNvbHV0ZVwiPT1nZXRDb21wdXRlZFN0eWxlKGUsbnVsbCkucG9zaXRpb259KX1yZXR1cm4gbn1mdW5jdGlvbiBnKGUsdCxvLGkpe2Z1bmN0aW9uIHMoKXtmJiYoZGVsZXRlIEwuc3R5bGUsZGVsZXRlIEwubW9kRWxlbSl9aWYoaT1yKGksXCJ1bmRlZmluZWRcIik/ITE6aSwhcihvLFwidW5kZWZpbmVkXCIpKXt2YXIgdT1oKGUsbyk7aWYoIXIodSxcInVuZGVmaW5lZFwiKSlyZXR1cm4gdX1mb3IodmFyIGYsZCxwLG0sZyx2PVtcIm1vZGVybml6clwiLFwidHNwYW5cIl07IUwuc3R5bGU7KWY9ITAsTC5tb2RFbGVtPWEodi5zaGlmdCgpKSxMLnN0eWxlPUwubW9kRWxlbS5zdHlsZTtmb3IocD1lLmxlbmd0aCxkPTA7cD5kO2QrKylpZihtPWVbZF0sZz1MLnN0eWxlW21dLGwobSxcIi1cIikmJihtPWMobSkpLEwuc3R5bGVbbV0hPT1uKXtpZihpfHxyKG8sXCJ1bmRlZmluZWRcIikpcmV0dXJuIHMoKSxcInBmeFwiPT10P206ITA7dHJ5e0wuc3R5bGVbbV09b31jYXRjaCh5KXt9aWYoTC5zdHlsZVttXSE9ZylyZXR1cm4gcygpLFwicGZ4XCI9PXQ/bTohMH1yZXR1cm4gcygpLCExfWZ1bmN0aW9uIHYoZSx0LG4sbyxpKXt2YXIgcz1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSksYT0oZStcIiBcIitrLmpvaW4ocytcIiBcIikrcykuc3BsaXQoXCIgXCIpO3JldHVybiByKHQsXCJzdHJpbmdcIil8fHIodCxcInVuZGVmaW5lZFwiKT9nKGEsdCxvLGkpOihhPShlK1wiIFwiK1Quam9pbihzK1wiIFwiKStzKS5zcGxpdChcIiBcIikscChhLHQsbikpfWZ1bmN0aW9uIHkoZSx0LHIpe3JldHVybiB2KGUsbixuLHQscil9dmFyIEM9W10sUz1bXSx4PXtfdmVyc2lvbjpcIjMuMS4wXCIsX2NvbmZpZzp7Y2xhc3NQcmVmaXg6XCJcIixlbmFibGVDbGFzc2VzOiEwLGVuYWJsZUpTQ2xhc3M6ITAsdXNlUHJlZml4ZXM6ITB9LF9xOltdLG9uOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dChuW2VdKX0sMCl9LGFkZFRlc3Q6ZnVuY3Rpb24oZSx0LG4pe1MucHVzaCh7bmFtZTplLGZuOnQsb3B0aW9uczpufSl9LGFkZEFzeW5jVGVzdDpmdW5jdGlvbihlKXtTLnB1c2goe25hbWU6bnVsbCxmbjplfSl9fSxNb2Rlcm5penI9ZnVuY3Rpb24oKXt9O01vZGVybml6ci5wcm90b3R5cGU9eCxNb2Rlcm5penI9bmV3IE1vZGVybml6cixNb2Rlcm5penIuYWRkVGVzdChcInN2Z1wiLCEhdC5jcmVhdGVFbGVtZW50TlMmJiEhdC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwic3ZnXCIpLmNyZWF0ZVNWR1JlY3QpO3ZhciBiPXguX2NvbmZpZy51c2VQcmVmaXhlcz9cIiAtd2Via2l0LSAtbW96LSAtby0gLW1zLSBcIi5zcGxpdChcIiBcIik6W107eC5fcHJlZml4ZXM9Yjt2YXIgdz10LmRvY3VtZW50RWxlbWVudCxfPVwic3ZnXCI9PT13Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7X3x8IWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbihlLHQpe3ZhciBuPWUuY3JlYXRlRWxlbWVudChcInBcIikscj1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXXx8ZS5kb2N1bWVudEVsZW1lbnQ7cmV0dXJuIG4uaW5uZXJIVE1MPVwieDxzdHlsZT5cIit0K1wiPC9zdHlsZT5cIixyLmluc2VydEJlZm9yZShuLmxhc3RDaGlsZCxyLmZpcnN0Q2hpbGQpfWZ1bmN0aW9uIHIoKXt2YXIgZT1DLmVsZW1lbnRzO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlP2Uuc3BsaXQoXCIgXCIpOmV9ZnVuY3Rpb24gbyhlLHQpe3ZhciBuPUMuZWxlbWVudHM7XCJzdHJpbmdcIiE9dHlwZW9mIG4mJihuPW4uam9pbihcIiBcIikpLFwic3RyaW5nXCIhPXR5cGVvZiBlJiYoZT1lLmpvaW4oXCIgXCIpKSxDLmVsZW1lbnRzPW4rXCIgXCIrZSx1KHQpfWZ1bmN0aW9uIGkoZSl7dmFyIHQ9eVtlW2ddXTtyZXR1cm4gdHx8KHQ9e30sdisrLGVbZ109dix5W3ZdPXQpLHR9ZnVuY3Rpb24gcyhlLG4scil7aWYobnx8KG49dCksYylyZXR1cm4gbi5jcmVhdGVFbGVtZW50KGUpO3J8fChyPWkobikpO3ZhciBvO3JldHVybiBvPXIuY2FjaGVbZV0/ci5jYWNoZVtlXS5jbG9uZU5vZGUoKTpoLnRlc3QoZSk/KHIuY2FjaGVbZV09ci5jcmVhdGVFbGVtKGUpKS5jbG9uZU5vZGUoKTpyLmNyZWF0ZUVsZW0oZSksIW8uY2FuSGF2ZUNoaWxkcmVufHxtLnRlc3QoZSl8fG8udGFnVXJuP286ci5mcmFnLmFwcGVuZENoaWxkKG8pfWZ1bmN0aW9uIGEoZSxuKXtpZihlfHwoZT10KSxjKXJldHVybiBlLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtuPW58fGkoZSk7Zm9yKHZhciBvPW4uZnJhZy5jbG9uZU5vZGUoKSxzPTAsYT1yKCksbD1hLmxlbmd0aDtsPnM7cysrKW8uY3JlYXRlRWxlbWVudChhW3NdKTtyZXR1cm4gb31mdW5jdGlvbiBsKGUsdCl7dC5jYWNoZXx8KHQuY2FjaGU9e30sdC5jcmVhdGVFbGVtPWUuY3JlYXRlRWxlbWVudCx0LmNyZWF0ZUZyYWc9ZS5jcmVhdGVEb2N1bWVudEZyYWdtZW50LHQuZnJhZz10LmNyZWF0ZUZyYWcoKSksZS5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uKG4pe3JldHVybiBDLnNoaXZNZXRob2RzP3MobixlLHQpOnQuY3JlYXRlRWxlbShuKX0sZS5jcmVhdGVEb2N1bWVudEZyYWdtZW50PUZ1bmN0aW9uKFwiaCxmXCIsXCJyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj1mLmNsb25lTm9kZSgpLGM9bi5jcmVhdGVFbGVtZW50O2guc2hpdk1ldGhvZHMmJihcIityKCkuam9pbigpLnJlcGxhY2UoL1tcXHdcXC06XSsvZyxmdW5jdGlvbihlKXtyZXR1cm4gdC5jcmVhdGVFbGVtKGUpLHQuZnJhZy5jcmVhdGVFbGVtZW50KGUpLCdjKFwiJytlKydcIiknfSkrXCIpO3JldHVybiBufVwiKShDLHQuZnJhZyl9ZnVuY3Rpb24gdShlKXtlfHwoZT10KTt2YXIgcj1pKGUpO3JldHVybiFDLnNoaXZDU1N8fGZ8fHIuaGFzQ1NTfHwoci5oYXNDU1M9ISFuKGUsXCJhcnRpY2xlLGFzaWRlLGRpYWxvZyxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsaGVhZGVyLGhncm91cCxtYWluLG5hdixzZWN0aW9ue2Rpc3BsYXk6YmxvY2t9bWFya3tiYWNrZ3JvdW5kOiNGRjA7Y29sb3I6IzAwMH10ZW1wbGF0ZXtkaXNwbGF5Om5vbmV9XCIpKSxjfHxsKGUsciksZX12YXIgZixjLGQ9XCIzLjcuM1wiLHA9ZS5odG1sNXx8e30sbT0vXjx8Xig/OmJ1dHRvbnxtYXB8c2VsZWN0fHRleHRhcmVhfG9iamVjdHxpZnJhbWV8b3B0aW9ufG9wdGdyb3VwKSQvaSxoPS9eKD86YXxifGNvZGV8ZGl2fGZpZWxkc2V0fGgxfGgyfGgzfGg0fGg1fGg2fGl8bGFiZWx8bGl8b2x8cHxxfHNwYW58c3Ryb25nfHN0eWxlfHRhYmxlfHRib2R5fHRkfHRofHRyfHVsKSQvaSxnPVwiX2h0bWw1c2hpdlwiLHY9MCx5PXt9OyFmdW5jdGlvbigpe3RyeXt2YXIgZT10LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO2UuaW5uZXJIVE1MPVwiPHh5ej48L3h5ej5cIixmPVwiaGlkZGVuXCJpbiBlLGM9MT09ZS5jaGlsZE5vZGVzLmxlbmd0aHx8ZnVuY3Rpb24oKXt0LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO3ZhciBlPXQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBlLmNsb25lTm9kZXx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGUuY3JlYXRlRG9jdW1lbnRGcmFnbWVudHx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGUuY3JlYXRlRWxlbWVudH0oKX1jYXRjaChuKXtmPSEwLGM9ITB9fSgpO3ZhciBDPXtlbGVtZW50czpwLmVsZW1lbnRzfHxcImFiYnIgYXJ0aWNsZSBhc2lkZSBhdWRpbyBiZGkgY2FudmFzIGRhdGEgZGF0YWxpc3QgZGV0YWlscyBkaWFsb2cgZmlnY2FwdGlvbiBmaWd1cmUgZm9vdGVyIGhlYWRlciBoZ3JvdXAgbWFpbiBtYXJrIG1ldGVyIG5hdiBvdXRwdXQgcGljdHVyZSBwcm9ncmVzcyBzZWN0aW9uIHN1bW1hcnkgdGVtcGxhdGUgdGltZSB2aWRlb1wiLHZlcnNpb246ZCxzaGl2Q1NTOnAuc2hpdkNTUyE9PSExLHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzOmMsc2hpdk1ldGhvZHM6cC5zaGl2TWV0aG9kcyE9PSExLHR5cGU6XCJkZWZhdWx0XCIsc2hpdkRvY3VtZW50OnUsY3JlYXRlRWxlbWVudDpzLGNyZWF0ZURvY3VtZW50RnJhZ21lbnQ6YSxhZGRFbGVtZW50czpvfTtlLmh0bWw1PUMsdSh0KSxcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmKG1vZHVsZS5leHBvcnRzPUMpfShcInVuZGVmaW5lZFwiIT10eXBlb2YgZT9lOnRoaXMsdCk7dmFyIEU9XCJNb3ogTyBtcyBXZWJraXRcIixUPXguX2NvbmZpZy51c2VQcmVmaXhlcz9FLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCIgXCIpOltdO3guX2RvbVByZWZpeGVzPVQ7dmFyIE47IWZ1bmN0aW9uKCl7dmFyIGU9e30uaGFzT3duUHJvcGVydHk7Tj1yKGUsXCJ1bmRlZmluZWRcIil8fHIoZS5jYWxsLFwidW5kZWZpbmVkXCIpP2Z1bmN0aW9uKGUsdCl7cmV0dXJuIHQgaW4gZSYmcihlLmNvbnN0cnVjdG9yLnByb3RvdHlwZVt0XSxcInVuZGVmaW5lZFwiKX06ZnVuY3Rpb24odCxuKXtyZXR1cm4gZS5jYWxsKHQsbil9fSgpLHguX2w9e30seC5vbj1mdW5jdGlvbihlLHQpe3RoaXMuX2xbZV18fCh0aGlzLl9sW2VdPVtdKSx0aGlzLl9sW2VdLnB1c2godCksTW9kZXJuaXpyLmhhc093blByb3BlcnR5KGUpJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7TW9kZXJuaXpyLl90cmlnZ2VyKGUsTW9kZXJuaXpyW2VdKX0sMCl9LHguX3RyaWdnZXI9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLl9sW2VdKXt2YXIgbj10aGlzLl9sW2VdO3NldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgZSxyO2ZvcihlPTA7ZTxuLmxlbmd0aDtlKyspKHI9bltlXSkodCl9LDApLGRlbGV0ZSB0aGlzLl9sW2VdfX0sTW9kZXJuaXpyLl9xLnB1c2goZnVuY3Rpb24oKXt4LmFkZFRlc3Q9c30pLE1vZGVybml6ci5hZGRUZXN0KFwiY2FudmFzXCIsZnVuY3Rpb24oKXt2YXIgZT1hKFwiY2FudmFzXCIpO3JldHVybiEoIWUuZ2V0Q29udGV4dHx8IWUuZ2V0Q29udGV4dChcIjJkXCIpKX0pO3ZhciBQPVwiQ1NTXCJpbiBlJiZcInN1cHBvcnRzXCJpbiBlLkNTUyxqPVwic3VwcG9ydHNDU1NcImluIGU7TW9kZXJuaXpyLmFkZFRlc3QoXCJzdXBwb3J0c1wiLFB8fGopO3ZhciBrPXguX2NvbmZpZy51c2VQcmVmaXhlcz9FLnNwbGl0KFwiIFwiKTpbXTt4Ll9jc3NvbVByZWZpeGVzPWs7dmFyIHo9eC50ZXN0U3R5bGVzPWYsRj17ZWxlbTphKFwibW9kZXJuaXpyXCIpfTtNb2Rlcm5penIuX3EucHVzaChmdW5jdGlvbigpe2RlbGV0ZSBGLmVsZW19KTt2YXIgTD17c3R5bGU6Ri5lbGVtLnN0eWxlfTtNb2Rlcm5penIuX3EudW5zaGlmdChmdW5jdGlvbigpe2RlbGV0ZSBMLnN0eWxlfSk7eC50ZXN0UHJvcD1mdW5jdGlvbihlLHQscil7cmV0dXJuIGcoW2VdLG4sdCxyKX07eC50ZXN0QWxsUHJvcHM9dix4LnRlc3RBbGxQcm9wcz15LE1vZGVybml6ci5hZGRUZXN0KFwiYm9yZGVycmFkaXVzXCIseShcImJvcmRlclJhZGl1c1wiLFwiMHB4XCIsITApKSxNb2Rlcm5penIuYWRkVGVzdChcImJveHNoYWRvd1wiLHkoXCJib3hTaGFkb3dcIixcIjFweCAxcHhcIiwhMCkpLE1vZGVybml6ci5hZGRUZXN0KFwiY3NzYW5pbWF0aW9uc1wiLHkoXCJhbmltYXRpb25OYW1lXCIsXCJhXCIsITApKSxNb2Rlcm5penIuYWRkVGVzdChcImNzc3RyYW5zZm9ybXNcIixmdW5jdGlvbigpe3JldHVybi0xPT09bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiQW5kcm9pZCAyLlwiKSYmeShcInRyYW5zZm9ybVwiLFwic2NhbGUoMSlcIiwhMCl9KSxNb2Rlcm5penIuYWRkVGVzdChcImNzc3RyYW5zZm9ybXMzZFwiLGZ1bmN0aW9uKCl7dmFyIGU9ISF5KFwicGVyc3BlY3RpdmVcIixcIjFweFwiLCEwKSx0PU1vZGVybml6ci5fY29uZmlnLnVzZVByZWZpeGVzO2lmKGUmJighdHx8XCJ3ZWJraXRQZXJzcGVjdGl2ZVwiaW4gdy5zdHlsZSkpe3ZhciBuO01vZGVybml6ci5zdXBwb3J0cz9uPVwiQHN1cHBvcnRzIChwZXJzcGVjdGl2ZTogMXB4KVwiOihuPVwiQG1lZGlhICh0cmFuc2Zvcm0tM2QpXCIsdCYmKG4rPVwiLCgtd2Via2l0LXRyYW5zZm9ybS0zZClcIikpLG4rPVwieyNtb2Rlcm5penJ7bGVmdDo5cHg7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjVweDttYXJnaW46MDtwYWRkaW5nOjA7Ym9yZGVyOjB9fVwiLHoobixmdW5jdGlvbih0KXtlPTk9PT10Lm9mZnNldExlZnQmJjU9PT10Lm9mZnNldEhlaWdodH0pfXJldHVybiBlfSksTW9kZXJuaXpyLmFkZFRlc3QoXCJjc3N0cmFuc2l0aW9uc1wiLHkoXCJ0cmFuc2l0aW9uXCIsXCJhbGxcIiwhMCkpLG8oKSxpKEMpLGRlbGV0ZSB4LmFkZFRlc3QsZGVsZXRlIHguYWRkQXN5bmNUZXN0O2Zvcih2YXIgQT0wO0E8TW9kZXJuaXpyLl9xLmxlbmd0aDtBKyspTW9kZXJuaXpyLl9xW0FdKCk7ZS5Nb2Rlcm5penI9TW9kZXJuaXpyfSh3aW5kb3csZG9jdW1lbnQpOyIsIiFmdW5jdGlvbiBuKHQsZSxyKXtmdW5jdGlvbiBvKHUsZil7aWYoIWVbdV0pe2lmKCF0W3VdKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKHUsITApO2lmKGkpcmV0dXJuIGkodSwhMCk7dmFyIHM9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIit1K1wiJ1wiKTt0aHJvdyBzLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsc312YXIgbD1lW3VdPXtleHBvcnRzOnt9fTt0W3VdWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKG4pe3ZhciBlPXRbdV1bMV1bbl07cmV0dXJuIG8oZT9lOm4pfSxsLGwuZXhwb3J0cyxuLHQsZSxyKX1yZXR1cm4gZVt1XS5leHBvcnRzfWZvcih2YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLHU9MDt1PHIubGVuZ3RoO3UrKylvKHJbdV0pO3JldHVybiBvfSh7MTpbZnVuY3Rpb24obix0LGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoKXt9ZnVuY3Rpb24gbyhuKXt0cnl7cmV0dXJuIG4udGhlbn1jYXRjaCh0KXtyZXR1cm4gZD10LHd9fWZ1bmN0aW9uIGkobix0KXt0cnl7cmV0dXJuIG4odCl9Y2F0Y2goZSl7cmV0dXJuIGQ9ZSx3fX1mdW5jdGlvbiB1KG4sdCxlKXt0cnl7bih0LGUpfWNhdGNoKHIpe3JldHVybiBkPXIsd319ZnVuY3Rpb24gZihuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdGhpcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3XCIpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIGZ1bmN0aW9uXCIpO3RoaXMuXzM3PTAsdGhpcy5fMTI9bnVsbCx0aGlzLl81OT1bXSxuIT09ciYmdihuLHRoaXMpfWZ1bmN0aW9uIGMobix0LGUpe3JldHVybiBuZXcgbi5jb25zdHJ1Y3RvcihmdW5jdGlvbihvLGkpe3ZhciB1PW5ldyBmKHIpO3UudGhlbihvLGkpLHMobixuZXcgcCh0LGUsdSkpfSl9ZnVuY3Rpb24gcyhuLHQpe2Zvcig7Mz09PW4uXzM3OyluPW4uXzEyO3JldHVybiAwPT09bi5fMzc/dm9pZCBuLl81OS5wdXNoKHQpOnZvaWQgeShmdW5jdGlvbigpe3ZhciBlPTE9PT1uLl8zNz90Lm9uRnVsZmlsbGVkOnQub25SZWplY3RlZDtpZihudWxsPT09ZSlyZXR1cm4gdm9pZCgxPT09bi5fMzc/bCh0LnByb21pc2Usbi5fMTIpOmEodC5wcm9taXNlLG4uXzEyKSk7dmFyIHI9aShlLG4uXzEyKTtyPT09dz9hKHQucHJvbWlzZSxkKTpsKHQucHJvbWlzZSxyKX0pfWZ1bmN0aW9uIGwobix0KXtpZih0PT09bilyZXR1cm4gYShuLG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLlwiKSk7aWYodCYmKFwib2JqZWN0XCI9PXR5cGVvZiB0fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KSl7dmFyIGU9byh0KTtpZihlPT09dylyZXR1cm4gYShuLGQpO2lmKGU9PT1uLnRoZW4mJnQgaW5zdGFuY2VvZiBmKXJldHVybiBuLl8zNz0zLG4uXzEyPXQsdm9pZCBoKG4pO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpcmV0dXJuIHZvaWQgdihlLmJpbmQodCksbil9bi5fMzc9MSxuLl8xMj10LGgobil9ZnVuY3Rpb24gYShuLHQpe24uXzM3PTIsbi5fMTI9dCxoKG4pfWZ1bmN0aW9uIGgobil7Zm9yKHZhciB0PTA7dDxuLl81OS5sZW5ndGg7dCsrKXMobixuLl81OVt0XSk7bi5fNTk9bnVsbH1mdW5jdGlvbiBwKG4sdCxlKXt0aGlzLm9uRnVsZmlsbGVkPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjpudWxsLHRoaXMub25SZWplY3RlZD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6bnVsbCx0aGlzLnByb21pc2U9ZX1mdW5jdGlvbiB2KG4sdCl7dmFyIGU9ITEscj11KG4sZnVuY3Rpb24obil7ZXx8KGU9ITAsbCh0LG4pKX0sZnVuY3Rpb24obil7ZXx8KGU9ITAsYSh0LG4pKX0pO2V8fHIhPT13fHwoZT0hMCxhKHQsZCkpfXZhciB5PW4oXCJhc2FwL3Jhd1wiKSxkPW51bGwsdz17fTt0LmV4cG9ydHM9ZixmLl85OT1yLGYucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24obix0KXtpZih0aGlzLmNvbnN0cnVjdG9yIT09ZilyZXR1cm4gYyh0aGlzLG4sdCk7dmFyIGU9bmV3IGYocik7cmV0dXJuIHModGhpcyxuZXcgcChuLHQsZSkpLGV9fSx7XCJhc2FwL3Jhd1wiOjR9XSwyOltmdW5jdGlvbihuLHQsZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihuKXt2YXIgdD1uZXcgbyhvLl85OSk7cmV0dXJuIHQuXzM3PTEsdC5fMTI9bix0fXZhciBvPW4oXCIuL2NvcmUuanNcIik7dC5leHBvcnRzPW87dmFyIGk9cighMCksdT1yKCExKSxmPXIobnVsbCksYz1yKHZvaWQgMCkscz1yKDApLGw9cihcIlwiKTtvLnJlc29sdmU9ZnVuY3Rpb24obil7aWYobiBpbnN0YW5jZW9mIG8pcmV0dXJuIG47aWYobnVsbD09PW4pcmV0dXJuIGY7aWYodm9pZCAwPT09bilyZXR1cm4gYztpZihuPT09ITApcmV0dXJuIGk7aWYobj09PSExKXJldHVybiB1O2lmKDA9PT1uKXJldHVybiBzO2lmKFwiXCI9PT1uKXJldHVybiBsO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBufHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuKXRyeXt2YXIgdD1uLnRoZW47aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdClyZXR1cm4gbmV3IG8odC5iaW5kKG4pKX1jYXRjaChlKXtyZXR1cm4gbmV3IG8oZnVuY3Rpb24obix0KXt0KGUpfSl9cmV0dXJuIHIobil9LG8uYWxsPWZ1bmN0aW9uKG4pe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4pO3JldHVybiBuZXcgbyhmdW5jdGlvbihuLGUpe2Z1bmN0aW9uIHIodSxmKXtpZihmJiYoXCJvYmplY3RcIj09dHlwZW9mIGZ8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGYpKXtpZihmIGluc3RhbmNlb2YgbyYmZi50aGVuPT09by5wcm90b3R5cGUudGhlbil7Zm9yKDszPT09Zi5fMzc7KWY9Zi5fMTI7cmV0dXJuIDE9PT1mLl8zNz9yKHUsZi5fMTIpOigyPT09Zi5fMzcmJmUoZi5fMTIpLHZvaWQgZi50aGVuKGZ1bmN0aW9uKG4pe3IodSxuKX0sZSkpfXZhciBjPWYudGhlbjtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBjKXt2YXIgcz1uZXcgbyhjLmJpbmQoZikpO3JldHVybiB2b2lkIHMudGhlbihmdW5jdGlvbihuKXtyKHUsbil9LGUpfX10W3VdPWYsMD09PS0taSYmbih0KX1pZigwPT09dC5sZW5ndGgpcmV0dXJuIG4oW10pO2Zvcih2YXIgaT10Lmxlbmd0aCx1PTA7dTx0Lmxlbmd0aDt1Kyspcih1LHRbdV0pfSl9LG8ucmVqZWN0PWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgbyhmdW5jdGlvbih0LGUpe2Uobil9KX0sby5yYWNlPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgbyhmdW5jdGlvbih0LGUpe24uZm9yRWFjaChmdW5jdGlvbihuKXtvLnJlc29sdmUobikudGhlbih0LGUpfSl9KX0sby5wcm90b3R5cGVbXCJjYXRjaFwiXT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy50aGVuKG51bGwsbil9fSx7XCIuL2NvcmUuanNcIjoxfV0sMzpbZnVuY3Rpb24obix0LGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoKXtpZihjLmxlbmd0aCl0aHJvdyBjLnNoaWZ0KCl9ZnVuY3Rpb24gbyhuKXt2YXIgdDt0PWYubGVuZ3RoP2YucG9wKCk6bmV3IGksdC50YXNrPW4sdSh0KX1mdW5jdGlvbiBpKCl7dGhpcy50YXNrPW51bGx9dmFyIHU9bihcIi4vcmF3XCIpLGY9W10sYz1bXSxzPXUubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKHIpO3QuZXhwb3J0cz1vLGkucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oKXt0cnl7dGhpcy50YXNrLmNhbGwoKX1jYXRjaChuKXtvLm9uZXJyb3I/by5vbmVycm9yKG4pOihjLnB1c2gobikscygpKX1maW5hbGx5e3RoaXMudGFzaz1udWxsLGZbZi5sZW5ndGhdPXRoaXN9fX0se1wiLi9yYXdcIjo0fV0sNDpbZnVuY3Rpb24obix0LGUpeyhmdW5jdGlvbihuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKG4pe2YubGVuZ3RofHwodSgpLGM9ITApLGZbZi5sZW5ndGhdPW59ZnVuY3Rpb24gcigpe2Zvcig7czxmLmxlbmd0aDspe3ZhciBuPXM7aWYocys9MSxmW25dLmNhbGwoKSxzPmwpe2Zvcih2YXIgdD0wLGU9Zi5sZW5ndGgtcztlPnQ7dCsrKWZbdF09Zlt0K3NdO2YubGVuZ3RoLT1zLHM9MH19Zi5sZW5ndGg9MCxzPTAsYz0hMX1mdW5jdGlvbiBvKG4pe3ZhciB0PTEsZT1uZXcgYShuKSxyPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO3JldHVybiBlLm9ic2VydmUocix7Y2hhcmFjdGVyRGF0YTohMH0pLGZ1bmN0aW9uKCl7dD0tdCxyLmRhdGE9dH19ZnVuY3Rpb24gaShuKXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7Y2xlYXJUaW1lb3V0KGUpLGNsZWFySW50ZXJ2YWwociksbigpfXZhciBlPXNldFRpbWVvdXQodCwwKSxyPXNldEludGVydmFsKHQsNTApfX10LmV4cG9ydHM9ZTt2YXIgdSxmPVtdLGM9ITEscz0wLGw9MTAyNCxhPW4uTXV0YXRpb25PYnNlcnZlcnx8bi5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO3U9XCJmdW5jdGlvblwiPT10eXBlb2YgYT9vKHIpOmkociksZS5yZXF1ZXN0Rmx1c2g9dSxlLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcj1pfSkuY2FsbCh0aGlzLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6e30pfSx7fV0sNTpbZnVuY3Rpb24obix0LGUpe1wiZnVuY3Rpb25cIiE9dHlwZW9mIFByb21pc2UucHJvdG90eXBlLmRvbmUmJihQcm9taXNlLnByb3RvdHlwZS5kb25lPWZ1bmN0aW9uKG4sdCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD90aGlzLnRoZW4uYXBwbHkodGhpcyxhcmd1bWVudHMpOnRoaXM7ZS50aGVuKG51bGwsZnVuY3Rpb24obil7c2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IG59LDApfSl9KX0se31dLDY6W2Z1bmN0aW9uKG4sdCxlKXtuKFwiYXNhcFwiKTtcInVuZGVmaW5lZFwiPT10eXBlb2YgUHJvbWlzZSYmKFByb21pc2U9bihcIi4vbGliL2NvcmUuanNcIiksbihcIi4vbGliL2VzNi1leHRlbnNpb25zLmpzXCIpKSxuKFwiLi9wb2x5ZmlsbC1kb25lLmpzXCIpfSx7XCIuL2xpYi9jb3JlLmpzXCI6MSxcIi4vbGliL2VzNi1leHRlbnNpb25zLmpzXCI6MixcIi4vcG9seWZpbGwtZG9uZS5qc1wiOjUsYXNhcDozfV19LHt9LFs2XSk7XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDEyIEJhcm5lc2FuZG5vYmxlLmNvbSwgbGxjLCBEb25hdm9uIFdlc3QsIGFuZCBEb21lbmljIERlbmljb2xhXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciBzZXRJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3MpIHtcbiAgICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHBhcnRpYWxseUFwcGxpZWQuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHNldEltbWVkaWF0ZSwgYnV0XG4gICAgLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmVxdWlyZXMgbm8gYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIHBhcnRpYWxseUFwcGxpZWQoaGFuZGxlcikge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChuZXcgRnVuY3Rpb24oXCJcIiArIGhhbmRsZXIpKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFzaygpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgc2V0VGltZW91dChwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0oZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXM7fSgpKSk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVmlld3BvcnQoKSB7XG5cbiAgICAgICAgdGhpcy5QUkVfSU9TN19WSUVXUE9SVCA9IFwiaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTEsIHVzZXItc2NhbGFibGU9bm9cIjtcbiAgICAgICAgdGhpcy5JT1M3X1ZJRVdQT1JUID0gXCJpbml0aWFsLXNjYWxlPTEsIG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ub1wiO1xuICAgICAgICB0aGlzLkRFRkFVTFRfVklFV1BPUlQgPSBcImluaXRpYWwtc2NhbGU9MSwgbWF4aW11bS1zY2FsZT0xLCB1c2VyLXNjYWxhYmxlPW5vXCI7XG5cbiAgICAgICAgdGhpcy5lbnN1cmVWaWV3cG9ydEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHt9O1xuICAgICAgICB0aGlzLnBsYXRmb3JtLm5hbWUgPSB0aGlzLmdldFBsYXRmb3JtTmFtZSgpO1xuICAgICAgICB0aGlzLnBsYXRmb3JtLnZlcnNpb24gPSB0aGlzLmdldFBsYXRmb3JtVmVyc2lvbigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuZW5zdXJlVmlld3BvcnRFbGVtZW50ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG4gICAgICAgIGlmKCF0aGlzLnZpZXdwb3J0RWxlbWVudCl7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRFbGVtZW50Lm5hbWUgPSBcInZpZXdwb3J0XCI7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMudmlld3BvcnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBWaWV3cG9ydC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdwb3J0RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1uby1hZGp1c3QnKSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0ubmFtZSA9PSAnaW9zJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0udmVyc2lvbiA+PSA3ICYmIGlzV2ViVmlldygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgdGhpcy5JT1M3X1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3cG9ydEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgdGhpcy5QUkVfSU9TN19WSUVXUE9SVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCB0aGlzLkRFRkFVTFRfVklFV1BPUlQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNXZWJWaWV3KCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKHdpbmRvdy5jb3Jkb3ZhIHx8IHdpbmRvdy5waG9uZWdhcCB8fCB3aW5kb3cuUGhvbmVHYXApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFZpZXdwb3J0LnByb3RvdHlwZS5nZXRQbGF0Zm9ybU5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcImFuZHJvaWRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUGhvbmV8aVBhZHxpUG9kL2kpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJpb3NcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVua25vd25cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgVmlld3BvcnQucHJvdG90eXBlLmdldFBsYXRmb3JtVmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdPUyAnKTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5OdW1iZXIod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuc3Vic3RyKHN0YXJ0ICsgMywgMykucmVwbGFjZSgnXycsICcuJykpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuVmlld3BvcnQgPSBWaWV3cG9ydDtcbn0pKCk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBPcGVuIFRlY2hub2xvZ2llcywgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAuICBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbi8vIEphdmFTY3JpcHQgRHluYW1pYyBDb250ZW50IHNoaW0gZm9yIFdpbmRvd3MgU3RvcmUgYXBwc1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh3aW5kb3cuTVNBcHAgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcblxuICAgICAgICAvLyBTb21lIG5vZGVzIHdpbGwgaGF2ZSBhbiBcImF0dHJpYnV0ZXNcIiBwcm9wZXJ0eSB3aGljaCBzaGFkb3dzIHRoZSBOb2RlLnByb3RvdHlwZS5hdHRyaWJ1dGVzIHByb3BlcnR5XG4gICAgICAgIC8vICBhbmQgbWVhbnMgd2UgZG9uJ3QgYWN0dWFsbHkgc2VlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBOb2RlIChpbnRlcmVzdGluZ2x5IHRoZSBWUyBkZWJ1ZyBjb25zb2xlXG4gICAgICAgIC8vICBhcHBlYXJzIHRvIHN1ZmZlciBmcm9tIHRoZSBzYW1lIGlzc3VlKS5cbiAgICAgICAgLy9cbiAgICAgICAgdmFyIEVsZW1lbnRfc2V0QXR0cmlidXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSwgXCJzZXRBdHRyaWJ1dGVcIikudmFsdWU7XG4gICAgICAgIHZhciBFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsIFwicmVtb3ZlQXR0cmlidXRlXCIpLnZhbHVlO1xuICAgICAgICB2YXIgSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRIVE1MUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsIFwiaW5zZXJ0QWRqYWNlbnRIVE1MXCIpO1xuICAgICAgICB2YXIgTm9kZV9nZXRfYXR0cmlidXRlcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsIFwiYXR0cmlidXRlc1wiKS5nZXQ7XG4gICAgICAgIHZhciBOb2RlX2dldF9jaGlsZE5vZGVzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSwgXCJjaGlsZE5vZGVzXCIpLmdldDtcbiAgICAgICAgdmFyIGRldGVjdGlvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTm9kZV9nZXRfYXR0cmlidXRlcy5jYWxsKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRWxlbWVudF9zZXRBdHRyaWJ1dGUuY2FsbChlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlLmNhbGwoZWxlbWVudCwgYXR0cmlidXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoaWxkTm9kZXMoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVfZ2V0X2NoaWxkTm9kZXMuY2FsbChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVtcHR5KGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50Lmxhc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnNlcnRBZGphY2VudEhUTUwoZWxlbWVudCwgcG9zaXRpb24sIGh0bWwpIHtcbiAgICAgICAgICAgIEhUTUxFbGVtZW50X2luc2VydEFkamFjZW50SFRNTFByb3BlcnR5RGVzY3JpcHRvci52YWx1ZS5jYWxsKGVsZW1lbnQsIHBvc2l0aW9uLCBodG1sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluVW5zYWZlTW9kZSgpIHtcbiAgICAgICAgICAgIHZhciBpc1Vuc2FmZSA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRldGVjdGlvbkRpdi5pbm5lckhUTUwgPSBcIjx0ZXN0Lz5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGlzVW5zYWZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpc1Vuc2FmZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFuc2UoaHRtbCwgdGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGNsZWFuZXIgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJjbGVhbmVyXCIpO1xuICAgICAgICAgICAgZW1wdHkoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGluc2VydEFkamFjZW50SFRNTChjbGVhbmVyLmRvY3VtZW50RWxlbWVudCwgXCJhZnRlcmJlZ2luXCIsIGh0bWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBzY3JpcHRzID0gY2xlYW5lci5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoc2NyaXB0cywgZnVuY3Rpb24gKHNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NyaXB0LnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9pbmVydFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvZWNtYXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC94LWphdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvanNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9saXZlc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0L2phdmFzY3JpcHQxLjFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvamF2YXNjcmlwdDEuMlwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9qYXZhc2NyaXB0MS4zXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9pbmVydC1cIiArIHNjcmlwdC50eXBlLnNsaWNlKFwidGV4dC9cIi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC50eXBlID0gXCJhcHBsaWNhdGlvbi9pbmVydC1cIiArIHNjcmlwdC50eXBlLnNsaWNlKFwiYXBwbGljYXRpb24vXCIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW5zZUF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlcyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBhdHRyaWJ1dGVzIGNvbGxlY3Rpb24gaXMgbGl2ZSBpdCBpcyBzaW1wbGVyIHRvIHF1ZXVlIHVwIHRoZSByZW5hbWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG5hbWVbMF0gPT09IFwib1wiIHx8IG5hbWVbMF0gPT09IFwiT1wiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lWzFdID09PSBcIm5cIiB8fCBuYW1lWzFdID09PSBcIk5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goeyBuYW1lOiBhdHRyaWJ1dGUubmFtZSwgdmFsdWU6IGF0dHJpYnV0ZS52YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZShlbGVtZW50LCBcIngtXCIgKyBhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBjaGlsZE5vZGVzKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnNlQXR0cmlidXRlcyhjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYW5zZUF0dHJpYnV0ZXMoY2xlYW5lci5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgY2xlYW5lZE5vZGVzID0gW107XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50LnRhZ05hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgICAgICAgIGNsZWFuZWROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmFkb3B0Tm9kZShjbGVhbmVyLmRvY3VtZW50RWxlbWVudCkuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjbGVhbmVyLmhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZE5vZGVzID0gY2xlYW5lZE5vZGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5hZG9wdE5vZGUoY2xlYW5lci5oZWFkKS5jaGlsZE5vZGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGVhbmVyLmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZE5vZGVzID0gY2xlYW5lZE5vZGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5hZG9wdE5vZGUoY2xlYW5lci5ib2R5KS5jaGlsZE5vZGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2xlYW5lZE5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2xlYW5zZVByb3BlcnR5U2V0dGVyKHByb3BlcnR5LCBzZXR0ZXIpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgcHJvcGVydHkpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsU2V0dGVyID0gcHJvcGVydHlEZXNjcmlwdG9yLnNldDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHdpbmRvdy5XaW5KUyAmJiB3aW5kb3cuV2luSlMuX2V4ZWNVbnNhZmUgJiYgaW5VbnNhZmVNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU2V0dGVyLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gY2xlYW5zZSh2YWx1ZSwgdGhhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyKHByb3BlcnR5RGVzY3JpcHRvciwgdGhhdCwgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHByb3BlcnR5RGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogcHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFuc2VQcm9wZXJ0eVNldHRlcihcImlubmVySFRNTFwiLCBmdW5jdGlvbiAocHJvcGVydHlEZXNjcmlwdG9yLCB0YXJnZXQsIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBlbXB0eSh0YXJnZXQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFuc2VQcm9wZXJ0eVNldHRlcihcIm91dGVySFRNTFwiLCBmdW5jdGlvbiAocHJvcGVydHlEZXNjcmlwdG9yLCB0YXJnZXQsIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbn0oKSk7IiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAoZ2xvYmFsLm9ucyA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICB2YXIgYmFiZWxIZWxwZXJzID0ge307XG5cbiAgIGJhYmVsSGVscGVycy50eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgfTtcblxuICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgIH1cbiAgIH07XG5cbiAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgIH1cbiAgICAgfVxuXG4gICAgIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgIH07XG4gICB9KSgpO1xuXG4gICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICAgICB9XG5cbiAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICB9XG4gICAgIH0pO1xuICAgICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gICB9O1xuXG4gICBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gICAgIGlmICghc2VsZikge1xuICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgfVxuXG4gICAgIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xuICAgfTtcblxuICAgYmFiZWxIZWxwZXJzLnNsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgICAgIHZhciBfYXJyID0gW107XG4gICAgICAgdmFyIF9uID0gdHJ1ZTtcbiAgICAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICAgICB0cnkge1xuICAgICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgICAgIH1cbiAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgIF9kID0gdHJ1ZTtcbiAgICAgICAgIF9lID0gZXJyO1xuICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICB0cnkge1xuICAgICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gX2FycjtcbiAgICAgfVxuXG4gICAgIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgICAgfVxuICAgICB9O1xuICAgfSkoKTtcblxuICAgYmFiZWxIZWxwZXJzO1xuXG4gICB2YXIgdW53cmFwID0gZnVuY3Rpb24gdW53cmFwKHN0cmluZykge1xuICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDEsIC0xKTtcbiAgIH07XG4gICB2YXIgaXNPYmplY3RTdHJpbmcgPSBmdW5jdGlvbiBpc09iamVjdFN0cmluZyhzdHJpbmcpIHtcbiAgICAgcmV0dXJuIHN0cmluZy5zdGFydHNXaXRoKCd7JykgJiYgc3RyaW5nLmVuZHNXaXRoKCd9Jyk7XG4gICB9O1xuICAgdmFyIGlzQXJyYXlTdHJpbmcgPSBmdW5jdGlvbiBpc0FycmF5U3RyaW5nKHN0cmluZykge1xuICAgICByZXR1cm4gc3RyaW5nLnN0YXJ0c1dpdGgoJ1snKSAmJiBzdHJpbmcuZW5kc1dpdGgoJ10nKTtcbiAgIH07XG4gICB2YXIgaXNRdW90ZWRTdHJpbmcgPSBmdW5jdGlvbiBpc1F1b3RlZFN0cmluZyhzdHJpbmcpIHtcbiAgICAgcmV0dXJuIHN0cmluZy5zdGFydHNXaXRoKCdcXCcnKSAmJiBzdHJpbmcuZW5kc1dpdGgoJ1xcJycpIHx8IHN0cmluZy5zdGFydHNXaXRoKCdcIicpICYmIHN0cmluZy5lbmRzV2l0aCgnXCInKTtcbiAgIH07XG5cbiAgIHZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSB7XG4gICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB0b2tlbiBcXCcnICsgdG9rZW4gKyAnXFwnIGF0IHBvc2l0aW9uICcgKyAob3JpZ2luYWxTdHJpbmcubGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCAtIDEpICsgJyBpbiBzdHJpbmc6IFxcJycgKyBvcmlnaW5hbFN0cmluZyArICdcXCcnKTtcbiAgIH07XG5cbiAgIHZhciBwcm9jZXNzVG9rZW4gPSBmdW5jdGlvbiBwcm9jZXNzVG9rZW4odG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpIHtcbiAgICAgaWYgKHRva2VuID09PSAndHJ1ZScgfHwgdG9rZW4gPT09ICdmYWxzZScpIHtcbiAgICAgICByZXR1cm4gdG9rZW4gPT09ICd0cnVlJztcbiAgICAgfSBlbHNlIGlmIChpc1F1b3RlZFN0cmluZyh0b2tlbikpIHtcbiAgICAgICByZXR1cm4gdW53cmFwKHRva2VuKTtcbiAgICAgfSBlbHNlIGlmICghaXNOYU4odG9rZW4pKSB7XG4gICAgICAgcmV0dXJuICt0b2tlbjtcbiAgICAgfSBlbHNlIGlmIChpc09iamVjdFN0cmluZyh0b2tlbikpIHtcbiAgICAgICByZXR1cm4gcGFyc2VPYmplY3QodW53cmFwKHRva2VuKSk7XG4gICAgIH0gZWxzZSBpZiAoaXNBcnJheVN0cmluZyh0b2tlbikpIHtcbiAgICAgICByZXR1cm4gcGFyc2VBcnJheSh1bndyYXAodG9rZW4pKTtcbiAgICAgfSBlbHNlIHtcbiAgICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgIH1cbiAgIH07XG5cbiAgIHZhciBuZXh0VG9rZW4gPSBmdW5jdGlvbiBuZXh0VG9rZW4oc3RyaW5nKSB7XG4gICAgIHN0cmluZyA9IHN0cmluZy50cmltTGVmdCgpO1xuICAgICB2YXIgbGltaXQgPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgIGlmIChzdHJpbmdbMF0gPT09ICc6JyB8fCBzdHJpbmdbMF0gPT09ICcsJykge1xuXG4gICAgICAgbGltaXQgPSAxO1xuICAgICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ3snIHx8IHN0cmluZ1swXSA9PT0gJ1snKSB7XG5cbiAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KDApO1xuICAgICAgIHZhciBuZXN0ZWRPYmplY3QgPSAxO1xuICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IGMpIHtcbiAgICAgICAgICAgbmVzdGVkT2JqZWN0Kys7XG4gICAgICAgICB9IGVsc2UgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09PSBjICsgMikge1xuICAgICAgICAgICBuZXN0ZWRPYmplY3QtLTtcbiAgICAgICAgICAgaWYgKG5lc3RlZE9iamVjdCA9PT0gMCkge1xuICAgICAgICAgICAgIGxpbWl0ID0gaSArIDE7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0gZWxzZSBpZiAoc3RyaW5nWzBdID09PSAnXFwnJyB8fCBzdHJpbmdbMF0gPT09ICdcXFwiJykge1xuXG4gICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIGlmIChzdHJpbmdbaV0gPT09IHN0cmluZ1swXSkge1xuICAgICAgICAgICBsaW1pdCA9IGkgKyAxO1xuICAgICAgICAgICBicmVhaztcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0gZWxzZSB7XG5cbiAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgaWYgKFsnICcsICcsJywgJzonXS5pbmRleE9mKHN0cmluZ1tpXSkgIT09IC0xKSB7XG4gICAgICAgICAgIGxpbWl0ID0gaTtcbiAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9XG5cbiAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBsaW1pdCk7XG4gICB9O1xuXG4gICB2YXIgcGFyc2VPYmplY3QgPSBmdW5jdGlvbiBwYXJzZU9iamVjdChzdHJpbmcpIHtcbiAgICAgdmFyIGlzVmFsaWRLZXkgPSBmdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICAgICAgIHJldHVybiAoL15bQS1aX1xcJF1bQS1aMC05X1xcJF0qJC9pLnRlc3Qoa2V5KVxuICAgICAgICk7XG4gICAgIH07XG5cbiAgICAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgICAgdmFyIG9yaWdpbmFsU3RyaW5nID0gc3RyaW5nLFxuICAgICAgICAgcmVhZGluZ0tleSA9IHRydWUsXG4gICAgICAgICBrZXkgPSB1bmRlZmluZWQsXG4gICAgICAgICBwcmV2aW91c1Rva2VuID0gdW5kZWZpbmVkLFxuICAgICAgICAgdG9rZW4gPSB1bmRlZmluZWQsXG4gICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICB3aGlsZSAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG4gICAgICAgdG9rZW4gPSBuZXh0VG9rZW4oc3RyaW5nKTtcbiAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UodG9rZW4ubGVuZ3RoLCBzdHJpbmcubGVuZ3RoKS50cmltTGVmdCgpO1xuXG4gICAgICAgaWYgKHRva2VuID09PSAnOicgJiYgKCFyZWFkaW5nS2V5IHx8ICFwcmV2aW91c1Rva2VuIHx8IHByZXZpb3VzVG9rZW4gPT09ICcsJykgfHwgdG9rZW4gPT09ICcsJyAmJiByZWFkaW5nS2V5IHx8IHRva2VuICE9PSAnOicgJiYgdG9rZW4gIT09ICcsJyAmJiBwcmV2aW91c1Rva2VuICYmIHByZXZpb3VzVG9rZW4gIT09ICcsJyAmJiBwcmV2aW91c1Rva2VuICE9PSAnOicpIHtcbiAgICAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnOicgJiYgcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICAgICBpZiAoaXNWYWxpZEtleShwcmV2aW91c1Rva2VuKSkge1xuICAgICAgICAgICBrZXkgPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICAgICByZWFkaW5nS2V5ID0gZmFsc2U7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHRva2VuIFxcJycgKyBwcmV2aW91c1Rva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAwIGluIHN0cmluZzogXFwnJyArIG9yaWdpbmFsU3RyaW5nICsgJ1xcJycpO1xuICAgICAgICAgfVxuICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJyAmJiAhcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICAgICBvYmplY3Rba2V5XSA9IHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICAgICAgIHJlYWRpbmdLZXkgPSB0cnVlO1xuICAgICAgIH1cbiAgICAgfVxuXG4gICAgIGlmICh0b2tlbikge1xuICAgICAgIG9iamVjdFtrZXldID0gcHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICAgfVxuXG4gICAgIHJldHVybiBvYmplY3Q7XG4gICB9O1xuXG4gICB2YXIgcGFyc2VBcnJheSA9IGZ1bmN0aW9uIHBhcnNlQXJyYXkoc3RyaW5nKSB7XG4gICAgIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG4gICAgIHZhciBvcmlnaW5hbFN0cmluZyA9IHN0cmluZyxcbiAgICAgICAgIHByZXZpb3VzVG9rZW4gPSB1bmRlZmluZWQsXG4gICAgICAgICB0b2tlbiA9IHVuZGVmaW5lZCxcbiAgICAgICAgIGFycmF5ID0gW107XG5cbiAgICAgd2hpbGUgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgICAgIHRva2VuID0gbmV4dFRva2VuKHN0cmluZyk7XG4gICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCwgc3RyaW5nLmxlbmd0aCkudHJpbUxlZnQoKTtcblxuICAgICAgIGlmICh0b2tlbiA9PT0gJywnICYmICghcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKSB7XG4gICAgICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJywnKSB7XG4gICAgICAgICBhcnJheS5wdXNoKHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgICAgfVxuICAgICB9XG5cbiAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgaWYgKHRva2VuICE9PSAnLCcpIHtcbiAgICAgICAgIGFycmF5LnB1c2gocHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICAgICB9XG4gICAgIH1cblxuICAgICByZXR1cm4gYXJyYXk7XG4gICB9O1xuXG4gICB2YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShzdHJpbmcpIHtcbiAgICAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcblxuICAgICBpZiAoaXNPYmplY3RTdHJpbmcoc3RyaW5nKSkge1xuICAgICAgIHJldHVybiBwYXJzZU9iamVjdCh1bndyYXAoc3RyaW5nKSk7XG4gICAgIH0gZWxzZSBpZiAoaXNBcnJheVN0cmluZyhzdHJpbmcpKSB7XG4gICAgICAgcmV0dXJuIHBhcnNlQXJyYXkodW53cmFwKHN0cmluZykpO1xuICAgICB9IGVsc2Uge1xuICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgc3RyaW5nIG11c3QgYmUgb2JqZWN0IG9yIGFycmF5IGxpa2U6ICcgKyBzdHJpbmcpO1xuICAgICB9XG4gICB9O1xuXG4gICB2YXIgdXRpbCA9IHt9O1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICovXG4gICB1dGlsLnByZXBhcmVRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICByZXR1cm4gcXVlcnkgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHF1ZXJ5IDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICByZXR1cm4gdXRpbC5tYXRjaChlbGVtZW50LCBxdWVyeSk7XG4gICAgIH07XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZS5cbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgKi9cbiAgIHV0aWwubWF0Y2ggPSBmdW5jdGlvbiAoZWxlbWVudCwgcXVlcnkpIHtcbiAgICAgaWYgKHF1ZXJ5WzBdID09PSAnLicpIHtcbiAgICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMocXVlcnkuc2xpY2UoMSkpO1xuICAgICB9XG4gICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHF1ZXJ5O1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50L251bGx9XG4gICAgKi9cbiAgIHV0aWwuZmluZENoaWxkID0gZnVuY3Rpb24gKGVsZW1lbnQsIHF1ZXJ5KSB7XG4gICAgIHZhciBtYXRjaCA9IHV0aWwucHJlcGFyZVF1ZXJ5KHF1ZXJ5KTtcblxuICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICB2YXIgbm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5baV07XG4gICAgICAgaWYgKG1hdGNoKG5vZGUpKSB7XG4gICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICB9XG4gICAgIH1cbiAgICAgcmV0dXJuIG51bGw7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZSBvciBtYXRjaGVyIGZ1bmN0aW9uLlxuICAgICogQHJldHVybiB7SFRNTEVsZW1lbnQvbnVsbH1cbiAgICAqL1xuICAgdXRpbC5maW5kQ2hpbGRSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChlbGVtZW50LCBxdWVyeSkge1xuICAgICB2YXIgbWF0Y2ggPSB1dGlsLnByZXBhcmVRdWVyeShxdWVyeSk7XG5cbiAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgdmFyIG5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2ldO1xuICAgICAgIGlmIChtYXRjaChub2RlKSkge1xuICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHZhciBub2RlTWF0Y2ggPSB1dGlsLmZpbmRDaGlsZFJlY3Vyc2l2ZWx5KG5vZGUsIG1hdGNoKTtcbiAgICAgICAgIGlmIChub2RlTWF0Y2gpIHtcbiAgICAgICAgICAgcmV0dXJuIG5vZGVNYXRjaDtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1cblxuICAgICByZXR1cm4gbnVsbDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxuICAgICovXG4gICB1dGlsLmZpbmRQYXJlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgcXVlcnkpIHtcbiAgICAgdmFyIG1hdGNoID0gdXRpbC5wcmVwYXJlUXVlcnkocXVlcnkpO1xuXG4gICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgIGZvciAoOzspIHtcbiAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICB9XG4gICAgICAgaWYgKG1hdGNoKHBhcmVudCkpIHtcbiAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgfVxuICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICB9XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAqL1xuICAgdXRpbC5pc0F0dGFjaGVkID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgd2hpbGUgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICB9XG4gICAgIHJldHVybiB0cnVlO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgKi9cbiAgIHV0aWwuaGFzQW55Q29tcG9uZW50QXNQYXJlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICB3aGlsZSAoZWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKS5tYXRjaCgvKG9ucy1uYXZpZ2F0b3J8b25zLXRhYmJhcnxvbnMtc2xpZGluZy1tZW51fG9ucy1zcGxpdC12aWV3KS8pKSB7XG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICB9XG4gICAgIH1cbiAgICAgcmV0dXJuIGZhbHNlO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gdG8gcHJvcGFnYXRlXG4gICAgKi9cbiAgIHV0aWwucHJvcGFnYXRlQWN0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFjdGlvbikge1xuICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICAgICBpZiAoY2hpbGRbYWN0aW9uXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICBjaGlsZFthY3Rpb25dKCk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKGNoaWxkLCBhY3Rpb24pO1xuICAgICAgIH1cbiAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSB0YWcgYW5kIGNsYXNzIG9ubHlcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICogQHBhcmFtIHtFbGVtZW50fVxuICAgICovXG4gICB1dGlsLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgdmFyIHNlbGVjdG9yID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJycgOiBhcmd1bWVudHNbMF07XG4gICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgIHZhciBjbGFzc0xpc3QgPSBzZWxlY3Rvci5zcGxpdCgnLicpLFxuICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY2xhc3NMaXN0LnNoaWZ0KCkgfHwgJ2RpdicpO1xuXG4gICAgIGlmIChjbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc0xpc3Quam9pbignICcpO1xuICAgICB9XG5cbiAgICAgdXRpbC5leHRlbmQoZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuXG4gICAgIHJldHVybiBlbGVtZW50O1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAqL1xuICAgdXRpbC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgd3JhcHBlci5pbm5lckhUTUwgPSBodG1sO1xuXG4gICAgIGlmICh3cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiaHRtbFwiIG11c3QgYmUgb25lIHdyYXBwZXIgZWxlbWVudC4nKTtcbiAgICAgfVxuXG4gICAgIHJldHVybiB3cmFwcGVyLmNoaWxkcmVuWzBdO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICAgICogQHJldHVybiB7SFRNTEZyYWdtZW50fVxuICAgICovXG4gICB1dGlsLmNyZWF0ZUZyYWdtZW50ID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgd3JhcHBlci5pbm5lckhUTUwgPSBodG1sO1xuICAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgIH1cblxuICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICB9O1xuXG4gICAvKlxuICAgICogQHBhcmFtIHtPYmplY3R9IGRzdCBEZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc3JjIFNvdXJjZSBvYmplY3QocykuXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZWZlcmVuY2UgdG8gYGRzdGAuXG4gICAgKi9cbiAgIHV0aWwuZXh0ZW5kID0gZnVuY3Rpb24gKGRzdCkge1xuICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgfVxuXG4gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgIGlmIChhcmdzW2ldKSB7XG4gICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFyZ3NbaV0pO1xuICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICBkc3Rba2V5XSA9IGFyZ3NbaV1ba2V5XTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1cblxuICAgICByZXR1cm4gZHN0O1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge09iamVjdH0gYXJyYXlMaWtlXG4gICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAqL1xuICAgdXRpbC5hcnJheUZyb20gPSBmdW5jdGlvbiAoYXJyYXlMaWtlKSB7XG4gICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXlMaWtlKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IGpzb25TdHJpbmdcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZmFpbFNhZmVdXG4gICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgKi9cbiAgIHV0aWwucGFyc2VKU09OT2JqZWN0U2FmZWx5ID0gZnVuY3Rpb24gKGpzb25TdHJpbmcpIHtcbiAgICAgdmFyIGZhaWxTYWZlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgdHJ5IHtcbiAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5wYXJzZSgnJyArIGpzb25TdHJpbmcpO1xuICAgICAgIGlmICgodHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IGJhYmVsSGVscGVycy50eXBlb2YocmVzdWx0KSkgPT09ICdvYmplY3QnICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICB9XG4gICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICByZXR1cm4gZmFpbFNhZmU7XG4gICAgIH1cbiAgICAgcmV0dXJuIGZhaWxTYWZlO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIHBhdGggc3VjaCBhcyAnbXlBcHAuY29udHJvbGxlcnMuZGF0YS5sb2FkRGF0YSdcbiAgICAqIEByZXR1cm4ge0FueX0gLSB3aGF0ZXZlciBpcyBsb2NhdGVkIGF0IHRoYXQgcGF0aFxuICAgICovXG4gICB1dGlsLmZpbmRGcm9tUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgIHZhciBlbCA9IHdpbmRvdyxcbiAgICAgICAgIGtleTtcbiAgICAgd2hpbGUgKGtleSA9IHBhdGguc2hpZnQoKSkge1xuICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICBlbCA9IGVsW2tleV07XG4gICAgIH1cbiAgICAgcmV0dXJuIGVsO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGV0YWlsXVxuICAgICogQHJldHVybiB7Q3VzdG9tRXZlbnR9XG4gICAgKi9cbiAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSkge1xuICAgICB2YXIgZGV0YWlsID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xuICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICB9KTtcblxuICAgICBPYmplY3Qua2V5cyhkZXRhaWwpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgIGV2ZW50W2tleV0gPSBkZXRhaWxba2V5XTtcbiAgICAgfSk7XG5cbiAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgIHJldHVybiBldmVudDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgKi9cbiAgIHV0aWwuaGFzTW9kaWZpZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBtb2RpZmllck5hbWUpIHtcbiAgICAgaWYgKCF0YXJnZXQuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICB9XG4gICAgIHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpLnNwbGl0KC9cXHMrLykuc29tZShmdW5jdGlvbiAoZSkge1xuICAgICAgIHJldHVybiBlID09PSBtb2RpZmllck5hbWU7XG4gICAgIH0pO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBpdCB3YXMgYWRkZWQgb3Igbm90LlxuICAgICovXG4gICB1dGlsLmFkZE1vZGlmaWVyID0gZnVuY3Rpb24gKHRhcmdldCwgbW9kaWZpZXJOYW1lKSB7XG4gICAgIGlmICh1dGlsLmhhc01vZGlmaWVyKHRhcmdldCwgbW9kaWZpZXJOYW1lKSkge1xuICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgfVxuXG4gICAgIG1vZGlmaWVyTmFtZSA9IG1vZGlmaWVyTmFtZS50cmltKCk7XG4gICAgIHZhciBtb2RpZmllckF0dHJpYnV0ZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJyc7XG4gICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgKG1vZGlmaWVyQXR0cmlidXRlICsgJyAnICsgbW9kaWZpZXJOYW1lKS50cmltKCkpO1xuICAgICByZXR1cm4gdHJ1ZTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGZvdW5kIG9yIG5vdC5cbiAgICAqL1xuICAgdXRpbC5yZW1vdmVNb2RpZmllciA9IGZ1bmN0aW9uICh0YXJnZXQsIG1vZGlmaWVyTmFtZSkge1xuICAgICBpZiAoIXRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgIH1cblxuICAgICB2YXIgbW9kaWZpZXJzID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKS5zcGxpdCgvXFxzKy8pO1xuXG4gICAgIHZhciBuZXdNb2RpZmllcnMgPSBtb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgcmV0dXJuIGl0ZW0gJiYgaXRlbSAhPT0gbW9kaWZpZXJOYW1lO1xuICAgICB9KTtcbiAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllcnMuam9pbignICcpKTtcblxuICAgICByZXR1cm4gbW9kaWZpZXJzLmxlbmd0aCAhPT0gbmV3TW9kaWZpZXJzLmxlbmd0aDtcbiAgIH07XG5cbiAgIHV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24gPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgaWYgKCFlbC5fcGFyZW50VXBkYXRlZCAmJiBlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLnBhcmVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICB9XG4gICAgICAgZWwuX3BhcmVudFVwZGF0ZWQgPSB0cnVlO1xuICAgICB9XG4gICB9O1xuXG4gICB1dGlsLmJpbmRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZWxlbWVudCwgbGlzdGVuZXJOYW1lcykge1xuICAgICBsaXN0ZW5lck5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICB2YXIgYm91bmROYW1lID0gbmFtZS5yZXBsYWNlKC9eX1thLXpdLywgJ19ib3VuZCcgKyBuYW1lWzFdLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgIGVsZW1lbnRbYm91bmROYW1lXSA9IGVsZW1lbnRbYm91bmROYW1lXSB8fCBlbGVtZW50W25hbWVdLmJpbmQoZWxlbWVudCk7XG4gICAgIH0pO1xuICAgfTtcblxuICAgdXRpbC5lYWNoID0gZnVuY3Rpb24gKG9iaiwgZikge1xuICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICByZXR1cm4gZihrZXksIG9ialtrZXldKTtcbiAgICAgfSk7XG4gICB9O1xuXG4gICB2YXIgc2FmZSA9IGZ1bmN0aW9uIHNhZmUoZikge1xuICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgIGlmIChmIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgfVxuICAgICB9O1xuICAgfTtcbiAgIHV0aWwuc2FmZUNhbGwgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wKSB7XG4gICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICByZXN0W19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICB9XG5cbiAgICAgcmV0dXJuIHNhZmUob2JqZWN0W3Byb3BdKS5hcHBseShvYmplY3QsIHJlc3QpO1xuICAgfTtcbiAgIHV0aWwuc2FmZUFwcGx5ID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcCwgcmVzdCkge1xuICAgICByZXR1cm4gc2FmZShvYmplY3RbcHJvcF0pLmFwcGx5KG9iamVjdCwgcmVzdCk7XG4gICB9O1xuXG4gICB2YXIgaXNPZlR5cGUgPSBmdW5jdGlvbiBpc09mVHlwZShvYmplY3QsIHR5cGUpIHtcbiAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICByZXR1cm4gdHlwZS5zb21lKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICByZXR1cm4gaXNPZlR5cGUob2JqZWN0LCB0eXBlKTtcbiAgICAgICB9KTtcbiAgICAgfVxuICAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgcmV0dXJuIHR5cGUgPT09ICdudWxsJztcbiAgICAgfVxuICAgICByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9iamVjdCBpbnN0YW5jZW9mIHR5cGUgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnICYmICh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogYmFiZWxIZWxwZXJzLnR5cGVvZihvYmplY3QpKSA9PT0gdHlwZTtcbiAgIH07XG5cbiAgIHZhciBfcHJpbnRUeXBlID0gZnVuY3Rpb24gX3ByaW50VHlwZSh0eXBlKSB7XG4gICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgcmV0dXJuIHR5cGUubWFwKF9wcmludFR5cGUpLmpvaW4oJyBvciAnKTtcbiAgICAgfVxuICAgICByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmICdhbiBpbnN0YW5jZSBvZiAnICsgdHlwZSB8fCB0eXBlID09PSAnbnVsbCcgJiYgJ251bGwnIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyAmJiAnYSAnICsgdHlwZSB8fCBKU09OLnN0cmluZ2lmeSh0eXBlKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBpbiB0aGUgZXJyb3IgaWYgdGhlIHZhbGlkYXRpb24gZmFpbHNcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfE51bWJlcnxCb29sZWFufSBvYmplY3QgLSBvYmplY3QgdG8gYmUgdmFsaWRhdGVkXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHZhbGlkYXRpb24gb3B0aW9ucyBvciB0eXBlXG4gICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xGdW5jdGlvbn0gb3B0aW9ucy50eXBlIC0gZXhwZWN0ZWQgdHlwZSBvciBhcnJheSBvZiB2YWxpZCB0eXBlc1xuICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd8RnVuY3Rpb259IG9wdGlvbnMucmV0dXJucyAtIGV4cGVjdGVkIHR5cGUgb2YgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvblxuICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnNhZmVDYWxsIC0gaWYgdGhpcyBpcyB0cnVlIHRoZW4gcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggY2FsbHMgdGhlIGBvYmplY3RgIGFyZ3VtZW50IGlmIGl0J3MgYSBmdW5jdGlvbi4gSXQgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgaXQgaXQncyBub3QuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5keW5hbWljQ2FsbCAtIGlmIHRoaXMgaXMgc2V0IHRoZW4gYWxsIGNoZWNrcyB3aWxsIGJlIGNvbXBsZXRlZCB3aGVuIHRyeWluZyB0byBleGVjdXRlIHRoZSByZXN1bHRpbmcgZnVuY3Rpb24uIEZ1cnRoZXJtb3JlIGluc3RlYWQgb2YgdXNpbmcgdGhlIGBvYmplY3RgIGFyZ3VtZW50IGl0IHdpbGwgdXNlIG9wdGlvbnMuZHluYW1pY0NhbGwncyBgb2JqZWN0W2tleV1gLlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZHluYW1pY0NhbGwub2JqZWN0IC0gcmVxdWlyZWQgaWYgZHluYW1pY0NhbGwgaXMgZXhpc3RzXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5keW5hbWljQ2FsbC5rZXkgLSByZXF1aXJlZCBpZiBkeW5hbWljQ2FsbCBpcyBleGlzdHNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmNvbnRleHQgLSB0aGlzIGlzIHN0aWxsIGFuIGV4cGVyaW1lbnRhbCBzZXR0aW5nLiBDb250ZXh0IG9mIHRoZSBmdW5jdGlvbi4gVXNlZCBvbmx5IHdpdGggZHluYW1pY0NhbGwgYW5kIHJldHVybnMuIERlZmF1bHRzIHRvIGR5bmFtaWNDYWxsLm9iamVjdC5cbiAgICAqIEByZXR1cm4gdmFsaWRhdGVkIG9iamVjdFxuICAgICogQHRocm93cyBFcnJvciBpZiB0aGUgdmFsaWRhdGlvbiBmYWlsc1xuICAgICogQGV4YW1wbGVcbiAgICAqICAgIGRvZ2UgPSB2YWxpZGF0ZWQoJ2RvZ2UnLCBkb2dlLCBbRG9nZSwgJ3N0cmluZyddKTtcbiAgICAqICAgIGZvbyA9IHZhbGlkYXRlZCgnZm9vJywgZm9vLCB7dHlwZTogWydudW1iZXInLCBBcnJheSwgJ251bGwnXX0pO1xuICAgICogICAgYmFyID0gdmFsaWRhdGVkKCdiYXInLCBiYXIsIHt0eXBlOiAnZnVuY3Rpb24nLCBzYWZlQ2FsbDogdHJ1ZX0pO1xuICAgICogICAgYmF6ID0gdmFsaWRhdGVkKCdiYXonLCBudWxsLCB7dHlwZTogJ2Z1bmN0aW9uJywgcmV0dXJuczogJ3N0cmluZycsIGR5bmFtaWNDYWxsOiB7b2JqZWN0OiBvYmosIGtleTogJ2Zvbyd9fSk7XG4gICAgKlxuICAgICogICAgaG9nZSA9IHZhbGlkYXRlZCgnaG9nZScsIG9iaiwge1xuICAgICogICAgICB0eXBlOiBbRG9nZSwgRHVja10sXG4gICAgKiAgICAgIG9iamVjdDoge1xuICAgICogICAgICAgIG5hbWU6ICdzdHJpbmcnLFxuICAgICogICAgICAgIHdvdzogJ2Jvb2xlYW4nLFxuICAgICogICAgICAgIHdhbGs6IHt0eXBlOiAnZnVuY3Rpb24nLCByZXR1cm5zOiAnYm9vbGVhbid9LFxuICAgICogICAgICAgIHRhbGs6IHt0eXBlOiAnZnVuY3Rpb24nLCBkeW5hbWljQ2FsbDoge29iamVjdDogb2JqLCBrZXk6ICdxdWFjayd9LCBzYWZlQ2FsbDogdHJ1ZX1cbiAgICAqICAgICAgfVxuICAgICogICAgfSk7XG4gICAgKlxuICAgICogQHRvZG8gU3VwcG9ydCBmb3IgZnVuY3Rpb25zIHdpdGggb3B0aW9ucy5vYmplY3QgLSB7dHlwZTogRnVuY3Rpb24sIG9iamVjdDogb2JqfVxuICAgICovXG5cbiAgIHZhciB2YWxpZGF0ZWQgPSB1dGlsLnZhbGlkYXRlZCA9IGZ1bmN0aW9uIChuYW1lLCBvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgdmFyIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCAhb3B0aW9ucy5vYmplY3QgJiYgb3B0aW9ucztcbiAgICAgaWYgKHR5cGUgJiYgIWlzT2ZUeXBlKG9iamVjdCwgdHlwZSkgJiYgIShvcHRpb25zLmR5bmFtaWNDYWxsIHx8IG9wdGlvbnMuc2FmZUNhbGwpKSB7XG4gICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyAnIG11c3QgYmUgJyArIF9wcmludFR5cGUodHlwZSkgKyAnLiBZb3UgcHJvdmlkZWQgJyArIG9iamVjdCk7XG4gICAgIH1cbiAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vYmplY3QpIHtcbiAgICAgICB2YXIgX3JldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICBuYW1lID0gbmFtZSA/IG5hbWUgKyAnLicgOiAnJztcbiAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMub2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgdmFyIGR5bmFtaWNDYWxsID0gb3B0aW9ucy5vYmplY3Rba2V5XS5keW5hbWljQ2FsbDtcbiAgICAgICAgICAgaWYgKGR5bmFtaWNDYWxsKSB7XG4gICAgICAgICAgICAgZHluYW1pY0NhbGwub2JqZWN0ID0gZHluYW1pY0NhbGwub2JqZWN0IHx8IG9iamVjdDtcbiAgICAgICAgICAgICBkeW5hbWljQ2FsbC5rZXkgPSBkeW5hbWljQ2FsbC5rZXkgfHwga2V5O1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsaWRhdGVkKG5hbWUgKyBrZXksIG9iamVjdFtrZXldLCBvcHRpb25zLm9iamVjdFtrZXldKTtcbiAgICAgICAgIH0pO1xuICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgdjogcmVzdWx0XG4gICAgICAgICB9O1xuICAgICAgIH0pKCk7XG5cbiAgICAgICBpZiAoKHR5cGVvZiBfcmV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogYmFiZWxIZWxwZXJzLnR5cGVvZihfcmV0KSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gICAgIH1cbiAgICAgaWYgKHR5cGUgPT09IEZ1bmN0aW9uIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICB2YXIgX3JldDIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgdmFyIF9yZWYgPSBvcHRpb25zLmR5bmFtaWNDYWxsIHx8IHt9O1xuXG4gICAgICAgICB2YXIgb2JqID0gX3JlZi5vYmplY3Q7XG4gICAgICAgICB2YXIga2V5ID0gX3JlZi5rZXk7XG5cbiAgICAgICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0IHx8IG9iajtcbiAgICAgICAgIHZhciB0ZXN0ID0gb3B0aW9ucy5zYWZlQ2FsbCA/IHNhZmUgOiBvcHRpb25zLmR5bmFtaWNDYWxsID8gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlZChuYW1lLCBmLCBGdW5jdGlvbik7XG4gICAgICAgICB9IDogZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICB9O1xuXG4gICAgICAgICBvYmplY3QgPSBvcHRpb25zLmR5bmFtaWNDYWxsID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgICAgIHJlc3RbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIHJldHVybiB0ZXN0KG9ialtrZXldKS5hcHBseShjb250ZXh0LCByZXN0KTtcbiAgICAgICAgIH0gOiB0ZXN0KG9iamVjdCk7XG5cbiAgICAgICAgIGlmIChvcHRpb25zLnJldHVybnMpIHtcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICB2OiBmdW5jdGlvbiB2KCkge1xuICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgICAgICAgICAgcmVzdFtfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVkKG5hbWUgKyAnXFwncyByZXN1bHQnLCBvYmplY3QuYXBwbHkoY29udGV4dCwgcmVzdCksIG9wdGlvbnMucmV0dXJucyk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9O1xuICAgICAgICAgfVxuICAgICAgIH0pKCk7XG5cbiAgICAgICBpZiAoKHR5cGVvZiBfcmV0MiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IGJhYmVsSGVscGVycy50eXBlb2YoX3JldDIpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQyLnY7XG4gICAgIH1cbiAgICAgcmV0dXJuIG9iamVjdDtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICAqL1xuICAgdXRpbC51cGRhdGVSaXBwbGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgIHZhciByaXBwbGVFbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGFyZ2V0LCAnb25zLXJpcHBsZScpO1xuXG4gICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKCdyaXBwbGUnKSkge1xuICAgICAgIGlmICghcmlwcGxlRWxlbWVudCkge1xuICAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtcmlwcGxlJyksIHRhcmdldC5maXJzdENoaWxkKTtcbiAgICAgICB9XG4gICAgIH0gZWxzZSBpZiAocmlwcGxlRWxlbWVudCkge1xuICAgICAgIHJpcHBsZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtTdHJpbmd9XG4gICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgKi9cbiAgIHV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlID0gcGFyc2U7XG5cbiAgIHZhciBFdmVudCQxO1xuICAgdmFyIFV0aWxzO1xuICAgdmFyIERldGVjdGlvbjtcbiAgIHZhciBQb2ludGVyRXZlbnQ7XG4gICAvKipcbiAgICAqIEBvYmplY3Qgb25zLkdlc3R1cmVEZXRlY3RvclxuICAgICogQGNhdGVnb3J5IHV0aWxcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dVXRpbGl0eSBjbGFzcyBmb3IgZ2VzdHVyZSBkZXRlY3Rpb24uWy9lbl1cbiAgICAqICAgW2phXeOCuOOCp+OCueODgeODo+OCkuaknOefpeOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+OCr+ODqeOCueOBp+OBmeOAglsvamFdXG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAgKiBAc2lnbmF0dXJlIGNvbnN0cnVjdG9yKGVsZW1lbnRbLCBvcHRpb25zXSlcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogIFtlbl1DcmVhdGUgYSBuZXcgR2VzdHVyZURldGVjdG9yIGluc3RhbmNlLlsvZW5dXG4gICAgKiAgW2phXUdlc3R1cmVEZXRlY3RvcuOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PjgpLmpJznn6XjgZnjgotET03opoHntKDjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICogICBbZW5dT3B0aW9ucyBvYmplY3QuWy9lbl1cbiAgICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAcmV0dXJuIHtvbnMuR2VzdHVyZURldGVjdG9yLkluc3RhbmNlfVxuICAgICovXG4gICB2YXIgR2VzdHVyZURldGVjdG9yID0gZnVuY3Rpb24gR2VzdHVyZURldGVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgcmV0dXJuIG5ldyBHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UoZWxlbWVudCwgb3B0aW9ucyB8fCB7fSk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIGRlZmF1bHQgc2V0dGluZ3MuXG4gICAgKiBtb3JlIHNldHRpbmdzIGFyZSBkZWZpbmVkIHBlciBnZXN0dXJlIGF0IGAvZ2VzdHVyZXNgLiBFYWNoIGdlc3R1cmUgY2FuIGJlIGRpc2FibGVkL2VuYWJsZWRcbiAgICAqIGJ5IHNldHRpbmcgaXQncyBuYW1lIChsaWtlIGBzd2lwZWApIHRvIGZhbHNlLlxuICAgICogWW91IGNhbiBzZXQgdGhlIGRlZmF1bHRzIGZvciBhbGwgaW5zdGFuY2VzIGJ5IGNoYW5naW5nIHRoaXMgb2JqZWN0IGJlZm9yZSBjcmVhdGluZyBhbiBpbnN0YW5jZS5cbiAgICAqIEBleGFtcGxlXG4gICAgKiBgYGBgXG4gICAgKiAgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmRyYWcgPSBmYWxzZTtcbiAgICAqICBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuYmVoYXZpb3IudG91Y2hBY3Rpb24gPSAncGFuLXknO1xuICAgICogIGRlbGV0ZSBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuYmVoYXZpb3IudXNlclNlbGVjdDtcbiAgICAqIGBgYGBcbiAgICAqIEBwcm9wZXJ0eSBkZWZhdWx0c1xuICAgICogQHR5cGUge09iamVjdH1cbiAgICAqL1xuICAgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzID0ge1xuICAgICBiZWhhdmlvcjoge1xuICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICB0b3VjaEFjdGlvbjogJ3Bhbi15JyxcbiAgICAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcbiAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuICAgICAgIHVzZXJEcmFnOiAnbm9uZScsXG4gICAgICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICAgICB9XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEdlc3R1cmVEZXRlY3RvciBkb2N1bWVudCB3aGVyZSB0aGUgYmFzZSBldmVudHMgYXJlIGFkZGVkIGF0XG4gICAgKiBAcHJvcGVydHkgRE9DVU1FTlRcbiAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAqIEBkZWZhdWx0IHdpbmRvdy5kb2N1bWVudFxuICAgICovXG4gICBHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQgPSBkb2N1bWVudDtcblxuICAgLyoqXG4gICAgKiBkZXRlY3Qgc3VwcG9ydCBmb3IgcG9pbnRlciBldmVudHNcbiAgICAqIEBwcm9wZXJ0eSBIQVNfUE9JTlRFUkVWRU5UU1xuICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgKi9cbiAgIEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUyA9IG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZDtcblxuICAgLyoqXG4gICAgKiBkZXRlY3Qgc3VwcG9ydCBmb3IgdG91Y2ggZXZlbnRzXG4gICAgKiBAcHJvcGVydHkgSEFTX1RPVUNIRVZFTlRTXG4gICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAqL1xuICAgR2VzdHVyZURldGVjdG9yLkhBU19UT1VDSEVWRU5UUyA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcblxuICAgLyoqXG4gICAgKiBkZXRlY3QgbW9iaWxlIGJyb3dzZXJzXG4gICAgKiBAcHJvcGVydHkgSVNfTU9CSUxFXG4gICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAqL1xuICAgR2VzdHVyZURldGVjdG9yLklTX01PQklMRSA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWR8c2lsay9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgIC8qKlxuICAgICogZGV0ZWN0IGlmIHdlIHdhbnQgdG8gc3VwcG9ydCBtb3VzZWV2ZW50cyBhdCBhbGxcbiAgICAqIEBwcm9wZXJ0eSBOT19NT1VTRUVWRU5UU1xuICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgKi9cbiAgIEdlc3R1cmVEZXRlY3Rvci5OT19NT1VTRUVWRU5UUyA9IEdlc3R1cmVEZXRlY3Rvci5IQVNfVE9VQ0hFVkVOVFMgJiYgR2VzdHVyZURldGVjdG9yLklTX01PQklMRSB8fCBHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFM7XG5cbiAgIC8qKlxuICAgICogaW50ZXJ2YWwgaW4gd2hpY2ggR2VzdHVyZURldGVjdG9yIHJlY2FsY3VsYXRlcyBjdXJyZW50IHZlbG9jaXR5L2RpcmVjdGlvbi9hbmdsZSBpbiBtc1xuICAgICogQHByb3BlcnR5IENBTENVTEFURV9JTlRFUlZBTFxuICAgICogQHR5cGUge051bWJlcn1cbiAgICAqIEBkZWZhdWx0IDI1XG4gICAgKi9cbiAgIEdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwgPSAyNTtcblxuICAgLyoqXG4gICAgKiBldmVudHR5cGVzIHBlciB0b3VjaGV2ZW50IChzdGFydCwgbW92ZSwgZW5kKSBhcmUgZmlsbGVkIGJ5IGBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzYCBvbiBgc2V0dXBgXG4gICAgKiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBET00gZXZlbnQgbmFtZXMgcGVyIHR5cGUgKGBFVkVOVF9TVEFSVGAsIGBFVkVOVF9NT1ZFYCwgYEVWRU5UX0VORGApXG4gICAgKiBAcHJvcGVydHkgRVZFTlRfVFlQRVNcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAd3JpdGVPbmNlXG4gICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICovXG4gICB2YXIgRVZFTlRfVFlQRVMgPSB7fTtcblxuICAgLyoqXG4gICAgKiBkaXJlY3Rpb24gc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAgICAqIEBwcm9wZXJ0eSBESVJFQ1RJT05fRE9XTnxMRUZUfFVQfFJJR0hUXG4gICAgKiBAZmluYWxcbiAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgKiBAZGVmYXVsdCAnZG93bicgJ2xlZnQnICd1cCcgJ3JpZ2h0J1xuICAgICovXG4gICB2YXIgRElSRUNUSU9OX0RPV04gPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX0RPV04gPSAnZG93bic7XG4gICB2YXIgRElSRUNUSU9OX0xFRlQgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX0xFRlQgPSAnbGVmdCc7XG4gICB2YXIgRElSRUNUSU9OX1VQID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9VUCA9ICd1cCc7XG4gICB2YXIgRElSRUNUSU9OX1JJR0hUID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XG5cbiAgIC8qKlxuICAgICogcG9pbnRlcnR5cGUgc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAgICAqIEBwcm9wZXJ0eSBQT0lOVEVSX01PVVNFfFRPVUNIfFBFTlxuICAgICogQGZpbmFsXG4gICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICogQGRlZmF1bHQgJ21vdXNlJyAndG91Y2gnICdwZW4nXG4gICAgKi9cbiAgIHZhciBQT0lOVEVSX01PVVNFID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfTU9VU0UgPSAnbW91c2UnO1xuICAgdmFyIFBPSU5URVJfVE9VQ0ggPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9UT1VDSCA9ICd0b3VjaCc7XG4gICB2YXIgUE9JTlRFUl9QRU4gPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9QRU4gPSAncGVuJztcblxuICAgLyoqXG4gICAgKiBldmVudHR5cGVzXG4gICAgKiBAcHJvcGVydHkgRVZFTlRfU1RBUlR8TU9WRXxFTkR8UkVMRUFTRXxUT1VDSFxuICAgICogQGZpbmFsXG4gICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICogQGRlZmF1bHQgJ3N0YXJ0JyAnY2hhbmdlJyAnbW92ZScgJ2VuZCcgJ3JlbGVhc2UnICd0b3VjaCdcbiAgICAqL1xuICAgdmFyIEVWRU5UX1NUQVJUID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1NUQVJUID0gJ3N0YXJ0JztcbiAgIHZhciBFVkVOVF9NT1ZFID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX01PVkUgPSAnbW92ZSc7XG4gICB2YXIgRVZFTlRfRU5EID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX0VORCA9ICdlbmQnO1xuICAgdmFyIEVWRU5UX1JFTEVBU0UgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfUkVMRUFTRSA9ICdyZWxlYXNlJztcbiAgIHZhciBFVkVOVF9UT1VDSCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9UT1VDSCA9ICd0b3VjaCc7XG5cbiAgIC8qKlxuICAgICogaWYgdGhlIHdpbmRvdyBldmVudHMgYXJlIHNldC4uLlxuICAgICogQHByb3BlcnR5IFJFQURZXG4gICAgKiBAd3JpdGVPbmNlXG4gICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgKi9cbiAgIEdlc3R1cmVEZXRlY3Rvci5SRUFEWSA9IGZhbHNlO1xuXG4gICAvKipcbiAgICAqIHBsdWdpbnMgbmFtZXNwYWNlXG4gICAgKiBAcHJvcGVydHkgcGx1Z2luc1xuICAgICogQHR5cGUge09iamVjdH1cbiAgICAqL1xuICAgR2VzdHVyZURldGVjdG9yLnBsdWdpbnMgPSBHZXN0dXJlRGV0ZWN0b3IucGx1Z2lucyB8fCB7fTtcblxuICAgLyoqXG4gICAgKiBnZXN0dXJlcyBuYW1lc3BhY2VcbiAgICAqIHNlZSBgL2dlc3R1cmVzYCBmb3IgdGhlIGRlZmluaXRpb25zXG4gICAgKiBAcHJvcGVydHkgZ2VzdHVyZXNcbiAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgKi9cbiAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyA9IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyB8fCB7fTtcblxuICAgLyoqXG4gICAgKiBzZXR1cCBldmVudHMgdG8gZGV0ZWN0IGdlc3R1cmVzIG9uIHRoZSBkb2N1bWVudFxuICAgICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBjcmVhdGluZyBhbiBuZXcgaW5zdGFuY2VcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICBpZiAoR2VzdHVyZURldGVjdG9yLlJFQURZKSB7XG4gICAgICAgcmV0dXJuO1xuICAgICB9XG5cbiAgICAgLy8gZmluZCB3aGF0IGV2ZW50dHlwZXMgd2UgYWRkIGxpc3RlbmVycyB0b1xuICAgICBFdmVudCQxLmRldGVybWluZUV2ZW50VHlwZXMoKTtcblxuICAgICAvLyBSZWdpc3RlciBhbGwgZ2VzdHVyZXMgaW5zaWRlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlc1xuICAgICBVdGlscy5lYWNoKEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcywgZnVuY3Rpb24gKGdlc3R1cmUpIHtcbiAgICAgICBEZXRlY3Rpb24ucmVnaXN0ZXIoZ2VzdHVyZSk7XG4gICAgIH0pO1xuXG4gICAgIC8vIEFkZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50XG4gICAgIEV2ZW50JDEub25Ub3VjaChHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQsIEVWRU5UX01PVkUsIERldGVjdGlvbi5kZXRlY3QpO1xuICAgICBFdmVudCQxLm9uVG91Y2goR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5ULCBFVkVOVF9FTkQsIERldGVjdGlvbi5kZXRlY3QpO1xuXG4gICAgIC8vIEdlc3R1cmVEZXRlY3RvciBpcyByZWFkeS4uLiFcbiAgICAgR2VzdHVyZURldGVjdG9yLlJFQURZID0gdHJ1ZTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICAgICpcbiAgICAqIEBjbGFzcyBVdGlsc1xuICAgICogQHN0YXRpY1xuICAgICovXG4gICBVdGlscyA9IEdlc3R1cmVEZXRlY3Rvci51dGlscyA9IHtcbiAgICAgLyoqXG4gICAgICAqIGV4dGVuZCBtZXRob2QsIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgY2xvbmluZyB3aGVuIGBkZXN0YCBpcyBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAqIGNoYW5nZXMgdGhlIGRlc3Qgb2JqZWN0XG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICAgICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdICBkbyBhIG1lcmdlXG4gICAgICAqIEByZXR1cm4ge09iamVjdH0gZGVzdFxuICAgICAgKi9cbiAgICAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZGVzdFtrZXldID09PSB1bmRlZmluZWQgfHwgIW1lcmdlKSkge1xuICAgICAgICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIHNpbXBsZSBhZGRFdmVudExpc3RlbmVyIHdyYXBwZXJcbiAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICAqL1xuICAgICBvbjogZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIHNpbXBsZSByZW1vdmVFdmVudExpc3RlbmVyIHdyYXBwZXJcbiAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICAqL1xuICAgICBvZmY6IGZ1bmN0aW9uIG9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogZm9yRWFjaCBvdmVyIGFycmF5cyBhbmQgb2JqZWN0c1xuICAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAgICAqIEBwYXJhbSB7YW55fSBpdGVyYXRvci5pdGVtXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyYXRvci5pbmRleFxuICAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gaXRlcmF0b3Iub2JqIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IHZhbHVlIHRvIHVzZSBhcyBgdGhpc2AgaW4gdGhlIGl0ZXJhdG9yXG4gICAgICAqL1xuICAgICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgICB2YXIgaSwgbGVuO1xuXG4gICAgICAgLy8gbmF0aXZlIGZvckVhY2ggb24gYXJyYXlzXG4gICAgICAgaWYgKCdmb3JFYWNoJyBpbiBvYmopIHtcbiAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgIC8vIGFycmF5c1xuICAgICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgIGlmIChpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgLy8gb2JqZWN0c1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIGZpbmQgaWYgYSBzdHJpbmcgY29udGFpbnMgdGhlIHN0cmluZyB1c2luZyBpbmRleE9mXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICAgICovXG4gICAgIGluU3RyOiBmdW5jdGlvbiBpblN0cihzcmMsIGZpbmQpIHtcbiAgICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCkgPiAtMTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5ZmlsbFxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAgICAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gICAgICAqL1xuICAgICBpbkFycmF5OiBmdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCkge1xuICAgICAgIGlmIChzcmMuaW5kZXhPZikge1xuICAgICAgICAgdmFyIGluZGV4ID0gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gZmFsc2UgOiBpbmRleDtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNyYy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICBpZiAoc3JjW2ldID09PSBmaW5kKSB7XG4gICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QgKGBhcmd1bWVudHNgLCBgdG91Y2hsaXN0YCkgdG8gYW4gYXJyYXlcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICovXG4gICAgIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICAgICovXG4gICAgIGhhc1BhcmVudDogZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICB9XG4gICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgdG91Y2hlc1xuICAgICAgKiBAcGFyYW0ge0FycmF5fSB0b3VjaGVzXG4gICAgICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGBwYWdlWGAsIGBwYWdlWWAsIGBjbGllbnRYYCBhbmQgYGNsaWVudFlgIHByb3BlcnRpZXNcbiAgICAgICovXG4gICAgIGdldENlbnRlcjogZnVuY3Rpb24gZ2V0Q2VudGVyKHRvdWNoZXMpIHtcbiAgICAgICB2YXIgcGFnZVggPSBbXSxcbiAgICAgICAgICAgcGFnZVkgPSBbXSxcbiAgICAgICAgICAgY2xpZW50WCA9IFtdLFxuICAgICAgICAgICBjbGllbnRZID0gW10sXG4gICAgICAgICAgIG1pbiA9IE1hdGgubWluLFxuICAgICAgICAgICBtYXggPSBNYXRoLm1heDtcblxuICAgICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgICAgaWYgKHRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICBwYWdlWDogdG91Y2hlc1swXS5wYWdlWCxcbiAgICAgICAgICAgcGFnZVk6IHRvdWNoZXNbMF0ucGFnZVksXG4gICAgICAgICAgIGNsaWVudFg6IHRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgY2xpZW50WTogdG91Y2hlc1swXS5jbGllbnRZXG4gICAgICAgICB9O1xuICAgICAgIH1cblxuICAgICAgIFV0aWxzLmVhY2godG91Y2hlcywgZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgICBwYWdlWC5wdXNoKHRvdWNoLnBhZ2VYKTtcbiAgICAgICAgIHBhZ2VZLnB1c2godG91Y2gucGFnZVkpO1xuICAgICAgICAgY2xpZW50WC5wdXNoKHRvdWNoLmNsaWVudFgpO1xuICAgICAgICAgY2xpZW50WS5wdXNoKHRvdWNoLmNsaWVudFkpO1xuICAgICAgIH0pO1xuXG4gICAgICAgcmV0dXJuIHtcbiAgICAgICAgIHBhZ2VYOiAobWluLmFwcGx5KE1hdGgsIHBhZ2VYKSArIG1heC5hcHBseShNYXRoLCBwYWdlWCkpIC8gMixcbiAgICAgICAgIHBhZ2VZOiAobWluLmFwcGx5KE1hdGgsIHBhZ2VZKSArIG1heC5hcHBseShNYXRoLCBwYWdlWSkpIC8gMixcbiAgICAgICAgIGNsaWVudFg6IChtaW4uYXBwbHkoTWF0aCwgY2xpZW50WCkgKyBtYXguYXBwbHkoTWF0aCwgY2xpZW50WCkpIC8gMixcbiAgICAgICAgIGNsaWVudFk6IChtaW4uYXBwbHkoTWF0aCwgY2xpZW50WSkgKyBtYXguYXBwbHkoTWF0aCwgY2xpZW50WSkpIC8gMlxuICAgICAgIH07XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICAgICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICAgICAgKi9cbiAgICAgZ2V0VmVsb2NpdHk6IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgICByZXR1cm4ge1xuICAgICAgICAgeDogTWF0aC5hYnMoZGVsdGFYIC8gZGVsdGFUaW1lKSB8fCAwLFxuICAgICAgICAgeTogTWF0aC5hYnMoZGVsdGFZIC8gZGVsdGFUaW1lKSB8fCAwXG4gICAgICAgfTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAgICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAgICAgICovXG4gICAgIGdldEFuZ2xlOiBmdW5jdGlvbiBnZXRBbmdsZSh0b3VjaDEsIHRvdWNoMikge1xuICAgICAgIHZhciB4ID0gdG91Y2gyLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WCxcbiAgICAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIGRvIGEgc21hbGwgY29tcGFyaXNvbiB0byBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byB0b3VjaGVzLlxuICAgICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAgICAqIEByZXR1cm4ge1N0cmluZ30gZGlyZWN0aW9uIG1hdGNoZXMgYERJUkVDVElPTl9MRUZUfFJJR0hUfFVQfERPV05gXG4gICAgICAqL1xuICAgICBnZXREaXJlY3Rpb246IGZ1bmN0aW9uIGdldERpcmVjdGlvbih0b3VjaDEsIHRvdWNoMikge1xuICAgICAgIHZhciB4ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCksXG4gICAgICAgICAgIHkgPSBNYXRoLmFicyh0b3VjaDEuY2xpZW50WSAtIHRvdWNoMi5jbGllbnRZKTtcblxuICAgICAgIGlmICh4ID49IHkpIHtcbiAgICAgICAgIHJldHVybiB0b3VjaDEuY2xpZW50WCAtIHRvdWNoMi5jbGllbnRYID4gMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gdG91Y2gxLmNsaWVudFkgLSB0b3VjaDIuY2xpZW50WSA+IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0b3VjaGVzXG4gICAgICAqIEBwYXJhbSB7VG91Y2h9dG91Y2gxXG4gICAgICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxuICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAgICAqL1xuICAgICBnZXREaXN0YW5jZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2UodG91Y2gxLCB0b3VjaDIpIHtcbiAgICAgICB2YXIgeCA9IHRvdWNoMi5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFgsXG4gICAgICAgICAgIHkgPSB0b3VjaDIuY2xpZW50WSAtIHRvdWNoMS5jbGllbnRZO1xuXG4gICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xuICAgICAgKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAgICAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xuICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gICAgICAqL1xuICAgICBnZXRTY2FsZTogZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgICAgIC8vIG5lZWQgdHdvIGZpbmdlcnMuLi5cbiAgICAgICBpZiAoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5nZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSkgLyB0aGlzLmdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSk7XG4gICAgICAgfVxuICAgICAgIHJldHVybiAxO1xuICAgICB9LFxuXG4gICAgIC8qKlxuICAgICAgKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xuICAgICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiB0b3VjaGVzXG4gICAgICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiB0b3VjaGVzXG4gICAgICAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAgICAgICovXG4gICAgIGdldFJvdGF0aW9uOiBmdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgLy8gbmVlZCB0d28gZmluZ2Vyc1xuICAgICAgIGlmIChzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdKSAtIHRoaXMuZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdKTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIDA7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIGZpbmQgb3V0IGlmIHRoZSBkaXJlY3Rpb24gaXMgdmVydGljYWwgICAqXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gbWF0Y2hlcyBgRElSRUNUSU9OX1VQfERPV05gXG4gICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzX3ZlcnRpY2FsXG4gICAgICAqL1xuICAgICBpc1ZlcnRpY2FsOiBmdW5jdGlvbiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikge1xuICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX1VQIHx8IGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fRE9XTjtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogc2V0IGNzcyBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgcHJlZml4ZXNcbiAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAqL1xuICAgICBzZXRQcmVmaXhlZENzczogZnVuY3Rpb24gc2V0UHJlZml4ZWRDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUsIHRvZ2dsZSkge1xuICAgICAgIHZhciBwcmVmaXhlcyA9IFsnJywgJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddO1xuICAgICAgIHByb3AgPSBVdGlscy50b0NhbWVsQ2FzZShwcm9wKTtcblxuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHZhciBwID0gcHJvcDtcbiAgICAgICAgIC8vIHByZWZpeGVzXG4gICAgICAgICBpZiAocHJlZml4ZXNbaV0pIHtcbiAgICAgICAgICAgcCA9IHByZWZpeGVzW2ldICsgcC5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpICsgcC5zbGljZSgxKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgLy8gdGVzdCB0aGUgc3R5bGVcbiAgICAgICAgIGlmIChwIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwXSA9ICh0b2dnbGUgPT09IG51bGwgfHwgdG9nZ2xlKSAmJiB2YWx1ZSB8fCAnJztcbiAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LFxuXG4gICAgIC8qKlxuICAgICAgKiB0b2dnbGUgYnJvd3NlciBkZWZhdWx0IGJlaGF2aW9yIGJ5IHNldHRpbmcgY3NzIHByb3BlcnRpZXMuXG4gICAgICAqIGB1c2VyU2VsZWN0PSdub25lJ2AgYWxzbyBzZXRzIGBlbGVtZW50Lm9uc2VsZWN0c3RhcnRgIHRvIGZhbHNlXG4gICAgICAqIGB1c2VyRHJhZz0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbmRyYWdzdGFydGAgdG8gZmFsc2VcbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtIdG1sRWxlbWVudH0gZWxlbWVudFxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICAgICogQHBhcmFtIHtCb29sZWFufSBbdG9nZ2xlPXRydWVdXG4gICAgICAqL1xuICAgICB0b2dnbGVCZWhhdmlvcjogZnVuY3Rpb24gdG9nZ2xlQmVoYXZpb3IoZWxlbWVudCwgcHJvcHMsIHRvZ2dsZSkge1xuICAgICAgIGlmICghcHJvcHMgfHwgIWVsZW1lbnQgfHwgIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgICB9XG5cbiAgICAgICAvLyBzZXQgdGhlIGNzcyBwcm9wZXJ0aWVzXG4gICAgICAgVXRpbHMuZWFjaChwcm9wcywgZnVuY3Rpb24gKHZhbHVlLCBwcm9wKSB7XG4gICAgICAgICBVdGlscy5zZXRQcmVmaXhlZENzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSwgdG9nZ2xlKTtcbiAgICAgICB9KTtcblxuICAgICAgIHZhciBmYWxzZUZuID0gdG9nZ2xlICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICB9O1xuXG4gICAgICAgLy8gYWxzbyB0aGUgZGlzYWJsZSBvbnNlbGVjdHN0YXJ0XG4gICAgICAgaWYgKHByb3BzLnVzZXJTZWxlY3QgPT0gJ25vbmUnKSB7XG4gICAgICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICAgICAgIH1cbiAgICAgICAvLyBhbmQgZGlzYWJsZSBvbmRyYWdzdGFydFxuICAgICAgIGlmIChwcm9wcy51c2VyRHJhZyA9PSAnbm9uZScpIHtcbiAgICAgICAgIGVsZW1lbnQub25kcmFnc3RhcnQgPSBmYWxzZUZuO1xuICAgICAgIH1cbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogY29udmVydCBhIHN0cmluZyB3aXRoIHVuZGVyc2NvcmVzIHRvIGNhbWVsQ2FzZVxuICAgICAgKiBzbyBwcmV2ZW50X2RlZmF1bHQgYmVjb21lcyBwcmV2ZW50RGVmYXVsdFxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgICAqIEByZXR1cm4ge1N0cmluZ30gY2FtZWxDYXNlU3RyXG4gICAgICAqL1xuICAgICB0b0NhbWVsQ2FzZTogZnVuY3Rpb24gdG9DYW1lbENhc2Uoc3RyKSB7XG4gICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXy1dKFthLXpdKS9nLCBmdW5jdGlvbiAocykge1xuICAgICAgICAgcmV0dXJuIHNbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICB9KTtcbiAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICAgICovXG4gICAvKipcbiAgICAqIEBjbGFzcyBFdmVudFxuICAgICogQHN0YXRpY1xuICAgICovXG4gICBFdmVudCQxID0gR2VzdHVyZURldGVjdG9yLmV2ZW50ID0ge1xuICAgICAvKipcbiAgICAgICogd2hlbiB0b3VjaCBldmVudHMgaGF2ZSBiZWVuIGZpcmVkLCB0aGlzIGlzIHRydWVcbiAgICAgICogdGhpcyBpcyB1c2VkIHRvIHN0b3AgbW91c2UgZXZlbnRzXG4gICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50X21vdXNlZXZlbnRzXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgKi9cbiAgICAgcHJldmVudE1vdXNlRXZlbnRzOiBmYWxzZSxcblxuICAgICAvKipcbiAgICAgICogaWYgRVZFTlRfU1RBUlQgaGFzIGJlZW4gZmlyZWRcbiAgICAgICogQHByb3BlcnR5IHN0YXJ0ZWRcbiAgICAgICogQHByaXZhdGVcbiAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAqL1xuICAgICBzdGFydGVkOiBmYWxzZSxcblxuICAgICAvKipcbiAgICAgICogd2hlbiB0aGUgbW91c2UgaXMgaG9sZCBkb3duLCB0aGlzIGlzIHRydWVcbiAgICAgICogQHByb3BlcnR5IHNob3VsZF9kZXRlY3RcbiAgICAgICogQHByaXZhdGVcbiAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAqL1xuICAgICBzaG91bGREZXRlY3Q6IGZhbHNlLFxuXG4gICAgIC8qKlxuICAgICAgKiBzaW1wbGUgZXZlbnQgYmluZGVyIHdpdGggYSBob29rIGFuZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB0eXBlc1xuICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBob29rLnR5cGVcbiAgICAgICovXG4gICAgIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBob29rKSB7XG4gICAgICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgICAgIFV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICBVdGlscy5vbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICAgICB9KTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogc2ltcGxlIGV2ZW50IHVuYmluZGVyIHdpdGggYSBob29rIGFuZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB0eXBlc1xuICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBob29rLnR5cGVcbiAgICAgICovXG4gICAgIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGhvb2spIHtcbiAgICAgICB2YXIgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XG4gICAgICAgVXRpbHMuZWFjaCh0eXBlcywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgIFV0aWxzLm9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICAgICB9KTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogdGhlIGNvcmUgdG91Y2ggZXZlbnQgaGFuZGxlci5cbiAgICAgICogdGhpcyBmaW5kcyBvdXQgaWYgd2Ugc2hvdWxkIHRvIGRldGVjdCBnZXN0dXJlc1xuICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgICogQHJldHVybiBvblRvdWNoSGFuZGxlciB7RnVuY3Rpb259IHRoZSBjb3JlIGV2ZW50IGhhbmRsZXJcbiAgICAgICovXG4gICAgIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goZWxlbWVudCwgZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgdmFyIG9uVG91Y2hIYW5kbGVyID0gZnVuY3Rpb24gb25Ub3VjaEhhbmRsZXIoZXYpIHtcbiAgICAgICAgIHZhciBzcmNUeXBlID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgIGlzUG9pbnRlciA9IEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUyxcbiAgICAgICAgICAgICBpc01vdXNlID0gVXRpbHMuaW5TdHIoc3JjVHlwZSwgJ21vdXNlJyksXG4gICAgICAgICAgICAgdHJpZ2dlclR5cGU7XG5cbiAgICAgICAgIC8vIGlmIHdlIGFyZSBpbiBhIG1vdXNlZXZlbnQsIGJ1dCB0aGVyZSBoYXMgYmVlbiBhIHRvdWNoZXZlbnQgdHJpZ2dlcmVkIGluIHRoaXMgc2Vzc2lvblxuICAgICAgICAgLy8gd2Ugd2FudCB0byBkbyBub3RoaW5nLiBzaW1wbHkgYnJlYWsgb3V0IG9mIHRoZSBldmVudC5cbiAgICAgICAgIGlmIChpc01vdXNlICYmIHNlbGYucHJldmVudE1vdXNlRXZlbnRzKSB7XG4gICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAvLyBtb3VzZWJ1dHRvbiBtdXN0IGJlIGRvd25cbiAgICAgICAgIH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IHRydWU7XG4gICAgICAgICAgIH0gZWxzZSBpZiAoaXNQb2ludGVyICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gZXYuYnV0dG9ucyA9PT0gMSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfVE9VQ0gsIGV2KTtcbiAgICAgICAgICAgICAvLyBqdXN0IGEgdmFsaWQgc3RhcnQgZXZlbnQsIGJ1dCBubyBtb3VzZVxuICAgICAgICAgICB9IGVsc2UgaWYgKCFpc01vdXNlICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgICAgICAgIH1cblxuICAgICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyIGV2ZW50IGJlZm9yZSBlbnRlcmluZyB0aGUgZGV0ZWN0aW9uXG4gICAgICAgICBpZiAoaXNQb2ludGVyICYmIGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQpIHtcbiAgICAgICAgICAgUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICAgICB9XG5cbiAgICAgICAgIC8vIHdlIGFyZSBpbiBhIHRvdWNoL2Rvd24gc3RhdGUsIHNvIGFsbG93ZWQgZGV0ZWN0aW9uIG9mIGdlc3R1cmVzXG4gICAgICAgICBpZiAoc2VsZi5zaG91bGREZXRlY3QpIHtcbiAgICAgICAgICAgdHJpZ2dlclR5cGUgPSBzZWxmLmRvRGV0ZWN0LmNhbGwoc2VsZiwgZXYsIGV2ZW50VHlwZSwgZWxlbWVudCwgaGFuZGxlcik7XG4gICAgICAgICB9XG5cbiAgICAgICAgIC8vIC4uLmFuZCB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBkZXRlY3Rpb25cbiAgICAgICAgIC8vIHNvIHJlc2V0IGV2ZXJ5dGhpbmcgdG8gc3RhcnQgZWFjaCBkZXRlY3Rpb24gdG90YWxseSBmcmVzaFxuICAgICAgICAgaWYgKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IGZhbHNlO1xuICAgICAgICAgICBQb2ludGVyRXZlbnQucmVzZXQoKTtcbiAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyZXZlbnQgb2JqZWN0IGFmdGVyIHRoZSBkZXRlY3Rpb25cbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgICAgfVxuICAgICAgIH07XG5cbiAgICAgICB0aGlzLm9uKGVsZW1lbnQsIEVWRU5UX1RZUEVTW2V2ZW50VHlwZV0sIG9uVG91Y2hIYW5kbGVyKTtcbiAgICAgICByZXR1cm4gb25Ub3VjaEhhbmRsZXI7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIHRoZSBjb3JlIGRldGVjdGlvbiBtZXRob2RcbiAgICAgICogdGhpcyBmaW5kcyBvdXQgd2hhdCBHZXN0dXJlRGV0ZWN0b3ItdG91Y2gtZXZlbnRzIHRvIHRyaWdnZXJcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRyaWdnZXJUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgICAgKi9cbiAgICAgZG9EZXRlY3Q6IGZ1bmN0aW9uIGRvRGV0ZWN0KGV2LCBldmVudFR5cGUsIGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICAgICB2YXIgdG91Y2hMaXN0ID0gdGhpcy5nZXRUb3VjaExpc3QoZXYsIGV2ZW50VHlwZSk7XG4gICAgICAgdmFyIHRvdWNoTGlzdExlbmd0aCA9IHRvdWNoTGlzdC5sZW5ndGg7XG4gICAgICAgdmFyIHRyaWdnZXJUeXBlID0gZXZlbnRUeXBlO1xuICAgICAgIHZhciB0cmlnZ2VyQ2hhbmdlID0gdG91Y2hMaXN0LnRyaWdnZXI7IC8vIHVzZWQgYnkgZmFrZU11bHRpdG91Y2ggcGx1Z2luXG4gICAgICAgdmFyIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3RMZW5ndGg7XG5cbiAgICAgICAvLyBhdCBlYWNoIHRvdWNoc3RhcnQtbGlrZSBldmVudCB3ZSB3YW50IGFsc28gd2FudCB0byB0cmlnZ2VyIGEgVE9VQ0ggZXZlbnQuLi5cbiAgICAgICBpZiAoZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfVE9VQ0g7XG4gICAgICAgICAvLyAuLi50aGUgc2FtZSBmb3IgYSB0b3VjaGVuZC1saWtlIGV2ZW50XG4gICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICAgIHRyaWdnZXJDaGFuZ2UgPSBFVkVOVF9SRUxFQVNFO1xuXG4gICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdG91Y2hlcyBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0Lmxlbmd0aCAtIChldi5jaGFuZ2VkVG91Y2hlcyA/IGV2LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA6IDEpO1xuICAgICAgICAgfVxuXG4gICAgICAgLy8gYWZ0ZXIgdGhlcmUgYXJlIHN0aWxsIHRvdWNoZXMgb24gdGhlIHNjcmVlbixcbiAgICAgICAvLyB3ZSBqdXN0IHdhbnQgdG8gdHJpZ2dlciBhIE1PVkUgZXZlbnQuIHNvIGNoYW5nZSB0aGUgU1RBUlQgb3IgRU5EIHRvIGEgTU9WRVxuICAgICAgIC8vIGJ1dCBvbmx5IGFmdGVyIGRldGVjdGlvbiBoYXMgYmVlbiBzdGFydGVkLCB0aGUgZmlyc3QgdGltZSB3ZSBhY3R1YWxseSB3YW50IGEgU1RBUlRcbiAgICAgICBpZiAoY2hhbmdlZExlbmd0aCA+IDAgJiYgdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICB0cmlnZ2VyVHlwZSA9IEVWRU5UX01PVkU7XG4gICAgICAgfVxuXG4gICAgICAgLy8gZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHdlIGtlZXAgdHJhY2sgb2YgdGhpcywgc2VlIGFib3ZlXG4gICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgIC8vIGdlbmVyYXRlIHNvbWUgZXZlbnQgZGF0YSwgc29tZSBiYXNpYyBpbmZvcm1hdGlvblxuICAgICAgIHZhciBldkRhdGEgPSB0aGlzLmNvbGxlY3RFdmVudERhdGEoZWxlbWVudCwgdHJpZ2dlclR5cGUsIHRvdWNoTGlzdCwgZXYpO1xuXG4gICAgICAgLy8gdHJpZ2dlciB0aGUgdHJpZ2dlclR5cGUgZXZlbnQgYmVmb3JlIHRoZSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudHNcbiAgICAgICAvLyBidXQgdGhlIEVORCBldmVudCBzaG91bGQgYmUgYXQgbGFzdFxuICAgICAgIGlmIChldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuICAgICAgIH1cblxuICAgICAgIC8vIHRyaWdnZXIgYSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudCwgdGhpcyBtZWFucyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaGVzIGNoYW5nZWRcbiAgICAgICBpZiAodHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgZXZEYXRhLmNoYW5nZWRMZW5ndGggPSBjaGFuZ2VkTGVuZ3RoO1xuICAgICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJDaGFuZ2U7XG5cbiAgICAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG5cbiAgICAgICAgIGV2RGF0YS5ldmVudFR5cGUgPSB0cmlnZ2VyVHlwZTtcbiAgICAgICAgIGRlbGV0ZSBldkRhdGEuY2hhbmdlZExlbmd0aDtcbiAgICAgICB9XG5cbiAgICAgICAvLyB0cmlnZ2VyIHRoZSBFTkQgZXZlbnRcbiAgICAgICBpZiAodHJpZ2dlclR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuXG4gICAgICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcbiAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiB0cmlnZ2VyVHlwZTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogd2UgaGF2ZSBkaWZmZXJlbnQgZXZlbnRzIGZvciBlYWNoIGRldmljZS9icm93c2VyXG4gICAgICAqIGRldGVybWluZSB3aGF0IHdlIG5lZWQgYW5kIHNldCB0aGVtIGluIHRoZSBFVkVOVF9UWVBFUyBjb25zdGFudFxuICAgICAgKiB0aGUgYG9uVG91Y2hgIG1ldGhvZCBpcyBiaW5kIHRvIHRoZXNlIHByb3BlcnRpZXMuXG4gICAgICAqIEByZXR1cm4ge09iamVjdH0gZXZlbnRzXG4gICAgICAqL1xuICAgICBkZXRlcm1pbmVFdmVudFR5cGVzOiBmdW5jdGlvbiBkZXRlcm1pbmVFdmVudFR5cGVzKCkge1xuICAgICAgIHZhciB0eXBlcztcbiAgICAgICBpZiAoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgICAgICB0eXBlcyA9IFsncG9pbnRlcmRvd24nLCAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgbG9zdHBvaW50ZXJjYXB0dXJlJ107XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0eXBlcyA9IFsnTVNQb2ludGVyRG93bicsICdNU1BvaW50ZXJNb3ZlJywgJ01TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCBNU0xvc3RQb2ludGVyQ2FwdHVyZSddO1xuICAgICAgICAgfVxuICAgICAgIH0gZWxzZSBpZiAoR2VzdHVyZURldGVjdG9yLk5PX01PVVNFRVZFTlRTKSB7XG4gICAgICAgICB0eXBlcyA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnXTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgdHlwZXMgPSBbJ3RvdWNoc3RhcnQgbW91c2Vkb3duJywgJ3RvdWNobW92ZSBtb3VzZW1vdmUnLCAndG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2V1cCddO1xuICAgICAgIH1cblxuICAgICAgIEVWRU5UX1RZUEVTW0VWRU5UX1NUQVJUXSA9IHR5cGVzWzBdO1xuICAgICAgIEVWRU5UX1RZUEVTW0VWRU5UX01PVkVdID0gdHlwZXNbMV07XG4gICAgICAgRVZFTlRfVFlQRVNbRVZFTlRfRU5EXSA9IHR5cGVzWzJdO1xuICAgICAgIHJldHVybiBFVkVOVF9UWVBFUztcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogY3JlYXRlIHRvdWNoTGlzdCBkZXBlbmRpbmcgb24gdGhlIGV2ZW50XG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gICAgICAqIEByZXR1cm4ge0FycmF5fSB0b3VjaGVzXG4gICAgICAqL1xuICAgICBnZXRUb3VjaExpc3Q6IGZ1bmN0aW9uIGdldFRvdWNoTGlzdChldiwgZXZlbnRUeXBlKSB7XG4gICAgICAgLy8gZ2V0IHRoZSBmYWtlIHBvaW50ZXJFdmVudCB0b3VjaGxpc3RcbiAgICAgICBpZiAoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICAgICByZXR1cm4gUG9pbnRlckV2ZW50LmdldFRvdWNoTGlzdCgpO1xuICAgICAgIH1cblxuICAgICAgIC8vIGdldCB0aGUgdG91Y2hsaXN0XG4gICAgICAgaWYgKGV2LnRvdWNoZXMpIHtcbiAgICAgICAgIGlmIChldmVudFR5cGUgPT0gRVZFTlRfTU9WRSkge1xuICAgICAgICAgICByZXR1cm4gZXYudG91Y2hlcztcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gICAgICAgICB2YXIgY29uY2F0ID0gW10uY29uY2F0KFV0aWxzLnRvQXJyYXkoZXYudG91Y2hlcyksIFV0aWxzLnRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpKTtcbiAgICAgICAgIHZhciB0b3VjaExpc3QgPSBbXTtcblxuICAgICAgICAgVXRpbHMuZWFjaChjb25jYXQsIGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICAgICBpZiAoVXRpbHMuaW5BcnJheShpZGVudGlmaWVycywgdG91Y2guaWRlbnRpZmllcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgdG91Y2hMaXN0LnB1c2godG91Y2gpO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2godG91Y2guaWRlbnRpZmllcik7XG4gICAgICAgICB9KTtcblxuICAgICAgICAgcmV0dXJuIHRvdWNoTGlzdDtcbiAgICAgICB9XG5cbiAgICAgICAvLyBtYWtlIGZha2UgdG91Y2hMaXN0IGZyb20gbW91c2UgcG9zaXRpb25cbiAgICAgICBldi5pZGVudGlmaWVyID0gMTtcbiAgICAgICByZXR1cm4gW2V2XTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogY29sbGVjdCBiYXNpYyBldmVudCBkYXRhXG4gICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgICogQHJldHVybiB7T2JqZWN0fSBldlxuICAgICAgKi9cbiAgICAgY29sbGVjdEV2ZW50RGF0YTogZnVuY3Rpb24gY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCBldmVudFR5cGUsIHRvdWNoZXMsIGV2KSB7XG4gICAgICAgLy8gZmluZCBvdXQgcG9pbnRlclR5cGVcbiAgICAgICB2YXIgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1RPVUNIO1xuICAgICAgIGlmIChVdGlscy5pblN0cihldi50eXBlLCAnbW91c2UnKSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfTU9VU0UsIGV2KSkge1xuICAgICAgICAgcG9pbnRlclR5cGUgPSBQT0lOVEVSX01PVVNFO1xuICAgICAgIH0gZWxzZSBpZiAoUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX1BFTiwgZXYpKSB7XG4gICAgICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfUEVOO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiB7XG4gICAgICAgICBjZW50ZXI6IFV0aWxzLmdldENlbnRlcih0b3VjaGVzKSxcbiAgICAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgIHRhcmdldDogZXYudGFyZ2V0LFxuICAgICAgICAgdG91Y2hlczogdG91Y2hlcyxcbiAgICAgICAgIGV2ZW50VHlwZTogZXZlbnRUeXBlLFxuICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgc3JjRXZlbnQ6IGV2LFxuXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIHByZXZlbnQgdGhlIGJyb3dzZXIgZGVmYXVsdCBhY3Rpb25zXG4gICAgICAgICAgKiBtb3N0bHkgdXNlZCB0byBkaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgYnJvd3NlclxuICAgICAgICAgICovXG4gICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgICAgIHZhciBzcmNFdmVudCA9IHRoaXMuc3JjRXZlbnQ7XG4gICAgICAgICAgIHNyY0V2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24gJiYgc3JjRXZlbnQucHJldmVudE1hbmlwdWxhdGlvbigpO1xuICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgfSxcblxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBzdG9wIGJ1YmJsaW5nIHRoZSBldmVudCB1cCB0byBpdHMgcGFyZW50c1xuICAgICAgICAgICovXG4gICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgIH0sXG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgICogaW1tZWRpYXRlbHkgc3RvcCBnZXN0dXJlIGRldGVjdGlvblxuICAgICAgICAgICogbWlnaHQgYmUgdXNlZnVsIGFmdGVyIGEgc3dpcGUgd2FzIGRldGVjdGVkXG4gICAgICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICAgICovXG4gICAgICAgICBzdG9wRGV0ZWN0OiBmdW5jdGlvbiBzdG9wRGV0ZWN0KCkge1xuICAgICAgICAgICByZXR1cm4gRGV0ZWN0aW9uLnN0b3BEZXRlY3QoKTtcbiAgICAgICAgIH1cbiAgICAgICB9O1xuICAgICB9XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gICAgKlxuICAgICogQGNsYXNzIFBvaW50ZXJFdmVudFxuICAgICogQHN0YXRpY1xuICAgICovXG4gICBQb2ludGVyRXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuUG9pbnRlckV2ZW50ID0ge1xuICAgICAvKipcbiAgICAgICogaG9sZHMgYWxsIHBvaW50ZXJzLCBieSBgaWRlbnRpZmllcmBcbiAgICAgICogQHByb3BlcnR5IHBvaW50ZXJzXG4gICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAqL1xuICAgICBwb2ludGVyczoge30sXG5cbiAgICAgLyoqXG4gICAgICAqIGdldCB0aGUgcG9pbnRlcnMgYXMgYW4gYXJyYXlcbiAgICAgICogQHJldHVybiB7QXJyYXl9IHRvdWNobGlzdFxuICAgICAgKi9cbiAgICAgZ2V0VG91Y2hMaXN0OiBmdW5jdGlvbiBnZXRUb3VjaExpc3QoKSB7XG4gICAgICAgdmFyIHRvdWNobGlzdCA9IFtdO1xuICAgICAgIC8vIHdlIGNhbiB1c2UgZm9yRWFjaCBzaW5jZSBwb2ludGVyRXZlbnRzIG9ubHkgaXMgaW4gSUUxMFxuICAgICAgIFV0aWxzLmVhY2godGhpcy5wb2ludGVycywgZnVuY3Rpb24gKHBvaW50ZXIpIHtcbiAgICAgICAgIHRvdWNobGlzdC5wdXNoKHBvaW50ZXIpO1xuICAgICAgIH0pO1xuICAgICAgIHJldHVybiB0b3VjaGxpc3Q7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgYSBwb2ludGVyXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyRXZlbnRcbiAgICAgICovXG4gICAgIHVwZGF0ZVBvaW50ZXI6IGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBwb2ludGVyRXZlbnQpIHtcbiAgICAgICBpZiAoZXZlbnRUeXBlID09IEVWRU5UX0VORCB8fCBldmVudFR5cGUgIT0gRVZFTlRfRU5EICYmIHBvaW50ZXJFdmVudC5idXR0b25zICE9PSAxKSB7XG4gICAgICAgICBkZWxldGUgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgcG9pbnRlckV2ZW50LmlkZW50aWZpZXIgPSBwb2ludGVyRXZlbnQucG9pbnRlcklkO1xuICAgICAgICAgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXSA9IHBvaW50ZXJFdmVudDtcbiAgICAgICB9XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIGNoZWNrIGlmIGV2IG1hdGNoZXMgcG9pbnRlcnR5cGVcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50ZXJUeXBlIG1hdGNoZXMgYFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOYFxuICAgICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZcbiAgICAgICovXG4gICAgIG1hdGNoVHlwZTogZnVuY3Rpb24gbWF0Y2hUeXBlKHBvaW50ZXJUeXBlLCBldikge1xuICAgICAgIGlmICghZXYucG9pbnRlclR5cGUpIHtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICB9XG5cbiAgICAgICB2YXIgcHQgPSBldi5wb2ludGVyVHlwZSxcbiAgICAgICAgICAgdHlwZXMgPSB7fTtcblxuICAgICAgIHR5cGVzW1BPSU5URVJfTU9VU0VdID0gcHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBQT0lOVEVSX01PVVNFKTtcbiAgICAgICB0eXBlc1tQT0lOVEVSX1RPVUNIXSA9IHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggfHwgUE9JTlRFUl9UT1VDSCk7XG4gICAgICAgdHlwZXNbUE9JTlRFUl9QRU5dID0gcHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9QRU4gfHwgUE9JTlRFUl9QRU4pO1xuICAgICAgIHJldHVybiB0eXBlc1twb2ludGVyVHlwZV07XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIHJlc2V0IHRoZSBzdG9yZWQgcG9pbnRlcnNcbiAgICAgICovXG4gICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldExpc3QoKSB7XG4gICAgICAgdGhpcy5wb2ludGVycyA9IHt9O1xuICAgICB9XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gICAgKlxuICAgICogQGNsYXNzIERldGVjdGlvblxuICAgICogQHN0YXRpY1xuICAgICovXG4gICBEZXRlY3Rpb24gPSBHZXN0dXJlRGV0ZWN0b3IuZGV0ZWN0aW9uID0ge1xuICAgICAvLyBjb250YWlucyBhbGwgcmVnaXN0ZXJlZCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcbiAgICAgZ2VzdHVyZXM6IFtdLFxuXG4gICAgIC8vIGRhdGEgb2YgdGhlIGN1cnJlbnQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uIHNlc3Npb25cbiAgICAgY3VycmVudDogbnVsbCxcblxuICAgICAvLyB0aGUgcHJldmlvdXMgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgc2Vzc2lvbiBkYXRhXG4gICAgIC8vIGlzIGEgZnVsbCBjbG9uZSBvZiB0aGUgcHJldmlvdXMgZ2VzdHVyZS5jdXJyZW50IG9iamVjdFxuICAgICBwcmV2aW91czogbnVsbCxcblxuICAgICAvLyB3aGVuIHRoaXMgYmVjb21lcyB0cnVlLCBubyBnZXN0dXJlcyBhcmUgZmlyZWRcbiAgICAgc3RvcHBlZDogZmFsc2UsXG5cbiAgICAgLyoqXG4gICAgICAqIHN0YXJ0IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvblxuICAgICAgKiBAcGFyYW0ge0dlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZX0gaW5zdFxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhXG4gICAgICAqL1xuICAgICBzdGFydERldGVjdDogZnVuY3Rpb24gc3RhcnREZXRlY3QoaW5zdCwgZXZlbnREYXRhKSB7XG4gICAgICAgLy8gYWxyZWFkeSBidXN5IHdpdGggYSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb24gb24gYW4gZWxlbWVudFxuICAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgICB9XG5cbiAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgICAgIC8vIGhvbGRzIGN1cnJlbnQgc2Vzc2lvblxuICAgICAgIHRoaXMuY3VycmVudCA9IHtcbiAgICAgICAgIGluc3Q6IGluc3QsIC8vIHJlZmVyZW5jZSB0byBHZXN0dXJlRGV0ZWN0b3JJbnN0YW5jZSB3ZSdyZSB3b3JraW5nIGZvclxuICAgICAgICAgc3RhcnRFdmVudDogVXRpbHMuZXh0ZW5kKHt9LCBldmVudERhdGEpLCAvLyBzdGFydCBldmVudERhdGEgZm9yIGRpc3RhbmNlcywgdGltaW5nIGV0Y1xuICAgICAgICAgbGFzdEV2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGFcbiAgICAgICAgIGxhc3RDYWxjRXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YSBmb3IgY2FsY3VsYXRpb25zLlxuICAgICAgICAgZnV0dXJlQ2FsY0V2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGEgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgIGxhc3RDYWxjRGF0YToge30sIC8vIGxhc3QgbGFzdENhbGNEYXRhXG4gICAgICAgICBuYW1lOiAnJyAvLyBjdXJyZW50IGdlc3R1cmUgd2UncmUgaW4vZGV0ZWN0ZWQsIGNhbiBiZSAndGFwJywgJ2hvbGQnIGV0Y1xuICAgICAgIH07XG5cbiAgICAgICB0aGlzLmRldGVjdChldmVudERhdGEpO1xuICAgICB9LFxuXG4gICAgIC8qKlxuICAgICAgKiBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICAqL1xuICAgICBkZXRlY3Q6IGZ1bmN0aW9uIGRldGVjdChldmVudERhdGEpIHtcbiAgICAgICBpZiAoIXRoaXMuY3VycmVudCB8fCB0aGlzLnN0b3BwZWQpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgICB9XG5cbiAgICAgICAvLyBleHRlbmQgZXZlbnQgZGF0YSB3aXRoIGNhbGN1bGF0aW9ucyBhYm91dCBzY2FsZSwgZGlzdGFuY2UgZXRjXG4gICAgICAgZXZlbnREYXRhID0gdGhpcy5leHRlbmRFdmVudERhdGEoZXZlbnREYXRhKTtcblxuICAgICAgIC8vIEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZSBhbmQgaW5zdGFuY2Ugb3B0aW9uc1xuICAgICAgIHZhciBpbnN0ID0gdGhpcy5jdXJyZW50Lmluc3QsXG4gICAgICAgICAgIGluc3RPcHRpb25zID0gaW5zdC5vcHRpb25zO1xuXG4gICAgICAgLy8gY2FsbCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBoYW5kbGVyc1xuICAgICAgIFV0aWxzLmVhY2godGhpcy5nZXN0dXJlcywgZnVuY3Rpb24gdHJpZ2dlckdlc3R1cmUoZ2VzdHVyZSkge1xuICAgICAgICAgLy8gb25seSB3aGVuIHRoZSBpbnN0YW5jZSBvcHRpb25zIGhhdmUgZW5hYmxlZCB0aGlzIGdlc3R1cmVcbiAgICAgICAgIGlmICghdGhpcy5zdG9wcGVkICYmIGluc3QuZW5hYmxlZCAmJiBpbnN0T3B0aW9uc1tnZXN0dXJlLm5hbWVdKSB7XG4gICAgICAgICAgIGdlc3R1cmUuaGFuZGxlci5jYWxsKGdlc3R1cmUsIGV2ZW50RGF0YSwgaW5zdCk7XG4gICAgICAgICB9XG4gICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAvLyBzdG9yZSBhcyBwcmV2aW91cyBldmVudCBldmVudFxuICAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgIHRoaXMuY3VycmVudC5sYXN0RXZlbnQgPSBldmVudERhdGE7XG4gICAgICAgfVxuXG4gICAgICAgaWYgKGV2ZW50RGF0YS5ldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgICB0aGlzLnN0b3BEZXRlY3QoKTtcbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gZXZlbnREYXRhOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIGNsZWFyIHRoZSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSB2YXJzXG4gICAgICAqIHRoaXMgaXMgY2FsbGVkIG9uIGVuZERldGVjdCwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgd2hlbiBhIGZpbmFsIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGhhcyBiZWVuIGRldGVjdGVkXG4gICAgICAqIHRvIHN0b3Agb3RoZXIgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIGZyb20gYmVpbmcgZmlyZWRcbiAgICAgICovXG4gICAgIHN0b3BEZXRlY3Q6IGZ1bmN0aW9uIHN0b3BEZXRlY3QoKSB7XG4gICAgICAgLy8gY2xvbmUgY3VycmVudCBkYXRhIHRvIHRoZSBzdG9yZSBhcyB0aGUgcHJldmlvdXMgZ2VzdHVyZVxuICAgICAgIC8vIHVzZWQgZm9yIHRoZSBkb3VibGUgdGFwIGdlc3R1cmUsIHNpbmNlIHRoaXMgaXMgYW4gb3RoZXIgZ2VzdHVyZSBkZXRlY3Qgc2Vzc2lvblxuICAgICAgIHRoaXMucHJldmlvdXMgPSBVdGlscy5leHRlbmQoe30sIHRoaXMuY3VycmVudCk7XG5cbiAgICAgICAvLyByZXNldCB0aGUgY3VycmVudFxuICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogY2FsY3VsYXRlIHZlbG9jaXR5LCBhbmdsZSBhbmQgZGlyZWN0aW9uXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2VudGVyXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWFxuICAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFZXG4gICAgICAqL1xuICAgICBnZXRDYWxjdWxhdGVkRGF0YTogZnVuY3Rpb24gZ2V0Q2FsY3VsYXRlZERhdGEoZXYsIGNlbnRlciwgZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSkge1xuICAgICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQsXG4gICAgICAgICAgIHJlY2FsYyA9IGZhbHNlLFxuICAgICAgICAgICBjYWxjRXYgPSBjdXIubGFzdENhbGNFdmVudCxcbiAgICAgICAgICAgY2FsY0RhdGEgPSBjdXIubGFzdENhbGNEYXRhO1xuXG4gICAgICAgaWYgKGNhbGNFdiAmJiBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wID4gR2VzdHVyZURldGVjdG9yLkNBTENVTEFURV9JTlRFUlZBTCkge1xuICAgICAgICAgY2VudGVyID0gY2FsY0V2LmNlbnRlcjtcbiAgICAgICAgIGRlbHRhVGltZSA9IGV2LnRpbWVTdGFtcCAtIGNhbGNFdi50aW1lU3RhbXA7XG4gICAgICAgICBkZWx0YVggPSBldi5jZW50ZXIuY2xpZW50WCAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WDtcbiAgICAgICAgIGRlbHRhWSA9IGV2LmNlbnRlci5jbGllbnRZIC0gY2FsY0V2LmNlbnRlci5jbGllbnRZO1xuICAgICAgICAgcmVjYWxjID0gdHJ1ZTtcbiAgICAgICB9XG5cbiAgICAgICBpZiAoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XG4gICAgICAgfVxuXG4gICAgICAgaWYgKCFjdXIubGFzdENhbGNFdmVudCB8fCByZWNhbGMpIHtcbiAgICAgICAgIGNhbGNEYXRhLnZlbG9jaXR5ID0gVXRpbHMuZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgICBjYWxjRGF0YS5hbmdsZSA9IFV0aWxzLmdldEFuZ2xlKGNlbnRlciwgZXYuY2VudGVyKTtcbiAgICAgICAgIGNhbGNEYXRhLmRpcmVjdGlvbiA9IFV0aWxzLmdldERpcmVjdGlvbihjZW50ZXIsIGV2LmNlbnRlcik7XG5cbiAgICAgICAgIGN1ci5sYXN0Q2FsY0V2ZW50ID0gY3VyLmZ1dHVyZUNhbGNFdmVudCB8fCBldjtcbiAgICAgICAgIGN1ci5mdXR1cmVDYWxjRXZlbnQgPSBldjtcbiAgICAgICB9XG5cbiAgICAgICBldi52ZWxvY2l0eVggPSBjYWxjRGF0YS52ZWxvY2l0eS54O1xuICAgICAgIGV2LnZlbG9jaXR5WSA9IGNhbGNEYXRhLnZlbG9jaXR5Lnk7XG4gICAgICAgZXYuaW50ZXJpbUFuZ2xlID0gY2FsY0RhdGEuYW5nbGU7XG4gICAgICAgZXYuaW50ZXJpbURpcmVjdGlvbiA9IGNhbGNEYXRhLmRpcmVjdGlvbjtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogZXh0ZW5kIGV2ZW50RGF0YSBmb3IgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2XG4gICAgICAqL1xuICAgICBleHRlbmRFdmVudERhdGE6IGZ1bmN0aW9uIGV4dGVuZEV2ZW50RGF0YShldikge1xuICAgICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQsXG4gICAgICAgICAgIHN0YXJ0RXYgPSBjdXIuc3RhcnRFdmVudCxcbiAgICAgICAgICAgbGFzdEV2ID0gY3VyLmxhc3RFdmVudCB8fCBzdGFydEV2O1xuXG4gICAgICAgLy8gdXBkYXRlIHRoZSBzdGFydCB0b3VjaGxpc3QgdG8gY2FsY3VsYXRlIHRoZSBzY2FsZS9yb3RhdGlvblxuICAgICAgIGlmIChldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0ggfHwgZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgIHN0YXJ0RXYudG91Y2hlcyA9IFtdO1xuICAgICAgICAgVXRpbHMuZWFjaChldi50b3VjaGVzLCBmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgICAgc3RhcnRFdi50b3VjaGVzLnB1c2goe1xuICAgICAgICAgICAgIGNsaWVudFg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgICAgY2xpZW50WTogdG91Y2guY2xpZW50WVxuICAgICAgICAgICB9KTtcbiAgICAgICAgIH0pO1xuICAgICAgIH1cblxuICAgICAgIHZhciBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBzdGFydEV2LnRpbWVTdGFtcCxcbiAgICAgICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBzdGFydEV2LmNlbnRlci5jbGllbnRYLFxuICAgICAgICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFk7XG5cbiAgICAgICB0aGlzLmdldENhbGN1bGF0ZWREYXRhKGV2LCBsYXN0RXYuY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcblxuICAgICAgIFV0aWxzLmV4dGVuZChldiwge1xuICAgICAgICAgc3RhcnRFdmVudDogc3RhcnRFdixcblxuICAgICAgICAgZGVsdGFUaW1lOiBkZWx0YVRpbWUsXG4gICAgICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgICAgIGRlbHRhWTogZGVsdGFZLFxuXG4gICAgICAgICBkaXN0YW5jZTogVXRpbHMuZ2V0RGlzdGFuY2Uoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICAgICBhbmdsZTogVXRpbHMuZ2V0QW5nbGUoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICAgICBkaXJlY3Rpb246IFV0aWxzLmdldERpcmVjdGlvbihzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgICAgIHNjYWxlOiBVdGlscy5nZXRTY2FsZShzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpLFxuICAgICAgICAgcm90YXRpb246IFV0aWxzLmdldFJvdGF0aW9uKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcylcbiAgICAgICB9KTtcblxuICAgICAgIHJldHVybiBldjtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogcmVnaXN0ZXIgbmV3IGdlc3R1cmVcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IGdlc3R1cmUgb2JqZWN0LCBzZWUgYGdlc3R1cmVzL2AgZm9yIGRvY3VtZW50YXRpb25cbiAgICAgICogQHJldHVybiB7QXJyYXl9IGdlc3R1cmVzXG4gICAgICAqL1xuICAgICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoZ2VzdHVyZSkge1xuICAgICAgIC8vIGFkZCBhbiBlbmFibGUgZ2VzdHVyZSBvcHRpb25zIGlmIHRoZXJlIGlzIG5vIGdpdmVuXG4gICAgICAgdmFyIG9wdGlvbnMgPSBnZXN0dXJlLmRlZmF1bHRzIHx8IHt9O1xuICAgICAgIGlmIChvcHRpb25zW2dlc3R1cmUubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgb3B0aW9uc1tnZXN0dXJlLm5hbWVdID0gdHJ1ZTtcbiAgICAgICB9XG5cbiAgICAgICAvLyBleHRlbmQgR2VzdHVyZURldGVjdG9yIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBvcHRpb25zXG4gICAgICAgVXRpbHMuZXh0ZW5kKEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cywgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAvLyBzZXQgaXRzIGluZGV4XG4gICAgICAgZ2VzdHVyZS5pbmRleCA9IGdlc3R1cmUuaW5kZXggfHwgMTAwMDtcblxuICAgICAgIC8vIGFkZCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSB0byB0aGUgbGlzdFxuICAgICAgIHRoaXMuZ2VzdHVyZXMucHVzaChnZXN0dXJlKTtcblxuICAgICAgIC8vIHNvcnQgdGhlIGxpc3QgYnkgaW5kZXhcbiAgICAgICB0aGlzLmdlc3R1cmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgIGlmIChhLmluZGV4IDwgYi5pbmRleCkge1xuICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAoYS5pbmRleCA+IGIuaW5kZXgpIHtcbiAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gMDtcbiAgICAgICB9KTtcblxuICAgICAgIHJldHVybiB0aGlzLmdlc3R1cmVzO1xuICAgICB9XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBjcmVhdGUgbmV3IEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZVxuICAgICogYWxsIG1ldGhvZHMgc2hvdWxkIHJldHVybiB0aGUgaW5zdGFuY2UgaXRzZWxmLCBzbyBpdCBpcyBjaGFpbmFibGUuXG4gICAgKlxuICAgICogQGNsYXNzIEluc3RhbmNlXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggYEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0c2BcbiAgICAqIEByZXR1cm4ge0dlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZX1cbiAgICAqL1xuICAgR2VzdHVyZURldGVjdG9yLkluc3RhbmNlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgIC8vIHNldHVwIEdlc3R1cmVEZXRlY3RvckpTIHdpbmRvdyBldmVudHMgYW5kIHJlZ2lzdGVyIGFsbCBnZXN0dXJlc1xuICAgICAvLyB0aGlzIGFsc28gc2V0cyB1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgIHNldHVwKCk7XG5cbiAgICAgLyoqXG4gICAgICAqIEBwcm9wZXJ0eSBlbGVtZW50XG4gICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICovXG4gICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgLyoqXG4gICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAqL1xuICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgIC8qKlxuICAgICAgKiBvcHRpb25zLCBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdHNcbiAgICAgICogb3B0aW9ucyB3aXRoIGFuIF8gYXJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2VcbiAgICAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICovXG4gICAgIFV0aWxzLmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgZGVsZXRlIG9wdGlvbnNbbmFtZV07XG4gICAgICAgb3B0aW9uc1tVdGlscy50b0NhbWVsQ2FzZShuYW1lKV0gPSB2YWx1ZTtcbiAgICAgfSk7XG5cbiAgICAgdGhpcy5vcHRpb25zID0gVXRpbHMuZXh0ZW5kKFV0aWxzLmV4dGVuZCh7fSwgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzKSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICAgLy8gYWRkIHNvbWUgY3NzIHRvIHRoZSBlbGVtZW50IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBkb2luZyBpdHMgbmF0aXZlIGJlaGF2aW9yXG4gICAgIGlmICh0aGlzLm9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgdHJ1ZSk7XG4gICAgIH1cblxuICAgICAvKipcbiAgICAgICogZXZlbnQgc3RhcnQgaGFuZGxlciBvbiB0aGUgZWxlbWVudCB0byBzdGFydCB0aGUgZGV0ZWN0aW9uXG4gICAgICAqIEBwcm9wZXJ0eSBldmVudFN0YXJ0SGFuZGxlclxuICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgKi9cbiAgICAgdGhpcy5ldmVudFN0YXJ0SGFuZGxlciA9IEV2ZW50JDEub25Ub3VjaChlbGVtZW50LCBFVkVOVF9TVEFSVCwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgaWYgKHNlbGYuZW5hYmxlZCAmJiBldi5ldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgIERldGVjdGlvbi5zdGFydERldGVjdChzZWxmLCBldik7XG4gICAgICAgfSBlbHNlIGlmIChldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0gpIHtcbiAgICAgICAgIERldGVjdGlvbi5kZXRlY3QoZXYpO1xuICAgICAgIH1cbiAgICAgfSk7XG5cbiAgICAgLyoqXG4gICAgICAqIGtlZXAgYSBsaXN0IG9mIHVzZXIgZXZlbnQgaGFuZGxlcnMgd2hpY2ggbmVlZHMgdG8gYmUgcmVtb3ZlZCB3aGVuIGNhbGxpbmcgJ2Rpc3Bvc2UnXG4gICAgICAqIEBwcm9wZXJ0eSBldmVudEhhbmRsZXJzXG4gICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICovXG4gICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xuICAgfTtcblxuICAgR2VzdHVyZURldGVjdG9yLkluc3RhbmNlLnByb3RvdHlwZSA9IHtcbiAgICAgLyoqXG4gICAgICAqIEBtZXRob2Qgb25cbiAgICAgICogQHNpZ25hdHVyZSBvbihnZXN0dXJlcywgaGFuZGxlcilcbiAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAqICBbZW5dQWRkcyBhbiBldmVudCBoYW5kbGVyIGZvciBhIGdlc3R1cmUuIEF2YWlsYWJsZSBnZXN0dXJlcyBhcmU6IGRyYWcsIGRyYWdsZWZ0LCBkcmFncmlnaHQsIGRyYWd1cCwgZHJhZ2Rvd24sIGhvbGQsIHJlbGVhc2UsIHN3aXBlLCBzd2lwZWxlZnQsIHN3aXBlcmlnaHQsIHN3aXBldXAsIHN3aXBlZG93biwgdGFwLCBkb3VibGV0YXAsIHRvdWNoLCB0cmFuc2Zvcm0sIHBpbmNoLCBwaW5jaGluLCBwaW5jaG91dCBhbmQgcm90YXRlLiBbL2VuXVxuICAgICAgKiAgW2phXeOCuOOCp+OCueODgeODo+OBq+WvvuOBmeOCi+OCpOODmeODs+ODiOODj+ODs+ODieODqeOCkui/veWKoOOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+OCuOOCp+OCueODgeODo+WQjeOBr+OAgWRyYWcgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWd1cCBkcmFnZG93biBob2xkIHJlbGVhc2Ugc3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHQgc3dpcGV1cCBzd2lwZWRvd24gdGFwIGRvdWJsZXRhcCB0b3VjaCB0cmFuc2Zvcm0gcGluY2ggcGluY2hpbiBwaW5jaG91dCByb3RhdGUg44Gn44GZ44CCWy9qYV1cbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVzXG4gICAgICAqICAgW2VuXUEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZ2VzdHVyZXMuWy9lbl1cbiAgICAgICogICBbamFd5qSc55+l44GZ44KL44K444Kn44K544OB44Oj5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44K544Oa44O844K544Gn6KSH5pWw5oyH5a6a44GZ44KL44GT44Go44GM44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAgKiAgIFtlbl1BbiBldmVudCBoYW5kbGluZyBmdW5jdGlvbi5bL2VuXVxuICAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgajjgarjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgKi9cbiAgICAgb246IGZ1bmN0aW9uIG9uRXZlbnQoZ2VzdHVyZXMsIGhhbmRsZXIpIHtcbiAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgRXZlbnQkMS5vbihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnB1c2goeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgICAgIH0pO1xuICAgICAgIHJldHVybiBzZWxmO1xuICAgICB9LFxuXG4gICAgIC8qKlxuICAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAgKiBAc2lnbmF0dXJlIG9mZihnZXN0dXJlcywgaGFuZGxlcilcbiAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAqICBbZW5dUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlsvZW5dXG4gICAgICAqICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5YmK6Zmk44GX44G+44GZ44CCWy9qYV1cbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVzXG4gICAgICAqICAgW2VuXUEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZ2VzdHVyZXMuWy9lbl1cbiAgICAgICogICBbamFd44K444Kn44K544OB44Oj5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44K544Oa44O844K544Gn6KSH5pWw5oyH5a6a44GZ44KL44GT44Go44GM44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAgKiAgIFtlbl1BbiBldmVudCBoYW5kbGluZyBmdW5jdGlvbi5bL2VuXVxuICAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgajjgarjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgKi9cbiAgICAgb2ZmOiBmdW5jdGlvbiBvZmZFdmVudChnZXN0dXJlcywgaGFuZGxlcikge1xuICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgIEV2ZW50JDEub2ZmKHNlbGYuZWxlbWVudCwgZ2VzdHVyZXMsIGhhbmRsZXIsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICB2YXIgaW5kZXggPSBVdGlscy5pbkFycmF5KHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICAgICAgIGlmIChpbmRleCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICB9XG4gICAgICAgfSk7XG4gICAgICAgcmV0dXJuIHNlbGY7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIHRyaWdnZXIgZ2VzdHVyZSBldmVudFxuICAgICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICAgICogQHNpZ25hdHVyZSB0cmlnZ2VyKGdlc3R1cmUsIGV2ZW50RGF0YSlcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IFtldmVudERhdGFdXG4gICAgICAqL1xuICAgICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZ2VzdHVyZSwgZXZlbnREYXRhKSB7XG4gICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICBpZiAoIWV2ZW50RGF0YSkge1xuICAgICAgICAgZXZlbnREYXRhID0ge307XG4gICAgICAgfVxuXG4gICAgICAgLy8gY3JlYXRlIERPTSBldmVudFxuICAgICAgIHZhciBldmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICBldmVudC5pbml0RXZlbnQoZ2VzdHVyZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgZXZlbnQuZ2VzdHVyZSA9IGV2ZW50RGF0YTtcblxuICAgICAgIC8vIHRyaWdnZXIgb24gdGhlIHRhcmdldCBpZiBpdCBpcyBpbiB0aGUgaW5zdGFuY2UgZWxlbWVudCxcbiAgICAgICAvLyB0aGlzIGlzIGZvciBldmVudCBkZWxlZ2F0aW9uIHRyaWNrc1xuICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgIGlmIChVdGlscy5oYXNQYXJlbnQoZXZlbnREYXRhLnRhcmdldCwgZWxlbWVudCkpIHtcbiAgICAgICAgIGVsZW1lbnQgPSBldmVudERhdGEudGFyZ2V0O1xuICAgICAgIH1cblxuICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgcmV0dXJuIHRoaXM7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIEBtZXRob2QgZW5hYmxlXG4gICAgICAqIEBzaWduYXR1cmUgZW5hYmxlKHN0YXRlKVxuICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICogIFtlbl1FbmFibGUgb3IgZGlzYWJsZSBnZXN0dXJlIGRldGVjdGlvbi5bL2VuXVxuICAgICAgKiAgW2phXeOCuOOCp+OCueODgeODo+aknOefpeOCkuacieWKueWMli/nhKHlirnljJbjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXRlXG4gICAgICAqICAgW2VuXVNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIGVuYWJsZWQgb3Igbm90LlsvZW5dXG4gICAgICAqICAgW2phXeacieWKueOBq+OBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAqL1xuICAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgICAgIHRoaXMuZW5hYmxlZCA9IHN0YXRlO1xuICAgICAgIHJldHVybiB0aGlzO1xuICAgICB9LFxuXG4gICAgIC8qKlxuICAgICAgKiBAbWV0aG9kIGRpc3Bvc2VcbiAgICAgICogQHNpZ25hdHVyZSBkaXNwb3NlKClcbiAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAqICBbZW5dUmVtb3ZlIGFuZCBkZXN0cm95IGFsbCBldmVudCBoYW5kbGVycyBmb3IgdGhpcyBpbnN0YW5jZS5bL2VuXVxuICAgICAgKiAgW2phXeOBk+OBruOCpOODs+OCueOCv+ODs+OCueOBp+OBruOCuOOCp+OCueODgeODo+OBruaknOefpeOChOOAgeOCpOODmeODs+ODiOODj+ODs+ODieODqeOCkuWFqOOBpuino+mZpOOBl+OBpuW7g+ajhOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAqL1xuICAgICBkaXNwb3NlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgIHZhciBpLCBlaDtcblxuICAgICAgIC8vIHVuZG8gYWxsIGNoYW5nZXMgbWFkZSBieSBzdG9wX2Jyb3dzZXJfYmVoYXZpb3JcbiAgICAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgZmFsc2UpO1xuXG4gICAgICAgLy8gdW5iaW5kIGFsbCBjdXN0b20gZXZlbnQgaGFuZGxlcnNcbiAgICAgICBmb3IgKGkgPSAtMTsgZWggPSB0aGlzLmV2ZW50SGFuZGxlcnNbKytpXTspIHtcbiAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgIFV0aWxzLm9mZih0aGlzLmVsZW1lbnQsIGVoLmdlc3R1cmUsIGVoLmhhbmRsZXIpO1xuICAgICAgIH1cblxuICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xuXG4gICAgICAgLy8gdW5iaW5kIHRoZSBzdGFydCBldmVudCBsaXN0ZW5lclxuICAgICAgIEV2ZW50JDEub2ZmKHRoaXMuZWxlbWVudCwgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdLCB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyKTtcblxuICAgICAgIHJldHVybiBudWxsO1xuICAgICB9XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICAqL1xuICAgLyoqXG4gICAgKiBNb3ZlIHdpdGggeCBmaW5nZXJzIChkZWZhdWx0IDEpIGFyb3VuZCBvbiB0aGUgcGFnZS5cbiAgICAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy5cbiAgICAqIGBgYGBcbiAgICAqICBHZXN0dXJlRGV0ZWN0b3J0aW1lLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbihldikge1xuICAgICogICAgY29uc29sZS5sb2coZXYpO1xuICAgICogICAgZXYuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICogIH0pO1xuICAgICogYGBgYFxuICAgICpcbiAgICAqIEBjbGFzcyBEcmFnXG4gICAgKiBAc3RhdGljXG4gICAgKi9cbiAgIC8qKlxuICAgICogQGV2ZW50IGRyYWdcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICovXG4gICAvKipcbiAgICAqIEBldmVudCBkcmFnc3RhcnRcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICovXG4gICAvKipcbiAgICAqIEBldmVudCBkcmFnZW5kXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAqL1xuICAgLyoqXG4gICAgKiBAZXZlbnQgZHJhcGxlZnRcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICovXG4gICAvKipcbiAgICAqIEBldmVudCBkcmFncmlnaHRcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICovXG4gICAvKipcbiAgICAqIEBldmVudCBkcmFndXBcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICovXG4gICAvKipcbiAgICAqIEBldmVudCBkcmFnZG93blxuICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICovXG4gICAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgdmFyIHRyaWdnZXJlZCA9IGZhbHNlO1xuXG4gICAgIGZ1bmN0aW9uIGRyYWdHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICAgdmFyIGN1ciA9IERldGVjdGlvbi5jdXJyZW50O1xuXG4gICAgICAgLy8gbWF4IHRvdWNoZXNcbiAgICAgICBpZiAoaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzID4gMCAmJiBldi50b3VjaGVzLmxlbmd0aCA+IGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcykge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgIH1cblxuICAgICAgIHN3aXRjaCAoZXYuZXZlbnRUeXBlKSB7XG4gICAgICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgICAgIGlmIChldi5kaXN0YW5jZSA8IGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgJiYgY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIHZhciBzdGFydENlbnRlciA9IGN1ci5zdGFydEV2ZW50LmNlbnRlcjtcblxuICAgICAgICAgICAvLyB3ZSBhcmUgZHJhZ2dpbmchXG4gICAgICAgICAgIGlmIChjdXIubmFtZSAhPSBuYW1lKSB7XG4gICAgICAgICAgICAgY3VyLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgIGlmIChpbnN0Lm9wdGlvbnMuZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiAmJiBldi5kaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgIC8vIFdoZW4gYSBkcmFnIGlzIHRyaWdnZXJlZCwgc2V0IHRoZSBldmVudCBjZW50ZXIgdG8gZHJhZ01pbkRpc3RhbmNlIHBpeGVscyBmcm9tIHRoZSBvcmlnaW5hbCBldmVudCBjZW50ZXIuXG4gICAgICAgICAgICAgICAvLyBXaXRob3V0IHRoaXMgY29ycmVjdGlvbiwgdGhlIGRyYWdnZWQgZGlzdGFuY2Ugd291bGQganVtcHN0YXJ0IGF0IGRyYWdNaW5EaXN0YW5jZSBwaXhlbHMgaW5zdGVhZCBvZiBhdCAwLlxuICAgICAgICAgICAgICAgLy8gSXQgbWlnaHQgYmUgdXNlZnVsIHRvIHNhdmUgdGhlIG9yaWdpbmFsIHN0YXJ0IHBvaW50IHNvbWV3aGVyZVxuICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IE1hdGguYWJzKGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgLyBldi5kaXN0YW5jZSk7XG4gICAgICAgICAgICAgICBzdGFydENlbnRlci5wYWdlWCArPSBldi5kZWx0YVggKiBmYWN0b3I7XG4gICAgICAgICAgICAgICBzdGFydENlbnRlci5wYWdlWSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG4gICAgICAgICAgICAgICBzdGFydENlbnRlci5jbGllbnRYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgIHN0YXJ0Q2VudGVyLmNsaWVudFkgKz0gZXYuZGVsdGFZICogZmFjdG9yO1xuXG4gICAgICAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBldmVudCBkYXRhIHVzaW5nIG5ldyBzdGFydCBwb2ludFxuICAgICAgICAgICAgICAgZXYgPSBEZXRlY3Rpb24uZXh0ZW5kRXZlbnREYXRhKGV2KTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICAvLyBsb2NrIGRyYWcgdG8gYXhpcz9cbiAgICAgICAgICAgaWYgKGN1ci5sYXN0RXZlbnQuZHJhZ0xvY2tUb0F4aXMgfHwgaW5zdC5vcHRpb25zLmRyYWdMb2NrVG9BeGlzICYmIGluc3Qub3B0aW9ucy5kcmFnTG9ja01pbkRpc3RhbmNlIDw9IGV2LmRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgZXYuZHJhZ0xvY2tUb0F4aXMgPSB0cnVlO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgLy8ga2VlcCBkaXJlY3Rpb24gb24gdGhlIGF4aXMgdGhhdCB0aGUgZHJhZyBnZXN0dXJlIHN0YXJ0ZWQgb25cbiAgICAgICAgICAgdmFyIGxhc3REaXJlY3Rpb24gPSBjdXIubGFzdEV2ZW50LmRpcmVjdGlvbjtcbiAgICAgICAgICAgaWYgKGV2LmRyYWdMb2NrVG9BeGlzICYmIGxhc3REaXJlY3Rpb24gIT09IGV2LmRpcmVjdGlvbikge1xuICAgICAgICAgICAgIGlmIChVdGlscy5pc1ZlcnRpY2FsKGxhc3REaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICBldi5kaXJlY3Rpb24gPSBldi5kZWx0YVkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IGV2LmRlbHRhWCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICAgICBpZiAoIXRyaWdnZXJlZCkge1xuICAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICAvLyB0cmlnZ2VyIGV2ZW50c1xuICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuXG4gICAgICAgICAgIHZhciBpc1ZlcnRpY2FsID0gVXRpbHMuaXNWZXJ0aWNhbChldi5kaXJlY3Rpb24pO1xuXG4gICAgICAgICAgIC8vIGJsb2NrIHRoZSBicm93c2VyIGV2ZW50c1xuICAgICAgICAgICBpZiAoaW5zdC5vcHRpb25zLmRyYWdCbG9ja1ZlcnRpY2FsICYmIGlzVmVydGljYWwgfHwgaW5zdC5vcHRpb25zLmRyYWdCbG9ja0hvcml6b250YWwgJiYgIWlzVmVydGljYWwpIHtcbiAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgICAgIGlmICh0cmlnZ2VyZWQgJiYgZXYuY2hhbmdlZExlbmd0aCA8PSBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XG4gICAgICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgRVZFTlRfRU5EOlxuICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgYnJlYWs7XG4gICAgICAgfVxuICAgICB9XG5cbiAgICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkRyYWcgPSB7XG4gICAgICAgbmFtZTogbmFtZSxcbiAgICAgICBpbmRleDogNTAsXG4gICAgICAgaGFuZGxlcjogZHJhZ0dlc3R1cmUsXG4gICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogbWluaW1hbCBtb3ZlbWVudCB0aGF0IGhhdmUgdG8gYmUgbWFkZSBiZWZvcmUgdGhlIGRyYWcgZXZlbnQgZ2V0cyB0cmlnZ2VyZWRcbiAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWluRGlzdGFuY2VcbiAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAgICAgICovXG4gICAgICAgICBkcmFnTWluRGlzdGFuY2U6IDEwLFxuXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIFNldCBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uIHRvIHRydWUgdG8gbWFrZSB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGRyYWdcbiAgICAgICAgICAqIGJlIGNhbGN1bGF0ZWQgZnJvbSB3aGVyZSB0aGUgZHJhZyB3YXMgdHJpZ2dlcmVkLCBub3QgZnJvbSB3aGVyZSB0aGUgdG91Y2ggc3RhcnRlZC5cbiAgICAgICAgICAqIFVzZWZ1bCB0byBhdm9pZCBhIGplcmstc3RhcnRpbmcgZHJhZywgd2hpY2ggY2FuIG1ha2UgZmluZS1hZGp1c3RtZW50c1xuICAgICAgICAgICogdGhyb3VnaCBkcmFnZ2luZyBkaWZmaWN1bHQsIGFuZCBiZSB2aXN1YWxseSB1bmFwcGVhbGluZy5cbiAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uXG4gICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICAqL1xuICAgICAgICAgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbjogdHJ1ZSxcblxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBzZXQgMCBmb3IgdW5saW1pdGVkLCBidXQgdGhpcyBjYW4gY29uZmxpY3Qgd2l0aCB0cmFuc2Zvcm1cbiAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWF4VG91Y2hlc1xuICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICAqL1xuICAgICAgICAgZHJhZ01heFRvdWNoZXM6IDEsXG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgICogcHJldmVudCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3Igd2hlbiBkcmFnZ2luZyBvY2N1cnNcbiAgICAgICAgICAqIGJlIGNhcmVmdWwgd2l0aCBpdCwgaXQgbWFrZXMgdGhlIGVsZW1lbnQgYSBibG9ja2luZyBlbGVtZW50XG4gICAgICAgICAgKiB3aGVuIHlvdSBhcmUgdXNpbmcgdGhlIGRyYWcgZ2VzdHVyZSwgaXQgaXMgYSBnb29kIHByYWN0aWNlIHRvIHNldCB0aGlzIHRydWVcbiAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tIb3Jpem9udGFsXG4gICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgKi9cbiAgICAgICAgIGRyYWdCbG9ja0hvcml6b250YWw6IGZhbHNlLFxuXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIHNhbWUgYXMgYGRyYWdCbG9ja0hvcml6b250YWxgLCBidXQgZm9yIHZlcnRpY2FsIG1vdmVtZW50XG4gICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Jsb2NrVmVydGljYWxcbiAgICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICAqL1xuICAgICAgICAgZHJhZ0Jsb2NrVmVydGljYWw6IGZhbHNlLFxuXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIGRyYWdMb2NrVG9BeGlzIGtlZXBzIHRoZSBkcmFnIGdlc3R1cmUgb24gdGhlIGF4aXMgdGhhdCBpdCBzdGFydGVkIG9uLFxuICAgICAgICAgICogSXQgZGlzYWxsb3dzIHZlcnRpY2FsIGRpcmVjdGlvbnMgaWYgdGhlIGluaXRpYWwgZGlyZWN0aW9uIHdhcyBob3Jpem9udGFsLCBhbmQgdmljZSB2ZXJzYS5cbiAgICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTG9ja1RvQXhpc1xuICAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgICovXG4gICAgICAgICBkcmFnTG9ja1RvQXhpczogZmFsc2UsXG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgICogZHJhZyBsb2NrIG9ubHkga2lja3MgaW4gd2hlbiBkaXN0YW5jZSA+IGRyYWdMb2NrTWluRGlzdGFuY2VcbiAgICAgICAgICAqIFRoaXMgd2F5LCBsb2NraW5nIG9jY3VycyBvbmx5IHdoZW4gdGhlIGRpc3RhbmNlIGhhcyBiZWNvbWUgbGFyZ2UgZW5vdWdoIHRvIHJlbGlhYmx5IGRldGVybWluZSB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0xvY2tNaW5EaXN0YW5jZVxuICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAqIEBkZWZhdWx0IDI1XG4gICAgICAgICAgKi9cbiAgICAgICAgIGRyYWdMb2NrTWluRGlzdGFuY2U6IDI1XG4gICAgICAgfVxuICAgICB9O1xuICAgfSkoJ2RyYWcnKTtcblxuICAgLyoqXG4gICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAgKi9cbiAgIC8qKlxuICAgICogdHJpZ2dlciBhIHNpbXBsZSBnZXN0dXJlIGV2ZW50LCBzbyB5b3UgY2FuIGRvIGFueXRoaW5nIGluIHlvdXIgaGFuZGxlci5cbiAgICAqIG9ubHkgdXNhYmxlIGlmIHlvdSBrbm93IHdoYXQgeW91ciBkb2luZy4uLlxuICAgICpcbiAgICAqIEBjbGFzcyBHZXN0dXJlXG4gICAgKiBAc3RhdGljXG4gICAgKi9cbiAgIC8qKlxuICAgICogQGV2ZW50IGdlc3R1cmVcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICovXG4gICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuR2VzdHVyZSA9IHtcbiAgICAgbmFtZTogJ2dlc3R1cmUnLFxuICAgICBpbmRleDogMTMzNyxcbiAgICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgICovXG4gICAvKipcbiAgICAqIFRvdWNoIHN0YXlzIGF0IHRoZSBzYW1lIHBsYWNlIGZvciB4IHRpbWVcbiAgICAqXG4gICAgKiBAY2xhc3MgSG9sZFxuICAgICogQHN0YXRpY1xuICAgICovXG4gICAvKipcbiAgICAqIEBldmVudCBob2xkXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAqL1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgKi9cbiAgIChmdW5jdGlvbiAobmFtZSkge1xuICAgICB2YXIgdGltZXI7XG5cbiAgICAgZnVuY3Rpb24gaG9sZEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICB2YXIgb3B0aW9ucyA9IGluc3Qub3B0aW9ucyxcbiAgICAgICAgICAgY3VycmVudCA9IERldGVjdGlvbi5jdXJyZW50O1xuXG4gICAgICAgc3dpdGNoIChldi5ldmVudFR5cGUpIHtcbiAgICAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgICAgICAgLy8gc2V0IHRoZSBnZXN0dXJlIHNvIHdlIGNhbiBjaGVjayBpbiB0aGUgdGltZW91dCBpZiBpdCBzdGlsbCBpc1xuICAgICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgICAgIC8vIHNldCB0aW1lciBhbmQgaWYgYWZ0ZXIgdGhlIHRpbWVvdXQgaXQgc3RpbGwgaXMgaG9sZCxcbiAgICAgICAgICAgLy8gd2UgdHJpZ2dlciB0aGUgaG9sZCBldmVudFxuICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSwgb3B0aW9ucy5ob2xkVGltZW91dCk7XG4gICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgICAgIGlmIChldi5kaXN0YW5jZSA+IG9wdGlvbnMuaG9sZFRocmVzaG9sZCkge1xuICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgYnJlYWs7XG4gICAgICAgfVxuICAgICB9XG5cbiAgICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkhvbGQgPSB7XG4gICAgICAgbmFtZTogbmFtZSxcbiAgICAgICBpbmRleDogMTAsXG4gICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogQHByb3BlcnR5IGhvbGRUaW1lb3V0XG4gICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICogQGRlZmF1bHQgNTAwXG4gICAgICAgICAgKi9cbiAgICAgICAgIGhvbGRUaW1lb3V0OiA1MDAsXG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgICogbW92ZW1lbnQgYWxsb3dlZCB3aGlsZSBob2xkaW5nXG4gICAgICAgICAgKiBAcHJvcGVydHkgaG9sZFRocmVzaG9sZFxuICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAqIEBkZWZhdWx0IDJcbiAgICAgICAgICAqL1xuICAgICAgICAgaG9sZFRocmVzaG9sZDogMlxuICAgICAgIH0sXG4gICAgICAgaGFuZGxlcjogaG9sZEdlc3R1cmVcbiAgICAgfTtcbiAgIH0pKCdob2xkJyk7XG5cbiAgIC8qKlxuICAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgICovXG4gICAvKipcbiAgICAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyByZWxlYXNlZCBmcm9tIHRoZSBwYWdlXG4gICAgKlxuICAgICogQGNsYXNzIFJlbGVhc2VcbiAgICAqIEBzdGF0aWNcbiAgICAqL1xuICAgLyoqXG4gICAgKiBAZXZlbnQgcmVsZWFzZVxuICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgKi9cbiAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5SZWxlYXNlID0ge1xuICAgICBuYW1lOiAncmVsZWFzZScsXG4gICAgIGluZGV4OiBJbmZpbml0eSxcbiAgICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICBpZiAoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgICB9XG4gICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgICovXG4gICAvKipcbiAgICAqIHRyaWdnZXJzIHN3aXBlIGV2ZW50cyB3aGVuIHRoZSBlbmQgdmVsb2NpdHkgaXMgYWJvdmUgdGhlIHRocmVzaG9sZFxuICAgICogZm9yIGJlc3QgdXNhZ2UsIHNldCBgcHJldmVudERlZmF1bHRgIChvbiB0aGUgZHJhZyBnZXN0dXJlKSB0byBgdHJ1ZWBcbiAgICAqIGBgYGBcbiAgICAqICBHZXN0dXJlRGV0ZWN0b3J0aW1lLm9uKFwiZHJhZ2xlZnQgc3dpcGVsZWZ0XCIsIGZ1bmN0aW9uKGV2KSB7XG4gICAgKiAgICBjb25zb2xlLmxvZyhldik7XG4gICAgKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgKiAgfSk7XG4gICAgKiBgYGBgXG4gICAgKlxuICAgICogQGNsYXNzIFN3aXBlXG4gICAgKiBAc3RhdGljXG4gICAgKi9cbiAgIC8qKlxuICAgICogQGV2ZW50IHN3aXBlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAqL1xuICAgLyoqXG4gICAgKiBAZXZlbnQgc3dpcGVsZWZ0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAqL1xuICAgLyoqXG4gICAgKiBAZXZlbnQgc3dpcGVyaWdodFxuICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgKi9cbiAgIC8qKlxuICAgICogQGV2ZW50IHN3aXBldXBcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICovXG4gICAvKipcbiAgICAqIEBldmVudCBzd2lwZWRvd25cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICovXG4gICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuU3dpcGUgPSB7XG4gICAgIG5hbWU6ICdzd2lwZScsXG4gICAgIGluZGV4OiA0MCxcbiAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAvKipcbiAgICAgICAgKiBAcHJvcGVydHkgc3dpcGVNaW5Ub3VjaGVzXG4gICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICovXG4gICAgICAgc3dpcGVNaW5Ub3VjaGVzOiAxLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHByb3BlcnR5IHN3aXBlTWF4VG91Y2hlc1xuICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAqL1xuICAgICAgIHN3aXBlTWF4VG91Y2hlczogMSxcblxuICAgICAgIC8qKlxuICAgICAgICAqIGhvcml6b250YWwgc3dpcGUgdmVsb2NpdHlcbiAgICAgICAgKiBAcHJvcGVydHkgc3dpcGVWZWxvY2l0eVhcbiAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAqIEBkZWZhdWx0IDAuNlxuICAgICAgICAqL1xuICAgICAgIHN3aXBlVmVsb2NpdHlYOiAwLjYsXG5cbiAgICAgICAvKipcbiAgICAgICAgKiB2ZXJ0aWNhbCBzd2lwZSB2ZWxvY2l0eVxuICAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZVZlbG9jaXR5WVxuICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICogQGRlZmF1bHQgMC42XG4gICAgICAgICovXG4gICAgICAgc3dpcGVWZWxvY2l0eVk6IDAuNlxuICAgICB9LFxuXG4gICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHN3aXBlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgIGlmIChldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICAgdmFyIHRvdWNoZXMgPSBldi50b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgICBvcHRpb25zID0gaW5zdC5vcHRpb25zO1xuXG4gICAgICAgICAvLyBtYXggdG91Y2hlc1xuICAgICAgICAgaWYgKHRvdWNoZXMgPCBvcHRpb25zLnN3aXBlTWluVG91Y2hlcyB8fCB0b3VjaGVzID4gb3B0aW9ucy5zd2lwZU1heFRvdWNoZXMpIHtcbiAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuXG4gICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgICBpZiAoZXYudmVsb2NpdHlYID4gb3B0aW9ucy5zd2lwZVZlbG9jaXR5WCB8fCBldi52ZWxvY2l0eVkgPiBvcHRpb25zLnN3aXBlVmVsb2NpdHlZKSB7XG4gICAgICAgICAgIC8vIHRyaWdnZXIgc3dpcGUgZXZlbnRzXG4gICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAgKi9cbiAgIC8qKlxuICAgICogU2luZ2xlIHRhcCBhbmQgYSBkb3VibGUgdGFwIG9uIGEgcGxhY2VcbiAgICAqXG4gICAgKiBAY2xhc3MgVGFwXG4gICAgKiBAc3RhdGljXG4gICAgKi9cbiAgIC8qKlxuICAgICogQGV2ZW50IHRhcFxuICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgKi9cbiAgIC8qKlxuICAgICogQGV2ZW50IGRvdWJsZXRhcFxuICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICovXG4gICAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgdmFyIGhhc01vdmVkID0gZmFsc2U7XG5cbiAgICAgZnVuY3Rpb24gdGFwR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgICBjdXJyZW50ID0gRGV0ZWN0aW9uLmN1cnJlbnQsXG4gICAgICAgICAgIHByZXYgPSBEZXRlY3Rpb24ucHJldmlvdXMsXG4gICAgICAgICAgIHNpbmNlUHJldixcbiAgICAgICAgICAgZGlkRG91YmxlVGFwO1xuXG4gICAgICAgc3dpdGNoIChldi5ldmVudFR5cGUpIHtcbiAgICAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgICAgIGhhc01vdmVkID0gZmFsc2U7XG4gICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgICAgIGhhc01vdmVkID0gaGFzTW92ZWQgfHwgZXYuZGlzdGFuY2UgPiBvcHRpb25zLnRhcE1heERpc3RhbmNlO1xuICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgY2FzZSBFVkVOVF9FTkQ6XG4gICAgICAgICAgIGlmICghVXRpbHMuaW5TdHIoZXYuc3JjRXZlbnQudHlwZSwgJ2NhbmNlbCcpICYmIGV2LmRlbHRhVGltZSA8IG9wdGlvbnMudGFwTWF4VGltZSAmJiAhaGFzTW92ZWQpIHtcbiAgICAgICAgICAgICAvLyBwcmV2aW91cyBnZXN0dXJlLCBmb3IgdGhlIGRvdWJsZSB0YXAgc2luY2UgdGhlc2UgYXJlIHR3byBkaWZmZXJlbnQgZ2VzdHVyZSBkZXRlY3Rpb25zXG4gICAgICAgICAgICAgc2luY2VQcmV2ID0gcHJldiAmJiBwcmV2Lmxhc3RFdmVudCAmJiBldi50aW1lU3RhbXAgLSBwcmV2Lmxhc3RFdmVudC50aW1lU3RhbXA7XG4gICAgICAgICAgICAgZGlkRG91YmxlVGFwID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAvLyBjaGVjayBpZiBkb3VibGUgdGFwXG4gICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5uYW1lID09IG5hbWUgJiYgc2luY2VQcmV2ICYmIHNpbmNlUHJldiA8IG9wdGlvbnMuZG91YmxlVGFwSW50ZXJ2YWwgJiYgZXYuZGlzdGFuY2UgPCBvcHRpb25zLmRvdWJsZVRhcERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ2RvdWJsZXRhcCcsIGV2KTtcbiAgICAgICAgICAgICAgIGRpZERvdWJsZVRhcCA9IHRydWU7XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgLy8gZG8gYSBzaW5nbGUgdGFwXG4gICAgICAgICAgICAgaWYgKCFkaWREb3VibGVUYXAgfHwgb3B0aW9ucy50YXBBbHdheXMpIHtcbiAgICAgICAgICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICBpbnN0LnRyaWdnZXIoY3VycmVudC5uYW1lLCBldik7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIGJyZWFrO1xuICAgICAgIH1cbiAgICAgfVxuXG4gICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5UYXAgPSB7XG4gICAgICAgbmFtZTogbmFtZSxcbiAgICAgICBpbmRleDogMTAwLFxuICAgICAgIGhhbmRsZXI6IHRhcEdlc3R1cmUsXG4gICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgIC8qKlxuICAgICAgICAgICogbWF4IHRpbWUgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhUaW1lXG4gICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICogQGRlZmF1bHQgMjUwXG4gICAgICAgICAgKi9cbiAgICAgICAgIHRhcE1heFRpbWU6IDI1MCxcblxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBtYXggZGlzdGFuY2Ugb2YgbW92ZW1lbnQgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhEaXN0YW5jZVxuICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgICAgKi9cbiAgICAgICAgIHRhcE1heERpc3RhbmNlOiAxMCxcblxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBhbHdheXMgdHJpZ2dlciB0aGUgYHRhcGAgZXZlbnQsIGV2ZW4gd2hpbGUgZG91YmxlLXRhcHBpbmdcbiAgICAgICAgICAqIEBwcm9wZXJ0eSB0YXBBbHdheXNcbiAgICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgICovXG4gICAgICAgICB0YXBBbHdheXM6IHRydWUsXG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgICogbWF4IGRpc3RhbmNlIGJldHdlZW4gdHdvIHRhcHNcbiAgICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBEaXN0YW5jZVxuICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAqIEBkZWZhdWx0IDIwXG4gICAgICAgICAgKi9cbiAgICAgICAgIGRvdWJsZVRhcERpc3RhbmNlOiAyMCxcblxuICAgICAgICAgLyoqXG4gICAgICAgICAgKiBtYXggdGltZSBiZXR3ZWVuIHR3byB0YXBzXG4gICAgICAgICAgKiBAcHJvcGVydHkgZG91YmxlVGFwSW50ZXJ2YWxcbiAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgKiBAZGVmYXVsdCAzMDBcbiAgICAgICAgICAqL1xuICAgICAgICAgZG91YmxlVGFwSW50ZXJ2YWw6IDMwMFxuICAgICAgIH1cbiAgICAgfTtcbiAgIH0pKCd0YXAnKTtcblxuICAgLyoqXG4gICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAgKi9cbiAgIC8qKlxuICAgICogd2hlbiBhIHRvdWNoIGlzIGJlaW5nIHRvdWNoZWQgYXQgdGhlIHBhZ2VcbiAgICAqXG4gICAgKiBAY2xhc3MgVG91Y2hcbiAgICAqIEBzdGF0aWNcbiAgICAqL1xuICAgLyoqXG4gICAgKiBAZXZlbnQgdG91Y2hcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgICovXG4gICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVG91Y2ggPSB7XG4gICAgIG5hbWU6ICd0b3VjaCcsXG4gICAgIGluZGV4OiAtSW5maW5pdHksXG4gICAgIGRlZmF1bHRzOiB7XG4gICAgICAgLyoqXG4gICAgICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCBhdCB0b3VjaHN0YXJ0LCBhbmQgbWFrZXMgdGhlIGVsZW1lbnQgYmxvY2tpbmcgYnkgZGlzYWJsaW5nIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHBhZ2UsXG4gICAgICAgICogYnV0IGl0IGltcHJvdmVzIGdlc3R1cmVzIGxpa2UgdHJhbnNmb3JtaW5nIGFuZCBkcmFnZ2luZy5cbiAgICAgICAgKiBiZSBjYXJlZnVsIHdpdGggdXNpbmcgdGhpcywgaXQgY2FuIGJlIHZlcnkgYW5ub3lpbmcgZm9yIHVzZXJzIHRvIGJlIHN0dWNrIG9uIHRoZSBwYWdlXG4gICAgICAgICogQHByb3BlcnR5IHByZXZlbnREZWZhdWx0XG4gICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgKi9cbiAgICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBkaXNhYmxlIG1vdXNlIGV2ZW50cywgc28gb25seSB0b3VjaCAob3IgcGVuISkgaW5wdXQgdHJpZ2dlcnMgZXZlbnRzXG4gICAgICAgICogQHByb3BlcnR5IHByZXZlbnRNb3VzZVxuICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICovXG4gICAgICAgcHJldmVudE1vdXNlOiBmYWxzZVxuICAgICB9LFxuICAgICBoYW5kbGVyOiBmdW5jdGlvbiB0b3VjaEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgICBpZiAoaW5zdC5vcHRpb25zLnByZXZlbnRNb3VzZSAmJiBldi5wb2ludGVyVHlwZSA9PSBQT0lOVEVSX01PVVNFKSB7XG4gICAgICAgICBldi5zdG9wRGV0ZWN0KCk7XG4gICAgICAgICByZXR1cm47XG4gICAgICAgfVxuXG4gICAgICAgaWYgKGluc3Qub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICB9XG5cbiAgICAgICBpZiAoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIKSB7XG4gICAgICAgICBpbnN0LnRyaWdnZXIoJ3RvdWNoJywgZXYpO1xuICAgICAgIH1cbiAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAgKi9cbiAgIC8qKlxuICAgICogVXNlciB3YW50IHRvIHNjYWxlIG9yIHJvdGF0ZSB3aXRoIDIgZmluZ2Vyc1xuICAgICogUHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGlzIGEgZ29vZCB3YXkgdG8gaW1wcm92ZSBmZWVsIGFuZCB3b3JraW5nLiBUaGlzIGNhbiBiZSBkb25lIHdpdGggdGhlXG4gICAgKiBgcHJldmVudERlZmF1bHRgIG9wdGlvbi5cbiAgICAqXG4gICAgKiBAY2xhc3MgVHJhbnNmb3JtXG4gICAgKiBAc3RhdGljXG4gICAgKi9cbiAgIC8qKlxuICAgICogQGV2ZW50IHRyYW5zZm9ybVxuICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgKi9cbiAgIC8qKlxuICAgICogQGV2ZW50IHRyYW5zZm9ybXN0YXJ0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAqL1xuICAgLyoqXG4gICAgKiBAZXZlbnQgdHJhbnNmb3JtZW5kXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAqL1xuICAgLyoqXG4gICAgKiBAZXZlbnQgcGluY2hpblxuICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgKi9cbiAgIC8qKlxuICAgICogQGV2ZW50IHBpbmNob3V0XG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAqL1xuICAgLyoqXG4gICAgKiBAZXZlbnQgcm90YXRlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAqL1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgKi9cbiAgIChmdW5jdGlvbiAobmFtZSkge1xuICAgICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XG5cbiAgICAgZnVuY3Rpb24gdHJhbnNmb3JtR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgIHN3aXRjaCAoZXYuZXZlbnRUeXBlKSB7XG4gICAgICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgICAgLy8gYXQgbGVhc3QgbXVsdGl0b3VjaFxuICAgICAgICAgICBpZiAoZXYudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgdmFyIHNjYWxlVGhyZXNob2xkID0gTWF0aC5hYnMoMSAtIGV2LnNjYWxlKTtcbiAgICAgICAgICAgdmFyIHJvdGF0aW9uVGhyZXNob2xkID0gTWF0aC5hYnMoZXYucm90YXRpb24pO1xuXG4gICAgICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgICAgICBpZiAoc2NhbGVUaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluU2NhbGUgJiYgcm90YXRpb25UaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICAvLyB3ZSBhcmUgdHJhbnNmb3JtaW5nIVxuICAgICAgICAgICBEZXRlY3Rpb24uY3VycmVudC5uYW1lID0gbmFtZTtcblxuICAgICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICAgICBpZiAoIXRyaWdnZXJlZCkge1xuICAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpOyAvLyBiYXNpYyB0cmFuc2Zvcm0gZXZlbnRcblxuICAgICAgICAgICAvLyB0cmlnZ2VyIHJvdGF0ZSBldmVudFxuICAgICAgICAgICBpZiAocm90YXRpb25UaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3JvdGF0ZScsIGV2KTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIHRyaWdnZXIgcGluY2ggZXZlbnRcbiAgICAgICAgICAgaWYgKHNjYWxlVGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblNjYWxlKSB7XG4gICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCdwaW5jaCcsIGV2KTtcbiAgICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJyArIChldi5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCcpLCBldik7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgICAgaWYgKHRyaWdnZXJlZCAmJiBldi5jaGFuZ2VkTGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBicmVhaztcbiAgICAgICB9XG4gICAgIH1cblxuICAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVHJhbnNmb3JtID0ge1xuICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgaW5kZXg6IDQ1LFxuICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAvKipcbiAgICAgICAgICAqIG1pbmltYWwgc2NhbGUgZmFjdG9yLCBubyBzY2FsZSBpcyAxLCB6b29taW4gaXMgdG8gMCBhbmQgem9vbW91dCB1bnRpbCBoaWdoZXIgdGhlbiAxXG4gICAgICAgICAgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWluU2NhbGVcbiAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgKiBAZGVmYXVsdCAwLjAxXG4gICAgICAgICAgKi9cbiAgICAgICAgIHRyYW5zZm9ybU1pblNjYWxlOiAwLjAxLFxuXG4gICAgICAgICAvKipcbiAgICAgICAgICAqIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5Sb3RhdGlvblxuICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICAqL1xuICAgICAgICAgdHJhbnNmb3JtTWluUm90YXRpb246IDFcbiAgICAgICB9LFxuXG4gICAgICAgaGFuZGxlcjogdHJhbnNmb3JtR2VzdHVyZVxuICAgICB9O1xuICAgfSkoJ3RyYW5zZm9ybScpO1xuXG4gICAvKlxuICAgQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG4gICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gICAqL1xuXG4gICAvKipcbiAgICAqIEBvYmplY3Qgb25zLnBsYXRmb3JtXG4gICAgKiBAY2F0ZWdvcnkgdXRpbFxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1VdGlsaXR5IG1ldGhvZHMgdG8gZGV0ZWN0IGN1cnJlbnQgcGxhdGZvcm0uWy9lbl1cbiAgICAqICAgW2phXeePvuWcqOWun+ihjOOBleOCjOOBpuOBhOOCi+ODl+ODqeODg+ODiOODleOCqeODvOODoOOCkuaknOefpeOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBn+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAgKi9cblxuICAgdmFyIFBsYXRmb3JtID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAvKipcbiAgICAgICogQWxsIGVsZW1lbnRzIHdpbGwgYmUgcmVuZGVyZWQgYXMgaWYgdGhlIGFwcCB3YXMgcnVubmluZyBvbiB0aGlzIHBsYXRmb3JtLlxuICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgKi9cblxuICAgICBmdW5jdGlvbiBQbGF0Zm9ybSgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxhdGZvcm0pO1xuXG4gICAgICAgdGhpcy5fcmVuZGVyUGxhdGZvcm0gPSBudWxsO1xuICAgICB9XG5cbiAgICAgLyoqXG4gICAgICAqIEBtZXRob2Qgc2VsZWN0XG4gICAgICAqIEBzaWduYXR1cmUgc2VsZWN0KHBsYXRmb3JtKVxuICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBsYXRmb3JtIE5hbWUgb2YgdGhlIHBsYXRmb3JtLlxuICAgICAgKiAgIFtlbl1Qb3NzaWJsZSB2YWx1ZXMgYXJlOiBcIm9wZXJhXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiLCBcImNocm9tZVwiLCBcImllXCIsIFwiYW5kcm9pZFwiLCBcImJsYWNrYmVycnlcIiwgXCJpb3NcIiBvciBcIndwXCIuWy9lbl1cbiAgICAgICogICBbamFdXCJvcGVyYVwiLCBcImZpcmVmb3hcIiwgXCJzYWZhcmlcIiwgXCJjaHJvbWVcIiwgXCJpZVwiLCBcImFuZHJvaWRcIiwgXCJibGFja2JlcnJ5XCIsIFwiaW9zXCIsIFwid3BcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgKiAgIFtlbl1TZXRzIHRoZSBwbGF0Zm9ybSB1c2VkIHRvIHJlbmRlciB0aGUgZWxlbWVudHMuIFVzZWZ1bCBmb3IgdGVzdGluZy5bL2VuXVxuICAgICAgKiAgIFtqYV3opoHntKDjgpLmj4/nlLvjgZnjgovjgZ/jgoHjgavliKnnlKjjgZnjgovjg5fjg6njg4Pjg4jjg5Xjgqnjg7zjg6DlkI3jgpLoqK3lrprjgZfjgb7jgZnjgILjg4bjgrnjg4jjgavkvr/liKnjgafjgZnjgIJbL2phXVxuICAgICAgKi9cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoUGxhdGZvcm0sIFt7XG4gICAgICAga2V5OiAnc2VsZWN0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KHBsYXRmb3JtKSB7XG4gICAgICAgICBpZiAodHlwZW9mIHBsYXRmb3JtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9IHBsYXRmb3JtLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaXNXZWJWaWV3XG4gICAgICAgICogQHNpZ25hdHVyZSBpc1dlYlZpZXcoKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBDb3Jkb3ZhLlsvZW5dXG4gICAgICAgICogICBbamFdQ29yZG92YeWGheOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNXZWJWaWV3JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNXZWJWaWV3KCkge1xuICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09ICd1bmluaXRpYWxpemVkJykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzV2ViVmlldygpIG1ldGhvZCBpcyBhdmFpbGFibGUgYWZ0ZXIgZG9tIGNvbnRlbnRzIGxvYWRlZC4nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuICEhKHdpbmRvdy5jb3Jkb3ZhIHx8IHdpbmRvdy5waG9uZWdhcCB8fCB3aW5kb3cuUGhvbmVHYXApO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaXNJT1NcbiAgICAgICAgKiBAc2lnbmF0dXJlIGlzSU9TKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIE9TIGlzIGlPUy5bL2VuXVxuICAgICAgICAqICAgW2phXWlPU+S4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNJT1MnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0lPUygpIHtcbiAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdpb3MnO1xuICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGRldmljZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IGJhYmVsSGVscGVycy50eXBlb2YoZGV2aWNlKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgIHJldHVybiAoL2lPUy9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKVxuICAgICAgICAgICApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuICgvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgICAgICAgKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzQW5kcm9pZFxuICAgICAgICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIE9TIGlzIEFuZHJvaWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1BbmRyb2lk5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdpc0FuZHJvaWQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FuZHJvaWQoKSB7XG4gICAgICAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnYW5kcm9pZCc7XG4gICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGV2aWNlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogYmFiZWxIZWxwZXJzLnR5cGVvZihkZXZpY2UpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgcmV0dXJuICgvQW5kcm9pZC9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKVxuICAgICAgICAgICApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuICgvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgICAgICAgKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzQW5kcm9pZFBob25lXG4gICAgICAgICogQHNpZ25hdHVyZSBpc0FuZHJvaWRQaG9uZSgpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQW5kcm9pZCBwaG9uZS5bL2VuXVxuICAgICAgICAqICAgW2phXUFuZHJvaWTmkLrluK/kuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzQW5kcm9pZFBob25lJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNBbmRyb2lkUGhvbmUoKSB7XG4gICAgICAgICByZXR1cm4gKC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICAgICAgKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzQW5kcm9pZFRhYmxldFxuICAgICAgICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkVGFibGV0KClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBBbmRyb2lkIHRhYmxldC5bL2VuXVxuICAgICAgICAqICAgW2phXUFuZHJvaWTjgr/jg5bjg6zjg4Pjg4jkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzQW5kcm9pZFRhYmxldCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzQW5kcm9pZFRhYmxldCgpIHtcbiAgICAgICAgIHJldHVybiAoL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICAgICAgKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdpc1dQJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNXUCgpIHtcbiAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICd3cCc7XG4gICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGV2aWNlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogYmFiZWxIZWxwZXJzLnR5cGVvZihkZXZpY2UpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgcmV0dXJuICgvV2luMzJOVHxXaW5DRS9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKVxuICAgICAgICAgICApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuICgvV2luZG93cyBQaG9uZXxJRU1vYmlsZXxXUERlc2t0b3AvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgICAgICAgICk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvcyBpc0lQaG9uZVxuICAgICAgICAqIEBzaWduYXR1cmUgaXNJUGhvbmUoKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIGlQaG9uZS5bL2VuXVxuICAgICAgICAqICAgW2phXWlQaG9uZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNJUGhvbmUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0lQaG9uZSgpIHtcbiAgICAgICAgIHJldHVybiAoL2lQaG9uZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICAgICAgICk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc0lQYWRcbiAgICAgICAgKiBAc2lnbmF0dXJlIGlzSVBhZCgpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgaVBhZC5bL2VuXVxuICAgICAgICAqICAgW2phXWlQYWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzSVBhZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzSVBhZCgpIHtcbiAgICAgICAgIHJldHVybiAoL2lQYWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgICAgICApO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzSVBvZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzSVBvZCgpIHtcbiAgICAgICAgIHJldHVybiAoL2lQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgICAgICApO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaXNCbGFja0JlcnJ5XG4gICAgICAgICogQHNpZ25hdHVyZSBpc0JsYWNrQmVycnkoKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEJsYWNrQmVycnkuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1CbGFja0JlcnJ55LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdpc0JsYWNrQmVycnknLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JsYWNrQmVycnkoKSB7XG4gICAgICAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnYmxhY2tiZXJyeSc7XG4gICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGV2aWNlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogYmFiZWxIZWxwZXJzLnR5cGVvZihkZXZpY2UpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgcmV0dXJuICgvQmxhY2tCZXJyeS9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKVxuICAgICAgICAgICApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuICgvQmxhY2tCZXJyeXxSSU0gVGFibGV0IE9TfEJCMTAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgICAgICAgICk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc09wZXJhXG4gICAgICAgICogQHNpZ25hdHVyZSBpc09wZXJhKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgT3BlcmEuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1PcGVyYeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNPcGVyYScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3BlcmEoKSB7XG4gICAgICAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnb3BlcmEnO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuICEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaXNGaXJlZm94XG4gICAgICAgICogQHNpZ25hdHVyZSBpc0ZpcmVmb3goKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBGaXJlZm94LlsvZW5dXG4gICAgICAgICogICBbamFdRmlyZWZveOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNGaXJlZm94JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNGaXJlZm94KCkge1xuICAgICAgICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2ZpcmVmb3gnO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc1NhZmFyaVxuICAgICAgICAqIEBzaWduYXR1cmUgaXNTYWZhcmkoKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBTYWZhcmkuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1TYWZhcmnkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzU2FmYXJpJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgICAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnc2FmYXJpJztcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LkhUTUxFbGVtZW50KS5pbmRleE9mKCdDb25zdHJ1Y3RvcicpID4gMDtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzQ2hyb21lXG4gICAgICAgICogQHNpZ25hdHVyZSBpc0Nocm9tZSgpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIENocm9tZS5bL2VuXVxuICAgICAgICAqICAgW2phXUNocm9tZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNDaHJvbWUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Nocm9tZSgpIHtcbiAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJQbGF0Zm9ybSkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGxhdGZvcm0gPT09ICdjaHJvbWUnO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuICEhd2luZG93LmNocm9tZSAmJiAhKCEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwKSAmJiAhKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIEVkZ2UvJykgPj0gMCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc0lFXG4gICAgICAgICogQHNpZ25hdHVyZSBpc0lFKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1JbnRlcm5ldCBFeHBsb3JlcuS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNJRScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzSUUoKSB7XG4gICAgICAgICBpZiAodGhpcy5fcmVuZGVyUGxhdGZvcm0pIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBsYXRmb3JtID09PSAnaWUnO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuIGZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaXNFZGdlXG4gICAgICAgICogQHNpZ25hdHVyZSBpc0VkZ2UoKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBFZGdlLlsvZW5dXG4gICAgICAgICogICBbamFdRWRnZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNFZGdlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNFZGdlKCkge1xuICAgICAgICAgaWYgKHRoaXMuX3JlbmRlclBsYXRmb3JtKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQbGF0Zm9ybSA9PT0gJ2VkZ2UnO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIEVkZ2UvJykgPj0gMDtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzSU9TN2Fib3ZlXG4gICAgICAgICogQHNpZ25hdHVyZSBpc0lPUzdhYm92ZSgpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBpT1MgdmVyc2lvbiBpcyA3IG9yIGFib3ZlLlsvZW5dXG4gICAgICAgICogICBbamFdaU9TN+S7peS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNJT1M3YWJvdmUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0lPUzdhYm92ZSgpIHtcbiAgICAgICAgIGlmICgodHlwZW9mIGRldmljZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IGJhYmVsSGVscGVycy50eXBlb2YoZGV2aWNlKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgIHJldHVybiAoL2lPUy9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSAmJiBwYXJzZUludChkZXZpY2UudmVyc2lvbi5zcGxpdCgnLicpWzBdKSA+PSA3XG4gICAgICAgICAgICk7XG4gICAgICAgICB9IGVsc2UgaWYgKC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICB2YXIgdmVyID0gKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1xcYlswLTldK19bMC05XSsoPzpfWzAtOV0rKT9cXGIvKSB8fCBbJyddKVswXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICAgICAgIHJldHVybiBwYXJzZUludCh2ZXIuc3BsaXQoJy4nKVswXSkgPj0gNztcbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2dldE1vYmlsZU9TJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW9iaWxlT1MoKSB7XG4gICAgICAgICBpZiAodGhpcy5pc0FuZHJvaWQoKSkge1xuICAgICAgICAgICByZXR1cm4gJ2FuZHJvaWQnO1xuICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSU9TKCkpIHtcbiAgICAgICAgICAgcmV0dXJuICdpb3MnO1xuICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzV1AoKSkge1xuICAgICAgICAgICByZXR1cm4gJ3dwJztcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZ2V0SU9TRGV2aWNlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SU9TRGV2aWNlKCkge1xuICAgICAgICAgaWYgKHRoaXMuaXNJUGhvbmUoKSkge1xuICAgICAgICAgICByZXR1cm4gJ2lwaG9uZSc7XG4gICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNJUGFkKCkpIHtcbiAgICAgICAgICAgcmV0dXJuICdpcGFkJztcbiAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0lQb2QoKSkge1xuICAgICAgICAgICByZXR1cm4gJ2lwb2QnO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuICduYSc7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBQbGF0Zm9ybTtcbiAgIH0pKCk7XG5cbiAgIHZhciBwbGF0Zm9ybSA9IG5ldyBQbGF0Zm9ybSgpO1xuXG4gICAvKipcbiAgICAqIEBvYmplY3Qgb25zLm5vdGlmaWNhdGlvblxuICAgICogQGNhdGVnb3J5IGRpYWxvZ1xuICAgICogQGNvZGVwZW4gUXd3eHlwXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyB0byBjcmVhdGUgZGlmZmVyZW50IGtpbmRzIG9mIGFsZXJ0IGRpYWxvZ3MuIFRoZXJlIGFyZSB0aHJlZSBtZXRob2RzIGF2YWlsYWJsZTogYWxlcnQsIGNvbmZpcm0gYW5kIHByb21wdC5bL2VuXVxuICAgICogICBbamFd44GE44GP44Gk44GL44Gu56iu6aGe44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS5L2c5oiQ44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8c2NyaXB0PlxuICAgICogICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KHtcbiAgICAqICAgICBtZXNzYWdlOiAnSGVsbG8sIHdvcmxkISdcbiAgICAqICAgfSk7XG4gICAgKlxuICAgICogICAvLyBTaG93IGEgTWF0ZXJpYWwgRGVzaWduIGFsZXJ0IGRpYWxvZy5cbiAgICAqICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydCh7XG4gICAgKiAgICBtZXNzYWdlOiAnSGVsbG8sIHdvcmxkIScsXG4gICAgKiAgICBtb2RpZmllcjogJ21hdGVyaWFsJ1xuICAgICogICB9KTtcbiAgICAqXG4gICAgKiAgIG9ucy5ub3RpZmljYXRpb24uY29uZmlybSh7XG4gICAgKiAgICAgbWVzc2FnZTogJ0FyZSB5b3UgcmVhZHk/JyxcbiAgICAqICAgICBjYWxsYmFjazogZnVuY3Rpb24oYW5zd2VyKSB7XG4gICAgKiAgICAgICAvLyBEbyBzb21ldGhpbmcgaGVyZS5cbiAgICAqICAgICB9XG4gICAgKiAgIH0pO1xuICAgICpcbiAgICAqICAgb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQoe1xuICAgICogICAgIG1lc3NhZ2U6ICdIb3cgb2xkIGFyZSB5b3U/JyxcbiAgICAqICAgICBjYWxsYmFjazogZnVuY3Rpb24oYWdlKSB7XG4gICAgKiAgICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KHtcbiAgICAqICAgICAgICAgbWVzc2FnZTogJ1lvdSBhcmUgJyArIGFnZSArICcgeWVhcnMgb2xkLidcbiAgICAqICAgICAgIH0pO1xuICAgICogICAgIH0pO1xuICAgICogICB9KTtcbiAgICAqIDwvc2NyaXB0PlxuICAgICovXG4gICB2YXIgbm90aWZpY2F0aW9uID0ge307XG5cbiAgIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cgPSBmdW5jdGlvbiAodGl0bGUsIG1lc3NhZ2UsIGJ1dHRvbkxhYmVscywgcHJpbWFyeUJ1dHRvbkluZGV4LCBtb2RpZmllciwgYW5pbWF0aW9uLCBpZCwgX2NhbGxiYWNrLCBtZXNzYWdlSXNIVE1MLCBjYW5jZWxhYmxlLCBwcm9tcHREaWFsb2csIGF1dG9mb2N1cywgcGxhY2Vob2xkZXIsIGRlZmF1bHRWYWx1ZSwgc3VibWl0T25FbnRlciwgY29tcGlsZSkge1xuXG4gICAgIGNvbXBpbGUgPSBjb21waWxlIHx8IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICB9O1xuXG4gICAgIHZhciB0aXRsZUVsZW1lbnRIVE1MID0gdHlwZW9mIHRpdGxlID09PSAnc3RyaW5nJyA/ICc8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+PC9kaXY+JyA6ICcnO1xuXG4gICAgIHZhciBkaWFsb2dFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KCdcXG4gIDxvbnMtYWxlcnQtZGlhbG9nPlxcbiAgICAnICsgdGl0bGVFbGVtZW50SFRNTCArICdcXG4gICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctZm9vdGVyXCI+PC9kaXY+XFxuICA8L29ucy1hbGVydC1kaWFsb2c+Jyk7XG5cbiAgICAgQ3VzdG9tRWxlbWVudHMudXBncmFkZShkaWFsb2dFbGVtZW50KTtcblxuICAgICBpZiAoaWQpIHtcbiAgICAgICBkaWFsb2dFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgIH1cblxuICAgICB2YXIgdGl0bGVFbGVtZW50ID0gZGlhbG9nRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuYWxlcnQtZGlhbG9nLXRpdGxlJyk7XG4gICAgIHZhciBtZXNzYWdlRWxlbWVudCA9IGRpYWxvZ0VsZW1lbnQucXVlcnlTZWxlY3RvcignLmFsZXJ0LWRpYWxvZy1jb250ZW50Jyk7XG4gICAgIHZhciBmb290ZXJFbGVtZW50ID0gZGlhbG9nRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuYWxlcnQtZGlhbG9nLWZvb3RlcicpO1xuICAgICB2YXIgaW5wdXRFbGVtZW50ID0gdW5kZWZpbmVkLFxuICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgcmVzdWx0LnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgcmVzdWx0LnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgIHJlc3VsdC5yZWplY3QgPSByZWplY3Q7XG4gICAgIH0pO1xuXG4gICAgIG1vZGlmaWVyID0gbW9kaWZpZXIgfHwgZGlhbG9nRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XG5cbiAgICAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICB0aXRsZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0aXRsZTtcbiAgICAgfVxuXG4gICAgIHRpdGxlRWxlbWVudCA9IG51bGw7XG5cbiAgICAgZGlhbG9nRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicsIGFuaW1hdGlvbik7XG5cbiAgICAgaWYgKG1lc3NhZ2VJc0hUTUwpIHtcbiAgICAgICBtZXNzYWdlRWxlbWVudC5pbm5lckhUTUwgPSBtZXNzYWdlO1xuICAgICB9IGVsc2Uge1xuICAgICAgIG1lc3NhZ2VFbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgfVxuXG4gICAgIGlmIChwcm9tcHREaWFsb2cpIHtcbiAgICAgICBpbnB1dEVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoJzxpbnB1dCBjbGFzcz1cInRleHQtaW5wdXRcIiB0eXBlPVwidGV4dFwiPjwvaW5wdXQ+Jyk7XG5cbiAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgIGlucHV0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWlucHV0LS0nICsgbW9kaWZpZXIpO1xuICAgICAgIH1cblxuICAgICAgIGlucHV0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgcGxhY2Vob2xkZXIpO1xuICAgICAgIGlucHV0RWxlbWVudC52YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICBpbnB1dEVsZW1lbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgaW5wdXRFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICcxMHB4JztcblxuICAgICAgIG1lc3NhZ2VFbGVtZW50LmFwcGVuZENoaWxkKGlucHV0RWxlbWVudCk7XG5cbiAgICAgICBpZiAoc3VibWl0T25FbnRlcikge1xuICAgICAgICAgaW5wdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgIGRpYWxvZ0VsZW1lbnQuaGlkZSh7XG4gICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICAgIF9jYWxsYmFjayhpbnB1dEVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZShpbnB1dEVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgICBkaWFsb2dFbGVtZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgZGlhbG9nRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICB9XG4gICAgIH1cblxuICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpYWxvZ0VsZW1lbnQpO1xuXG4gICAgIGNvbXBpbGUoZGlhbG9nRWxlbWVudCk7XG5cbiAgICAgaWYgKGJ1dHRvbkxhYmVscy5sZW5ndGggPD0gMikge1xuICAgICAgIGZvb3RlckVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLWZvb3Rlci0tb25lJyk7XG4gICAgIH1cblxuICAgICB2YXIgY3JlYXRlQnV0dG9uID0gZnVuY3Rpb24gY3JlYXRlQnV0dG9uKGkpIHtcbiAgICAgICB2YXIgYnV0dG9uRWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudCgnPGJ1dHRvbiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIj48L2J1dHRvbj4nKTtcbiAgICAgICBidXR0b25FbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGJ1dHRvbkxhYmVsc1tpXSkpO1xuXG4gICAgICAgaWYgKGkgPT0gcHJpbWFyeUJ1dHRvbkluZGV4KSB7XG4gICAgICAgICBidXR0b25FbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbCcpO1xuICAgICAgIH1cblxuICAgICAgIGlmIChidXR0b25MYWJlbHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgIGJ1dHRvbkVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tb25lJyk7XG4gICAgICAgfVxuXG4gICAgICAgdmFyIG9uQ2xpY2sgPSBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgICAgYnV0dG9uRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIGZhbHNlKTtcblxuICAgICAgICAgZGlhbG9nRWxlbWVudC5oaWRlKHtcbiAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgICAgICAgIGlmIChwcm9tcHREaWFsb2cpIHtcbiAgICAgICAgICAgICAgIF9jYWxsYmFjayhpbnB1dEVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoaW5wdXRFbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgX2NhbGxiYWNrKGkpO1xuICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoaSk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGRpYWxvZ0VsZW1lbnQuZGVzdHJveSgpO1xuICAgICAgICAgICAgIGRpYWxvZ0VsZW1lbnQgPSBpbnB1dEVsZW1lbnQgPSBidXR0b25FbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG4gICAgICAgfTtcblxuICAgICAgIGJ1dHRvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrLCBmYWxzZSk7XG4gICAgICAgZm9vdGVyRWxlbWVudC5hcHBlbmRDaGlsZChidXR0b25FbGVtZW50KTtcbiAgICAgfTtcblxuICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1dHRvbkxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgIGNyZWF0ZUJ1dHRvbihpKTtcbiAgICAgfVxuXG4gICAgIGlmIChjYW5jZWxhYmxlKSB7XG4gICAgICAgZGlhbG9nRWxlbWVudC5zZXRDYW5jZWxhYmxlKGNhbmNlbGFibGUpO1xuICAgICAgIGRpYWxvZ0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2FuY2VsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgaWYgKHByb21wdERpYWxvZykge1xuICAgICAgICAgICBfY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgIHJlc3VsdC5yZWplY3QobnVsbCk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBfY2FsbGJhY2soLTEpO1xuICAgICAgICAgICByZXN1bHQucmVqZWN0KC0xKTtcbiAgICAgICAgIH1cbiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICBkaWFsb2dFbGVtZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgZGlhbG9nRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgIGlucHV0RWxlbWVudCA9IG51bGw7XG4gICAgICAgICB9KTtcbiAgICAgICB9LCBmYWxzZSk7XG4gICAgIH1cblxuICAgICBkaWFsb2dFbGVtZW50LnNob3coe1xuICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgICAgIGlmIChpbnB1dEVsZW1lbnQgJiYgcHJvbXB0RGlhbG9nICYmIGF1dG9mb2N1cykge1xuICAgICAgICAgICBpbnB1dEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0pO1xuXG4gICAgIG1lc3NhZ2VFbGVtZW50ID0gZm9vdGVyRWxlbWVudCA9IG51bGw7XG5cbiAgICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICAgZGlhbG9nRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgJycpO1xuICAgICAgIGRpYWxvZ0VsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG1vZGlmaWVyKTtcbiAgICAgfVxuXG4gICAgIHJldHVybiByZXN1bHQucHJvbWlzZTtcbiAgIH07XG5cbiAgIG5vdGlmaWNhdGlvbi5fYWxlcnRPcmlnaW5hbCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZSA6IG9wdGlvbnMgPSBtZXNzYWdlO1xuXG4gICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICBidXR0b25MYWJlbDogJ09LJyxcbiAgICAgICBhbmltYXRpb246ICdkZWZhdWx0JyxcbiAgICAgICB0aXRsZTogJ0FsZXJ0JyxcbiAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soKSB7fVxuICAgICB9O1xuXG4gICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICBpZiAoIW9wdGlvbnMubWVzc2FnZSAmJiAhb3B0aW9ucy5tZXNzYWdlSFRNTCkge1xuICAgICAgIHRocm93IG5ldyBFcnJvcignQWxlcnQgZGlhbG9nIG11c3QgY29udGFpbiBhIG1lc3NhZ2UuJyk7XG4gICAgIH1cblxuICAgICByZXR1cm4gbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhvcHRpb25zLnRpdGxlLCBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5tZXNzYWdlSFRNTCwgW29wdGlvbnMuYnV0dG9uTGFiZWxdLCAwLCBvcHRpb25zLm1vZGlmaWVyLCBvcHRpb25zLmFuaW1hdGlvbiwgb3B0aW9ucy5pZCwgb3B0aW9ucy5jYWxsYmFjaywgIW9wdGlvbnMubWVzc2FnZSA/IHRydWUgOiBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJycsICcnLCBmYWxzZSwgb3B0aW9ucy5jb21waWxlKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQG1ldGhvZCBhbGVydChvcHRpb25zKVxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZV1cbiAgICAqICAgW2VuXUFsZXJ0IG1lc3NhZ2UuWy9lbl1cbiAgICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi+aWh+Wtl+WIl+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZUhUTUxdXG4gICAgKiAgIFtlbl1BbGVydCBtZXNzYWdlIGluIEhUTUwuWy9lbl1cbiAgICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi0hUTUzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJ1dHRvbkxhYmVsXVxuICAgICogICBbZW5dTGFiZWwgZm9yIGNvbmZpcm1hdGlvbiBidXR0b24uIERlZmF1bHQgaXMgXCJPS1wiLlsvZW5dXG4gICAgKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIk9LXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJub25lXCIsIFwiZmFkZVwiIGFuZCBcInNsaWRlXCIuWy9lbl1cbiAgICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAgICAqICAgW2VuXW9ucy1hbGVydC1kaWFsb2cgZWxlbWVudCdzIElELlsvZW5dXG4gICAgKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n6KaB57Sg44GuSUTjgIJbL2phXVxuICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpdGxlXVxuICAgICogICBbZW5dRGlhbG9nIHRpdGxlLiBEZWZhdWx0IGlzIFwiQWxlcnRcIi5bL2VuXVxuICAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu5LiK6YOo44Gr6KGo56S644GZ44KL44K/44Kk44OI44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJBbGVydFwi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cbiAgICAqICAgW2VuXU1vZGlmaWVyIGZvciB0aGUgZGlhbG9nLlsvZW5dXG4gICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga5tb2RpZmllcuWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgZGlhbG9nIGhhcyBiZWVuIGNsb3NlZC5bL2VuXVxuICAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44KJ44KM44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dXG4gICAgKiAgICAgRGlzcGxheSBhbiBhbGVydCBkaWFsb2cgdG8gc2hvdyB0aGUgdXNlciBhIG1lc3NhZ2UuXG4gICAgKiAgICAgVGhlIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UgY2FuIGJlIGVpdGhlciBzaW1wbGUgdGV4dCBvciBIVE1MLlxuICAgICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgbWVzc2FnZSBvciBtZXNzYWdlSFRNTC5cbiAgICAqICAgWy9lbl1cbiAgICAqICAgW2phXVxuICAgICogICAgIOODpuODvOOCtuODvOOBuOODoeODg+OCu+ODvOOCuOOCkuimi+OBm+OCi+OBn+OCgeOBruOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICAgICogICAgIOihqOekuuOBmeOCi+ODoeODg+OCu+ODvOOCuOOBr+OAgeODhuOCreOCueODiOOBi+OCguOBl+OBj+OBr0hUTUzjgpLmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gICAgKiAgIFsvamFdXG4gICAgKi9cbiAgIG5vdGlmaWNhdGlvbi5hbGVydCA9IG5vdGlmaWNhdGlvbi5fYWxlcnRPcmlnaW5hbDtcblxuICAgbm90aWZpY2F0aW9uLl9jb25maXJtT3JpZ2luYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgYnV0dG9uTGFiZWxzOiBbJ0NhbmNlbCcsICdPSyddLFxuICAgICAgIHByaW1hcnlCdXR0b25JbmRleDogMSxcbiAgICAgICBhbmltYXRpb246ICdkZWZhdWx0JyxcbiAgICAgICB0aXRsZTogJ0NvbmZpcm0nLFxuICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjaygpIHt9LFxuICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgIH07XG5cbiAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgaWYgKCFvcHRpb25zLm1lc3NhZ2UgJiYgIW9wdGlvbnMubWVzc2FnZUhUTUwpIHtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpcm0gZGlhbG9nIG11c3QgY29udGFpbiBhIG1lc3NhZ2UuJyk7XG4gICAgIH1cblxuICAgICByZXR1cm4gbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhvcHRpb25zLnRpdGxlLCBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5tZXNzYWdlSFRNTCwgb3B0aW9ucy5idXR0b25MYWJlbHMsIG9wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4LCBvcHRpb25zLm1vZGlmaWVyLCBvcHRpb25zLmFuaW1hdGlvbiwgb3B0aW9ucy5pZCwgb3B0aW9ucy5jYWxsYmFjaywgIW9wdGlvbnMubWVzc2FnZSA/IHRydWUgOiBmYWxzZSwgb3B0aW9ucy5jYW5jZWxhYmxlLCBmYWxzZSwgZmFsc2UsICcnLCAnJywgZmFsc2UsIG9wdGlvbnMuY29tcGlsZSk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBtZXRob2QgY29uZmlybVxuICAgICogQHNpZ25hdHVyZSBjb25maXJtKG9wdGlvbnMpXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VdXG4gICAgKiAgIFtlbl1Db25maXJtYXRpb24gcXVlc3Rpb24uWy9lbl1cbiAgICAqICAgW2phXeeiuuiqjeODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi+ODoeODg+OCu+ODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZUhUTUxdXG4gICAgKiAgIFtlbl1EaWFsb2cgY29udGVudCBpbiBIVE1MLlsvZW5dXG4gICAgKiAgIFtqYV3norroqo3jg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgotIVE1M44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmJ1dHRvbkxhYmVsc11cbiAgICAqICAgW2VuXUxhYmVscyBmb3IgdGhlIGJ1dHRvbnMuIERlZmF1bHQgaXMgW1wiQ2FuY2VsXCIsIFwiT0tcIl0uWy9lbl1cbiAgICAqICAgW2phXeODnOOCv+ODs+OBruODqeODmeODq+OBrumFjeWIl+OCkuaMh+WumuOBl+OBvuOBmeOAgltcIkNhbmNlbFwiLCBcIk9LXCJd44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXhdXG4gICAgKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyAxLlsvZW5dXG4gICAgKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMSDjgafjgZnjgIJbL2phXVxuICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxhYmxlXVxuICAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBEZWZhdWx0IGlzIGZhbHNlLlsvZW5dXG4gICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJub25lXCIsIFwiZmFkZVwiIGFuZCBcInNsaWRlXCIuWy9lbl1cbiAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJzbGlkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAgICAqICAgW2VuXW9ucy1hbGVydC1kaWFsb2cgZWxlbWVudCdzIElELlsvZW5dXG4gICAgKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n6KaB57Sg44GuSUTjgIJbL2phXVxuICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpdGxlXVxuICAgICogICBbZW5dRGlhbG9nIHRpdGxlLiBEZWZhdWx0IGlzIFwiQ29uZmlybVwiLlsvZW5dXG4gICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgr/jgqTjg4jjg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIkNvbmZpcm1cIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubW9kaWZpZXJdXG4gICAgKiAgIFtlbl1Nb2RpZmllciBmb3IgdGhlIGRpYWxvZy5bL2VuXVxuICAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GubW9kaWZpZXLlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAgKiAgIFtlbl1cbiAgICAqICAgICBGdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gY2xvc2VkLlxuICAgICogICAgIEFyZ3VtZW50IGZvciB0aGUgZnVuY3Rpb24gaXMgdGhlIGluZGV4IG9mIHRoZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZCBvciAtMSBpZiB0aGUgZGlhbG9nIHdhcyBjYW5jZWxlZC5cbiAgICAqICAgWy9lbl1cbiAgICAqICAgW2phXVxuICAgICogICAgIOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgICogICAgIOOBk+OBrumWouaVsOOBruW8leaVsOOBqOOBl+OBpuOAgeaKvOOBleOCjOOBn+ODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueWApOOBjOa4oeOBleOCjOOBvuOBmeOAglxuICAgICogICAgIOOCguOBl+ODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBn+WgtOWQiOOBq+OBry0x44GM5rih44GV44KM44G+44GZ44CCXG4gICAgKiAgIFsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXVxuICAgICogICAgIERpc3BsYXkgYSBkaWFsb2cgdG8gYXNrIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb24uXG4gICAgKiAgICAgVGhlIGRlZmF1bHQgYnV0dG9uIGxhYmVscyBhcmUgXCJDYW5jZWxcIiBhbmQgXCJPS1wiIGJ1dCB0aGV5IGNhbiBiZSBjdXN0b21pemVkLlxuICAgICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgbWVzc2FnZSBvciBtZXNzYWdlSFRNTC5cbiAgICAqICAgWy9lbl1cbiAgICAqICAgW2phXVxuICAgICogICAgIOODpuODvOOCtuOBq+eiuuiqjeOCkuS/g+OBmeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICAgICogICAgIOODh+OCquODq+OBqOOBruODnOOCv+ODs+ODqeODmeODq+OBr+OAgVwiQ2FuY2VsXCLjgahcIk9LXCLjgafjgZnjgYzjgIHjgZPjgozjga/jgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgafjgqvjgrnjgr/jg57jgqTjgrrjgafjgY3jgb7jgZnjgIJcbiAgICAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gICAgKiAgIFsvamFdXG4gICAgKi9cbiAgIG5vdGlmaWNhdGlvbi5jb25maXJtID0gbm90aWZpY2F0aW9uLl9jb25maXJtT3JpZ2luYWw7XG5cbiAgIG5vdGlmaWNhdGlvbi5fcHJvbXB0T3JpZ2luYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgYnV0dG9uTGFiZWw6ICdPSycsXG4gICAgICAgYW5pbWF0aW9uOiAnZGVmYXVsdCcsXG4gICAgICAgdGl0bGU6ICdBbGVydCcsXG4gICAgICAgZGVmYXVsdFZhbHVlOiAnJyxcbiAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKCkge30sXG4gICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgYXV0b2ZvY3VzOiB0cnVlLFxuICAgICAgIHN1Ym1pdE9uRW50ZXI6IHRydWVcbiAgICAgfTtcblxuICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgaWYgKCFvcHRpb25zLm1lc3NhZ2UgJiYgIW9wdGlvbnMubWVzc2FnZUhUTUwpIHtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb21wdCBkaWFsb2cgbXVzdCBjb250YWluIGEgbWVzc2FnZS4nKTtcbiAgICAgfVxuXG4gICAgIHJldHVybiBub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nKG9wdGlvbnMudGl0bGUsIG9wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLm1lc3NhZ2VIVE1MLCBbb3B0aW9ucy5idXR0b25MYWJlbF0sIDAsIG9wdGlvbnMubW9kaWZpZXIsIG9wdGlvbnMuYW5pbWF0aW9uLCBvcHRpb25zLmlkLCBvcHRpb25zLmNhbGxiYWNrLCAhb3B0aW9ucy5tZXNzYWdlID8gdHJ1ZSA6IGZhbHNlLCBvcHRpb25zLmNhbmNlbGFibGUsIHRydWUsIG9wdGlvbnMuYXV0b2ZvY3VzLCBvcHRpb25zLnBsYWNlaG9sZGVyLCBvcHRpb25zLmRlZmF1bHRWYWx1ZSwgb3B0aW9ucy5zdWJtaXRPbkVudGVyLCBvcHRpb25zLmNvbXBpbGUpO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAbWV0aG9kIHByb21wdFxuICAgICogQHNpZ25hdHVyZSBwcm9tcHQob3B0aW9ucylcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlXVxuICAgICogICBbZW5dUHJvbXB0IHF1ZXN0aW9uLlsvZW5dXG4gICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgovjg6Hjg4Pjgrvjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VIVE1MXVxuICAgICogICBbZW5dRGlhbG9nIGNvbnRlbnQgaW4gSFRNTC5bL2VuXVxuICAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KLSFRNTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYnV0dG9uTGFiZWxdXG4gICAgKiAgIFtlbl1MYWJlbCBmb3IgY29uZmlybWF0aW9uIGJ1dHRvbi4gRGVmYXVsdCBpcyBcIk9LXCIuWy9lbl1cbiAgICAqICAgW2phXeeiuuiqjeODnOOCv+ODs+OBruODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiT0tcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICAgICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgMS5bL2VuXVxuICAgICogICBbamFd44OX44Op44Kk44Oe44Oq44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIDEg44Gn44GZ44CCWy9qYV1cbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2FuY2VsYWJsZV1cbiAgICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gRGVmYXVsdCBpcyBmYWxzZS5bL2VuXVxuICAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM44Kt44Oj44Oz44K744Or5Y+v6IO944GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIGZhbHNlIOOBp+OBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBcIm5vbmVcIiwgXCJmYWRlXCIgYW5kIFwic2xpZGVcIi5bL2VuXVxuICAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXVxuICAgICogICBbZW5db25zLWFsZXJ0LWRpYWxvZyBlbGVtZW50J3MgSUQuWy9lbl1cbiAgICAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5JROOAglsvamFdXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gICAgKiAgIFtlbl1EaWFsb2cgdGl0bGUuIERlZmF1bHQgaXMgXCJBbGVydFwiLlsvZW5dXG4gICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgr/jgqTjg4jjg6vjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gXCJBbGVydFwiIOOBp+OBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGxhY2Vob2xkZXJdXG4gICAgKiAgIFtlbl1QbGFjZWhvbGRlciBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAgICAqICAgW2phXeODhuOCreOCueODiOashOOBruODl+ODrOODvOOCueODm+ODq+ODgOOBq+ihqOekuuOBmeOCi+ODhuOCreOCueODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGVmYXVsdFZhbHVlXVxuICAgICogICBbZW5dRGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAgICAqICAgW2phXeODhuOCreOCueODiOashOOBruODh+ODleOCqeODq+ODiOOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9mb2N1c11cbiAgICAqICAgW2VuXUF1dG9mb2N1cyB0aGUgaW5wdXQgZWxlbWVudC4gRGVmYXVsdCBpcyB0cnVlLlsvZW5dXG4gICAgKiAgIFtqYV1pbnB1dOimgee0oOOBq+iHquWLleeahOOBq+ODleOCqeODvOOCq+OCueOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr3RydWXjgafjgZnjgIJbL2phXVxuICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZGlmaWVyXVxuICAgICogICBbZW5dTW9kaWZpZXIgZm9yIHRoZSBkaWFsb2cuWy9lbl1cbiAgICAqICAgW2phXeODgOOCpOOCouODreOCsOOBrm1vZGlmaWVy5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgICogICBbZW5dXG4gICAgKiAgICAgRnVuY3Rpb24gdGhhdCBleGVjdXRlcyBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIGNsb3NlZC5cbiAgICAqICAgICBBcmd1bWVudCBmb3IgdGhlIGZ1bmN0aW9uIGlzIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgZmllbGQgb3IgbnVsbCBpZiB0aGUgZGlhbG9nIHdhcyBjYW5jZWxlZC5cbiAgICAqICAgWy9lbl1cbiAgICAqICAgW2phXVxuICAgICogICAgIOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+W+jOOBq+Wun+ihjOOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgICogICAgIOmWouaVsOOBruW8leaVsOOBqOOBl+OBpuOAgeOCpOODs+ODl+ODg+ODiOimgee0oOOBruS4reOBruWApOOBjOa4oeOBleOCjOOBvuOBmeOAguODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBn+WgtOWQiOOBq+OBr+OAgW51bGzjgYzmuKHjgZXjgozjgb7jgZnjgIJcbiAgICAqICAgWy9qYV1cbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3VibWl0T25FbnRlcl1cbiAgICAqICAgW2VuXVN1Ym1pdCBhdXRvbWF0aWNhbGx5IHdoZW4gZW50ZXIgaXMgcHJlc3NlZC4gRGVmYXVsdCBpcyBcInRydWVcIi5bL2VuXVxuICAgICogICBbamFdRW50ZXLjgYzmirzjgZXjgozjgZ/pmpvjgavjgZ3jga5mb3Jt44KSc3VibWl044GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvdHJ1ZeOBp+OBmeOAglsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXVxuICAgICogICAgIERpc3BsYXkgYSBkaWFsb2cgd2l0aCBhIHByb21wdCB0byBhc2sgdGhlIHVzZXIgYSBxdWVzdGlvbi5cbiAgICAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIG1lc3NhZ2Ugb3IgbWVzc2FnZUhUTUwuXG4gICAgKiAgIFsvZW5dXG4gICAgKiAgIFtqYV1cbiAgICAqICAgICDjg6bjg7zjgrbjg7zjgavlhaXlipvjgpLkv4PjgZnjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAgICAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gICAgKiAgIFsvamFdXG4gICAgKi9cbiAgIG5vdGlmaWNhdGlvbi5wcm9tcHQgPSBub3RpZmljYXRpb24uX3Byb21wdE9yaWdpbmFsO1xuXG4gICB2YXIgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gPSB7XG4gICAgIF92YXJpYWJsZXM6IHt9LFxuXG4gICAgIC8qKlxuICAgICAgKiBEZWZpbmUgYSB2YXJpYWJsZS5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGVcbiAgICAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHZhbHVlIFZhbHVlIG9mIHRoZSB2YXJpYWJsZS4gQ2FuIGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHN0cmluZy5cbiAgICAgICogQHBhcmFtIHtCb29sZWFufSBvdmVyd3JpdGUgSWYgdGhpcyB2YWx1ZSBpcyBmYWxzZSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gd2hlbiB0cnlpbmcgdG8gZGVmaW5lIGEgdmFyaWFibGUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXG4gICAgICAqL1xuICAgICBkZWZpbmVWYXJpYWJsZTogZnVuY3Rpb24gZGVmaW5lVmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICB2YXIgb3ZlcndyaXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcmlhYmxlIG5hbWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcmlhYmxlIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbi4nKTtcbiAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG5hbWUgKyAnXCIgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgICAgIH1cbiAgICAgICB0aGlzLl92YXJpYWJsZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogR2V0IGEgdmFyaWFibGUuXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmlhYmxlLlxuICAgICAgKiBAcmV0dXJuIHtTdHJpbmd8RnVuY3Rpb258bnVsbH1cbiAgICAgICovXG4gICAgIGdldFZhcmlhYmxlOiBmdW5jdGlvbiBnZXRWYXJpYWJsZShuYW1lKSB7XG4gICAgICAgaWYgKCF0aGlzLl92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXNbbmFtZV07XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIFJlbW92ZSBhIHZhcmlhYmxlLlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSB2YXJhaWJsZS5cbiAgICAgICovXG4gICAgIHJlbW92ZVZhcmlhYmxlOiBmdW5jdGlvbiByZW1vdmVWYXJpYWJsZShuYW1lKSB7XG4gICAgICAgZGVsZXRlIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogR2V0IGFsbCB2YXJpYWJsZXMuXG4gICAgICAqXG4gICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICovXG4gICAgIGdldEFsbFZhcmlhYmxlczogZnVuY3Rpb24gZ2V0QWxsVmFyaWFibGVzKCkge1xuICAgICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXM7XG4gICAgIH0sXG4gICAgIF9wYXJzZVBhcnQ6IGZ1bmN0aW9uIF9wYXJzZVBhcnQocGFydCkge1xuICAgICAgIHZhciBjID0gdW5kZWZpbmVkLFxuICAgICAgICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZSxcbiAgICAgICAgICAgY3VycmVudEluZGV4ID0gMCxcbiAgICAgICAgICAgdG9rZW5zID0gW107XG5cbiAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIGVtcHR5IHN0cmluZy4nKTtcbiAgICAgICB9XG5cbiAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIGMgPSBwYXJ0LmNoYXJBdChpKTtcblxuICAgICAgICAgaWYgKGMgPT09ICckJyAmJiBwYXJ0LmNoYXJBdChpICsgMSkgPT09ICd7Jykge1xuICAgICAgICAgICBpZiAoaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXN0ZWQgaW50ZXJwb2xhdGlvbiBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgdmFyIHRva2VuID0gcGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpKTtcbiAgICAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICB0b2tlbnMucHVzaChwYXJ0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIGkpKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGk7XG4gICAgICAgICAgIGluSW50ZXJwb2xhdGlvbiA9IHRydWU7XG4gICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICd9Jykge1xuICAgICAgICAgICBpZiAoIWluSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignfSBtdXN0IGJlIHByZWNlZWRlZCBieSAkeycpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgdmFyIHRva2VuID0gcGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpICsgMSk7XG4gICAgICAgICAgIGlmICh0b2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpICsgMSkpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgY3VycmVudEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgIGluSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIGlmIChpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW50ZXJtaW5hdGVkIGludGVycG9sYXRpb24uJyk7XG4gICAgICAgfVxuXG4gICAgICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBwYXJ0Lmxlbmd0aCkpO1xuXG4gICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgfSxcbiAgICAgX3JlcGxhY2VUb2tlbjogZnVuY3Rpb24gX3JlcGxhY2VUb2tlbih0b2tlbikge1xuICAgICAgIHZhciByZSA9IC9eXFwkeyguKj8pfSQvLFxuICAgICAgICAgICBtYXRjaCA9IHRva2VuLm1hdGNoKHJlKTtcblxuICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgdmFyIG5hbWUgPSBtYXRjaFsxXS50cmltKCksXG4gICAgICAgICAgICAgdmFyaWFibGUgPSB0aGlzLmdldFZhcmlhYmxlKG5hbWUpO1xuXG4gICAgICAgICBpZiAodmFyaWFibGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYXJpYWJsZSBcIicgKyBuYW1lICsgJ1wiIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFyaWFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHZhciBydiA9IHZhcmlhYmxlKCk7XG5cbiAgICAgICAgICAgaWYgKHR5cGVvZiBydiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcmV0dXJuIGEgc3RyaW5nLicpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgICAgfVxuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgfVxuICAgICB9LFxuICAgICBfcmVwbGFjZVRva2VuczogZnVuY3Rpb24gX3JlcGxhY2VUb2tlbnModG9rZW5zKSB7XG4gICAgICAgcmV0dXJuIHRva2Vucy5tYXAodGhpcy5fcmVwbGFjZVRva2VuLmJpbmQodGhpcykpO1xuICAgICB9LFxuICAgICBfcGFyc2VFeHByZXNzaW9uOiBmdW5jdGlvbiBfcGFyc2VFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgcmV0dXJuIHBhcnQudHJpbSgpO1xuICAgICAgIH0pLm1hcCh0aGlzLl9wYXJzZVBhcnQuYmluZCh0aGlzKSkubWFwKHRoaXMuX3JlcGxhY2VUb2tlbnMuYmluZCh0aGlzKSkubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICByZXR1cm4gcGFydC5qb2luKCcnKTtcbiAgICAgICB9KTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogRXZhbHVhdGUgYW4gZXhwcmVzc2lvbi5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb24gQW4gcGFnZSBhdHRyaWJ1dGUgZXhwcmVzc2lvbi5cbiAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAqL1xuICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUoZXhwcmVzc2lvbikge1xuICAgICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgIH1cbiAgIH07XG5cbiAgIC8vIERlZmluZSBkZWZhdWx0IHZhcmlhYmxlcy5cbiAgIHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmRlZmluZVZhcmlhYmxlKCdtb2JpbGVPUycsIHBsYXRmb3JtLmdldE1vYmlsZU9TKCkpO1xuICAgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ2lPU0RldmljZScsIHBsYXRmb3JtLmdldElPU0RldmljZSgpKTtcbiAgIHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmRlZmluZVZhcmlhYmxlKCdydW50aW1lJywgZnVuY3Rpb24gKCkge1xuICAgICByZXR1cm4gcGxhdGZvcm0uaXNXZWJWaWV3KCkgPyAnY29yZG92YScgOiAnYnJvd3Nlcic7XG4gICB9KTtcblxuICAgdmFyIGludGVybmFsID0ge307XG5cbiAgIGludGVybmFsLmNvbmZpZyA9IHtcbiAgICAgYXV0b1N0YXR1c0JhckZpbGw6IHRydWUsXG4gICAgIGFuaW1hdGlvbnNEaXNhYmxlZDogZmFsc2VcbiAgIH07XG5cbiAgIGludGVybmFsLm51bGxFbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAvKipcbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgKi9cbiAgIGludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsID0gZnVuY3Rpb24gKCkge1xuICAgICByZXR1cm4gISFpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGw7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgKi9cbiAgIGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgaHRtbCA9ICgnJyArIGh0bWwpLnRyaW0oKTtcblxuICAgICBpZiAoIWh0bWwubWF0Y2goL148b25zLXBhZ2UvKSkge1xuICAgICAgIGh0bWwgPSAnPG9ucy1wYWdlIF9tdXRlZD4nICsgaHRtbCArICc8L29ucy1wYWdlPic7XG4gICAgIH1cblxuICAgICByZXR1cm4gaHRtbDtcbiAgIH07XG5cbiAgIGludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgIGlmICh3aW5kb3cuZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IHdpbmRvdy5kb2N1bWVudC5yZWFkeVN0YXRlID09ICd1bmluaXRpYWxpemVkJykge1xuICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2FsbGJhY2spO1xuICAgICB9IGVsc2Uge1xuICAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAqL1xuICAgaW50ZXJuYWwuc2hvdWxkRmlsbFN0YXR1c0JhciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgIHZhciBjaGVja1N0YXR1c0JhciA9IGZ1bmN0aW9uIGNoZWNrU3RhdHVzQmFyKCkge1xuICAgICAgIGlmIChpbnRlcm5hbC5pc0VuYWJsZWRBdXRvU3RhdHVzQmFyRmlsbCgpICYmIHBsYXRmb3JtLmlzV2ViVmlldygpICYmIHBsYXRmb3JtLmlzSU9TN2Fib3ZlKCkpIHtcbiAgICAgICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQnKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ25vLXN0YXR1cy1iYXItZmlsbCcpKSB7XG4gICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSkge1xuICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgfTtcblxuICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgIGlmICgodHlwZW9mIGRldmljZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IGJhYmVsSGVscGVycy50eXBlb2YoZGV2aWNlKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgaWYgKGNoZWNrU3RhdHVzQmFyKCkpIHtcbiAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuICAgICAgIH0gZWxzZSBpZiAoY2hlY2tTdGF0dXNCYXIoKSkge1xuICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgIH1cbiAgICAgICByZWplY3QoKTtcbiAgICAgfSk7XG4gICB9O1xuXG4gICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlID0ge1xuICAgICBfc3RvcmFnZToge30sXG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgICogQHJldHVybiB7U3RyaW5nL251bGx9IHRlbXBsYXRlXG4gICAgICAqL1xuICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICByZXR1cm4gaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5fc3RvcmFnZVtrZXldIHx8IG51bGw7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gICAgICAqL1xuICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHRlbXBsYXRlKSB7XG4gICAgICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5fc3RvcmFnZVtrZXldID0gdGVtcGxhdGU7XG4gICAgIH1cbiAgIH07XG5cbiAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdfdGVtcGxhdGVsb2FkZWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICBpZiAoZS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10ZW1wbGF0ZScpIHtcbiAgICAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldChlLnRlbXBsYXRlSWQsIGUudGVtcGxhdGUpO1xuICAgICB9XG4gICB9LCBmYWxzZSk7XG5cbiAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICByZWdpc3Rlcignc2NyaXB0W3R5cGU9XCJ0ZXh0L29ucy10ZW1wbGF0ZVwiXScpO1xuICAgICByZWdpc3Rlcignc2NyaXB0W3R5cGU9XCJ0ZXh0L3RlbXBsYXRlXCJdJyk7XG4gICAgIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvbmctdGVtcGxhdGVcIl0nKTtcblxuICAgICBmdW5jdGlvbiByZWdpc3RlcihxdWVyeSkge1xuICAgICAgIHZhciB0ZW1wbGF0ZXMgPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChxdWVyeSk7XG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wbGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuc2V0KHRlbXBsYXRlc1tpXS5nZXRBdHRyaWJ1dGUoJ2lkJyksIHRlbXBsYXRlc1tpXS50ZXh0Q29udGVudCk7XG4gICAgICAgfVxuICAgICB9XG4gICB9LCBmYWxzZSk7XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgIGludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jID0gZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgdmFyIGNhY2hlID0gaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5nZXQocGFnZSk7XG5cbiAgICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICB2YXIgaHRtbCA9IHR5cGVvZiBjYWNoZSA9PT0gJ3N0cmluZycgPyBjYWNoZSA6IGNhY2hlWzFdO1xuICAgICAgICAgICByZXNvbHZlKGh0bWwpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhZ2UsIHRydWUpO1xuICAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgIHZhciBodG1sID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDQwMCAmJiB4aHIuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgIHJlamVjdChodG1sKTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIHJlc29sdmUoaHRtbCk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhZ2UgaXMgbm90IGZvdW5kOiAnICsgcGFnZSk7XG4gICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICAgfSkoKTtcbiAgICAgICAgIH1cbiAgICAgICB9KTtcbiAgICAgfSk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jID0gZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICAgdmFyIHBhZ2VzID0gcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZXZhbHVhdGUocGFnZSk7XG5cbiAgICAgdmFyIGdldFBhZ2UgPSBmdW5jdGlvbiBnZXRQYWdlKHBhZ2UpIHtcbiAgICAgICBpZiAodHlwZW9mIHBhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ011c3Qgc3BlY2lmeSBhIHBhZ2UuJyk7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIGludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgIHJldHVybiBpbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTChodG1sKTtcbiAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgIGlmIChwYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIGdldFBhZ2UocGFnZXMuc2hpZnQoKSk7XG4gICAgICAgfSkudGhlbihmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgcmV0dXJuIGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKGh0bWwpO1xuICAgICAgIH0pO1xuICAgICB9O1xuXG4gICAgIHJldHVybiBnZXRQYWdlKHBhZ2VzLnNoaWZ0KCkpO1xuICAgfTtcblxuICAgdmFyIEFuaW1hdG9yRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmFuaW1hdG9ycyBUaGUgZGljdGlvbmFyeSBmb3IgYW5pbWF0b3IgY2xhc3Nlc1xuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLmJhc2VDbGFzcyBUaGUgYmFzZSBjbGFzcyBvZiBhbmltYXRvcnNcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmJhc2VDbGFzc05hbWVdIFRoZSBuYW1lIG9mIHRoZSBiYXNlIGNsYXNzIG9mIGFuaW1hdG9yc1xuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMuZGVmYXVsdEFuaW1hdGlvbl0gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIG5hbWVcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmRlZmF1bHRBbmltYXRpb25PcHRpb25zXSBUaGUgZGVmYXVsdCBhbmltYXRpb24gb3B0aW9uc1xuICAgICAgKi9cblxuICAgICBmdW5jdGlvbiBBbmltYXRvckZhY3Rvcnkob3B0cykge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBBbmltYXRvckZhY3RvcnkpO1xuXG4gICAgICAgdGhpcy5fYW5pbWF0b3JzID0gb3B0cy5hbmltYXRvcnM7XG4gICAgICAgdGhpcy5fYmFzZUNsYXNzID0gb3B0cy5iYXNlQ2xhc3M7XG4gICAgICAgdGhpcy5fYmFzZUNsYXNzTmFtZSA9IG9wdHMuYmFzZUNsYXNzTmFtZSB8fCBvcHRzLmJhc2VDbGFzcy5uYW1lO1xuICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IG9wdHMuZGVmYXVsdEFuaW1hdGlvbiB8fCAnZGVmYXVsdCc7XG4gICAgICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyA9IG9wdHMuZGVmYXVsdEFuaW1hdGlvbk9wdGlvbnMgfHwge307XG5cbiAgICAgICBpZiAoIXRoaXMuX2FuaW1hdG9yc1t0aGlzLl9hbmltYXRpb25dKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1Y2ggYW5pbWF0aW9uOiAnICsgdGhpcy5fYW5pbWF0aW9uKTtcbiAgICAgICB9XG4gICAgIH1cblxuICAgICAvKipcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGpzb25TdHJpbmdcbiAgICAgICogQHJldHVybiB7T2JqZWN0L251bGx9XG4gICAgICAqL1xuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhBbmltYXRvckZhY3RvcnksIFt7XG4gICAgICAga2V5OiAnc2V0QW5pbWF0aW9uT3B0aW9ucycsXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAqL1xuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgIHRoaXMuX2FuaW1hdGlvbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl0gVGhlIGFuaW1hdGlvbiBuYW1lXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdIFRoZSBhbmltYXRpb24gb3B0aW9uc1xuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0QW5pbWF0b3IgVGhlIGRlZmF1bHQgYW5pbWF0b3IgaW5zdGFuY2VcbiAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGFuaW1hdG9yIGluc3RhbmNlXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ25ld0FuaW1hdG9yJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gbmV3QW5pbWF0b3IoKSB7XG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgICAgICAgdmFyIGRlZmF1bHRBbmltYXRvciA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgdmFyIGFuaW1hdG9yID0gbnVsbDtcblxuICAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uIGluc3RhbmNlb2YgdGhpcy5fYmFzZUNsYXNzKSB7XG4gICAgICAgICAgIHJldHVybiBvcHRpb25zLmFuaW1hdGlvbjtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIEFuaW1hdG9yID0gbnVsbDtcblxuICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmFuaW1hdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgQW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvcnNbb3B0aW9ucy5hbmltYXRpb25dO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAoIUFuaW1hdG9yICYmIGRlZmF1bHRBbmltYXRvcikge1xuICAgICAgICAgICBhbmltYXRvciA9IGRlZmF1bHRBbmltYXRvcjtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIEFuaW1hdG9yID0gQW5pbWF0b3IgfHwgdGhpcy5fYW5pbWF0b3JzW3RoaXMuX2FuaW1hdGlvbl07XG5cbiAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9wdHMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucywgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LCBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID8geyBkdXJhdGlvbjogMCwgZGVsYXk6IDAgfSA6IHt9KTtcblxuICAgICAgICAgICBhbmltYXRvciA9IG5ldyBBbmltYXRvcihhbmltYXRpb25PcHRzKTtcblxuICAgICAgICAgICBpZiAodHlwZW9mIGFuaW1hdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgYW5pbWF0b3IgPSBuZXcgYW5pbWF0b3IoYW5pbWF0aW9uT3B0cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICghKGFuaW1hdG9yIGluc3RhbmNlb2YgdGhpcy5fYmFzZUNsYXNzKSkge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiYW5pbWF0b3JcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgJyArIHRoaXMuX2Jhc2VDbGFzc05hbWUgKyAnLicpO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gYW5pbWF0b3I7XG4gICAgICAgfVxuICAgICB9XSwgW3tcbiAgICAgICBrZXk6ICdwYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcoanNvblN0cmluZykge1xuICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgIHZhciByZXN1bHQgPSB1dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZShqc29uU3RyaW5nKTtcbiAgICAgICAgICAgICBpZiAoKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBiYWJlbEhlbHBlcnMudHlwZW9mKHJlc3VsdCkpID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xuICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBBbmltYXRvckZhY3Rvcnk7XG4gICB9KSgpO1xuXG4gICAvKlxuICAgQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG4gICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gICAqL1xuXG4gICB2YXIgTW9kaWZpZXJVdGlsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgZnVuY3Rpb24gTW9kaWZpZXJVdGlsKCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RpZmllclV0aWwpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKE1vZGlmaWVyVXRpbCwgbnVsbCwgW3tcbiAgICAgICBrZXk6ICdkaWZmJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYXN0XG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRcbiAgICAgICAgKi9cbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlmZihsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgICBsYXN0ID0gbWFrZURpY3QoKCcnICsgbGFzdCkudHJpbSgpKTtcbiAgICAgICAgIGN1cnJlbnQgPSBtYWtlRGljdCgoJycgKyBjdXJyZW50KS50cmltKCkpO1xuXG4gICAgICAgICB2YXIgcmVtb3ZlZCA9IE9iamVjdC5rZXlzKGxhc3QpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCB0b2tlbikge1xuICAgICAgICAgICBpZiAoIWN1cnJlbnRbdG9rZW5dKSB7XG4gICAgICAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgIHZhciBhZGRlZCA9IE9iamVjdC5rZXlzKGN1cnJlbnQpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCB0b2tlbikge1xuICAgICAgICAgICBpZiAoIWxhc3RbdG9rZW5dKSB7XG4gICAgICAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgIHJldHVybiB7IGFkZGVkOiBhZGRlZCwgcmVtb3ZlZDogcmVtb3ZlZCB9O1xuXG4gICAgICAgICBmdW5jdGlvbiBtYWtlRGljdChtb2RpZmllcikge1xuICAgICAgICAgICB2YXIgZGljdCA9IHt9O1xuICAgICAgICAgICBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgcmV0dXJuIGRpY3RbdG9rZW5dID0gdG9rZW47XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICByZXR1cm4gZGljdDtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGlmZlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjbGFzc0xpc3RcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXBwbHlEaWZmVG9DbGFzc0xpc3QnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseURpZmZUb0NsYXNzTGlzdChkaWZmLCBjbGFzc0xpc3QsIHRlbXBsYXRlKSB7XG4gICAgICAgICBkaWZmLmFkZGVkLm1hcChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xcKi9nLCBtb2RpZmllcik7XG4gICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykge1xuICAgICAgICAgICByZXR1cm4gY2xhc3NMaXN0LmFkZChrbGFzcyk7XG4gICAgICAgICB9KTtcblxuICAgICAgICAgZGlmZi5yZW1vdmVkLm1hcChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL1xcKi9nLCBtb2RpZmllcik7XG4gICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykge1xuICAgICAgICAgICByZXR1cm4gY2xhc3NMaXN0LnJlbW92ZShrbGFzcyk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGlmZlxuICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2FwcGx5RGlmZlRvRWxlbWVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5RGlmZlRvRWxlbWVudChkaWZmLCBlbGVtZW50LCBzY2hlbWUpIHtcbiAgICAgICAgIHZhciBtYXRjaGVzID0gZnVuY3Rpb24gbWF0Y2hlcyhlLCBzKSB7XG4gICAgICAgICAgIHJldHVybiAoZS5tYXRjaGVzIHx8IGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGUubXNNYXRjaGVzU2VsZWN0b3IpLmNhbGwoZSwgcyk7XG4gICAgICAgICB9O1xuICAgICAgICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gc2NoZW1lKSB7XG4gICAgICAgICAgIGlmIChzY2hlbWUuaGFzT3duUHJvcGVydHkoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgdmFyIHRhcmdldEVsZW1lbnRzID0gIXNlbGVjdG9yIHx8IG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpID8gW2VsZW1lbnRdIDogZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICBNb2RpZmllclV0aWwuYXBwbHlEaWZmVG9DbGFzc0xpc3QoZGlmZiwgdGFyZ2V0RWxlbWVudHNbaV0uY2xhc3NMaXN0LCBzY2hlbWVbc2VsZWN0b3JdKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGFzdFxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50XG4gICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWVcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnb25Nb2RpZmllckNoYW5nZWQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCBlbGVtZW50LCBzY2hlbWUpIHtcbiAgICAgICAgIHJldHVybiBNb2RpZmllclV0aWwuYXBwbHlEaWZmVG9FbGVtZW50KE1vZGlmaWVyVXRpbC5kaWZmKGxhc3QsIGN1cnJlbnQpLCBlbGVtZW50LCBzY2hlbWUpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2luaXRNb2RpZmllcicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRNb2RpZmllcihlbGVtZW50LCBzY2hlbWUpIHtcbiAgICAgICAgIHZhciBtb2RpZmllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpO1xuICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuXG4gICAgICAgICBNb2RpZmllclV0aWwuYXBwbHlEaWZmVG9FbGVtZW50KHtcbiAgICAgICAgICAgcmVtb3ZlZDogW10sXG4gICAgICAgICAgIGFkZGVkOiBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpXG4gICAgICAgICB9LCBlbGVtZW50LCBzY2hlbWUpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NwbGl0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXQobW9kaWZpZXIpIHtcbiAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIG1vZGlmaWVyLnRyaW0oKS5zcGxpdCgvICsvKS5maWx0ZXIoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgIHJldHVybiB0b2tlbiAhPT0gJyc7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbDtcbiAgIH0pKCk7XG5cbiAgIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gICB2YXIgc2NoZW1lID0ge1xuICAgICBjcmVhdGVJdGVtQ29udGVudDogeyB0eXBlOiAnZnVuY3Rpb24nLCByZXR1cm5zOiBFbGVtZW50IH0sXG4gICAgIGNvdW50SXRlbXM6IHsgdHlwZTogJ2Z1bmN0aW9uJywgcmV0dXJuczogJ251bWJlcicgfSxcbiAgICAgY2FsY3VsYXRlSXRlbUhlaWdodDogeyB0eXBlOiAnZnVuY3Rpb24nLCByZXR1cm5zOiAnbnVtYmVyJyB9LFxuICAgICB1cGRhdGVJdGVtQ29udGVudDogeyB0eXBlOiAnZnVuY3Rpb24nLCBzYWZlQ2FsbDogdHJ1ZSB9LFxuICAgICBkZXN0cm95OiB7IHR5cGU6ICdmdW5jdGlvbicsIHNhZmVDYWxsOiB0cnVlIH0sXG4gICAgIGRlc3Ryb3lJdGVtOiB7IHR5cGU6ICdmdW5jdGlvbicsIHNhZmVDYWxsOiB0cnVlIH1cbiAgIH07XG4gICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG5cbiAgIHZhciBMYXp5UmVwZWF0RGVsZWdhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICBmdW5jdGlvbiBMYXp5UmVwZWF0RGVsZWdhdGUodXNlckRlbGVnYXRlKSB7XG4gICAgICAgdmFyIHRlbXBsYXRlRWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMV07XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIExhenlSZXBlYXREZWxlZ2F0ZSk7XG5cbiAgICAgICB0aGlzLl91c2VyRGVsZWdhdGUgPSB1dGlsLnZhbGlkYXRlZCgnZGVsZWdhdGUnLCB1c2VyRGVsZWdhdGUsICdvYmplY3QnKTtcbiAgICAgICB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgPSB1dGlsLnZhbGlkYXRlZCgndGVtcGxhdGVFbGVtZW50JywgdGVtcGxhdGVFbGVtZW50LCBbRWxlbWVudCwgJ251bGwnXSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoTGF6eVJlcGVhdERlbGVnYXRlLCBbe1xuICAgICAgIGtleTogJ192YWxpZGF0ZWQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsaWRhdGVkKGtleSkge1xuICAgICAgICAgdmFyIF9zY2hlbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBzY2hlbWUgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgIHJldHVybiB1dGlsLnZhbGlkYXRlZChrZXksIG51bGwsIHV0aWwuZXh0ZW5kKHt9LCBfc2NoZW1lW2tleV0sIHtcbiAgICAgICAgICAgZHluYW1pY0NhbGw6IHsgb2JqZWN0OiB0aGlzLl91c2VyRGVsZWdhdGUsIGtleToga2V5IH1cbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIEEgZnVuY3Rpb24gdGhhdCB0YWtlIGl0ZW0gb2JqZWN0IGFzIHBhcmFtZXRlci5cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAncHJlcGFyZUl0ZW0nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlSXRlbShpbmRleCwgZG9uZSkge1xuICAgICAgICAgcmV0dXJuIGRvbmUoe1xuICAgICAgICAgICBlbGVtZW50OiB0aGlzLl92YWxpZGF0ZWQoJ2NyZWF0ZUl0ZW1Db250ZW50JykoaW5kZXgsIHRoaXMuX3RlbXBsYXRlRWxlbWVudClcbiAgICAgICAgIH0pO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnY291bnRJdGVtcycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvdW50SXRlbXMoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkKCdjb3VudEl0ZW1zJykoKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gaXRlbS5lbGVtZW50XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3VwZGF0ZUl0ZW0nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVJdGVtKGluZGV4LCBpdGVtKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkKCd1cGRhdGVJdGVtQ29udGVudCcpKGluZGV4LCBpdGVtKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2NhbGN1bGF0ZUl0ZW1IZWlnaHQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJdGVtSGVpZ2h0KGluZGV4KSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkKCdjYWxjdWxhdGVJdGVtSGVpZ2h0JykoaW5kZXgpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2Rlc3Ryb3lJdGVtJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZWQoJ2Rlc3Ryb3lJdGVtJykoaW5kZXgsIGl0ZW0pO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgdGhpcy5fdmFsaWRhdGVkKCdkZXN0cm95JykoKTtcbiAgICAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZSA9IHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IG51bGw7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXRlbUhlaWdodCcsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fdXNlckRlbGVnYXRlLml0ZW1IZWlnaHQ7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBMYXp5UmVwZWF0RGVsZWdhdGU7XG4gICB9KSgpO1xuXG4gICAvKipcbiAgICAqIFRoaXMgY2xhc3MgcHJvdmlkZSBjb3JlIGZ1bmN0aW9ucyBmb3Igb25zLWxhenktcmVwZWF0LlxuICAgICovXG4gICB2YXIgTGF6eVJlcGVhdFByb3ZpZGVyID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAvKipcbiAgICAgICogQHBhcmFtIHtFbGVtZW50fSB3cmFwcGVyRWxlbWVudFxuICAgICAgKiBAcGFyYW0ge0xhenlSZXBlYXREZWxlZ2F0ZX0gZGVsZWdhdGVcbiAgICAgICovXG5cbiAgICAgZnVuY3Rpb24gTGF6eVJlcGVhdFByb3ZpZGVyKHdyYXBwZXJFbGVtZW50LCBkZWxlZ2F0ZSkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXp5UmVwZWF0UHJvdmlkZXIpO1xuXG4gICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQgPSB1dGlsLnZhbGlkYXRlZCgnd3JhcHBlckVsZW1lbnQnLCB3cmFwcGVyRWxlbWVudCwgRWxlbWVudCk7XG4gICAgICAgdGhpcy5fZGVsZWdhdGUgPSB1dGlsLnZhbGlkYXRlZCgnZGVsZWdhdGUnLCBkZWxlZ2F0ZSwgTGF6eVJlcGVhdERlbGVnYXRlKTtcblxuICAgICAgIGlmICh3cmFwcGVyRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdCcpIHtcbiAgICAgICAgIHdyYXBwZXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhenktbGlzdCcpO1xuICAgICAgIH1cblxuICAgICAgIC8vIHRvIGJlIHJlbW92ZWQgc29vblxuICAgICAgIHRoaXMuX3BhZ2VDb250ZW50ID0gdXRpbC5maW5kUGFyZW50KHdyYXBwZXJFbGVtZW50LCAnLm9ucy1zY3JvbGxlcl9fY29udGVudCcpO1xuXG4gICAgICAgaWYgKCF0aGlzLl9wYWdlQ29udGVudCkge1xuICAgICAgICAgdGhpcy5fcGFnZUNvbnRlbnQgPSB1dGlsLmZpbmRQYXJlbnQod3JhcHBlckVsZW1lbnQsICcucGFnZV9fY29udGVudCcpO1xuICAgICAgIH1cblxuICAgICAgIGlmICghdGhpcy5fcGFnZUNvbnRlbnQpIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcignb25zLWxhenktcmVwZWF0IG11c3QgYmUgYSBkZXNjZW5kYW50IG9mIGFuIDxvbnMtcGFnZT4gb3IgYW4gPG9ucy1zY3JvbGxlcj4gZWxlbWVudC4nKTtcbiAgICAgICB9XG5cbiAgICAgICB0aGlzLl90b3BQb3NpdGlvbnMgPSBbXTtcbiAgICAgICB0aGlzLl9yZW5kZXJlZEl0ZW1zID0ge307XG5cbiAgICAgICB0cnkge1xuICAgICAgICAgdGhpcy5fZGVsZWdhdGUuaXRlbUhlaWdodCB8fCB0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KDApO1xuICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgIGlmICghL211c3QgYmUgKGF8YW4gaW5zdGFuY2Ugb2YpIGZ1bmN0aW9uLy50ZXN0KCcnICsgZSkpIHtcbiAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICB9XG4gICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKExhenlSZXBlYXRQcm92aWRlciwgW3tcbiAgICAgICBrZXk6ICdfY2hlY2tJdGVtSGVpZ2h0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrSXRlbUhlaWdodChjYWxsYmFjaykge1xuICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgdGhpcy5fZGVsZWdhdGUucHJlcGFyZUl0ZW0oMCwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG5cbiAgICAgICAgICAgaWYgKF90aGlzLl91bmtub3duSXRlbUhlaWdodCkge1xuICAgICAgICAgICAgIF90aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgICBfdGhpcy5faXRlbUhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgIF90aGlzLl93cmFwcGVyRWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX3Vua25vd25JdGVtSGVpZ2h0O1xuICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jb3VudEl0ZW1zJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvdW50SXRlbXMoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY291bnRJdGVtcygpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19nZXRJdGVtSGVpZ2h0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEl0ZW1IZWlnaHQoaSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGljSXRlbUhlaWdodCB8fCB0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KGkpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkNoYW5nZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNoYW5nZSgpIHtcbiAgICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3JlZnJlc2gnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcbiAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3JlbmRlcicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXIoKSB7XG4gICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgaWYgKHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0KSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0l0ZW1IZWlnaHQodGhpcy5fcmVuZGVyLmJpbmQodGhpcykpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0luVmlldygpO1xuICAgICAgICAgdmFyIGtlZXAgPSB7fTtcblxuICAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICBfdGhpczIuX3JlbmRlckVsZW1lbnQoaXRlbSk7XG4gICAgICAgICAgIGtlZXBbaXRlbS5pbmRleF0gPSB0cnVlO1xuICAgICAgICAgfSk7XG5cbiAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICByZXR1cm4ga2VlcFtrZXldIHx8IF90aGlzMi5fcmVtb3ZlRWxlbWVudChrZXkpO1xuICAgICAgICAgfSk7XG5cbiAgICAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuX2xpc3RIZWlnaHQgKyAncHgnO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW0uaW5kZXhcbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaXRlbS50b3BcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3JlbmRlckVsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyRWxlbWVudChfcmVmMikge1xuICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgIHZhciBpbmRleCA9IF9yZWYyLmluZGV4O1xuICAgICAgICAgdmFyIHRvcCA9IF9yZWYyLnRvcDtcblxuICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLnVwZGF0ZUl0ZW0oaW5kZXgsIGl0ZW0pOyAvLyB1cGRhdGUgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgIGl0ZW0uZWxlbWVudC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2RlbGVnYXRlLnByZXBhcmVJdGVtKGluZGV4LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICB1dGlsLmV4dGVuZChpdGVtLmVsZW1lbnQuc3R5bGUsIHtcbiAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICB0b3A6IHRvcCArICdweCcsXG4gICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICByaWdodDogMFxuICAgICAgICAgICB9KTtcblxuICAgICAgICAgICBfdGhpczMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW0uZWxlbWVudCk7XG4gICAgICAgICAgIF90aGlzMy5fcmVuZGVyZWRJdGVtc1tpbmRleF0gPSBpdGVtO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19yZW1vdmVFbGVtZW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUVsZW1lbnQoaW5kZXgpIHtcbiAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XG5cbiAgICAgICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKTtcblxuICAgICAgICAgaWYgKGl0ZW0uZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgIGl0ZW0uZWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGl0ZW0uZWxlbWVudCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfcmVtb3ZlQWxsRWxlbWVudHMnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlQWxsRWxlbWVudHMoKSB7XG4gICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgIHJldHVybiBfdGhpczQuX3JlbW92ZUVsZW1lbnQoa2V5KTtcbiAgICAgICAgIH0pO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jYWxjdWxhdGVTdGFydEluZGV4JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZVN0YXJ0SW5kZXgoY3VycmVudCkge1xuICAgICAgICAgdmFyIHN0YXJ0ID0gMDtcbiAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9pdGVtQ291bnQgLSAxO1xuXG4gICAgICAgICBpZiAodGhpcy5zdGF0aWNJdGVtSGVpZ2h0KSB7XG4gICAgICAgICAgIHJldHVybiBwYXJzZUludCgtY3VycmVudCAvIHRoaXMuc3RhdGljSXRlbUhlaWdodCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIC8vIEJpbmFyeSBzZWFyY2ggZm9yIGluZGV4IGF0IHRvcCBvZiBzY3JlZW4gc28gd2UgY2FuIHNwZWVkIHVwIHJlbmRlcmluZy5cbiAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgICAgICB2YXIgdmFsdWUgPSBjdXJyZW50ICsgdGhpcy5fdG9wUG9zaXRpb25zW21pZGRsZV07XG5cbiAgICAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPD0gMCAmJiB2YWx1ZSArIHRoaXMuX2dldEl0ZW1IZWlnaHQobWlkZGxlKSA+IDApIHtcbiAgICAgICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICAgZW5kID0gbWlkZGxlIC0gMTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfcmVjYWxjdWxhdGVUb3BQb3NpdGlvbnMnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVjYWxjdWxhdGVUb3BQb3NpdGlvbnMoKSB7XG4gICAgICAgICB2YXIgbCA9IE1hdGgubWluKHRoaXMuX3RvcFBvc2l0aW9ucy5sZW5ndGgsIHRoaXMuX2l0ZW1Db3VudCk7XG4gICAgICAgICB0aGlzLl90b3BQb3NpdGlvbnNbMF0gPSAwO1xuICAgICAgICAgZm9yICh2YXIgaSA9IDEsIF9sOyBpIDwgX2w7IGkrKykge1xuICAgICAgICAgICB0aGlzLl90b3BQb3NpdGlvbnNbaV0gPSB0aGlzLl90b3BQb3NpdGlvbnNbaSAtIDFdICsgdGhpcy5fZ2V0SXRlbUhlaWdodChpKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0SXRlbXNJblZpZXcnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SXRlbXNJblZpZXcoKSB7XG4gICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICAgdmFyIGxpbWl0ID0gNCAqIHdpbmRvdy5pbm5lckhlaWdodCAtIG9mZnNldDtcbiAgICAgICAgIHZhciBjb3VudCA9IHRoaXMuX2NvdW50SXRlbXMoKTtcblxuICAgICAgICAgaWYgKGNvdW50ICE9PSB0aGlzLl9pdGVtQ291bnQpIHtcbiAgICAgICAgICAgdGhpcy5faXRlbUNvdW50ID0gY291bnQ7XG4gICAgICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHZhciBpID0gTWF0aC5tYXgoMCwgdGhpcy5fY2FsY3VsYXRlU3RhcnRJbmRleChvZmZzZXQpIC0gMzApO1xuXG4gICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgIGZvciAodmFyIHRvcCA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpXTsgaSA8IGNvdW50ICYmIHRvcCA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgIC8vIHBlcmYgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICAgdGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCArPSAxMDA7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB0aGlzLl90b3BQb3NpdGlvbnNbaV0gPSB0b3A7XG4gICAgICAgICAgIGl0ZW1zLnB1c2goeyB0b3A6IHRvcCwgaW5kZXg6IGkgfSk7XG4gICAgICAgICAgIHRvcCArPSB0aGlzLl9nZXRJdGVtSGVpZ2h0KGkpO1xuICAgICAgICAgfVxuICAgICAgICAgdGhpcy5fbGlzdEhlaWdodCA9IHRvcDtcblxuICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19kZWJvdW5jZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICAgICAgIHZhciB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgdmFyIF90aGlzNSA9IHRoaXMsXG4gICAgICAgICAgICAgICBfYXJndW1lbnRzID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgZnVuYy5hcHBseShfdGhpczUsIF9hcmd1bWVudHMpO1xuICAgICAgICAgICAgIH0sIHdhaXQpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9O1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19kb3VibGVGaXJlT25Ub3VjaGVuZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kb3VibGVGaXJlT25Ub3VjaGVuZCgpIHtcbiAgICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICAgdGhpcy5fZGVib3VuY2UodGhpcy5fcmVuZGVyLmJpbmQodGhpcyksIDEwMCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2FkZEV2ZW50TGlzdGVuZXJzJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICAgdXRpbC5iaW5kTGlzdGVuZXJzKHRoaXMsIFsnX29uQ2hhbmdlJywgJ19kb3VibGVGaXJlT25Ub3VjaGVuZCddKTtcblxuICAgICAgICAgaWYgKHBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgICAgICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX2RlYm91bmNlKHRoaXMuX2JvdW5kT25DaGFuZ2UsIDMwKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG5cbiAgICAgICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICAgICAgIHRoaXMuX3BhZ2VDb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuICAgICAgICAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3JlbW92ZUV2ZW50TGlzdGVuZXJzJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICAgdGhpcy5fcGFnZUNvbnRlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG5cbiAgICAgICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICAgICAgIHRoaXMuX3BhZ2VDb250ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuICAgICAgICAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICB0aGlzLl9yZW1vdmVBbGxFbGVtZW50cygpO1xuICAgICAgICAgdGhpcy5fZGVsZWdhdGUuZGVzdHJveSgpO1xuICAgICAgICAgdGhpcy5fcGFyZW50RWxlbWVudCA9IHRoaXMuX2RlbGVnYXRlID0gdGhpcy5fcmVuZGVyZWRJdGVtcyA9IG51bGw7XG4gICAgICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3N0YXRpY0l0ZW1IZWlnaHQnLFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLml0ZW1IZWlnaHQgfHwgdGhpcy5faXRlbUhlaWdodDtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIExhenlSZXBlYXRQcm92aWRlcjtcbiAgIH0pKCk7XG5cbiAgIGludGVybmFsLkFuaW1hdG9yRmFjdG9yeSA9IEFuaW1hdG9yRmFjdG9yeTtcbiAgIGludGVybmFsLk1vZGlmaWVyVXRpbCA9IE1vZGlmaWVyVXRpbDtcbiAgIGludGVybmFsLkxhenlSZXBlYXRQcm92aWRlciA9IExhenlSZXBlYXRQcm92aWRlcjtcbiAgIGludGVybmFsLkxhenlSZXBlYXREZWxlZ2F0ZSA9IExhenlSZXBlYXREZWxlZ2F0ZTtcblxuICAgLypcbiAgIENvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuICAgKi9cblxuICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcblxuICAgICAvKipcbiAgICAgICogQG9iamVjdCBvbnMub3JpZW50YXRpb25cbiAgICAgICogQGNhdGVnb3J5IHV0aWxcbiAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyBmb3Igb3JpZW50YXRpb24gZGV0ZWN0aW9uLlsvZW5dXG4gICAgICAqICAgW2phXeeUu+mdouOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+aknOefpeOBruOBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBpuOBhOOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAgICAqL1xuICAgICB2YXIgb2JqID0ge1xuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBjaGFuZ2VcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBkZXZpY2Ugb3JpZW50YXRpb24gY2hhbmdlcy5bL2VuXVxuICAgICAgICAqICAgW2phXeODh+ODkOOCpOOCueOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjOWkieWMluOBl+OBn+mam+OBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzUG9ydHJhaXRcbiAgICAgICAgKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgbW9kZS5bL2VuXVxuICAgICAgICAqICAgW2phXeePvuWcqOOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Gu5aC05ZCI44GrdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIG9uXG4gICAgICAgICogQHNpZ25hdHVyZSBvbihldmVudE5hbWUsIGxpc3RlbmVyKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUFkZCBhbiBldmVudCBsaXN0ZW5lci5bL2VuXVxuICAgICAgICAqICAgW2phXeOCpOODmeODs+ODiOODquOCueODiuODvOOCkui/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu44Kk44OZ44Oz44OI44GM55m654Gr44GV44KM44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgb25jZVxuICAgICAgICAqIEBzaWduYXR1cmUgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICBbZW5dQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQncyBvbmx5IHRyaWdnZXJlZCBvbmNlLlsvZW5dXG4gICAgICAgICogIFtqYV3kuIDluqbjgaDjgZHlkbzjgbPlh7rjgZXjgozjgovjgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAgICAqIEBzaWduYXR1cmUgb2ZmKGV2ZW50TmFtZSwgW2xpc3RlbmVyXSlcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXVJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci4gSWYgdGhlIGxpc3RlbmVyIGlzIG5vdCBzcGVjaWZpZWQgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50IHR5cGUgd2lsbCBiZSByZW1vdmVkLlsvZW5dXG4gICAgICAgICogIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLliYrpmaTjgZfjgb7jgZnjgILjgoLjgZfjgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLmjIflrprjgZfjgarjgYvjgaPjgZ/loLTlkIjjgavjga/jgIHjgZ3jga7jgqTjg5njg7Pjg4jjgavntJDjgaXjgY/lhajjgabjga7jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgYzliYrpmaTjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeWJiumZpOOBmeOCi+OCpOODmeODs+ODiOODquOCueODiuODvOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvLyBhY3R1YWwgaW1wbGVtZW50YXRpb24gdG8gZGV0ZWN0IGlmIHdoZXRoZXIgY3VycmVudCBzY3JlZW4gaXMgcG9ydHJhaXQgb3Igbm90XG4gICAgICAgX2lzUG9ydHJhaXQ6IGZhbHNlLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc1BvcnRyYWl0XG4gICAgICAgICogQHNpZ25hdHVyZSBpc1BvcnRyYWl0KClcbiAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBtb2RlLlsvZW5dXG4gICAgICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjg6Ljg7zjg4njga7loLTlkIjjgat0cnVl44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2NyZWVuIG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG9yIG5vdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Oi44O844OJ44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cbiAgICAgICBpc1BvcnRyYWl0OiBmdW5jdGlvbiBpc1BvcnRyYWl0KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2lzUG9ydHJhaXQoKTtcbiAgICAgICB9LFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc0xhbmRzY2FwZVxuICAgICAgICAqIEBzaWduYXR1cmUgaXNMYW5kc2NhcGUoKVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIGxhbmRzY2FwZSBtb2RlLlsvZW5dXG4gICAgICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNjcmVlbiBvcmllbnRhdGlvbiBpcyBsYW5kc2NhcGUgb3Igbm90LlsvZW5dXG4gICAgICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cbiAgICAgICBpc0xhbmRzY2FwZTogZnVuY3Rpb24gaXNMYW5kc2NhcGUoKSB7XG4gICAgICAgICByZXR1cm4gIXRoaXMuaXNQb3J0cmFpdCgpO1xuICAgICAgIH0sXG5cbiAgICAgICBfaW5pdDogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25ET01Db250ZW50TG9hZGVkLmJpbmQodGhpcyksIGZhbHNlKTtcblxuICAgICAgICAgaWYgKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSB7XG4gICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgfTtcblxuICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgfSxcblxuICAgICAgIF9vbkRPTUNvbnRlbnRMb2FkZWQ6IGZ1bmN0aW9uIF9vbkRPTUNvbnRlbnRMb2FkZWQoKSB7XG4gICAgICAgICB0aGlzLl9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uKCk7XG4gICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHsgaXNQb3J0cmFpdDogdGhpcy5pc1BvcnRyYWl0KCkgfSk7XG4gICAgICAgfSxcblxuICAgICAgIF9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uOiBmdW5jdGlvbiBfaW5zdGFsbElzUG9ydHJhaXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgIHZhciBpc1BvcnRyYWl0ID0gd2luZG93LmlubmVyV2lkdGggPCB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgIGlmICghKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSkge1xuICAgICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgfTtcbiAgICAgICAgIH0gZWxzZSBpZiAod2luZG93Lm9yaWVudGF0aW9uICUgMTgwID09PSAwKSB7XG4gICAgICAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5vcmllbnRhdGlvbiAlIDE4MCkgPT09IDAgPyBpc1BvcnRyYWl0IDogIWlzUG9ydHJhaXQ7XG4gICAgICAgICAgIH07XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSA5MCA/IGlzUG9ydHJhaXQgOiAhaXNQb3J0cmFpdDtcbiAgICAgICAgICAgfTtcbiAgICAgICAgIH1cbiAgICAgICB9LFxuXG4gICAgICAgX29uT3JpZW50YXRpb25DaGFuZ2U6IGZ1bmN0aW9uIF9vbk9yaWVudGF0aW9uQ2hhbmdlKCkge1xuICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgdmFyIGlzUG9ydHJhaXQgPSB0aGlzLl9pc1BvcnRyYWl0KCk7XG5cbiAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBkaW1lbnNpb25zIHRvIGNoYW5nZSBiZWNhdXNlXG4gICAgICAgICAvLyBvZiBBbmRyb2lkIGluY29uc2lzdGVuY3kuXG4gICAgICAgICB2YXIgbkl0ZXIgPSAwO1xuICAgICAgICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICBuSXRlcisrO1xuXG4gICAgICAgICAgIHZhciB3ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgIHZhciBoID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAgICAgIGlmIChpc1BvcnRyYWl0ICYmIHcgPD0gaCB8fCAhaXNQb3J0cmFpdCAmJiB3ID49IGgpIHtcbiAgICAgICAgICAgICBfdGhpcy5lbWl0KCdjaGFuZ2UnLCB7IGlzUG9ydHJhaXQ6IGlzUG9ydHJhaXQgfSk7XG4gICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgIH0gZWxzZSBpZiAobkl0ZXIgPT09IDUwKSB7XG4gICAgICAgICAgICAgX3RoaXMuZW1pdCgnY2hhbmdlJywgeyBpc1BvcnRyYWl0OiBpc1BvcnRyYWl0IH0pO1xuICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9LCAyMCk7XG4gICAgICAgfSxcblxuICAgICAgIC8vIFJ1biBvbiBub3QgbW9iaWxlIGJyb3dzZXIuXG4gICAgICAgX29uUmVzaXplOiBmdW5jdGlvbiBfb25SZXNpemUoKSB7XG4gICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHsgaXNQb3J0cmFpdDogdGhpcy5pc1BvcnRyYWl0KCkgfSk7XG4gICAgICAgfVxuICAgICB9O1xuXG4gICAgIE1pY3JvRXZlbnQubWl4aW4ob2JqKTtcblxuICAgICByZXR1cm4gb2JqO1xuICAgfTtcblxuICAgdmFyIG9yaWVudGF0aW9uID0gY3JlYXRlKCkuX2luaXQoKTtcblxuICAgLypcbiAgIENvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuICAgKi9cblxuICAgdmFyIHNvZnR3YXJlS2V5Ym9hcmQgPSBuZXcgTWljcm9FdmVudCgpO1xuICAgc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IGZhbHNlO1xuXG4gICB2YXIgb25TaG93ID0gZnVuY3Rpb24gb25TaG93KCkge1xuICAgICBzb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdzaG93Jyk7XG4gICB9O1xuXG4gICB2YXIgb25IaWRlID0gZnVuY3Rpb24gb25IaWRlKCkge1xuICAgICBzb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gZmFsc2U7XG4gICAgIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaGlkZScpO1xuICAgfTtcblxuICAgdmFyIGJpbmRFdmVudHMgPSBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICAgICBpZiAodHlwZW9mIEtleWJvYXJkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJ0aW5tb3NlL2NvcmRvdmEta2V5Ym9hcmQvYmxvYi85NWYzZGEzYTM4ZDhmOGUxZmE0MWZiZjQwMTQ1MzUyYzEzNTM1YTAwL1JFQURNRS5tZFxuICAgICAgIEtleWJvYXJkLm9uc2hvdyA9IG9uU2hvdztcbiAgICAgICBLZXlib2FyZC5vbmhpZGUgPSBvbkhpZGU7XG4gICAgICAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdpbml0JywgeyB2aXNpYmxlOiBLZXlib2FyZC5pc1Zpc2libGUgfSk7XG5cbiAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29yZG92YS5wbHVnaW5zICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29yZG92YS5wbHVnaW5zLktleWJvYXJkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kcmlmdHljby9pb25pYy1wbHVnaW5zLWtleWJvYXJkL2Jsb2IvY2EyN2VjZi9SRUFETUUubWRcbiAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkc2hvdycsIG9uU2hvdyk7XG4gICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZGhpZGUnLCBvbkhpZGUpO1xuICAgICAgIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaW5pdCcsIHsgdmlzaWJsZTogY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmlzVmlzaWJsZSB9KTtcblxuICAgICAgIHJldHVybiB0cnVlO1xuICAgICB9XG5cbiAgICAgcmV0dXJuIGZhbHNlO1xuICAgfTtcblxuICAgdmFyIG5vUGx1Z2luRXJyb3IgPSBmdW5jdGlvbiBub1BsdWdpbkVycm9yKCkge1xuICAgICBjb25zb2xlLndhcm4oJ29ucy1rZXlib2FyZDogQ29yZG92YSBLZXlib2FyZCBwbHVnaW4gaXMgbm90IHByZXNlbnQuJyk7XG4gICB9O1xuXG4gICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgaWYgKCFiaW5kRXZlbnRzKCkpIHtcbiAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW29ucy1rZXlib2FyZC1hY3RpdmVdJykgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW29ucy1rZXlib2FyZC1pbmFjdGl2ZV0nKSkge1xuICAgICAgICAgbm9QbHVnaW5FcnJvcigpO1xuICAgICAgIH1cblxuICAgICAgIHNvZnR3YXJlS2V5Ym9hcmQub24gPSBub1BsdWdpbkVycm9yO1xuICAgICB9XG4gICB9KTtcblxuICAgdmFyIHV0aWwkMSA9IHtcbiAgICAgX3JlYWR5OiBmYWxzZSxcblxuICAgICBfZG9tQ29udGVudExvYWRlZDogZmFsc2UsXG5cbiAgICAgX29uRE9NQ29udGVudExvYWRlZDogZnVuY3Rpb24gX29uRE9NQ29udGVudExvYWRlZCgpIHtcbiAgICAgICB1dGlsJDEuX2RvbUNvbnRlbnRMb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgaWYgKHBsYXRmb3JtLmlzV2ViVmlldygpKSB7XG4gICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIHV0aWwkMS5fcmVhZHkgPSB0cnVlO1xuICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICB1dGlsJDEuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgICB9XG4gICAgIH0sXG5cbiAgICAgYWRkQmFja0J1dHRvbkxpc3RlbmVyOiBmdW5jdGlvbiBhZGRCYWNrQnV0dG9uTGlzdGVuZXIoZm4pIHtcbiAgICAgICBpZiAoIXRoaXMuX2RvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIERPTUNvbnRlbnRMb2FkZWQnKTtcbiAgICAgICB9XG5cbiAgICAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sXG5cbiAgICAgcmVtb3ZlQmFja0J1dHRvbkxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXIoZm4pIHtcbiAgICAgICBpZiAoIXRoaXMuX2RvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIERPTUNvbnRlbnRMb2FkZWQnKTtcbiAgICAgICB9XG5cbiAgICAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH1cbiAgIH07XG4gICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgcmV0dXJuIHV0aWwkMS5fb25ET01Db250ZW50TG9hZGVkKCk7XG4gICB9LCBmYWxzZSk7XG5cbiAgIHZhciBIYW5kbGVyUmVwb3NpdG9yeSA9IHtcbiAgICAgX3N0b3JlOiB7fSxcblxuICAgICBfZ2VuSWQ6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgdmFyIGkgPSAwO1xuICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICByZXR1cm4gaSsrO1xuICAgICAgIH07XG4gICAgIH0pKCksXG5cbiAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZWxlbWVudCwgaGFuZGxlcikge1xuICAgICAgIGlmIChlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCkge1xuICAgICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICAgfVxuICAgICAgIHZhciBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkID0gSGFuZGxlclJlcG9zaXRvcnkuX2dlbklkKCk7XG4gICAgICAgdGhpcy5fc3RvcmVbaWRdID0gaGFuZGxlcjtcbiAgICAgfSxcblxuICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG4gICAgICAgaWYgKGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkKSB7XG4gICAgICAgICBkZWxldGUgdGhpcy5fc3RvcmVbZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWRdO1xuICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkO1xuICAgICAgIH1cbiAgICAgfSxcblxuICAgICBnZXQ6IGZ1bmN0aW9uIGdldChlbGVtZW50KSB7XG4gICAgICAgaWYgKCFlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCkge1xuICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICB9XG5cbiAgICAgICB2YXIgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgICAgIGlmICghdGhpcy5fc3RvcmVbaWRdKSB7XG4gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gdGhpcy5fc3RvcmVbaWRdO1xuICAgICB9LFxuXG4gICAgIGhhczogZnVuY3Rpb24gaGFzKGVsZW1lbnQpIHtcbiAgICAgICB2YXIgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgICAgIHJldHVybiAhIXRoaXMuX3N0b3JlW2lkXTtcbiAgICAgfVxuICAgfTtcblxuICAgdmFyIERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgZnVuY3Rpb24gRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyKTtcblxuICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgIHRoaXMuX2JvdW5kQ2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuICAgICB9XG5cbiAgICAgLyoqXG4gICAgICAqIEVuYWJsZSB0byBoYW5kbGUgJ2JhY2tidXR0b24nIGV2ZW50cy5cbiAgICAgICovXG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLCBbe1xuICAgICAgIGtleTogJ2VuYWJsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICAgICAgIHV0aWwkMS5hZGRCYWNrQnV0dG9uTGlzdGVuZXIodGhpcy5fYm91bmRDYWxsYmFjayk7XG4gICAgICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogRGlzYWJsZSB0byBoYW5kbGUgJ2JhY2tidXR0b24nIGV2ZW50cy5cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZGlzYWJsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgICBpZiAodGhpcy5faXNFbmFibGVkKSB7XG4gICAgICAgICAgIHV0aWwkMS5yZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXIodGhpcy5fYm91bmRDYWxsYmFjayk7XG4gICAgICAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEZpcmUgYSAnYmFja2J1dHRvbicgZXZlbnQgbWFudWFsbHkuXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2ZpcmVEZXZpY2VCYWNrQnV0dG9uRXZlbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50KCkge1xuICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICBldmVudC5pbml0RXZlbnQoJ2JhY2tidXR0b24nLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50KCk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2NyZWF0ZUhhbmRsZXInLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVIYW5kbGVyKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEhUTUxFbGVtZW50Jyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICghKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBGdW5jdGlvbicpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgaGFuZGxlciA9IHtcbiAgICAgICAgICAgX2NhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgX2VsZW1lbnQ6IGVsZW1lbnQsXG5cbiAgICAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5yZW1vdmUoZWxlbWVudCk7XG4gICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgc2V0TGlzdGVuZXI6IGZ1bmN0aW9uIHNldExpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgfSxcblxuICAgICAgICAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5zZXQoZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gICAgICAgICAgICAgcmV0dXJuIEhhbmRsZXJSZXBvc2l0b3J5LmdldChlbGVtZW50KSA9PT0gdGhpcztcbiAgICAgICAgICAgfSxcblxuICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnJlbW92ZShlbGVtZW50KTtcbiAgICAgICAgICAgICB0aGlzLl9jYWxsYmFjayA9IHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICB9XG4gICAgICAgICB9O1xuXG4gICAgICAgICBoYW5kbGVyLmVuYWJsZSgpO1xuXG4gICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKSB7XG4gICAgICAgICB2YXIgdHJlZSA9IHRoaXMuX2NhcHR1cmVUcmVlKCk7XG5cbiAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKTtcblxuICAgICAgICAgdmFyIGhhbmRsZXIgPSBIYW5kbGVyUmVwb3NpdG9yeS5nZXQoZWxlbWVudCk7XG4gICAgICAgICBoYW5kbGVyLl9jYWxsYmFjayhjcmVhdGVFdmVudChlbGVtZW50KSk7XG5cbiAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICBfZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICBjYWxsUGFyZW50SGFuZGxlcjogZnVuY3Rpb24gY2FsbFBhcmVudEhhbmRsZXIoKSB7XG4gICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBIYW5kbGVyUmVwb3NpdG9yeS5nZXQocGFyZW50KTtcbiAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5fY2FsbGJhY2soY3JlYXRlRXZlbnQocGFyZW50KSk7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9O1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2NhcHR1cmVUcmVlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhcHR1cmVUcmVlKCkge1xuICAgICAgICAgcmV0dXJuIGNyZWF0ZVRyZWUoZG9jdW1lbnQuYm9keSk7XG5cbiAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVRyZWUoZWxlbWVudCkge1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgY2hpbGRyZW46IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycmF5T2YoZWxlbWVudC5jaGlsZHJlbikubWFwKGZ1bmN0aW9uIChjaGlsZEVsZW1lbnQpIHtcblxuICAgICAgICAgICAgICAgaWYgKGNoaWxkRWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICBpZiAoY2hpbGRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJiAhSGFuZGxlclJlcG9zaXRvcnkuaGFzKGNoaWxkRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlVHJlZShjaGlsZEVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICBpZiAocmVzdWx0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJiAhSGFuZGxlclJlcG9zaXRvcnkuaGFzKHJlc3VsdC5lbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIHJldHVybiBbcmVzdWx0XTtcbiAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgfTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZnVuY3Rpb24gYXJyYXlPZih0YXJnZXQpIHtcbiAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRhcmdldFtpXSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJlZVxuICAgICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZmluZEhhbmRsZXJMZWFmRWxlbWVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kSGFuZGxlckxlYWZFbGVtZW50KHRyZWUpIHtcbiAgICAgICAgIHJldHVybiBmaW5kKHRyZWUpO1xuXG4gICAgICAgICBmdW5jdGlvbiBmaW5kKG5vZGUpIHtcbiAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgcmV0dXJuIG5vZGUuZWxlbWVudDtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgIHJldHVybiBmaW5kKG5vZGUuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlLmVsZW1lbnQ7XG4gICAgICAgICAgIH0pLnJlZHVjZShmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICBpZiAoIWxlZnQpIHtcbiAgICAgICAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICB2YXIgbGVmdFogPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShsZWZ0LCAnJykuekluZGV4LCAxMCk7XG4gICAgICAgICAgICAgdmFyIHJpZ2h0WiA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJpZ2h0LCAnJykuekluZGV4LCAxMCk7XG5cbiAgICAgICAgICAgICBpZiAoIWlzTmFOKGxlZnRaKSAmJiAhaXNOYU4ocmlnaHRaKSkge1xuICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaID4gcmlnaHRaID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwdHVyaW5nIGJhY2tidXR0b24taGFuZGxlciBpcyBmYWlsdXJlLicpO1xuICAgICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyO1xuICAgfSkoKTtcblxuICAgdmFyIGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyID0gbmV3IERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyKCk7XG5cbiAgIHZhciBhdXRvU3R5bGVFbmFibGVkID0gdHJ1ZTtcblxuICAgLy8gTW9kaWZpZXJzXG4gICB2YXIgbW9kaWZpZXJzTWFwID0ge1xuICAgICAncXVpZXQnOiAnbWF0ZXJpYWwtLWZsYXQnLFxuICAgICAnbGlnaHQnOiAnbWF0ZXJpYWwtLWZsYXQnLFxuICAgICAnb3V0bGluZSc6ICdtYXRlcmlhbC0tZmxhdCcsXG4gICAgICdjdGEnOiAnJyxcbiAgICAgJ2xhcmdlLS1xdWlldCc6ICdtYXRlcmlhbC0tZmxhdCBsYXJnZScsXG4gICAgICdsYXJnZS0tY3RhJzogJ2xhcmdlJyxcbiAgICAgJ25vYm9yZGVyJzogJycsXG4gICAgICdjaGV2cm9uJzogJycsXG4gICAgICd0YXBwYWJsZSc6ICcnLFxuICAgICAndW5kZXJiYXInOiAnJ1xuICAgfTtcblxuICAgdmFyIHBsYXRmb3JtcyA9IHt9O1xuXG4gICBwbGF0Zm9ybXMuYW5kcm9pZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgaWYgKCEvb25zLWZhYnxvbnMtc3BlZWQtZGlhbHxvbnMtcHJvZ3Jlc3MvLnRlc3QoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmICEvbWF0ZXJpYWwvLnRlc3QoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpKSB7XG5cbiAgICAgICB2YXIgb2xkTW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJztcblxuICAgICAgIHZhciBuZXdNb2RpZmllciA9IG9sZE1vZGlmaWVyLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgcmV0dXJuIG1vZGlmaWVyc01hcC5oYXNPd25Qcm9wZXJ0eShlKSA/IG1vZGlmaWVyc01hcFtlXSA6IGU7XG4gICAgICAgfSk7XG4gICAgICAgbmV3TW9kaWZpZXIudW5zaGlmdCgnbWF0ZXJpYWwnKTtcblxuICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG5ld01vZGlmaWVyLmpvaW4oJyAnKS50cmltKCkpO1xuICAgICB9XG5cbiAgICAgLy8gRWZmZWN0c1xuICAgICBpZiAoL29ucy1idXR0b258b25zLWxpc3QtaXRlbXxvbnMtZmFifG9ucy1zcGVlZC1kaWFsfG9ucy10YWIkLy50ZXN0KGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpICYmICF1dGlsLmZpbmRDaGlsZChlbGVtZW50LCAnb25zLXJpcHBsZScpKSB7XG5cbiAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdC1pdGVtJykge1xuICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YXBwYWJsZScpKSB7XG4gICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyaXBwbGUnLCAnJyk7XG4gICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YXBwYWJsZScpO1xuICAgICAgICAgfVxuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpO1xuICAgICAgIH1cbiAgICAgfVxuICAgfTtcblxuICAgcGxhdGZvcm1zLmlvcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgLy8gTW9kaWZpZXJzXG4gICAgIGlmICgvbWF0ZXJpYWwvLnRlc3QoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpKSB7XG4gICAgICAgdXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbWF0ZXJpYWwnKTtcblxuICAgICAgIGlmICh1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdtYXRlcmlhbC0tZmxhdCcpKSB7XG4gICAgICAgICB1dGlsLmFkZE1vZGlmaWVyKGVsZW1lbnQsIHV0aWwucmVtb3ZlTW9kaWZpZXIoZWxlbWVudCwgJ2xhcmdlJykgPyAnbGFyZ2UtLXF1aWV0JyA6ICdxdWlldCcpO1xuICAgICAgIH1cblxuICAgICAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtb2RpZmllcicpO1xuICAgICAgIH1cbiAgICAgfVxuXG4gICAgIC8vIEVmZmVjdHNcbiAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdyaXBwbGUnKSkge1xuICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1saXN0LWl0ZW0nKSB7XG4gICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFwcGFibGUnLCAnJyk7XG4gICAgICAgfVxuXG4gICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuICAgICB9XG4gICB9O1xuXG4gICB2YXIgdW5sb2NrZWQgPSB7XG4gICAgIGFuZHJvaWQ6IHRydWVcbiAgIH07XG5cbiAgIHZhciBwcmVwYXJlQXV0b1N0eWxlID0gZnVuY3Rpb24gcHJlcGFyZUF1dG9TdHlsZShlbGVtZW50LCBmb3JjZSkge1xuICAgICBpZiAoYXV0b1N0eWxlRW5hYmxlZCAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGUtYXV0by1zdHlsaW5nJykpIHtcbiAgICAgICB2YXIgbW9iaWxlT1MgPSBwbGF0Zm9ybS5nZXRNb2JpbGVPUygpO1xuICAgICAgIGlmIChwbGF0Zm9ybXMuaGFzT3duUHJvcGVydHkobW9iaWxlT1MpICYmICh1bmxvY2tlZC5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgfHwgZm9yY2UpKSB7XG4gICAgICAgICBwbGF0Zm9ybXNbbW9iaWxlT1NdKGVsZW1lbnQpO1xuICAgICAgIH1cbiAgICAgfVxuICAgfTtcblxuICAgdmFyIGF1dG9TdHlsZSA9IHtcbiAgICAgaXNFbmFibGVkOiBmdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gICAgICAgcmV0dXJuIGF1dG9TdHlsZUVuYWJsZWQ7XG4gICAgIH0sXG4gICAgIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgIHJldHVybiBhdXRvU3R5bGVFbmFibGVkID0gdHJ1ZTtcbiAgICAgfSxcbiAgICAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgICByZXR1cm4gYXV0b1N0eWxlRW5hYmxlZCA9IGZhbHNlO1xuICAgICB9LFxuICAgICBwcmVwYXJlOiBwcmVwYXJlQXV0b1N0eWxlXG4gICB9O1xuXG4gICB2YXIgZ2VuZXJhdGVJZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgIHZhciBpID0gMDtcbiAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICByZXR1cm4gaSsrO1xuICAgICB9O1xuICAgfSkoKTtcblxuICAgLyoqXG4gICAgKiBEb29yIGxvY2tpbmcgc3lzdGVtLlxuICAgICpcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ11cbiAgICAqL1xuXG4gICB2YXIgRG9vckxvY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgICBmdW5jdGlvbiBEb29yTG9jaygpIHtcbiAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBEb29yTG9jayk7XG5cbiAgICAgICB0aGlzLl9sb2NrTGlzdCA9IFtdO1xuICAgICAgIHRoaXMuX3dhaXRMaXN0ID0gW107XG4gICAgICAgdGhpcy5fbG9nID0gb3B0aW9ucy5sb2cgfHwgZnVuY3Rpb24gKCkge307XG4gICAgIH1cblxuICAgICAvKipcbiAgICAgICogUmVnaXN0ZXIgYSBsb2NrLlxuICAgICAgKlxuICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQ2FsbGJhY2sgZm9yIHVubG9ja2luZy5cbiAgICAgICovXG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKERvb3JMb2NrLCBbe1xuICAgICAgIGtleTogJ2xvY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2NrKCkge1xuICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgdmFyIHVubG9jayA9IGZ1bmN0aW9uIHVubG9jaygpIHtcbiAgICAgICAgICAgX3RoaXMuX3VubG9jayh1bmxvY2spO1xuICAgICAgICAgfTtcbiAgICAgICAgIHVubG9jay5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgIHRoaXMuX2xvY2tMaXN0LnB1c2godW5sb2NrKTtcbiAgICAgICAgIHRoaXMuX2xvZygnbG9jazogJyArIHVubG9jay5pZCk7XG5cbiAgICAgICAgIHJldHVybiB1bmxvY2s7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VubG9jaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bmxvY2soZm4pIHtcbiAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2xvY2tMaXN0LmluZGV4T2YoZm4pO1xuICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZnVuY3Rpb24gaXMgbm90IHJlZ2lzdGVyZWQgaW4gdGhlIGxvY2sgbGlzdC4nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5fbG9ja0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgIHRoaXMuX2xvZygndW5sb2NrOiAnICsgZm4uaWQpO1xuXG4gICAgICAgICB0aGlzLl90cnlUb0ZyZWVXYWl0TGlzdCgpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ190cnlUb0ZyZWVXYWl0TGlzdCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90cnlUb0ZyZWVXYWl0TGlzdCgpIHtcbiAgICAgICAgIHdoaWxlICghdGhpcy5pc0xvY2tlZCgpICYmIHRoaXMuX3dhaXRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgdGhpcy5fd2FpdExpc3Quc2hpZnQoKSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZm9yIHdhaXRpbmcgdW5sb2NrZWQgZG9vci5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbXMge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBvbiB1bmxvY2tpbmcgdGhlIGRvb3IgY29tcGxldGVseS5cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnd2FpdFVubG9jaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdhaXRVbmxvY2soY2FsbGJhY2spIHtcbiAgICAgICAgIGlmICghKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNhbGxiYWNrIHBhcmFtIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQoKSkge1xuICAgICAgICAgICB0aGlzLl93YWl0TGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNMb2NrZWQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xvY2tlZCgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9sb2NrTGlzdC5sZW5ndGggPiAwO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gRG9vckxvY2s7XG4gICB9KSgpO1xuXG4gICAvKipcbiAgICAqIEBvYmplY3Qgb25zXG4gICAgKiBAY2F0ZWdvcnkgdXRpbFxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtqYV1PbnNlbiBVSeOBp+WIqeeUqOOBp+OBjeOCi+OCsOODreODvOODkOODq+OBquOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAgKiAgIFtlbl1BIGdsb2JhbCBvYmplY3QgdGhhdCdzIHVzZWQgaW4gT25zZW4gVUkuIFsvZW5dXG4gICAgKi9cbiAgIHZhciBvbnMgPSB7fTtcblxuICAgb25zLl91dGlsID0gdXRpbDtcbiAgIG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlcjtcbiAgIG9ucy5faW50ZXJuYWwgPSBpbnRlcm5hbDtcbiAgIG9ucy5HZXN0dXJlRGV0ZWN0b3IgPSBHZXN0dXJlRGV0ZWN0b3I7XG4gICBvbnMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgIG9ucy5zb2Z0d2FyZUtleWJvYXJkID0gc29mdHdhcmVLZXlib2FyZDtcbiAgIG9ucy5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbiA9IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uO1xuICAgb25zLm9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gICBvbnMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xuICAgb25zLl9hbmltYXRpb25PcHRpb25zUGFyc2VyID0gcGFyc2U7XG4gICBvbnMuX2F1dG9TdHlsZSA9IGF1dG9TdHlsZTtcbiAgIG9ucy5fRG9vckxvY2sgPSBEb29yTG9jaztcblxuICAgb25zLl9yZWFkeUxvY2sgPSBuZXcgRG9vckxvY2soKTtcblxuICAgb25zLnBsYXRmb3JtLnNlbGVjdCgod2luZG93LmxvY2F0aW9uLnNlYXJjaC5tYXRjaCgvcGxhdGZvcm09KFtcXHctXSspLykgfHwgW10pWzFdKTtcblxuICAgd2FpdERldmljZVJlYWR5KCk7XG5cbiAgIC8qKlxuICAgICogQG1ldGhvZCBpc1JlYWR5XG4gICAgKiBAc2lnbmF0dXJlIGlzUmVhZHkoKVxuICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiBPbnNlbiBVSSBpcyBpbml0aWFsaXplZC5bL2VuXVxuICAgICogICBbamFd5Yid5pyf5YyW44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dUmV0dXJucyB0cnVlIGlmIE9uc2VuIFVJIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gICAgKiAgIFtqYV1PbnNlbiBVSeOBjOOBmeOBp+OBq+WIneacn+WMluOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBmeODoeOCveODg+ODieOBp+OBmeOAglsvamFdXG4gICAgKi9cbiAgIG9ucy5pc1JlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICByZXR1cm4gIW9ucy5fcmVhZHlMb2NrLmlzTG9ja2VkKCk7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBtZXRob2QgaXNXZWJWaWV3XG4gICAgKiBAc2lnbmF0dXJlIGlzV2ViVmlldygpXG4gICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBhcHAgaXMgcnVubmluZyBpbiBDb3Jkb3ZhLlsvZW5dXG4gICAgKiAgIFtqYV1Db3Jkb3Zh44Gn5a6f6KGM44GV44KM44Gm44GE44KL5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXVJldHVybnMgdHJ1ZSBpZiBydW5uaW5nIGluc2lkZSBDb3Jkb3ZhLlsvZW5dXG4gICAgKiAgIFtqYV1Db3Jkb3Zh44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GZ44Oh44K944OD44OJ44Gn44GZ44CCWy9qYV1cbiAgICAqL1xuICAgb25zLmlzV2ViVmlldyA9IG9ucy5wbGF0Zm9ybS5pc1dlYlZpZXc7XG5cbiAgIC8qKlxuICAgICogQG1ldGhvZCByZWFkeVxuICAgICogQHNpZ25hdHVyZSByZWFkeShjYWxsYmFjaylcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbamFd44Ki44OX44Oq44Gu5Yid5pyf5YyW44Gr5Yip55So44GZ44KL44Oh44K944OD44OJ44Gn44GZ44CC5rih44GV44KM44Gf6Zai5pWw44Gv44CBT25zZW4gVUnjga7liJ3mnJ/ljJbjgYzntYLkuobjgZfjgabjgYTjgovmmYLngrnjgaflv4XjgZrlkbzjgbDjgozjgb7jgZnjgIJbL2phXVxuICAgICogICBbZW5dTWV0aG9kIHVzZWQgdG8gd2FpdCBmb3IgYXBwIGluaXRpYWxpemF0aW9uLiBUaGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgZXhlY3V0ZWQgdW50aWwgT25zZW4gVUkgaGFzIGJlZW4gY29tcGxldGVseSBpbml0aWFsaXplZC5bL2VuXVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgT25zZW4gVUkgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuWy9lbl1cbiAgICAqICAgW2phXU9uc2VuIFVJ44GM5Yid5pyf5YyW44GM5a6M5LqG44GX44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAqL1xuICAgb25zLnJlYWR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgICAgY2FsbGJhY2soKTtcbiAgICAgfSBlbHNlIHtcbiAgICAgICBvbnMuX3JlYWR5TG9jay53YWl0VW5sb2NrKGNhbGxiYWNrKTtcbiAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBAbWV0aG9kIHNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXJcbiAgICAqIEBzaWduYXR1cmUgc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lcihsaXN0ZW5lcilcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHdoZW4gZGV2aWNlIGJhY2sgYnV0dG9uIGlzIHByZXNzZWQuWy9lbl1cbiAgICAqICAgW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBjOaKvOOBleOCjOOBn+aZguOBq+Wun+ihjOOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXVNldCBkZWZhdWx0IGhhbmRsZXIgZm9yIGRldmljZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgICogICBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44Gu44Gf44KB44Gu44OH44OV44Kp44Or44OI44Gu44OP44Oz44OJ44Op44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAqL1xuICAgb25zLnNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIuc2V0TGlzdGVuZXIobGlzdGVuZXIpO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAbWV0aG9kIGRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlclxuICAgICogQHNpZ25hdHVyZSBkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIoKVxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiBbZW5dRGlzYWJsZSBkZXZpY2UgYmFjayBidXR0b24gZXZlbnQgaGFuZGxlci5bL2VuXVxuICAgICogW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOCpOODmeODs+ODiOOCkuWPl+OBkeS7mOOBkeOBquOBhOOCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgKi9cbiAgIG9ucy5kaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgIG9ucy5fZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuZGlzYWJsZSgpO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAbWV0aG9kIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gICAgKiBAc2lnbmF0dXJlIGVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogW2VuXUVuYWJsZSBkZXZpY2UgYmFjayBidXR0b24gZXZlbnQgaGFuZGxlci5bL2VuXVxuICAgICogW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOCpOODmeODs+ODiOOCkuWPl+OBkeS7mOOBkeOCi+OCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgKi9cbiAgIG9ucy5lbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgb25zLl9kZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5lbmFibGUoKTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQG1ldGhvZCBlbmFibGVBdXRvU3RhdHVzQmFyRmlsbFxuICAgICogQHNpZ25hdHVyZSBlbmFibGVBdXRvU3RhdHVzQmFyRmlsbCgpXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXUVuYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZS5bL2VuXVxuICAgICogICBbamFdaU9TN+S7peS4iuOBp+OAgeOCueODhuODvOOCv+OCueODkOODvOmDqOWIhuOBrumrmOOBleOCkuiHquWLleeahOOBq+Wfi+OCgeOCi+WHpueQhuOCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgKi9cbiAgIG9ucy5lbmFibGVBdXRvU3RhdHVzQmFyRmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvbnMuaXNSZWFkeSgpIGlzIHRydWUuJyk7XG4gICAgIH1cbiAgICAgb25zLl9pbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGwgPSB0cnVlO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAbWV0aG9kIGRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbFxuICAgICogQHNpZ25hdHVyZSBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwoKVxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1EaXNhYmxlIHN0YXR1cyBiYXIgZmlsbCBmZWF0dXJlIG9uIGlPUzcgYW5kIGFib3ZlLlsvZW5dXG4gICAgKiAgIFtqYV1pT1M35Lul5LiK44Gn44CB44K544OG44O844K/44K544OQ44O86YOo5YiG44Gu6auY44GV44KS6Ieq5YuV55qE44Gr5Z+L44KB44KL5Yem55CG44KS54Sh5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAqL1xuICAgb25zLmRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvbnMuaXNSZWFkeSgpIGlzIHRydWUuJyk7XG4gICAgIH1cbiAgICAgb25zLl9pbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGwgPSBmYWxzZTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQG1ldGhvZCBkaXNhYmxlQW5pbWF0aW9uc1xuICAgICogQHNpZ25hdHVyZSBkaXNhYmxlQW5pbWF0aW9ucygpXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXURpc2FibGUgYWxsIGFuaW1hdGlvbnMuIENvdWxkIGJlIGhhbmR5IGZvciB0ZXN0aW5nIGFuZCBvbGRlciBkZXZpY2VzLlsvZW5dXG4gICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLlhajjgabnhKHlirnjgavjgZfjgb7jgZnjgILjg4bjgrnjg4jjga7pmpvjgavkvr/liKnjgafjgZnjgIJbL2phXVxuICAgICovXG4gICBvbnMuZGlzYWJsZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgIG9ucy5faW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA9IHRydWU7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBtZXRob2QgZW5hYmxlQW5pbWF0aW9uc1xuICAgICogQHNpZ25hdHVyZSBlbmFibGVBbmltYXRpb25zKClcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dRW5hYmxlIGFuaW1hdGlvbnMgKGRlZmF1bHQpLlsvZW5dXG4gICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgICovXG4gICBvbnMuZW5hYmxlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgb25zLl9pbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkID0gZmFsc2U7XG4gICB9O1xuXG4gICAvKipcbiAgICAqIERpc2FibGUgYXV0b21hdGljIHN0eWxpbmcuXG4gICAgKi9cbiAgIG9ucy5kaXNhYmxlQXV0b1N0eWxpbmcgPSBvbnMuX2F1dG9TdHlsZS5kaXNhYmxlO1xuXG4gICAvKipcbiAgICAqIEVuYWJsZSBhdXRvbWF0aWMgc3R5bGluZyBiYXNlZCBvbiBPUyAoZGVmYXVsdCkuXG4gICAgKi9cbiAgIG9ucy5lbmFibGVBdXRvU3R5bGluZyA9IG9ucy5fYXV0b1N0eWxlLmVuYWJsZTtcblxuICAgLyoqXG4gICAgKiBAbWV0aG9kIGZvcmNlUGxhdGZvcm1TdHlsaW5nXG4gICAgKiBAc2lnbmF0dXJlIGZvcmNlUGxhdGZvcm1TdHlsaW5nKHBsYXRmb3JtKVxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1SZWZyZXNoIHN0eWxpbmcgZm9yIHRoZSBnaXZlbiBwbGF0Zm9ybS5bL2VuXVxuICAgICogICBbamFdWy9qYV1cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBwbGF0Zm9ybSBOZXcgcGxhdGZvcm0gdG8gc3R5bGUgdGhlIGVsZW1lbnRzLlxuICAgICovXG4gICBvbnMuZm9yY2VQbGF0Zm9ybVN0eWxpbmcgPSBmdW5jdGlvbiAobmV3UGxhdGZvcm0pIHtcbiAgICAgb25zLmVuYWJsZUF1dG9TdHlsaW5nKCk7XG4gICAgIG9ucy5wbGF0Zm9ybS5zZWxlY3QobmV3UGxhdGZvcm0gfHwgJ2lvcycpO1xuICAgICBvbnMuX3V0aWwuYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ29ucy1pZicpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgZWxlbWVudC5fcGxhdGZvcm1VcGRhdGUoKTtcbiAgICAgfSk7XG4gICAgIG9ucy5fdXRpbC5hcnJheUZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW19jb21waWxlZF0nKSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgIG9ucy5fYXV0b1N0eWxlLnByZXBhcmUoZWxlbWVudCwgdHJ1ZSk7XG4gICAgIH0pO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMubGlua11cbiAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgIG9ucy5fY3JlYXRlUG9wb3Zlck9yaWdpbmFsID0gZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICBpZiAoIXBhZ2UpIHtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgdXJsIG11c3QgYmUgZGVmaW5lZC4nKTtcbiAgICAgfVxuXG4gICAgIHJldHVybiBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgIGh0bWwgPSBodG1sLm1hdGNoKC88b25zLXBvcG92ZXIvZ2kpID8gJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+JyA6ICc8b25zLXBvcG92ZXI+JyArIGh0bWwgKyAnPC9vbnMtcG9wb3Zlcj4nO1xuICAgICAgIHZhciBkaXYgPSBvbnMuX3V0aWwuY3JlYXRlRWxlbWVudCgnPGRpdj4nICsgaHRtbCArICc8L2Rpdj4nKTtcblxuICAgICAgIHZhciBwb3BvdmVyID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ29ucy1wb3BvdmVyJyk7XG4gICAgICAgQ3VzdG9tRWxlbWVudHMudXBncmFkZShwb3BvdmVyKTtcbiAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBvcG92ZXIpO1xuXG4gICAgICAgaWYgKG9wdGlvbnMubGluayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICBvcHRpb25zLmxpbmsocG9wb3Zlcik7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIHBvcG92ZXI7XG4gICAgIH0pO1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAbWV0aG9kIGNyZWF0ZVBvcG92ZXJcbiAgICAqIEBzaWduYXR1cmUgY3JlYXRlUG9wb3ZlcihwYWdlLCBbb3B0aW9uc10pXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiA8b25zLXRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyZW50U2NvcGVdXG4gICAgKiAgIFtlbl1QYXJlbnQgc2NvcGUgb2YgdGhlIGRpYWxvZy4gVXNlZCB0byBiaW5kIG1vZGVscyBhbmQgYWNjZXNzIHNjb3BlIG1ldGhvZHMgZnJvbSB0aGUgZGlhbG9nLlsvZW5dXG4gICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDlhoXjgafliKnnlKjjgZnjgovopqrjgrnjgrPjg7zjg5fjgpLmjIflrprjgZfjgb7jgZnjgILjg4DjgqTjgqLjg63jgrDjgYvjgonjg6Ljg4fjg6vjgoTjgrnjgrPjg7zjg5fjga7jg6Hjgr3jg4Pjg4njgavjgqLjgq/jgrvjgrnjgZnjgovjga7jgavkvb/jgYTjgb7jgZnjgILjgZPjga7jg5Hjg6njg6Hjg7zjgr/jga9Bbmd1bGFySlPjg5DjgqTjg7Pjg4fjgqPjg7PjgrDjgafjga7jgb/liKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBvcG92ZXIgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXUNyZWF0ZSBhIHBvcG92ZXIgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gICAgKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICAgICovXG4gICBvbnMuY3JlYXRlUG9wb3ZlciA9IG9ucy5fY3JlYXRlUG9wb3Zlck9yaWdpbmFsO1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5saW5rXVxuICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgb25zLl9jcmVhdGVEaWFsb2dPcmlnaW5hbCA9IGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYWdlIHVybCBtdXN0IGJlIGRlZmluZWQuJyk7XG4gICAgIH1cblxuICAgICByZXR1cm4gb25zLl9pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICBodG1sID0gaHRtbC5tYXRjaCgvPG9ucy1kaWFsb2cvZ2kpID8gJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+JyA6ICc8b25zLWRpYWxvZz4nICsgaHRtbCArICc8L29ucy1kaWFsb2c+JztcbiAgICAgICB2YXIgZGl2ID0gb25zLl91dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG5cbiAgICAgICB2YXIgZGlhbG9nID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ29ucy1kaWFsb2cnKTtcbiAgICAgICBDdXN0b21FbGVtZW50cy51cGdyYWRlKGRpYWxvZyk7XG4gICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaWFsb2cpO1xuXG4gICAgICAgaWYgKG9wdGlvbnMubGluayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICBvcHRpb25zLmxpbmsoZGlhbG9nKTtcbiAgICAgICB9XG5cbiAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgICB9KTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQG1ldGhvZCBjcmVhdGVEaWFsb2dcbiAgICAqIEBzaWduYXR1cmUgY3JlYXRlRGlhbG9nKHBhZ2UsIFtvcHRpb25zXSlcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAgKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGFuIDxvbnMtdGVtcGxhdGU+IGNvbnRhaW5pbmcgYSA8b25zLWRpYWxvZz4gY29tcG9uZW50LlsvZW5dXG4gICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKiAgIFtlbl1Qcm9taXNlIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBkaWFsb2cgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXUNyZWF0ZSBhIGRpYWxvZyBpbnN0YW5jZSBmcm9tIGEgdGVtcGxhdGUuWy9lbl1cbiAgICAqICAgW2phXeODhuODs+ODl+ODrOODvOODiOOBi+OCieODgOOCpOOCouODreOCsOOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gICAgKi9cbiAgIG9ucy5jcmVhdGVEaWFsb2cgPSBvbnMuX2NyZWF0ZURpYWxvZ09yaWdpbmFsO1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5saW5rXVxuICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgb25zLl9jcmVhdGVBbGVydERpYWxvZ09yaWdpbmFsID0gZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICBpZiAoIXBhZ2UpIHtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgdXJsIG11c3QgYmUgZGVmaW5lZC4nKTtcbiAgICAgfVxuXG4gICAgIHJldHVybiBvbnMuX2ludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgIGh0bWwgPSBodG1sLm1hdGNoKC88b25zLWFsZXJ0LWRpYWxvZy9naSkgPyAnPGRpdj4nICsgaHRtbCArICc8L2Rpdj4nIDogJzxvbnMtYWxlcnQtZGlhbG9nPicgKyBodG1sICsgJzwvb25zLWFsZXJ0LWRpYWxvZz4nO1xuICAgICAgIHZhciBkaXYgPSBvbnMuX3V0aWwuY3JlYXRlRWxlbWVudCgnPGRpdj4nICsgaHRtbCArICc8L2Rpdj4nKTtcblxuICAgICAgIHZhciBhbGVydERpYWxvZyA9IGRpdi5xdWVyeVNlbGVjdG9yKCdvbnMtYWxlcnQtZGlhbG9nJyk7XG4gICAgICAgQ3VzdG9tRWxlbWVudHMudXBncmFkZShhbGVydERpYWxvZyk7XG4gICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhbGVydERpYWxvZyk7XG5cbiAgICAgICBpZiAob3B0aW9ucy5saW5rIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgIG9wdGlvbnMubGluayhhbGVydERpYWxvZyk7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIGFsZXJ0RGlhbG9nO1xuICAgICB9KTtcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQG1ldGhvZCBjcmVhdGVBbGVydERpYWxvZ1xuICAgICogQHNpZ25hdHVyZSBjcmVhdGVBbGVydERpYWxvZyhwYWdlLCBbb3B0aW9uc10pXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiA8b25zLXRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1hbGVydC1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICogICBbZW5dUHJvbWlzZSBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgYWxlcnQgZGlhbG9nIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICAqICAgW2phXeODgOOCpOOCouODreOCsOOBruOCs+ODs+ODneODvOODjeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1DcmVhdGUgYSBhbGVydCBkaWFsb2cgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gICAgKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICAgICovXG4gICBvbnMuY3JlYXRlQWxlcnREaWFsb2cgPSBvbnMuX2NyZWF0ZUFsZXJ0RGlhbG9nT3JpZ2luYWw7XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtcbiAgICAqL1xuICAgb25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyT3JpZ2luYWwgPSBmdW5jdGlvbiAocGFnZSwgbGluaykge1xuICAgICB2YXIgZWxlbWVudHMgPSBvbnMuX3V0aWwuYXJyYXlGcm9tKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLWxvYWRpbmctcGxhY2Vob2xkZXJdJykpO1xuXG4gICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgZWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICByZXR1cm4gIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwYWdlJyk7XG4gICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyJywgcGFnZSk7XG4gICAgICAgICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIoZWxlbWVudCwgcGFnZSwgbGluayk7XG4gICAgICAgfSk7XG4gICAgIH0gZWxzZSB7XG4gICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBvbnMtbG9hZGluZy1wbGFjZWhvbGRlciBleGlzdHMuJyk7XG4gICAgIH1cbiAgIH07XG5cbiAgIC8qKlxuICAgICogQG1ldGhvZCByZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyXG4gICAgKiBAc2lnbmF0dXJlIHJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIocGFnZSlcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAgKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGFuIDxvbnMtdGVtcGxhdGU+IGVsZW1lbnQuWy9lbl1cbiAgICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXUlmIG5vIHBhZ2UgaXMgZGVmaW5lZCBmb3IgdGhlIGBvbnMtbG9hZGluZy1wbGFjZWhvbGRlcmAgYXR0cmlidXRlIGl0IHdpbGwgd2FpdCBmb3IgdGhpcyBtZXRob2QgYmVpbmcgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIHRoZSBwYWdlLlsvZW5dXG4gICAgKiAgIFtqYV1vbnMtbG9hZGluZy1wbGFjZWhvbGRlcuOBruWxnuaAp+WApOOBqOOBl+OBpuODmuODvOOCuOOBjOaMh+WumuOBleOCjOOBpuOBhOOBquOBhOWgtOWQiOOBr+OAgeODmuODvOOCuOODreODvOODieWJjeOBq+WRvOOBsOOCjOOCi29ucy5yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVy5Yem55CG44GM6KGM44KP44KM44KL44G+44Gn6KGo56S644GV44KM44G+44Gb44KT44CCWy9qYV1cbiAgICAqL1xuICAgb25zLnJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIgPSBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXJPcmlnaW5hbDtcblxuICAgb25zLl9zZXR1cExvYWRpbmdQbGFjZUhvbGRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgIG9ucy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgdmFyIGVsZW1lbnRzID0gb25zLl91dGlsLmFycmF5RnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyXScpKTtcblxuICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgIHZhciBwYWdlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyJyk7XG4gICAgICAgICBpZiAodHlwZW9mIHBhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgIG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihlbGVtZW50LCBwYWdlKTtcbiAgICAgICAgIH1cbiAgICAgICB9KTtcbiAgICAgfSk7XG4gICB9O1xuXG4gICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFnZSwgbGluaykge1xuICAgICBsaW5rID0gbGluayB8fCBmdW5jdGlvbiAoZWxlbWVudCwgZG9uZSkge1xuICAgICAgIGRvbmUoKTtcbiAgICAgfTtcbiAgICAgb25zLl9pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oZnVuY3Rpb24gKGh0bWwpIHtcblxuICAgICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICB9XG5cbiAgICAgICB2YXIgY29udGVudEVsZW1lbnQgPSBvbnMuX3V0aWwuY3JlYXRlRWxlbWVudCgnPGRpdj4nICsgaHRtbCArICc8L2Rpdj4nKTtcbiAgICAgICBjb250ZW50RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjb250ZW50RWxlbWVudCk7XG5cbiAgICAgICBsaW5rKGNvbnRlbnRFbGVtZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICBjb250ZW50RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgfSk7XG4gICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlZCB0byByZXNvbHZlIHBsYWNlaG9sZGVyOiAnICsgZXJyb3IpO1xuICAgICB9KTtcbiAgIH07XG5cbiAgIGZ1bmN0aW9uIHdhaXREZXZpY2VSZWFkeSgpIHtcbiAgICAgdmFyIHVubG9ja0RldmljZVJlYWR5ID0gb25zLl9yZWFkeUxvY2subG9jaygpO1xuICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignV2ViQ29tcG9uZW50c1JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgIGlmIChvbnMuaXNXZWJWaWV3KCkpIHtcbiAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIHVubG9ja0RldmljZVJlYWR5LCBmYWxzZSk7XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHVubG9ja0RldmljZVJlYWR5KCk7XG4gICAgICAgfVxuICAgICB9LCBmYWxzZSk7XG4gICB9XG5cbiAgIC8qXG4gICBDb3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiAgICovXG5cbiAgIHZhciBCYXNlRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICB2YXIgQmFzZUVsZW1lbnQgPSBmdW5jdGlvbiBCYXNlRWxlbWVudCgpIHt9O1xuICAgICAgIEJhc2VFbGVtZW50LnByb3RvdHlwZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgIHJldHVybiBCYXNlRWxlbWVudDtcbiAgICAgfSBlbHNlIHtcbiAgICAgICByZXR1cm4gSFRNTEVsZW1lbnQ7XG4gICAgIH1cbiAgIH0pKCk7XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLXRlbXBsYXRlXG4gICAgKiBAY2F0ZWdvcnkgdXRpbFxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1EZWZpbmUgYSBzZXBhcmF0ZSBIVE1MIGZyYWdtZW50IGFuZCB1c2UgYXMgYSB0ZW1wbGF0ZS5bL2VuXVxuICAgICogICBbamFd44OG44Oz44OX44Os44O844OI44Go44GX44Gm5L2/55So44GZ44KL44Gf44KB44GuSFRNTOODleODqeOCsOODoeODs+ODiOOCkuWumue+qeOBl+OBvuOBmeOAguOBk+OBruimgee0oOOBp0hUTUzjgpLlrqPoqIDjgZnjgovjgajjgIFpZOWxnuaAp+OBq+aMh+WumuOBl+OBn+WQjeWJjeOCknBhZ2Xjga5VUkzjgajjgZfjgaZvbnMtbmF2aWdhdG9y44Gq44Gp44Gu44Kz44Oz44Od44O844ON44Oz44OI44GL44KJ5Y+C54Wn44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAqIEBndWlkZSBEZWZpbmluZ011bHRpcGxlUGFnZXNpblNpbmdsZUhUTUxcbiAgICAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cbiAgICAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkjHjgaTjga5IVE1M44Gr6KiY6L+w44GZ44KLWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8b25zLXRlbXBsYXRlIGlkPVwiZm9vYmFyLmh0bWxcIj5cbiAgICAqICAgLi4uXG4gICAgKiA8L29ucy10ZW1wbGF0ZT5cbiAgICAqL1xuXG4gICB2YXIgVGVtcGxhdGVFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKFRlbXBsYXRlRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBUZW1wbGF0ZUVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFRlbXBsYXRlRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihUZW1wbGF0ZUVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKFRlbXBsYXRlRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5pbm5lckhUTUw7XG5cbiAgICAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdfdGVtcGxhdGVsb2FkZWQnLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSk7XG4gICAgICAgICBldmVudC50ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgICAgICBldmVudC50ZW1wbGF0ZUlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBUZW1wbGF0ZUVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNUZW1wbGF0ZUVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy10ZW1wbGF0ZScsIHtcbiAgICAgcHJvdG90eXBlOiBUZW1wbGF0ZUVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgdmFyIENvbmRpdGlvbmFsRWxlbWVudCA9IChmdW5jdGlvbiAoX0Jhc2VFbGVtZW50KSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhDb25kaXRpb25hbEVsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25kaXRpb25hbEVsZW1lbnQpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29uZGl0aW9uYWxFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhDb25kaXRpb25hbEVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgaWYgKHBsYXRmb3JtLl9yZW5kZXJQbGF0Zm9ybSAhPT0gbnVsbCkge1xuICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSkge1xuICAgICAgICAgICB0aGlzLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICBvcmllbnRhdGlvbi5vbignY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSkge1xuICAgICAgICAgaWYgKG5hbWUgPT09ICdvcmllbnRhdGlvbicpIHtcbiAgICAgICAgICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RldGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfcGxhdGZvcm1VcGRhdGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhdGZvcm1VcGRhdGUoKSB7XG4gICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSB0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpID8gJycgOiAnbm9uZSc7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2lzQWxsb3dlZFBsYXRmb3JtJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQWxsb3dlZFBsYXRmb3JtKCkge1xuICAgICAgICAgcmV0dXJuICF0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKS5zcGxpdCgvXFxzKy8pLmluZGV4T2YocGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSkgPj0gMDtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25PcmllbnRhdGlvbkNoYW5nZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk9yaWVudGF0aW9uQ2hhbmdlKCkge1xuICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdvcmllbnRhdGlvbicpICYmIHRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkpIHtcbiAgICAgICAgICAgdmFyIGNvbmRpdGlvbmFsT3JpZW50YXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnb3JpZW50YXRpb24nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICB2YXIgY3VycmVudE9yaWVudGF0aW9uID0gb3JpZW50YXRpb24uaXNQb3J0cmFpdCgpID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnO1xuXG4gICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IGNvbmRpdGlvbmFsT3JpZW50YXRpb24gPT09IGN1cnJlbnRPcmllbnRhdGlvbiA/ICcnIDogJ25vbmUnO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gQ29uZGl0aW9uYWxFbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zQ29uZGl0aW9uYWxFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtaWYnLCB7XG4gICAgIHByb3RvdHlwZTogQ29uZGl0aW9uYWxFbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIC8qXG4gICBDb3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiAgICovXG5cbiAgIHZhciBBbGVydERpYWxvZ0FuaW1hdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgZnVuY3Rpb24gQWxlcnREaWFsb2dBbmltYXRvcigpIHtcbiAgICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgdmFyIF9yZWYkdGltaW5nID0gX3JlZi50aW1pbmc7XG4gICAgICAgdmFyIHRpbWluZyA9IF9yZWYkdGltaW5nID09PSB1bmRlZmluZWQgPyAnbGluZWFyJyA6IF9yZWYkdGltaW5nO1xuICAgICAgIHZhciBfcmVmJGRlbGF5ID0gX3JlZi5kZWxheTtcbiAgICAgICB2YXIgZGVsYXkgPSBfcmVmJGRlbGF5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRkZWxheTtcbiAgICAgICB2YXIgX3JlZiRkdXJhdGlvbiA9IF9yZWYuZHVyYXRpb247XG4gICAgICAgdmFyIGR1cmF0aW9uID0gX3JlZiRkdXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gMC4yIDogX3JlZiRkdXJhdGlvbjtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgQWxlcnREaWFsb2dBbmltYXRvcik7XG5cbiAgICAgICB0aGlzLnRpbWluZyA9IHRpbWluZztcbiAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICB9XG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAgICAqL1xuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhBbGVydERpYWxvZ0FuaW1hdG9yLCBbe1xuICAgICAgIGtleTogJ3Nob3cnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KGRpYWxvZywgZG9uZSkge1xuICAgICAgICAgZG9uZSgpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaGlkZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoZGlhbG9nLCBkb25lKSB7XG4gICAgICAgICBkb25lKCk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBBbGVydERpYWxvZ0FuaW1hdG9yO1xuICAgfSkoKTtcblxuICAgLyoqXG4gICAgKiBBbmRyb2lkIHN0eWxlIGFuaW1hdG9yIGZvciBhbGVydCBkaWFsb2cuXG4gICAgKi9cbiAgIHZhciBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvciA9IChmdW5jdGlvbiAoX0FsZXJ0RGlhbG9nQW5pbWF0b3IpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yLCBfQWxlcnREaWFsb2dBbmltYXRvcik7XG5cbiAgICAgZnVuY3Rpb24gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICB2YXIgX3JlZjIkdGltaW5nID0gX3JlZjIudGltaW5nO1xuICAgICAgIHZhciB0aW1pbmcgPSBfcmVmMiR0aW1pbmcgPT09IHVuZGVmaW5lZCA/ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknIDogX3JlZjIkdGltaW5nO1xuICAgICAgIHZhciBfcmVmMiRkdXJhdGlvbiA9IF9yZWYyLmR1cmF0aW9uO1xuICAgICAgIHZhciBkdXJhdGlvbiA9IF9yZWYyJGR1cmF0aW9uID09PSB1bmRlZmluZWQgPyAwLjIgOiBfcmVmMiRkdXJhdGlvbjtcbiAgICAgICB2YXIgX3JlZjIkZGVsYXkgPSBfcmVmMi5kZWxheTtcbiAgICAgICB2YXIgZGVsYXkgPSBfcmVmMiRkZWxheSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYyJGRlbGF5O1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvcik7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvcikuY2FsbCh0aGlzLCB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgdGltaW5nOiB0aW1pbmcsIGRlbGF5OiBkZWxheSB9KSk7XG4gICAgIH1cblxuICAgICAvKipcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgKi9cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IsIFt7XG4gICAgICAga2V5OiAnc2hvdycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgIGFuaW1pdC5ydW5BbGwoYW5pbWl0KGRpYWxvZy5fbWFzaykucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICB9LCB7XG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KSwgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMC45LCAwLjksIDEuMCknLFxuICAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMS4wLCAxLjAsIDEuMCknLFxuICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkucmVzdG9yZVN0eWxlKCkucXVldWUoZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgfSkpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdoaWRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICAgYW5pbWl0LnJ1bkFsbChhbmltaXQoZGlhbG9nLl9tYXNrKS5xdWV1ZSh7XG4gICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgIH0sIHtcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLCBhbmltaXQoZGlhbG9nLl9kaWFsb2cpLnNhdmVTdHlsZSgpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjAsIDEuMCwgMS4wKScsXG4gICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgwLjksIDAuOSwgMS4wKScsXG4gICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KS5yZXN0b3JlU3R5bGUoKS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICB9KSk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvcjtcbiAgIH0pKEFsZXJ0RGlhbG9nQW5pbWF0b3IpO1xuXG4gICAvKipcbiAgICAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgYWxlcnQgZGlhbG9nLlxuICAgICovXG4gICB2YXIgSU9TQWxlcnREaWFsb2dBbmltYXRvciA9IChmdW5jdGlvbiAoX0FsZXJ0RGlhbG9nQW5pbWF0b3IyKSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhJT1NBbGVydERpYWxvZ0FuaW1hdG9yLCBfQWxlcnREaWFsb2dBbmltYXRvcjIpO1xuXG4gICAgIGZ1bmN0aW9uIElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICB2YXIgX3JlZjMkdGltaW5nID0gX3JlZjMudGltaW5nO1xuICAgICAgIHZhciB0aW1pbmcgPSBfcmVmMyR0aW1pbmcgPT09IHVuZGVmaW5lZCA/ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknIDogX3JlZjMkdGltaW5nO1xuICAgICAgIHZhciBfcmVmMyRkdXJhdGlvbiA9IF9yZWYzLmR1cmF0aW9uO1xuICAgICAgIHZhciBkdXJhdGlvbiA9IF9yZWYzJGR1cmF0aW9uID09PSB1bmRlZmluZWQgPyAwLjIgOiBfcmVmMyRkdXJhdGlvbjtcbiAgICAgICB2YXIgX3JlZjMkZGVsYXkgPSBfcmVmMy5kZWxheTtcbiAgICAgICB2YXIgZGVsYXkgPSBfcmVmMyRkZWxheSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYzJGRlbGF5O1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBJT1NBbGVydERpYWxvZ0FuaW1hdG9yKTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IpLmNhbGwodGhpcywgeyBkdXJhdGlvbjogZHVyYXRpb24sIHRpbWluZzogdGltaW5nLCBkZWxheTogZGVsYXkgfSkpO1xuICAgICB9XG5cbiAgICAgLypcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgKi9cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoSU9TQWxlcnREaWFsb2dBbmltYXRvciwgW3tcbiAgICAgICBrZXk6ICdzaG93JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICAgYW5pbWl0LnJ1bkFsbChhbmltaXQoZGlhbG9nLl9tYXNrKS5xdWV1ZSh7XG4gICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgIH0sIHtcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLCBhbmltaXQoZGlhbG9nLl9kaWFsb2cpLnNhdmVTdHlsZSgpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjMsIDEuMywgMS4wKScsXG4gICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjAsIDEuMCwgMS4wKScsXG4gICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KS5yZXN0b3JlU3R5bGUoKS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICB9KSk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2hpZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICBhbmltaXQucnVuQWxsKGFuaW1pdChkaWFsb2cuX21hc2spLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgfSwge1xuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSksIGFuaW1pdChkaWFsb2cuX2RpYWxvZykuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIElPU0FsZXJ0RGlhbG9nQW5pbWF0b3I7XG4gICB9KShBbGVydERpYWxvZ0FuaW1hdG9yKTtcblxuICAgdmFyIHNjaGVtZSQxID0ge1xuICAgICAnLmFsZXJ0LWRpYWxvZyc6ICdhbGVydC1kaWFsb2ctLSonLFxuICAgICAnLmFsZXJ0LWRpYWxvZy1jb250YWluZXInOiAnYWxlcnQtZGlhbG9nLWNvbnRhaW5lci0tKicsXG4gICAgICcuYWxlcnQtZGlhbG9nLXRpdGxlJzogJ2FsZXJ0LWRpYWxvZy10aXRsZS0tKicsXG4gICAgICcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnOiAnYWxlcnQtZGlhbG9nLWNvbnRlbnQtLSonLFxuICAgICAnLmFsZXJ0LWRpYWxvZy1mb290ZXInOiAnYWxlcnQtZGlhbG9nLWZvb3Rlci0tKicsXG4gICAgICcuYWxlcnQtZGlhbG9nLWJ1dHRvbic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS0qJyxcbiAgICAgJy5hbGVydC1kaWFsb2ctZm9vdGVyLS1vbmUnOiAnYWxlcnQtZGlhbG9nLWZvb3Rlci0tb25lLS0qJyxcbiAgICAgJy5hbGVydC1kaWFsb2ctYnV0dG9uLS1vbmUnOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tb25lLS0qJyxcbiAgICAgJy5hbGVydC1kaWFsb2ctYnV0dG9uLS1wcmltYWwnOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsLS0qJyxcbiAgICAgJy5hbGVydC1kaWFsb2ctbWFzayc6ICdhbGVydC1kaWFsb2ctbWFzay0tKidcbiAgIH07XG5cbiAgIHZhciB0ZW1wbGF0ZVNvdXJjZSA9IHV0aWwuY3JlYXRlRWxlbWVudCgnXFxuICA8ZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLW1hc2tcIj48L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZ1wiPlxcbiAgICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGFpbmVyXCI+PC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuJyk7XG5cbiAgIHZhciBfYW5pbWF0b3JEaWN0ID0ge1xuICAgICAnbm9uZSc6IEFsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICAgICdkZWZhdWx0JzogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgcmV0dXJuIHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yO1xuICAgICB9LFxuICAgICAnZmFkZSc6IGZ1bmN0aW9uIGZhZGUoKSB7XG4gICAgICAgcmV0dXJuIHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yO1xuICAgICB9XG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBlbGVtZW50IG9ucy1hbGVydC1kaWFsb2dcbiAgICAqIEBjYXRlZ29yeSBkaWFsb2dcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dQWxlcnQgZGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgY3VycmVudCBzY3JlZW4uWy9lbl1cbiAgICAqICAgW2phXeePvuWcqOOBruOCueOCr+ODquODvOODs+OBq+OCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAY29kZXBlbiBRd3d4eXBcbiAgICAqIEBndWlkZSBVc2luZ0FsZXJ0XG4gICAgKiAgIFtlbl1MZWFybiBob3cgdG8gdXNlIHRoZSBhbGVydCBkaWFsb2cuWy9lbl1cbiAgICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruS9v+OBhOaWueOBruino+iqrOOAglsvamFdXG4gICAgKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gICAgKiAgIFtlbl1vbnMtZGlhbG9nIGNvbXBvbmVudFsvZW5dXG4gICAgKiAgIFtqYV1vbnMtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gICAgKiAgIFtlbl1vbnMtcG9wb3ZlciBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gICAgKiBAc2VlYWxzbyBvbnMubm90aWZpY2F0aW9uXG4gICAgKiAgIFtlbl1Vc2luZyBvbnMubm90aWZpY2F0aW9uIHV0aWxpdHkgZnVuY3Rpb25zLlsvZW5dXG4gICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovjgavjga/jgIFvbnMubm90aWZpY2F0aW9u44Kq44OW44K444Kn44Kv44OI44Gu44Oh44K944OD44OJ44KS5L2/44GG44GT44Go44KC44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8c2NyaXB0PlxuICAgICogICBvbnMucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgKiAgICAgb25zLmNyZWF0ZUFsZXJ0RGlhbG9nKCdhbGVydC5odG1sJykudGhlbihmdW5jdGlvbihhbGVydERpYWxvZykge1xuICAgICogICAgICAgYWxlcnREaWFsb2cuc2hvdygpO1xuICAgICogICAgIH0pO1xuICAgICogICB9KTtcbiAgICAqIDwvc2NyaXB0PlxuICAgICpcbiAgICAqIDxzY3JpcHQgdHlwZT1cInRleHQvb25zLXRlbXBsYXRlXCIgaWQ9XCJhbGVydC5odG1sXCI+XG4gICAgKiAgIDxvbnMtYWxlcnQtZGlhbG9nIGFuaW1hdGlvbj1cImRlZmF1bHRcIiBjYW5jZWxhYmxlPlxuICAgICogICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctdGl0bGVcIj5XYXJuaW5nITwvZGl2PlxuICAgICogICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGVudFwiPlxuICAgICogICAgICAgQW4gZXJyb3IgaGFzIG9jY3VycmVkIVxuICAgICogICAgIDwvZGl2PlxuICAgICogICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctZm9vdGVyXCI+XG4gICAgKiAgICAgICA8YnV0dG9uIGNsYXNzPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiPk9LPC9idXR0b24+XG4gICAgKiAgICAgPC9kaXY+XG4gICAgKiAgIDwvb25zLWFsZXJ0LWRpYWxvZz5cbiAgICAqIDwvc2NyaXB0PlxuICAgICovXG5cbiAgIHZhciBBbGVydERpYWxvZ0VsZW1lbnQgPSAoZnVuY3Rpb24gKF9CYXNlRWxlbWVudCkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoQWxlcnREaWFsb2dFbGVtZW50LCBfQmFzZUVsZW1lbnQpO1xuXG4gICAgIGZ1bmN0aW9uIEFsZXJ0RGlhbG9nRWxlbWVudCgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgQWxlcnREaWFsb2dFbGVtZW50KTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEFsZXJ0RGlhbG9nRWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoQWxlcnREaWFsb2dFbGVtZW50LCBbe1xuICAgICAgIGtleTogJ2NyZWF0ZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICAgICAgIHRoaXMuX2JvdW5kQ2FuY2VsID0gdGhpcy5fY2FuY2VsLmJpbmQodGhpcyk7XG5cbiAgICAgICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICAgICAgIGJhc2VDbGFzczogQWxlcnREaWFsb2dBbmltYXRvcixcbiAgICAgICAgICAgYmFzZUNsYXNzTmFtZTogJ0FsZXJ0RGlhbG9nQW5pbWF0b3InLFxuICAgICAgICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICAgICAgIH0pO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jb21waWxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBpbGUoKSB7XG4gICAgICAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAgdmFyIHRlbXBsYXRlID0gdGVtcGxhdGVTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgdmFyIGFsZXJ0RGlhbG9nID0gdGVtcGxhdGUuY2hpbGRyZW5bMV07XG5cbiAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICBhbGVydERpYWxvZy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgc3R5bGUpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgIGFsZXJ0RGlhbG9nLmNoaWxkcmVuWzBdLmFwcGVuZENoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHdoaWxlICh0ZW1wbGF0ZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICAgICAgIHRoaXMuX21hc2suc3R5bGUuekluZGV4ID0gMjAwMDA7XG5cbiAgICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpKSB7XG4gICAgICAgICAgIHRoaXMuX21hc2suc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hc2stY29sb3InKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUkMSk7XG5cbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBzZXREaXNhYmxlZFxuICAgICAgICAqIEBzaWduYXR1cmUgc2V0RGlzYWJsZWQoZGlzYWJsZWQpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRGlzYWJsZSBvciBlbmFibGUgdGhlIGFsZXJ0IGRpYWxvZy5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBruOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkmRpc2FibGVk54q25oWL44Gr44GZ44KL44GL44Gp44GG44GL44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkXG4gICAgICAgICogICBbZW5dSWYgdHJ1ZSB0aGUgZGlhbG9nIHdpbGwgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1kaXNhYmxlZOeKtuaFi+OBq+OBmeOCi+OBi+OBqeOBhuOBi+OCkuecn+WBveWApOOBp+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldERpc2FibGVkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgICAgIGlmICh0eXBlb2YgZGlzYWJsZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuLicpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJycpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc0Rpc2FibGVkXG4gICAgICAgICogQHNpZ25hdHVyZSBpc0Rpc2FibGVkKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZCBvciBlbmFibGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GMZGlzYWJsZWTnirbmhYvjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogICBbZW5ddHJ1ZSBpZiB0aGUgZGlhbG9nIGlzIGRpc2FibGVkLlsvZW5dXG4gICAgICAgICogICBbamFdZGlzYWJsZWTnirbmhYvjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNEaXNhYmxlZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGlzYWJsZWQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBzZXRDYW5jZWxhYmxlXG4gICAgICAgICogQHNpZ25hdHVyZSBzZXRDYW5jZWxhYmxlKGNhbmNlbGFibGUpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRGVmaW5lIHdoZXRoZXIgdGhlIGRpYWxvZyBjYW4gYmUgY2FuY2VsZWQgYnkgdGhlIHVzZXIgb3Igbm90LlsvZW5dXG4gICAgICAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44Gf6Zqb44Gr44CB44Om44O844K244GM44Gd44Gu44OA44Kk44Ki44Ot44Kw44KS44Kt44Oj44Oz44K744Or44Gn44GN44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGVcbiAgICAgICAgKiAgIFtlbl1JZiB0cnVlIHRoZSBkaWFsb2cgd2lsbCBiZSBjYW5jZWxhYmxlLlsvZW5dXG4gICAgICAgICogICBbamFd44Kt44Oj44Oz44K744Or44Gn44GN44KL44GL44Gp44GG44GL44KS55yf5YG95YCk44Gn5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnc2V0Q2FuY2VsYWJsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldENhbmNlbGFibGUoY2FuY2VsYWJsZSkge1xuICAgICAgICAgaWYgKHR5cGVvZiBjYW5jZWxhYmxlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbi4nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NhbmNlbGFibGUnLCAnJyk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgc2hvd1xuICAgICAgICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAgICAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBcImZhZGVcIiwgXCJzbGlkZVwiIGFuZCBcIm5vbmVcIi5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+OBruOBr+OAgVwiZmFkZVwiLCBcInNsaWRlXCIsIFwibm9uZVwi44Gu44GE44Ga44KM44GL44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+OCs+ODvOODq+ODkOODg+OCr+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU2hvdyB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXG4gICAgICAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudFsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnc2hvdycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgdmFyIF9jYW5jZWwyID0gZmFsc2U7XG4gICAgICAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpKTtcblxuICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVzaG93Jywge1xuICAgICAgICAgICBhbGVydERpYWxvZzogdGhpcyxcbiAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgX2NhbmNlbDIgPSB0cnVlO1xuICAgICAgICAgICB9XG4gICAgICAgICB9KTtcblxuICAgICAgICAgaWYgKCFfY2FuY2VsMikge1xuICAgICAgICAgICB2YXIgX3JldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIHRyeVNob3cgPSBmdW5jdGlvbiB0cnlTaG93KCkge1xuICAgICAgICAgICAgICAgdmFyIHVubG9jayA9IF90aGlzMi5fZG9vckxvY2subG9jaygpO1xuICAgICAgICAgICAgICAgdmFyIGFuaW1hdG9yID0gX3RoaXMyLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgIF90aGlzMi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgIF90aGlzMi5fbWFzay5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuXG4gICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgYW5pbWF0b3Iuc2hvdyhfdGhpczIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICBfdGhpczIuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KF90aGlzMiwgJ3Bvc3RzaG93JywgeyBhbGVydERpYWxvZzogX3RoaXMyIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzMik7XG4gICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICB2OiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICBfdGhpczIuX2Rvb3JMb2NrLndhaXRVbmxvY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRyeVNob3coKSk7XG4gICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICB9O1xuICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBiYWJlbEhlbHBlcnMudHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlc2hvdyBldmVudC4nKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGhpZGVcbiAgICAgICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgICAgICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJmYWRlXCIsIFwic2xpZGVcIiBhbmQgXCJub25lXCIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGVcIiwgXCJzbGlkZVwiLCBcIm5vbmVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAgICAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL44Kz44O844Or44OQ44OD44Kv44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1IaWRlIHRoZSBhbGVydCBkaWFsb2cuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdoaWRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgICB2YXIgX2NhbmNlbDMgPSBmYWxzZTtcbiAgICAgICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSwgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkpO1xuXG4gICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZWhpZGUnLCB7XG4gICAgICAgICAgIGFsZXJ0RGlhbG9nOiB0aGlzLFxuICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICBfY2FuY2VsMyA9IHRydWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuXG4gICAgICAgICBpZiAoIV9jYW5jZWwzKSB7XG4gICAgICAgICAgIHZhciBfcmV0MiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIHRyeUhpZGUgPSBmdW5jdGlvbiB0cnlIaWRlKCkge1xuICAgICAgICAgICAgICAgdmFyIHVubG9jayA9IF90aGlzMy5fZG9vckxvY2subG9jaygpO1xuICAgICAgICAgICAgICAgdmFyIGFuaW1hdG9yID0gX3RoaXMzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICBhbmltYXRvci5oaWRlKF90aGlzMywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgIF90aGlzMy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgIF90aGlzMy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KF90aGlzMywgJ3Bvc3RoaWRlJywgeyBhbGVydERpYWxvZzogX3RoaXMzIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzMyk7XG4gICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICB2OiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICBfdGhpczMuX2Rvb3JMb2NrLndhaXRVbmxvY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRyeUhpZGUoKSk7XG4gICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICB9O1xuICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgIGlmICgodHlwZW9mIF9yZXQyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogYmFiZWxIZWxwZXJzLnR5cGVvZihfcmV0MikpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldDIudjtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlaGlkZSBldmVudC4nKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzU2hvd25cbiAgICAgICAgKiBAc2lnbmF0dXJlIGlzU2hvd24oKVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkaWFsb2cgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogICBbZW5ddHJ1ZSBpZiB0aGUgZGlhbG9nIGlzIGN1cnJlbnRseSB2aXNpYmxlLlsvZW5dXG4gICAgICAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gm44GE44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzU2hvd24nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Nob3duKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICAgICogQHNpZ25hdHVyZSBkZXN0cm95KClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1EZXN0cm95IHRoZSBhbGVydCBkaWFsb2cgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBET00gdHJlZS5bL2VuXVxuICAgICAgICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkuegtOajhOOBl+OBpuOAgURPTeODhOODquODvOOBi+OCieWPluOCiumZpOOBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgaWYgKHRoaXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc0NhbmNlbGFibGVcbiAgICAgICAgKiBAc2lnbmF0dXJlIGlzQ2FuY2VsYWJsZSgpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgZPjga7jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogICBbZW5ddHJ1ZSBpZiB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgq3jg6Pjg7Pjgrvjg6vlj6/og73jgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNDYW5jZWxhYmxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNDYW5jZWxhYmxlKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjYW5jZWxhYmxlJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRGV2aWNlQmFja0J1dHRvbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRldmljZUJhY2tCdXR0b24oZXZlbnQpIHtcbiAgICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsYWJsZSgpKSB7XG4gICAgICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgZXZlbnQuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY2FuY2VsJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbmNlbCgpIHtcbiAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGFibGUoKSAmJiAhdGhpcy5fcnVubmluZykge1xuICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgdGhpcy5oaWRlKHtcbiAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICAgICAgICAgICBfdGhpczQuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudChfdGhpczQsICdjYW5jZWwnKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5fZGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZGV0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICB0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgIHRoaXMuX21hc2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZENhbmNlbC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICAgICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lJDEpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19tYXNrJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBwcmVzaG93XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAgICAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAgICAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBzaG93aW5nLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644KS5q2i44KB44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBwb3N0c2hvd1xuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAgICAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBhbGVydCBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAgICAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgICAgICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgICAgICAqICAgW2VuXUV4ZWN1dGUgdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gaGlkaW5nLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44KI44GG44Go44GZ44KL44Gu44KS5q2i44KB44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBwb3N0aGlkZVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBhbGVydCBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAgICAgICogW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICAgICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGRpYWxvZy5bL2VuXVxuICAgICAgICAqICBbamFd44OA44Kk44Ki44Ot44Kw44Gu6KaL44Gf55uu44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgY2FuY2VsYWJsZVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgICAgICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL44Go44CB44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gf5pmC44Gr44CB6IOM5pmv44KE44OQ44OD44Kv44Oc44K/44Oz44KS44K/44OD44OX44GX44Gf5pmC44Gr44OA44Kk44Ki44Ot44Kw44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGlzIGRpc2FibGVkLlsvZW5dXG4gICAgICAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBkaWFsb2cuIENhbiBiZSBlaXRoZXIgXCJub25lXCIgb3IgXCJkZWZhdWx0XCIuWy9lbl1cbiAgICAgICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBp+OBr1wibm9uZVwi44GLXCJkZWZhdWx0XCLjgYzmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgICAgICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2VuXVxuICAgICAgICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBcInJnYmEoMCwgMCwgMCwgMC4yKVwiLlsvZW5dXG4gICAgICAgICogIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICAgICovXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2ctbWFzaycpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19kaWFsb2cnLFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYWxlcnQtZGlhbG9nJyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3RpdGxlRWxlbWVudCcsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLCAnLmFsZXJ0LWRpYWxvZy10aXRsZScpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jb250ZW50RWxlbWVudCcsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLCAnLmFsZXJ0LWRpYWxvZy1jb250ZW50Jyk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBBbGVydERpYWxvZ0VsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHZhciBPbnNBbGVydERpYWxvZ0VsZW1lbnQgPSB3aW5kb3cuT25zQWxlcnREaWFsb2dFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtYWxlcnQtZGlhbG9nJywge1xuICAgICBwcm90b3R5cGU6IEFsZXJ0RGlhbG9nRWxlbWVudC5wcm90b3R5cGVcbiAgIH0pO1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgKiBAcGFyYW0ge0RpYWxvZ0FuaW1hdG9yfSBBbmltYXRvclxuICAgICovXG4gICBPbnNBbGVydERpYWxvZ0VsZW1lbnQucmVnaXN0ZXJBbmltYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBBbmltYXRvcikge1xuICAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBBbGVydERpYWxvZ0FuaW1hdG9yKSkge1xuICAgICAgIHRocm93IG5ldyBFcnJvcignXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNBbGVydERpYWxvZ0VsZW1lbnQuQWxlcnREaWFsb2dBbmltYXRvcicpO1xuICAgICB9XG4gICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgIH07XG5cbiAgIE9uc0FsZXJ0RGlhbG9nRWxlbWVudC5BbGVydERpYWxvZ0FuaW1hdG9yID0gQWxlcnREaWFsb2dBbmltYXRvcjtcblxuICAgdmFyIHNjaGVtZSQyID0ge1xuICAgICAnJzogJ2JhY2stYnV0dG9uLS0qJyxcbiAgICAgJy5iYWNrLWJ1dHRvbl9faWNvbic6ICdiYWNrLWJ1dHRvbi0tKl9faWNvbicsXG4gICAgICcuYmFjay1idXR0b25fX2xhYmVsJzogJ2JhY2stYnV0dG9uLS0qX19sYWJlbCdcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLWJhY2stYnV0dG9uXG4gICAgKiBAY2F0ZWdvcnkgcGFnZVxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1CYWNrIGJ1dHRvbiBjb21wb25lbnQgZm9yIG9ucy10b29sYmFyLiBDYW4gYmUgdXNlZCB3aXRoIG9ucy1uYXZpZ2F0b3IgdG8gcHJvdmlkZSBiYWNrIGJ1dHRvbiBzdXBwb3J0LlsvZW5dXG4gICAgKiAgIFtqYV1vbnMtdG9vbGJhcuOBq+mFjee9ruOBp+OBjeOCi+OAjOaIu+OCi+ODnOOCv+ODs+OAjeeUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAgm9ucy1uYXZpZ2F0b3LjgajlhbHjgavkvb/nlKjjgZfjgIHjg5rjg7zjgrjjgpIx44Gk5YmN44Gr5oi744KL5YuV5L2c44KS6KGM44GE44G+44GZ44CCWy9qYV1cbiAgICAqIEBjb2RlcGVuIGFIbUdMXG4gICAgKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICAgICogICBbZW5db25zLXRvb2xiYXIgY29tcG9uZW50Wy9lbl1cbiAgICAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1uYXZpZ2F0b3JcbiAgICAqICAgW2VuXW9ucy1uYXZpZ2F0b3IgY29tcG9uZW50Wy9lbl1cbiAgICAqICAgW2phXW9ucy1uYXZpZ2F0b3LjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2VuXVxuICAgICogQGd1aWRlIEFkZGluZ2F0b29sYmFyXG4gICAgKiAgIFtlbl1BZGRpbmcgYSB0b29sYmFyWy9lbl1cbiAgICAqICAgW2phXeODhOODvOODq+ODkOODvOOBrui/veWKoFsvamFdXG4gICAgKiBAZ3VpZGUgUmV0dXJuaW5nZnJvbWFwYWdlXG4gICAgKiAgIFtlbl1SZXR1cm5pbmcgZnJvbSBhIHBhZ2VbL2VuXVxuICAgICogICBbamFd5LiA44Gk5YmN44Gu44Oa44O844K444Gr5oi744KLWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8b25zLWJhY2stYnV0dG9uPlxuICAgICogICBCYWNrXG4gICAgKiA8L29ucy1iYWNrLWJ1dHRvbj5cbiAgICAqL1xuXG4gICB2YXIgQmFja0J1dHRvbkVsZW1lbnQgPSAoZnVuY3Rpb24gKF9CYXNlRWxlbWVudCkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoQmFja0J1dHRvbkVsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gQmFja0J1dHRvbkVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIEJhY2tCdXR0b25FbGVtZW50KTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJhY2tCdXR0b25FbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhCYWNrQnV0dG9uRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcbiAgICAgICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYmFjay1idXR0b24nKTtcblxuICAgICAgICAgdmFyIGxhYmVsID0gdXRpbC5jcmVhdGVFbGVtZW50KCdcXG4gICAgICA8c3BhbiBjbGFzcz1cImJhY2stYnV0dG9uX19sYWJlbFwiPicgKyB0aGlzLmlubmVySFRNTCArICc8L3NwYW4+XFxuICAgICcpO1xuXG4gICAgICAgICB0aGlzLmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgICB2YXIgaWNvbiA9IHV0aWwuY3JlYXRlRWxlbWVudCgnXFxuICAgICAgPHNwYW4gY2xhc3M9XCJiYWNrLWJ1dHRvbl9faWNvblwiPjwvc3Bhbj5cXG4gICAgJyk7XG5cbiAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoaWNvbik7XG4gICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgICAgICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUkMik7XG5cbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25DbGljaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNsaWNrKCkge1xuICAgICAgICAgdmFyIG5hdmlnYXRvciA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLW5hdmlnYXRvcicpO1xuICAgICAgICAgaWYgKG5hdmlnYXRvcikge1xuICAgICAgICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpKSB7XG4gICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFuaW1hdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkge1xuICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdvbi10cmFuc2l0aW9uLWVuZCcpKSB7XG4gICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uVHJhbnNpdGlvbkVuZCA9IHdpbmRvdy5ldmFsKCcoJyArIHRoaXMuZ2V0QXR0cmlidXRlKCdvbi10cmFuc2l0aW9uLWVuZCcpICsgJyknKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgncmVmcmVzaCcpKSB7XG4gICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlZnJlc2ggPSB0aGlzLmdldEF0dHJpYnV0ZSgncmVmcmVzaCcpID09PSAndHJ1ZSc7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBuYXZpZ2F0b3IucG9wUGFnZSh0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSQyKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdkZXRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdzaG93JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2hpZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ29wdGlvbnMnLFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtvYmplY3R9XG4gICAgICAgICovXG4gICAgICAgLFxuICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG9iamVjdCkge1xuICAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIEJhY2tCdXR0b25FbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zQmFja0J1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1iYWNrLWJ1dHRvbicsIHtcbiAgICAgcHJvdG90eXBlOiBCYWNrQnV0dG9uRWxlbWVudC5wcm90b3R5cGVcbiAgIH0pO1xuXG4gICB2YXIgc2NoZW1lJDMgPSB7ICcnOiAnYm90dG9tLWJhci0tKicgfTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtYm90dG9tLXRvb2xiYXJcbiAgICAqIEBjYXRlZ29yeSBwYWdlXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXVRvb2xiYXIgY29tcG9uZW50IHRoYXQgaXMgcG9zaXRpb25lZCBhdCB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLlsvZW5dXG4gICAgKiAgIFtqYV3jg5rjg7zjgrjkuIvpg6jjgavphY3nva7jgZXjgozjgovjg4Tjg7zjg6vjg5Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICAgICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gICAgKiAgIFtlbl1NYWtlIHRoZSB0b29sYmFyIHRyYW5zcGFyZW50LlsvZW5dXG4gICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7og4zmma/jgpLpgI/mmI7jgavjgZfjgabooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQHNlZWFsc28gb25zLXRvb2xiYXIgW2VuXW9ucy10b29sYmFyIGNvbXBvbmVudFsvZW5dW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBndWlkZSBBZGRpbmdhdG9vbGJhclxuICAgICogICBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dXG4gICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICAgICogQGV4YW1wbGVcbiAgICAqIDxvbnMtYm90dG9tLXRvb2xiYXI+XG4gICAgKiAgIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7IGxpbmUtaGVpZ2h0OiA0NHB4XCI+VGV4dDwvZGl2PlxuICAgICogPC9vbnMtYm90dG9tLXRvb2xiYXI+XG4gICAgKi9cblxuICAgdmFyIEJvdHRvbVRvb2xiYXJFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKEJvdHRvbVRvb2xiYXJFbGVtZW50LCBfQmFzZUVsZW1lbnQpO1xuXG4gICAgIGZ1bmN0aW9uIEJvdHRvbVRvb2xiYXJFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBCb3R0b21Ub29sYmFyRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihCb3R0b21Ub29sYmFyRWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoQm90dG9tVG9vbGJhckVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0b29sYmFyLlsvZW5dXG4gICAgICAgICogICBbamFd44OE44O844Or44OQ44O844Gu6KaL44Gf55uu44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgaW5saW5lXG4gICAgICAgICogQGluaXRvbmx5XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRGlzcGxheSB0aGUgdG9vbGJhciBhcyBhbiBpbmxpbmUgZWxlbWVudC5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgeODhOODvOODq+ODkOODvOOCkueUu+mdouS4i+mDqOOBp+OBr+OBquOBj+OCueOCr+ODreODvOODq+mgmOWfn+WGheOBq+OBneOBruOBvuOBvuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdib3R0b20tYmFyJyk7XG5cbiAgICAgICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lJDMpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdmFyIHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJyk7XG4gICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlICE9IHBhZ2UpIHtcbiAgICAgICAgICAgcGFnZS5fcmVnaXN0ZXJCb3R0b21Ub29sYmFyKHRoaXMpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lJDMpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gQm90dG9tVG9vbGJhckVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNCb3R0b21Ub29sYmFyRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWJvdHRvbS10b29sYmFyJywge1xuICAgICBwcm90b3R5cGU6IEJvdHRvbVRvb2xiYXJFbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIHZhciBzY2hlbWUkNCA9IHsgJyc6ICdidXR0b24tLSonIH07XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLWJ1dHRvblxuICAgICogQGNhdGVnb3J5IGZvcm1cbiAgICAqIEBtb2RpZmllciBvdXRsaW5lXG4gICAgKiAgIFtlbl1CdXR0b24gd2l0aCBvdXRsaW5lIGFuZCB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kWy9lbl1cbiAgICAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuaMgeOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAbW9kaWZpZXIgbGlnaHRcbiAgICAqICAgW2VuXUJ1dHRvbiB0aGF0IGRvZXNuJ3Qgc3RhbmQgb3V0LlsvZW5dXG4gICAgKiAgIFtqYV3nm67nq4vjgZ/jgarjgYTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQG1vZGlmaWVyIHF1aWV0XG4gICAgKiAgIFtlbl1CdXR0b24gd2l0aCBubyBvdXRsaW5lIGFuZCBvciBiYWNrZ3JvdW5kLi5bL2VuXVxuICAgICogICBbamFd5p6g57ea44KE6IOM5pmv44GM54Sh44GE5paH5a2X44Gg44GR44Gu44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBtb2RpZmllciBjdGFcbiAgICAqICAgW2VuXUJ1dHRvbiB0aGF0IHJlYWxseSBzdGFuZHMgb3V0LlsvZW5dXG4gICAgKiAgIFtqYV3nm67nq4vjgaTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQG1vZGlmaWVyIGxhcmdlXG4gICAgKiAgIFtlbl1MYXJnZSBidXR0b24gdGhhdCBjb3ZlcnMgdGhlIHdpZHRoIG9mIHRoZSBzY3JlZW4uWy9lbl1cbiAgICAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi+Wkp+OBjeOBquODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAbW9kaWZpZXIgbGFyZ2UtLXF1aWV0XG4gICAgKiAgIFtlbl1MYXJnZSBxdWlldCBidXR0b24uWy9lbl1cbiAgICAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi3F1aWV044Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBtb2RpZmllciBsYXJnZS0tY3RhXG4gICAgKiAgIFtlbl1MYXJnZSBjYWxsIHRvIGFjdGlvbiBidXR0b24uWy9lbl1cbiAgICAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi2N0YeODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXUJ1dHRvbiBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIHBsYWNlIGEgYnV0dG9uIGluIGEgdG9vbGJhciwgdXNlIG9ucy10b29sYmFyLWJ1dHRvbiBvciBvbnMtYmFjay1idXR0b24gaW5zdGVhZC5bL2VuXVxuICAgICogICBbamFd44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44CC44OE44O844Or44OQ44O844Gr44Oc44K/44Oz44KS6Kit572u44GZ44KL5aC05ZCI44Gv44CBb25zLXRvb2xiYXItYnV0dG9u44KC44GX44GP44Gvb25zLWJhY2stYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OI44KS5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBjb2RlcGVuIGhMYXl4XG4gICAgKiBAZ3VpZGUgQnV0dG9uIFtlbl1HdWlkZSBmb3Igb25zLWJ1dHRvblsvZW5dW2phXW9ucy1idXR0b27jga7kvb/jgYTmlrlbL2phXVxuICAgICogQGd1aWRlIE92ZXJyaWRpbmdDU1NzdHlsZXMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCBtb2RpZmllciBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gICAgKiBAZXhhbXBsZVxuICAgICogPG9ucy1idXR0b24gbW9kaWZpZXI9XCJsYXJnZS0tY3RhXCI+XG4gICAgKiAgIFRhcCBNZVxuICAgICogPC9vbnMtYnV0dG9uPlxuICAgICovXG5cbiAgIHZhciBCdXR0b25FbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKEJ1dHRvbkVsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gQnV0dG9uRWxlbWVudCgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgQnV0dG9uRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihCdXR0b25FbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhCdXR0b25FbGVtZW50LCBbe1xuICAgICAgIGtleTogJ2NyZWF0ZWRDYWxsYmFjaycsXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICAgICAgKiAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSQ0KTtcbiAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnYnV0dG9uJyk7XG5cbiAgICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSQ0KTtcblxuICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfdXBkYXRlUmlwcGxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICAgICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gQnV0dG9uRWxlbWVudDtcbiAgIH0pKEJhc2VFbGVtZW50KTtcblxuICAgd2luZG93Lk9uc0J1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1idXR0b24nLCB7XG4gICAgIHByb3RvdHlwZTogQnV0dG9uRWxlbWVudC5wcm90b3R5cGVcbiAgIH0pO1xuXG4gICB2YXIgc2NoZW1lJDUgPSB7ICcnOiAnY2Fyb3VzZWwtaXRlbS0tKicgfTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWwtaXRlbVxuICAgICogQGNhdGVnb3J5IGNhcm91c2VsXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXUNhcm91c2VsIGl0ZW0gY29tcG9uZW50LlsvZW5dXG4gICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjga7opoHntKDjgpLooajnj77jgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgIJbL2phXVxuICAgICogQGNvZGVwZW4geGJiek9RXG4gICAgKiBAc2VlYWxzbyBvbnMtY2Fyb3VzZWxcbiAgICAqICAgW2VuXW9ucy1jYXJvdXNlbCBjb21wb25lbnRzWy9lbl1cbiAgICAqICAgW2phXW9ucy1jYXJvdXNlbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gICAgKiBAZXhhbXBsZVxuICAgICogPG9ucy1jYXJvdXNlbCBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDIwMHB4XCI+XG4gICAgKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAgICAqICAgIC4uLlxuICAgICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICAgICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gICAgKiAgICAuLi5cbiAgICAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAgICAqIDwvb25zLWNhcm91c2VsPlxuICAgICovXG5cbiAgIHZhciBDYXJvdXNlbEl0ZW1FbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKENhcm91c2VsSXRlbUVsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gQ2Fyb3VzZWxJdGVtRWxlbWVudCgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2Fyb3VzZWxJdGVtRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihDYXJvdXNlbEl0ZW1FbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhDYXJvdXNlbEl0ZW1FbGVtZW50LCBbe1xuICAgICAgIGtleTogJ2NyZWF0ZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSQ1KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUkNSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBDYXJvdXNlbEl0ZW1FbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zQ2Fyb3VzZWxJdGVtRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWNhcm91c2VsLWl0ZW0nLCB7XG4gICAgIHByb3RvdHlwZTogQ2Fyb3VzZWxJdGVtRWxlbWVudC5wcm90b3R5cGVcbiAgIH0pO1xuXG4gICB2YXIgVmVydGljYWxNb2RlVHJhaXQgPSB7XG5cbiAgICAgX2dldFNjcm9sbERlbHRhOiBmdW5jdGlvbiBfZ2V0U2Nyb2xsRGVsdGEoZXZlbnQpIHtcbiAgICAgICByZXR1cm4gZXZlbnQuZ2VzdHVyZS5kZWx0YVk7XG4gICAgIH0sXG5cbiAgICAgX2dldFNjcm9sbFZlbG9jaXR5OiBmdW5jdGlvbiBfZ2V0U2Nyb2xsVmVsb2NpdHkoZXZlbnQpIHtcbiAgICAgICByZXR1cm4gZXZlbnQuZ2VzdHVyZS52ZWxvY2l0eVk7XG4gICAgIH0sXG5cbiAgICAgX2dldEVsZW1lbnRTaXplOiBmdW5jdGlvbiBfZ2V0RWxlbWVudFNpemUoKSB7XG4gICAgICAgaWYgKCF0aGlzLl9jdXJyZW50RWxlbWVudFNpemUpIHtcbiAgICAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgIH1cblxuICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RWxlbWVudFNpemU7XG4gICAgIH0sXG5cbiAgICAgX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtOiBmdW5jdGlvbiBfZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0oc2Nyb2xsKSB7XG4gICAgICAgcmV0dXJuICd0cmFuc2xhdGUzZCgwcHgsICcgKyAtc2Nyb2xsICsgJ3B4LCAwcHgpJztcbiAgICAgfSxcblxuICAgICBfdXBkYXRlRGltZW5zaW9uRGF0YTogZnVuY3Rpb24gX3VwZGF0ZURpbWVuc2lvbkRhdGEoKSB7XG4gICAgICAgdGhpcy5fc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcbiAgICAgICB0aGlzLl9kaW1lbnNpb25zID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgfSxcblxuICAgICBfdXBkYXRlT2Zmc2V0OiBmdW5jdGlvbiBfdXBkYXRlT2Zmc2V0KCkge1xuICAgICAgIGlmICh0aGlzLmlzQ2VudGVyZWQoKSkge1xuICAgICAgICAgdmFyIGhlaWdodCA9ICh0aGlzLl9kaW1lbnNpb25zLmhlaWdodCB8fCAwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdUb3AsIDEwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdCb3R0b20sIDEwKTtcbiAgICAgICAgIHRoaXMuX29mZnNldCA9IC0oaGVpZ2h0IC0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpKSAvIDI7XG4gICAgICAgfVxuICAgICB9LFxuXG4gICAgIF9sYXlvdXRDYXJvdXNlbEl0ZW1zOiBmdW5jdGlvbiBfbGF5b3V0Q2Fyb3VzZWxJdGVtcygpIHtcbiAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpO1xuXG4gICAgICAgdmFyIHNpemVBdHRyID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKTtcbiAgICAgICB2YXIgc2l6ZUluZm8gPSB0aGlzLl9kZWNvbXBvc2VTaXplU3RyaW5nKHNpemVBdHRyKTtcblxuICAgICAgIHZhciB3aWR0aCA9ICh0aGlzLl9kaW1lbnNpb25zLndpZHRoIHx8IDApIC0gcGFyc2VJbnQodGhpcy5fc3R5bGUucGFkZGluZ0xlZnQsIDEwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdSaWdodCwgMTApO1xuXG4gICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUuaGVpZ2h0ID0gc2l6ZUF0dHI7XG4gICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSBpICogc2l6ZUluZm8ubnVtYmVyICsgc2l6ZUluZm8udW5pdDtcbiAgICAgICB9XG4gICAgIH0sXG5cbiAgICAgX3NldHVwOiBmdW5jdGlvbiBfc2V0dXAoKSB7XG4gICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uRGF0YSgpO1xuICAgICAgIHRoaXMuX3VwZGF0ZU9mZnNldCgpO1xuICAgICAgIHRoaXMuX2xheW91dENhcm91c2VsSXRlbXMoKTtcbiAgICAgfVxuICAgfTtcblxuICAgdmFyIEhvcml6b250YWxNb2RlVHJhaXQgPSB7XG5cbiAgICAgX2dldFNjcm9sbERlbHRhOiBmdW5jdGlvbiBfZ2V0U2Nyb2xsRGVsdGEoZXZlbnQpIHtcbiAgICAgICByZXR1cm4gZXZlbnQuZ2VzdHVyZS5kZWx0YVg7XG4gICAgIH0sXG5cbiAgICAgX2dldFNjcm9sbFZlbG9jaXR5OiBmdW5jdGlvbiBfZ2V0U2Nyb2xsVmVsb2NpdHkoZXZlbnQpIHtcbiAgICAgICByZXR1cm4gZXZlbnQuZ2VzdHVyZS52ZWxvY2l0eVg7XG4gICAgIH0sXG5cbiAgICAgX2dldEVsZW1lbnRTaXplOiBmdW5jdGlvbiBfZ2V0RWxlbWVudFNpemUoKSB7XG4gICAgICAgaWYgKCF0aGlzLl9jdXJyZW50RWxlbWVudFNpemUpIHtcbiAgICAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZSA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgfVxuXG4gICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRFbGVtZW50U2l6ZTtcbiAgICAgfSxcblxuICAgICBfZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm06IGZ1bmN0aW9uIF9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybShzY3JvbGwpIHtcbiAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCcgKyAtc2Nyb2xsICsgJ3B4LCAwcHgsIDBweCknO1xuICAgICB9LFxuXG4gICAgIF91cGRhdGVEaW1lbnNpb25EYXRhOiBmdW5jdGlvbiBfdXBkYXRlRGltZW5zaW9uRGF0YSgpIHtcbiAgICAgICB0aGlzLl9zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpO1xuICAgICAgIHRoaXMuX2RpbWVuc2lvbnMgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICB9LFxuXG4gICAgIF91cGRhdGVPZmZzZXQ6IGZ1bmN0aW9uIF91cGRhdGVPZmZzZXQoKSB7XG4gICAgICAgaWYgKHRoaXMuaXNDZW50ZXJlZCgpKSB7XG4gICAgICAgICB2YXIgd2lkdGggPSAodGhpcy5fZGltZW5zaW9ucy53aWR0aCB8fCAwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdMZWZ0LCAxMCkgLSBwYXJzZUludCh0aGlzLl9zdHlsZS5wYWRkaW5nUmlnaHQsIDEwKTtcbiAgICAgICAgIHRoaXMuX29mZnNldCA9IC0od2lkdGggLSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkpIC8gMjtcbiAgICAgICB9XG4gICAgIH0sXG5cbiAgICAgX2xheW91dENhcm91c2VsSXRlbXM6IGZ1bmN0aW9uIF9sYXlvdXRDYXJvdXNlbEl0ZW1zKCkge1xuICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCk7XG5cbiAgICAgICB2YXIgc2l6ZUF0dHIgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplQXR0cigpO1xuICAgICAgIHZhciBzaXplSW5mbyA9IHRoaXMuX2RlY29tcG9zZVNpemVTdHJpbmcoc2l6ZUF0dHIpO1xuXG4gICAgICAgdmFyIGhlaWdodCA9ICh0aGlzLl9kaW1lbnNpb25zLmhlaWdodCB8fCAwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdUb3AsIDEwKSAtIHBhcnNlSW50KHRoaXMuX3N0eWxlLnBhZGRpbmdCb3R0b20sIDEwKTtcblxuICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS53aWR0aCA9IHNpemVBdHRyO1xuICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSBpICogc2l6ZUluZm8ubnVtYmVyICsgc2l6ZUluZm8udW5pdDtcbiAgICAgICB9XG4gICAgIH0sXG5cbiAgICAgX3NldHVwOiBmdW5jdGlvbiBfc2V0dXAoKSB7XG4gICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uRGF0YSgpO1xuICAgICAgIHRoaXMuX3VwZGF0ZU9mZnNldCgpO1xuICAgICAgIHRoaXMuX2xheW91dENhcm91c2VsSXRlbXMoKTtcbiAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWxcbiAgICAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1DYXJvdXNlbCBjb21wb25lbnQuWy9lbl1cbiAgICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OCkuihqOekuuOBp+OBjeOCi+OCs+ODs+ODneODvOODjeODs+ODiOOAglsvamFdXG4gICAgKiBAY29kZXBlbiB4YmJ6T1FcbiAgICAqIEBzZWVhbHNvIG9ucy1jYXJvdXNlbC1pdGVtXG4gICAgKiAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLWNhcm91c2VsLWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICAgICogQGd1aWRlIFVzaW5nQ2Fyb3VzZWxcbiAgICAqICAgW2VuXUxlYXJuIGhvdyB0byB1c2UgdGhlIGNhcm91c2VsIGNvbXBvbmVudC5bL2VuXVxuICAgICogICBbamFdY2Fyb3VzZWzjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7kvb/jgYTmlrlbL2phXVxuICAgICogQGV4YW1wbGVcbiAgICAqIDxvbnMtY2Fyb3VzZWwgc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAyMDBweFwiPlxuICAgICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gICAgKiAgICAuLi5cbiAgICAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAgICAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICAgICogICAgLi4uXG4gICAgKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gICAgKiA8L29ucy1jYXJvdXNlbD5cbiAgICAqL1xuXG4gICB2YXIgQ2Fyb3VzZWxFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKENhcm91c2VsRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBDYXJvdXNlbEVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIENhcm91c2VsRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihDYXJvdXNlbEVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKENhcm91c2VsRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQGV2ZW50IHBvc3RjaGFuZ2VcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaGFzIGNoYW5nZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3nj77lnKjooajnpLrjgZfjgabjgYTjgovjgqvjg6vjg7zjgrvjg6vjga7opoHntKDjgYzlpInjgo/jgaPjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAgICAgICogICBbZW5dQ2Fyb3VzZWwgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44GfQ2Fyb3VzZWzjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5hY3RpdmVJbmRleFxuICAgICAgICAqICAgW2VuXUN1cnJlbnQgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAgICAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQubGFzdEFjdGl2ZUluZGV4XG4gICAgICAgICogICBbZW5dUHJldmlvdXMgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAgICAgICogICBbamFd5Lul5YmN44Ki44Kv44OG44Kj44OW44Gg44Gj44Gf6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCByZWZyZXNoXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gcmVmcmVzaGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44Kr44Or44O844K744Or44GM5pu05paw44GV44KM44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jYXJvdXNlbFxuICAgICAgICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn0Nhcm91c2Vs44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBvdmVyc2Nyb2xsXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gb3ZlcnNjcm9sbGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44Kr44Or44O844K744Or44GM44Kq44O844OQ44O844K544Kv44Ot44O844Or44GX44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jYXJvdXNlbFxuICAgICAgICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIHJlZnJlc2hlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOabtOaWsOOBleOCjOOBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmFjdGl2ZUluZGV4XG4gICAgICAgICogICBbZW5dQ3VycmVudCBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICAgICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovopoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5kaXJlY3Rpb25cbiAgICAgICAgKiAgIFtlbl1DYW4gYmUgb25lIG9mIGVpdGhlciBcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiBvciBcInJpZ2h0XCIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg7zjg5Djg7zjgrnjgq/jg63jg7zjg6vjgZXjgozjgZ/mlrnlkJHjgYzlvpfjgonjgozjgb7jgZnjgIJcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiwgXCJyaWdodFwi44Gu44GE44Ga44KM44GL44Gu5pa55ZCR44GM5rih44GV44KM44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC53YWl0VG9SZXR1cm5cbiAgICAgICAgKiAgIFtlbl1UYWtlcyBhIDxjb2RlPlByb21pc2U8L2NvZGU+IG9iamVjdCBhcyBhbiBhcmd1bWVudC4gVGhlIGNhcm91c2VsIHdpbGwgbm90IHNjcm9sbCBiYWNrIHVudGlsIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu6Zai5pWw44GvUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkuW8leaVsOOBqOOBl+OBpuWPl+OBkeWPluOCiuOBvuOBmeOAgua4oeOBl+OBn1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgYxyZXNvbHZl44GV44KM44KL44GLcmVqZWN044GV44KM44KL44G+44Gn44CB44Kr44Or44O844K744Or44Gv44K544Kv44Ot44O844Or44OQ44OD44Kv44GX44G+44Gb44KT44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgZGlyZWN0aW9uXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1UaGUgZGlyZWN0aW9uIG9mIHRoZSBjYXJvdXNlbC4gQ2FuIGJlIGVpdGhlciBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIuIERlZmF1bHQgaXMgXCJob3Jpem9udGFsXCIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjga7mlrnlkJHjgpLmjIflrprjgZfjgb7jgZnjgIJcImhvcml6b250YWxcIuOBi1widmVydGljYWxcIuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglwiaG9yaXpvbnRhbFwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgZnVsbHNjcmVlblxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgd2lsbCBjb3ZlciB0aGUgd2hvbGUgc2NyZWVuLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL44Go44CBYWJzb2x1dGXjg53jgrjjgrfjg6fjg7PjgpLkvb/jgaPjgabjgqvjg6vjg7zjgrvjg6vjgYzoh6rli5XnmoTjgavnlLvpnaLjgYTjgaPjgbHjgYTjgavluoPjgYzjgorjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBvdmVyc2Nyb2xsYWJsZVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgd2lsbCBiZSBzY3JvbGxhYmxlIG92ZXIgdGhlIGVkZ2UuIEl0IHdpbGwgYm91bmNlIGJhY2sgd2hlbiByZWxlYXNlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCv+ODg+ODgeOChOODieODqeODg+OCsOOBp+err+OBvuOBp+OCueOCr+ODreODvOODq+OBl+OBn+aZguOBq+OAgeODkOOCpuODs+ODieOBmeOCi+OCiOOBhuOBquWKueaenOOBjOW9k+OBn+OCiuOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGNlbnRlcmVkXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB0aGVuIHRoZSBzZWxlY3RlZCBpdGVtIHdpbGwgYmUgaW4gdGhlIGNlbnRlciBvZiB0aGUgY2Fyb3VzZWwgaW5zdGVhZCBvZiB0aGUgYmVnaW5uaW5nLiBVc2VmdWwgb25seSB3aGVuIHRoZSBpdGVtcyBhcmUgc21hbGxlciB0aGFuIHRoZSBjYXJvdXNlbC4gWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHpgbjjgpPjgafjgYTjgotvbnMtY2Fyb3VzZWwtaXRlbeOBr+OCq+ODq+ODvOOCu+ODq+OBruecn+OCk+S4reOBuOihjOOBjeOBvuOBmeOAgumgheebruOBjOOCq+ODq+ODvOOCu+ODq+OCiOOCiuOCguWwj+OBleOBhOWgtOWQiOOBq+OBruOBv+OAgeOBk+OCjOOBr+S+v+WIqeOBp+OBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGl0ZW0td2lkdGhcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIHdpZHRoLiBPbmx5IHdvcmtzIHdoZW4gdGhlIGRpcmVjdGlvbiBpcyBzZXQgdG8gXCJob3Jpem9udGFsXCIuWy9lbl1cbiAgICAgICAgKiAgICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7luYXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcImhvcml6b250YWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGl0ZW0taGVpZ2h0XG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIGhlaWdodC4gT25seSB3b3JrcyB3aGVuIHRoZSBkaXJlY3Rpb24gaXMgc2V0IHRvIFwidmVydGljYWxcIi5bL2VuXVxuICAgICAgICAqICAgW2phXW9ucy1jYXJvdXNlbC1pdGVt44Gu6auY44GV44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu5bGe5oCn44Gv44CBZGlyZWN0aW9u5bGe5oCn44GrXCJ2ZXJ0aWNhbFwi44KS5oyH5a6a44GX44Gf5pmC44Gu44G/5pyJ5Yq544Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgYXV0by1zY3JvbGxcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgYXV0b21hdGljYWxseSBzY3JvbGxlZCB0byB0aGUgY2xvc2VzdCBpdGVtIGJvcmRlciB3aGVuIHJlbGVhc2VkLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB5LiA55Wq6L+R44GEY2Fyb3VzZWwtaXRlbeOBruWig+eVjOOBvuOBp+iHquWLleeahOOBq+OCueOCr+ODreODvOODq+OBmeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGF1dG8tc2Nyb2xsLXJhdGlvXG4gICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgICBbZW5dQSBudW1iZXIgYmV0d2VlbiAwLjAgYW5kIDEuMCB0aGF0IHNwZWNpZmllcyBob3cgbXVjaCB0aGUgdXNlciBtdXN0IGRyYWcgdGhlIGNhcm91c2VsIGluIG9yZGVyIGZvciBpdCB0byBhdXRvIHNjcm9sbCB0byB0aGUgbmV4dCBpdGVtLlsvZW5dXG4gICAgICAgICogICAgW2phXTAuMOOBi+OCiTEuMOOBvuOBp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAguOCq+ODq+ODvOOCu+ODq+OBruimgee0oOOCkuOBqeOCjOOBkOOCieOBhOOBruWJsuWQiOOBvuOBp+ODieODqeODg+OCsOOBmeOCi+OBqOasoeOBruimgee0oOOBq+iHquWLleeahOOBq+OCueOCr+ODreODvOODq+OBmeOCi+OBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgY2FuIGJlIHNjcm9sbGVkIGJ5IGRyYWcgb3Igc3dpcGUuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjgqvjg6vjg7zjgrvjg6vjgpLjgrnjg6/jgqTjg5fjgoTjg4njg6njg4PjgrDjgafnp7vli5XjgafjgY3jgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIFkcmFn44KEdG91Y2jjgoRzd2lwZeOCkuWPl+OBkeS7mOOBkeOBquOBj+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGluaXRpYWwtaW5kZXhcbiAgICAgICAgKiBAaW5pdG9ubHlcbiAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBvbnMtY2Fyb3VzZWwtaXRlbSB0byBzaG93IGluaXRpYWxseS4gRGVmYXVsdCBpcyAwLlsvZW5dXG4gICAgICAgICogICBbamFd5pyA5Yid44Gr6KGo56S644GZ44KLb25zLWNhcm91c2VsLWl0ZW3jgpIw5aeL44G+44KK44Gu44Kk44Oz44OH44OD44Kv44K544Gn5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI5YCk44GvIDAg44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgYXV0by1yZWZyZXNoXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dV2hlbiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYXV0b21hdGljYWxseSByZWZyZXNoIHdoZW4gdGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBjaGFuZ2UuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHlrZDopoHntKDjga7mlbDjgYzlpInjgo/jgovjgajjgqvjg6vjg7zjgrvjg6vjga/oh6rli5XnmoTjgavmm7TmlrDjgZXjgozjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgICAgICB0aGlzLl9zY3JvbGwgPSAwO1xuICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICAgICAgIHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IDA7XG5cbiAgICAgICAgIHRoaXMuX2JvdW5kT25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgICAgICB0aGlzLl9ib3VuZE9uRHJhZ0VuZCA9IHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpO1xuICAgICAgICAgdGhpcy5fYm91bmRPblJlc2l6ZSA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG5cbiAgICAgICAgIHRoaXMuX21peGluKHRoaXMuX2lzVmVydGljYWwoKSA/IFZlcnRpY2FsTW9kZVRyYWl0IDogSG9yaXpvbnRhbE1vZGVUcmFpdCk7XG5cbiAgICAgICAgIHRoaXMuX3NldHVwKCk7XG4gICAgICAgICB0aGlzLl9zZXR1cEluaXRpYWxJbmRleCgpO1xuXG4gICAgICAgICB0aGlzLl9zYXZlTGFzdFN0YXRlKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uUmVzaXplJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uUmVzaXplKCkge1xuICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRGlyZWN0aW9uQ2hhbmdlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRGlyZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwoKSkge1xuICAgICAgICAgICB0aGlzLnN0eWxlLm92ZXJmbG93WCA9ICdhdXRvJztcbiAgICAgICAgICAgdGhpcy5zdHlsZS5vdmVyZmxvd1kgPSAnJztcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRoaXMuc3R5bGUub3ZlcmZsb3dYID0gJyc7XG4gICAgICAgICAgIHRoaXMuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfc2F2ZUxhc3RTdGF0ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zYXZlTGFzdFN0YXRlKCkge1xuICAgICAgICAgdGhpcy5fbGFzdFN0YXRlID0ge1xuICAgICAgICAgICBlbGVtZW50U2l6ZTogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpLFxuICAgICAgICAgICBjYXJvdXNlbEVsZW1lbnRDb3VudDogdGhpcy5nZXRDYXJvdXNlbEl0ZW1Db3VudCgpLFxuICAgICAgICAgICB3aWR0aDogdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpICogdGhpcy5nZXRDYXJvdXNlbEl0ZW1Db3VudCgpXG4gICAgICAgICB9O1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2dldENhcm91c2VsSXRlbVNpemUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpIHtcbiAgICAgICAgIHZhciBzaXplQXR0ciA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemVBdHRyKCk7XG4gICAgICAgICB2YXIgc2l6ZUluZm8gPSB0aGlzLl9kZWNvbXBvc2VTaXplU3RyaW5nKHNpemVBdHRyKTtcbiAgICAgICAgIHZhciBlbGVtZW50U2l6ZSA9IHRoaXMuX2dldEVsZW1lbnRTaXplKCk7XG5cbiAgICAgICAgIGlmIChzaXplSW5mby51bml0ID09PSAnJScpIHtcbiAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoc2l6ZUluZm8ubnVtYmVyIC8gMTAwICogZWxlbWVudFNpemUpO1xuICAgICAgICAgfSBlbHNlIGlmIChzaXplSW5mby51bml0ID09PSAncHgnKSB7XG4gICAgICAgICAgIHJldHVybiBzaXplSW5mby5udW1iZXI7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19nZXRJbml0aWFsSW5kZXgnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW5pdGlhbEluZGV4KCkge1xuICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ2luaXRpYWwtaW5kZXgnKSwgMTApO1xuXG4gICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihpbmRleCwgdGhpcy5nZXRDYXJvdXNlbEl0ZW1Db3VudCgpIC0gMSksIDApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHInLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2Fyb3VzZWxJdGVtU2l6ZUF0dHIoKSB7XG4gICAgICAgICB2YXIgYXR0ck5hbWUgPSAnaXRlbS0nICsgKHRoaXMuX2lzVmVydGljYWwoKSA/ICdoZWlnaHQnIDogJ3dpZHRoJyk7XG4gICAgICAgICB2YXIgaXRlbVNpemVBdHRyID0gKCcnICsgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKS50cmltKCk7XG5cbiAgICAgICAgIHJldHVybiBpdGVtU2l6ZUF0dHIubWF0Y2goL15cXGQrKHB4fCUpJC8pID8gaXRlbVNpemVBdHRyIDogJzEwMCUnO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2RlY29tcG9zZVNpemVTdHJpbmcnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjb21wb3NlU2l6ZVN0cmluZyhzaXplKSB7XG4gICAgICAgICB2YXIgbWF0Y2hlcyA9IHNpemUubWF0Y2goL14oXFxkKykocHh8JSkvKTtcblxuICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgbnVtYmVyOiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCksXG4gICAgICAgICAgIHVuaXQ6IG1hdGNoZXNbMl1cbiAgICAgICAgIH07XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3NldHVwSW5pdGlhbEluZGV4JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwSW5pdGlhbEluZGV4KCkge1xuICAgICAgICAgdGhpcy5fc2Nyb2xsID0gKHRoaXMuX29mZnNldCB8fCAwKSArIHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSAqIHRoaXMuX2dldEluaXRpYWxJbmRleCgpO1xuICAgICAgICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SW5pdGlhbEluZGV4KCk7XG4gICAgICAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgc2V0U3dpcGVhYmxlXG4gICAgICAgICogQHNpZ25hdHVyZSBzZXRTd2lwZWFibGUoc3dpcGVhYmxlKVxuICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3dpcGVhYmxlXG4gICAgICAgICogICBbZW5dSWYgdmFsdWUgaXMgdHJ1ZSB0aGUgY2Fyb3VzZWwgd2lsbCBiZSBzd2lwZWFibGUuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1zd2lwZWFibGXjgavjgZnjgovloLTlkIjjgavjga90cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1TZXQgd2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgc3dpcGVhYmxlIG9yIG5vdC5bL2VuXVxuICAgICAgICAqICAgW2phXXN3aXBl44Gn44GN44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnc2V0U3dpcGVhYmxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3dpcGVhYmxlKHN3aXBlYWJsZSkge1xuICAgICAgICAgaWYgKHN3aXBlYWJsZSkge1xuICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3dpcGVhYmxlJywgJycpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaXNTd2lwZWFibGVcbiAgICAgICAgKiBAc2lnbmF0dXJlIGlzU3dpcGVhYmxlKClcbiAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAqICAgW2VuXXRydWUgaWYgdGhlIGNhcm91c2VsIGlzIHN3aXBlYWJsZS5bL2VuXVxuICAgICAgICAqICAgW2phXXN3aXBlYWJsZeOBp+OBguOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgc3dpcGVhYmxlIG9yIG5vdC5bL2VuXVxuICAgICAgICAqICAgW2phXXN3aXBlYWJsZeWxnuaAp+OBjOOBguOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzU3dpcGVhYmxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNTd2lwZWFibGUoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgc2V0QXV0b1Njcm9sbFJhdGlvXG4gICAgICAgICogQHNpZ25hdHVyZSBzZXRBdXRvU2Nyb2xsUmF0aW8ocmF0aW8pXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG4gICAgICAgICogICBbZW5dVGhlIGRlc2lyZWQgcmF0aW8uWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg7zjg4jjgrnjgq/jg63jg7zjg6vjgZnjgovjga7jgavlv4XopoHjgaowLjDjgYvjgokxLjDjgb7jgafjga5yYXRpb+WApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU2V0IHRoZSBhdXRvIHNjcm9sbCByYXRpby4gTXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMC4wIGFuZCAxLjAuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg7zjg4jjgrnjgq/jg63jg7zjg6vjgZnjgovjga7jgavlv4XopoHjgapyYXRpb+WApOOCkuaMh+WumuOBl+OBvuOBmeOAgjAuMOOBi+OCiTEuMOOCkuW/heOBmuaMh+WumuOBl+OBquOBkeOCjOOBsOOBquOCieOBquOBhOOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldEF1dG9TY3JvbGxSYXRpbycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF1dG9TY3JvbGxSYXRpbyhyYXRpbykge1xuICAgICAgICAgaWYgKHJhdGlvIDwgMC4wIHx8IHJhdGlvID4gMS4wKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYXRpby4nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsLXJhdGlvJywgcmF0aW8pO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgZ2V0QXV0b1Njcm9sbFJhdGlvXG4gICAgICAgICogQHNpZ25hdHVyZSBnZXRBdXRvU2Nyb2xsUmF0aW8oKVxuICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgKiAgIFtlbl1UaGUgY3VycmVudCBhdXRvIHNjcm9sbCByYXRpby5bL2VuXVxuICAgICAgICAqICAgW2phXeePvuWcqOOBruOCquODvOODiOOCueOCr+ODreODvOODq+OBrnJhdGlv5YCk44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHRoZSBjdXJyZW50IGF1dG8gc2Nyb2xsIHJhdGlvLlsvZW5dXG4gICAgICAgICogICBbamFd54++5Zyo44Gu44Kq44O844OI44K544Kv44Ot44O844Or44GucmF0aW/lgKTjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdnZXRBdXRvU2Nyb2xsUmF0aW8nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdXRvU2Nyb2xsUmF0aW8oKSB7XG4gICAgICAgICB2YXIgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhdXRvLXNjcm9sbC1yYXRpbycpO1xuXG4gICAgICAgICBpZiAoIWF0dHIpIHtcbiAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIHNjcm9sbFJhdGlvID0gcGFyc2VGbG9hdChhdHRyKTtcbiAgICAgICAgIGlmIChzY3JvbGxSYXRpbyA8IDAuMCB8fCBzY3JvbGxSYXRpbyA+IDEuMCkge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmF0aW8uJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBpc05hTihzY3JvbGxSYXRpbykgPyAwLjUgOiBzY3JvbGxSYXRpbztcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHNldEFjdGl2ZUNhcm91c2VsSXRlbUluZGV4XG4gICAgICAgICogQHNpZ25hdHVyZSBzZXRBY3RpdmVDYXJvdXNlbEl0ZW1JbmRleChpbmRleCwgW29wdGlvbnNdKVxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAgICAqICAgW2VuXVRoZSBpbmRleCB0aGF0IHRoZSBjYXJvdXNlbCBzaG91bGQgYmUgc2V0IHRvLlsvZW5dXG4gICAgICAgICogICBbamFdY2Fyb3VzZWzopoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAgICAgICogICBbZW5dWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAgICAgICogICBbZW5dWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBvbnMtY2Fyb3VzZWwtaXRlbSB0byBzaG93LlsvZW5dXG4gICAgICAgICogICBbamFd6KGo56S644GZ44KLb25zLWNhcm91c2VsLWl0ZW3jgpJpbmRleOOBp+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnc2V0QWN0aXZlQ2Fyb3VzZWxJdGVtSW5kZXgnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBY3RpdmVDYXJvdXNlbEl0ZW1JbmRleChpbmRleCkge1xuICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgIGlmIChvcHRpb25zICYmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IGJhYmVsSGVscGVycy50eXBlb2Yob3B0aW9ucykpICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoeyBkdXJhdGlvbjogMC4zLCB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknIH0sIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSwgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykgPyB1dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZSh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkgOiB7fSk7XG5cbiAgICAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMuZ2V0Q2Fyb3VzZWxJdGVtQ291bnQoKSAtIDEpKTtcbiAgICAgICAgIHZhciBzY3JvbGwgPSAodGhpcy5fb2Zmc2V0IHx8IDApICsgdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpICogaW5kZXg7XG4gICAgICAgICB2YXIgbWF4ID0gdGhpcy5fY2FsY3VsYXRlTWF4U2Nyb2xsKCk7XG5cbiAgICAgICAgIHRoaXMuX3Njcm9sbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgc2Nyb2xsKSk7XG4gICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsVG8odGhpcy5fc2Nyb2xsLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgX3RoaXMyLl90cnlGaXJlUG9zdENoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgIHJldHVybiBfdGhpczI7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGdldEFjdGl2ZUNhcm91c2VsSXRlbUluZGV4XG4gICAgICAgICogQHNpZ25hdHVyZSBnZXRBY3RpdmVDYXJvdXNlbEl0ZW1JbmRleCgpXG4gICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAqICAgW2VuXVRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaW5kZXguWy9lbl1cbiAgICAgICAgKiAgIFtqYV3nj77lnKjooajnpLrjgZfjgabjgYTjgovjgqvjg6vjg7zjgrvjg6vopoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgYzov5TjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBvbnMtY2Fyb3VzZWwtaXRlbS5bL2VuXVxuICAgICAgICAqICAgW2phXeePvuWcqOihqOekuuOBleOCjOOBpuOBhOOCi29ucy1jYXJvdXNlbC1pdGVt6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZ2V0QWN0aXZlQ2Fyb3VzZWxJdGVtSW5kZXgnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBY3RpdmVDYXJvdXNlbEl0ZW1JbmRleCgpIHtcbiAgICAgICAgIHZhciBzY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSAodGhpcy5fb2Zmc2V0IHx8IDApO1xuICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRDYXJvdXNlbEl0ZW1Db3VudCgpO1xuICAgICAgICAgdmFyIHNpemUgPSB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCk7XG5cbiAgICAgICAgIGlmIChzY3JvbGwgPCAwKSB7XG4gICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgaSA9IHVuZGVmaW5lZDtcbiAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgIGlmIChzaXplICogaSA8PSBzY3JvbGwgJiYgc2l6ZSAqIChpICsgMSkgPiBzY3JvbGwpIHtcbiAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICAvLyBtYXggY2Fyb3VzZWwgaW5kZXhcbiAgICAgICAgIHJldHVybiBpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgbmV4dFxuICAgICAgICAqIEBzaWduYXR1cmUgbmV4dChbb3B0aW9uc10pXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqICAgW2VuXVsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICAgICAgKiAgIFtlbl1bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICAgICAgKiAgIFtlbl1bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAgICAgICogICBbZW5dWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU2hvdyBuZXh0IG9ucy1jYXJvdXNlbCBpdGVtLlsvZW5dXG4gICAgICAgICogICBbamFd5qyh44Gub25zLWNhcm91c2VsLWl0ZW3jgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICduZXh0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dChvcHRpb25zKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVDYXJvdXNlbEl0ZW1JbmRleCh0aGlzLmdldEFjdGl2ZUNhcm91c2VsSXRlbUluZGV4KCkgKyAxLCBvcHRpb25zKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHByZXZcbiAgICAgICAgKiBAc2lnbmF0dXJlIHByZXYoW29wdGlvbnNdKVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAgICAgICogICBbZW5dWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAgICAgICogICBbZW5dWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgICAgICAqICAgW2VuXVsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNob3cgcHJldmlvdXMgb25zLWNhcm91c2VsIGl0ZW0uWy9lbl1cbiAgICAgICAgKiAgIFtqYV3liY3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3ByZXYnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmV2KG9wdGlvbnMpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUNhcm91c2VsSXRlbUluZGV4KHRoaXMuZ2V0QWN0aXZlQ2Fyb3VzZWxJdGVtSW5kZXgoKSAtIDEsIG9wdGlvbnMpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgc2V0QXV0b1Njcm9sbEVuYWJsZWRcbiAgICAgICAgKiBAc2lnbmF0dXJlIHNldEF1dG9TY3JvbGxFbmFibGVkKGVuYWJsZWQpXG4gICAgICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICAgICogICBbZW5dSWYgdHJ1ZSBhdXRvIHNjcm9sbCB3aWxsIGJlIGVuYWJsZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg7zjg4jjgrnjgq/jg63jg7zjg6vjgpLmnInlirnjgavjgZnjgovloLTlkIjjgavjga90cnVl44KS5rih44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1FbmFibGUgb3IgZGlzYWJsZSBcImF1dG8tc2Nyb2xsXCIgYXR0cmlidXRlLlsvZW5dXG4gICAgICAgICogICBbamFdYXV0by1zY3JvbGzlsZ7mgKfjgYzjgYLjgovjgYvjganjgYbjgYvjgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdzZXRBdXRvU2Nyb2xsRW5hYmxlZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF1dG9TY3JvbGxFbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhdXRvLXNjcm9sbCcsICcnKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdhdXRvLXNjcm9sbCcpO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaXNBdXRvU2Nyb2xsRW5hYmxlZFxuICAgICAgICAqIEBzaWduYXR1cmUgaXNBdXRvU2Nyb2xsRW5hYmxlZCgpXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKiAgIFtlbl10cnVlIGlmIGF1dG8gc2Nyb2xsIGlzIGVuYWJsZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg7zjg4jjgrnjgq/jg63jg7zjg6vjgYzmnInlirnjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIFwiYXV0by1zY3JvbGxcIiBhdHRyaWJ1dGUgaXMgc2V0IG9yIG5vdC5bL2VuXVxuICAgICAgICAqICAgW2phXWF1dG8tc2Nyb2xs5bGe5oCn44GM44GC44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNBdXRvU2Nyb2xsRW5hYmxlZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzQXV0b1Njcm9sbEVuYWJsZWQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsJyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBzZXREaXNhYmxlZFxuICAgICAgICAqIEBzaWduYXR1cmUgc2V0RGlzYWJsZWQoZGlzYWJsZWQpXG4gICAgICAgICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZFxuICAgICAgICAqICAgW2VuXUlmIHRydWUgdGhlIGNhcm91c2VsIHdpbGwgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1kaXNhYmxlZOeKtuaFi+OBq+OBmeOCi+WgtOWQiOOBq+OBr3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXURpc2FibGUgb3IgZW5hYmxlIHRoZSBkaWFsb2cuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1kaXNhYmxlZOWxnuaAp+OBjOOBguOCi+OBi+OBqeOBhuOBi+OCkuioreWumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldERpc2FibGVkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnJyk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzRGlzYWJsZWRcbiAgICAgICAgKiBAc2lnbmF0dXJlIGlzRGlzYWJsZWQoKVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAgICAgICogICBbamFdZGlzYWJsZWTnirbmhYvjgavjgarjgaPjgabjgYTjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZCBvciBlbmFibGVkLlsvZW5dXG4gICAgICAgICogICBbamFdZGlzYWJsZWTlsZ7mgKfjgYzjgYLjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdpc0Rpc2FibGVkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNEaXNhYmxlZCgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHNldE92ZXJzY3JvbGxhYmxlXG4gICAgICAgICogQHNpZ25hdHVyZSBzZXRPdmVyc2Nyb2xsYWJsZShvdmVyc2Nyb2xsYWJsZSlcbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG92ZXJzY3JvbGxhYmxlXG4gICAgICAgICogICBbZW5dSWYgdHJ1ZSB0aGUgY2Fyb3VzZWwgd2lsbCBiZSBvdmVyc2Nyb2xsYWJsZS5bL2VuXVxuICAgICAgICAqICAgW2phXW92ZXJzY3JvbGzjgafjgY3jgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNldCB3aGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBvdmVyc2Nyb2xsYWJsZSBvciBub3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1vdmVyc2Nyb2xs5bGe5oCn44GM44GC44KL44GL44Gp44GG44GL44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnc2V0T3ZlcnNjcm9sbGFibGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPdmVyc2Nyb2xsYWJsZShzY3JvbGxhYmxlKSB7XG4gICAgICAgICBpZiAoc2Nyb2xsYWJsZSkge1xuICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnb3ZlcnNjcm9sbGFibGUnLCAnJyk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnb3ZlcnNjcm9sbGFibGUnKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzT3ZlcnNjcm9sbGFibGVcbiAgICAgICAgKiBAc2lnbmF0dXJlIGlzT3ZlcnNjcm9sbGFibGUoKVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgb3ZlcnNjcm9sbGFibGUgb3Igbm90LlsvZW5dXG4gICAgICAgICogICBbamFdb3ZlcnNjcm9sbOOBp+OBjeOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgb3ZlcnNjcm9sbGFibGUgb3Igbm90LlsvZW5dXG4gICAgICAgICogICBbamFdb3ZlcnNjcm9sbOWxnuaAp+OBjOOBguOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzT3ZlcnNjcm9sbGFibGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc092ZXJzY3JvbGxhYmxlKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdvdmVyc2Nyb2xsYWJsZScpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgc2V0Q2VudGVyZWRcbiAgICAgICAgKiBAc2lnbmF0dXJlIHNldENlbnRlcmVkKGNlbnRlcmVkKVxuICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2VudGVyZWRcbiAgICAgICAgKiAgIFtlbl1JZiB0cnVlIHRoZSBjYXJvdXNlbCB3aWxsIGJlIGNlbnRlcmVkLlsvZW5dXG4gICAgICAgICogICBbamFdY2VudGVyZWTnirbmhYvjgavjgZnjgovloLTlkIjjgavjga90cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1TZXQgd2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgY2VudGVyZWQgb3Igbm90LlsvZW5dXG4gICAgICAgICogICBbamFdY2VudGVyZWTlsZ7mgKfjgYzjgYLjgovjgYvjganjgYbjgYvjgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdzZXRDZW50ZXJlZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldENlbnRlcmVkKGNlbnRlcmVkKSB7XG4gICAgICAgICBpZiAoY2VudGVyZWQpIHtcbiAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NlbnRlcmVkJywgJycpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2NlbnRlcmVkJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc0NlbnRlcmVkXG4gICAgICAgICogQHNpZ25hdHVyZSBpc0NlbnRlcmVkKClcbiAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGNlbnRlcmVkIG9yIG5vdC5bL2VuXVxuICAgICAgICAqICAgW2phXWNlbnRlcmVk54q25oWL44Gr44Gq44Gj44Gm44GE44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBjZW50ZXJlZCBvciBub3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1jZW50ZXJlZOWxnuaAp+OBjOOBguOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzQ2VudGVyZWQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NlbnRlcmVkKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjZW50ZXJlZCcpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19pc0VuYWJsZWRDaGFuZ2VFdmVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0VuYWJsZWRDaGFuZ2VFdmVudCgpIHtcbiAgICAgICAgIHZhciBlbGVtZW50U2l6ZSA9IHRoaXMuX2dldEVsZW1lbnRTaXplKCk7XG4gICAgICAgICB2YXIgY2Fyb3VzZWxJdGVtU2l6ZSA9IHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuaXNBdXRvU2Nyb2xsRW5hYmxlZCgpICYmIGVsZW1lbnRTaXplID09PSBjYXJvdXNlbEl0ZW1TaXplO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19pc1ZlcnRpY2FsJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzVmVydGljYWwoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19wcmVwYXJlRXZlbnRMaXN0ZW5lcnMnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLCB7XG4gICAgICAgICAgIGRyYWdNaW5EaXN0YW5jZTogMVxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIHRoaXMuX3VwZGF0ZVN3aXBlYWJsZSgpO1xuXG4gICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPblJlc2l6ZSwgdHJ1ZSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3JlbW92ZUV2ZW50TGlzdGVuZXJzJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcbiAgICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG51bGw7XG5cbiAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uUmVzaXplLCB0cnVlKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfdXBkYXRlU3dpcGVhYmxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVN3aXBlYWJsZSgpIHtcbiAgICAgICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgaWYgKHRoaXMuaXNTd2lwZWFibGUoKSkge1xuICAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vbignZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIHN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IHN3aXBldXAgc3dpcGVkb3duJywgdGhpcy5fYm91bmRPbkRyYWcpO1xuICAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vbignZHJhZ2VuZCcsIHRoaXMuX2JvdW5kT25EcmFnRW5kKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub2ZmKCdkcmFnIGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFndXAgZHJhZ2Rvd24gc3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHQgc3dpcGV1cCBzd2lwZWRvd24nLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9mZignZHJhZ2VuZCcsIHRoaXMuX2JvdW5kT25EcmFnRW5kKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ190cnlGaXJlUG9zdENoYW5nZUV2ZW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKSB7XG4gICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5nZXRBY3RpdmVDYXJvdXNlbEl0ZW1JbmRleCgpO1xuXG4gICAgICAgICBpZiAodGhpcy5fbGFzdEFjdGl2ZUluZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgdmFyIGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX2xhc3RBY3RpdmVJbmRleDtcbiAgICAgICAgICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gY3VycmVudEluZGV4O1xuXG4gICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIHtcbiAgICAgICAgICAgICBjYXJvdXNlbDogdGhpcyxcbiAgICAgICAgICAgICBhY3RpdmVJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgIGxhc3RBY3RpdmVJbmRleDogbGFzdEFjdGl2ZUluZGV4XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkRyYWcnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25EcmFnKGV2ZW50KSB7XG4gICAgICAgICB2YXIgZGlyZWN0aW9uID0gZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb247XG4gICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCgpICYmIChkaXJlY3Rpb24gPT09ICdsZWZ0JyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcpIHx8ICF0aGlzLl9pc1ZlcnRpY2FsKCkgJiYgKGRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBkaXJlY3Rpb24gPT09ICdkb3duJykpIHtcbiAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuXG4gICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgdGhpcy5fbGFzdERyYWdFdmVudCA9IGV2ZW50O1xuXG4gICAgICAgICB2YXIgc2Nyb2xsID0gdGhpcy5fc2Nyb2xsIC0gdGhpcy5fZ2V0U2Nyb2xsRGVsdGEoZXZlbnQpO1xuICAgICAgICAgdGhpcy5fc2Nyb2xsVG8oc2Nyb2xsKTtcbiAgICAgICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkRyYWdFbmQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnRTaXplID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICB0aGlzLl9zY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSB0aGlzLl9nZXRTY3JvbGxEZWx0YShldmVudCk7XG5cbiAgICAgICAgIGlmICh0aGlzLl9nZXRTY3JvbGxEZWx0YShldmVudCkgIT09IDApIHtcbiAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICh0aGlzLl9pc092ZXJTY3JvbGwodGhpcy5fc2Nyb2xsKSkge1xuICAgICAgICAgICB2YXIgd2FpdEZvckFjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ292ZXJzY3JvbGwnLCB7XG4gICAgICAgICAgICAgY2Fyb3VzZWw6IHRoaXMsXG4gICAgICAgICAgICAgYWN0aXZlSW5kZXg6IHRoaXMuZ2V0QWN0aXZlQ2Fyb3VzZWxJdGVtSW5kZXgoKSxcbiAgICAgICAgICAgICBkaXJlY3Rpb246IHRoaXMuX2dldE92ZXJTY3JvbGxEaXJlY3Rpb24oKSxcbiAgICAgICAgICAgICB3YWl0VG9SZXR1cm46IGZ1bmN0aW9uIHdhaXRUb1JldHVybihwcm9taXNlKSB7XG4gICAgICAgICAgICAgICB3YWl0Rm9yQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMuX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwoKTtcbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgaWYgKCF3YWl0Rm9yQWN0aW9uKSB7XG4gICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCgpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLl9zdGFydE1vbWVudHVtU2Nyb2xsKCk7XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLl9sYXN0RHJhZ0V2ZW50ID0gbnVsbDtcblxuICAgICAgICAgZXZlbnQuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFpdFxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfbWl4aW4nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWl4aW4odHJhaXQpIHtcbiAgICAgICAgIE9iamVjdC5rZXlzKHRyYWl0KS5mb3JFYWNoKChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgIHRoaXNba2V5XSA9IHRyYWl0W2tleV07XG4gICAgICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfc3RhcnRNb21lbnR1bVNjcm9sbCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydE1vbWVudHVtU2Nyb2xsKCkge1xuICAgICAgICAgaWYgKHRoaXMuX2xhc3REcmFnRXZlbnQpIHtcbiAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5fZ2V0U2Nyb2xsVmVsb2NpdHkodGhpcy5fbGFzdERyYWdFdmVudCk7XG4gICAgICAgICAgIHZhciBkdXJhdGlvbiA9IDAuMztcbiAgICAgICAgICAgdmFyIHNjcm9sbERlbHRhID0gZHVyYXRpb24gKiAxMDAgKiB2ZWxvY2l0eTtcbiAgICAgICAgICAgdmFyIHNjcm9sbCA9IHRoaXMuX25vcm1hbGl6ZVNjcm9sbFBvc2l0aW9uKHRoaXMuX3Njcm9sbCArICh0aGlzLl9nZXRTY3JvbGxEZWx0YSh0aGlzLl9sYXN0RHJhZ0V2ZW50KSA+IDAgPyAtc2Nyb2xsRGVsdGEgOiBzY3JvbGxEZWx0YSkpO1xuXG4gICAgICAgICAgIHRoaXMuX3Njcm9sbCA9IHNjcm9sbDtcblxuICAgICAgICAgICBhbmltaXQodGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKSkucXVldWUoe1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVTY3JvbGxUcmFuc2Zvcm0odGhpcy5fc2Nyb2xsKVxuICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKSdcbiAgICAgICAgICAgfSkucXVldWUoKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgIHRoaXMuX3RyeUZpcmVQb3N0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgICAgfSkuYmluZCh0aGlzKSkucGxheSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19ub3JtYWxpemVTY3JvbGxQb3NpdGlvbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ub3JtYWxpemVTY3JvbGxQb3NpdGlvbihzY3JvbGwpIHtcbiAgICAgICAgIHZhciBtYXggPSB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKTtcblxuICAgICAgICAgaWYgKCF0aGlzLmlzQXV0b1Njcm9sbEVuYWJsZWQoKSkge1xuICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCBzY3JvbGwpKTtcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgIHZhciBzaXplID0gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtU2l6ZSgpO1xuICAgICAgICAgdmFyIG5ick9mSXRlbXMgPSB0aGlzLmdldENhcm91c2VsSXRlbUNvdW50KCk7XG5cbiAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmJyT2ZJdGVtczsgaSsrKSB7XG4gICAgICAgICAgIGlmIChpICogc2l6ZSArIHRoaXMuX29mZnNldCA8IG1heCkge1xuICAgICAgICAgICAgIGFyci5wdXNoKGkgKiBzaXplICsgdGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgYXJyLnB1c2gobWF4KTtcblxuICAgICAgICAgYXJyLnNvcnQoZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgIGxlZnQgPSBNYXRoLmFicyhsZWZ0IC0gc2Nyb2xsKTtcbiAgICAgICAgICAgcmlnaHQgPSBNYXRoLmFicyhyaWdodCAtIHNjcm9sbCk7XG5cbiAgICAgICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICAgICAgIH0pO1xuXG4gICAgICAgICBhcnIgPSBhcnIuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBwb3MpIHtcbiAgICAgICAgICAgcmV0dXJuICFwb3MgfHwgaXRlbSAhPSBhcnJbcG9zIC0gMV07XG4gICAgICAgICB9KTtcblxuICAgICAgICAgdmFyIGxhc3RTY3JvbGwgPSB0aGlzLl9sYXN0QWN0aXZlSW5kZXggKiBzaXplICsgdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgdmFyIHNjcm9sbFJhdGlvID0gTWF0aC5hYnMoc2Nyb2xsIC0gbGFzdFNjcm9sbCkgLyBzaXplO1xuICAgICAgICAgdmFyIHJlc3VsdCA9IGFyclswXTtcblxuICAgICAgICAgaWYgKHNjcm9sbFJhdGlvIDw9IHRoaXMuZ2V0QXV0b1Njcm9sbFJhdGlvKCkpIHtcbiAgICAgICAgICAgcmVzdWx0ID0gbGFzdFNjcm9sbDtcbiAgICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsUmF0aW8gPCAxLjApIHtcbiAgICAgICAgICAgaWYgKGFyclswXSA9PT0gbGFzdFNjcm9sbCAmJiBhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgIHJlc3VsdCA9IGFyclsxXTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCByZXN1bHQpKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2dldENhcm91c2VsSXRlbUVsZW1lbnRzJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkge1xuICAgICAgICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgcmV0dXJuIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtY2Fyb3VzZWwtaXRlbSc7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19zY3JvbGxUbycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zY3JvbGxUbyhzY3JvbGwpIHtcbiAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICB2YXIgaXNPdmVyc2Nyb2xsYWJsZSA9IHRoaXMuaXNPdmVyc2Nyb2xsYWJsZSgpO1xuXG4gICAgICAgICB2YXIgbm9ybWFsaXplU2Nyb2xsID0gZnVuY3Rpb24gbm9ybWFsaXplU2Nyb2xsKHNjcm9sbCkge1xuICAgICAgICAgICB2YXIgcmF0aW8gPSAwLjM1O1xuXG4gICAgICAgICAgIGlmIChzY3JvbGwgPCAwKSB7XG4gICAgICAgICAgICAgcmV0dXJuIGlzT3ZlcnNjcm9sbGFibGUgPyBNYXRoLnJvdW5kKHNjcm9sbCAqIHJhdGlvKSA6IDA7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB2YXIgbWF4U2Nyb2xsID0gX3RoaXM0Ll9jYWxjdWxhdGVNYXhTY3JvbGwoKTtcbiAgICAgICAgICAgaWYgKG1heFNjcm9sbCA8IHNjcm9sbCkge1xuICAgICAgICAgICAgIHJldHVybiBpc092ZXJzY3JvbGxhYmxlID8gbWF4U2Nyb2xsICsgTWF0aC5yb3VuZCgoc2Nyb2xsIC0gbWF4U2Nyb2xsKSAqIHJhdGlvKSA6IG1heFNjcm9sbDtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIHJldHVybiBzY3JvbGw7XG4gICAgICAgICB9O1xuXG4gICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgYW5pbWl0KF90aGlzNC5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKSkucXVldWUoe1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogX3RoaXM0Ll9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybShub3JtYWxpemVTY3JvbGwoc2Nyb2xsKSlcbiAgICAgICAgICAgfSwgb3B0aW9ucy5hbmltYXRpb24gIT09ICdub25lJyA/IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA6IHt9KS5wbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY2FsY3VsYXRlTWF4U2Nyb2xsJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZU1heFNjcm9sbCgpIHtcbiAgICAgICAgIHZhciBtYXggPSB0aGlzLmdldENhcm91c2VsSXRlbUNvdW50KCkgKiB0aGlzLl9nZXRDYXJvdXNlbEl0ZW1TaXplKCkgLSB0aGlzLl9nZXRFbGVtZW50U2l6ZSgpO1xuICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChtYXggPCAwID8gMCA6IG1heCk7IC8vIE5lZWQgdG8gcmV0dXJuIGFuIGludGVnZXIgdmFsdWUuXG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2lzT3ZlclNjcm9sbCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc092ZXJTY3JvbGwoc2Nyb2xsKSB7XG4gICAgICAgICBpZiAoc2Nyb2xsIDwgMCB8fCBzY3JvbGwgPiB0aGlzLl9jYWxjdWxhdGVNYXhTY3JvbGwoKSkge1xuICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0T3ZlclNjcm9sbERpcmVjdGlvbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRPdmVyU2Nyb2xsRGlyZWN0aW9uKCkge1xuICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwoKSkge1xuICAgICAgICAgICBpZiAodGhpcy5fc2Nyb2xsIDw9IDApIHtcbiAgICAgICAgICAgICByZXR1cm4gJ3VwJztcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICByZXR1cm4gJ2Rvd24nO1xuICAgICAgICAgICB9XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBpZiAodGhpcy5fc2Nyb2xsIDw9IDApIHtcbiAgICAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3Njcm9sbFRvS2lsbE92ZXJTY3JvbGwnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCgpIHtcbiAgICAgICAgIHZhciBkdXJhdGlvbiA9IDAuNDtcblxuICAgICAgICAgaWYgKHRoaXMuX3Njcm9sbCA8IDApIHtcbiAgICAgICAgICAgYW5pbWl0KHRoaXMuX2dldENhcm91c2VsSXRlbUVsZW1lbnRzKCkpLnF1ZXVlKHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlU2Nyb2xsVHJhbnNmb3JtKDApXG4gICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNCwgLjEsIDEpJ1xuICAgICAgICAgICB9KS5xdWV1ZSgoZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICB9KS5iaW5kKHRoaXMpKS5wbGF5KCk7XG4gICAgICAgICAgIHRoaXMuX3Njcm9sbCA9IDA7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIG1heFNjcm9sbCA9IHRoaXMuX2NhbGN1bGF0ZU1heFNjcm9sbCgpO1xuXG4gICAgICAgICBpZiAobWF4U2Nyb2xsIDwgdGhpcy5fc2Nyb2xsKSB7XG4gICAgICAgICAgIGFuaW1pdCh0aGlzLl9nZXRDYXJvdXNlbEl0ZW1FbGVtZW50cygpKS5xdWV1ZSh7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9nZW5lcmF0ZVNjcm9sbFRyYW5zZm9ybShtYXhTY3JvbGwpXG4gICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNCwgLjEsIDEpJ1xuICAgICAgICAgICB9KS5xdWV1ZSgoZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgdGhpcy5fdHJ5RmlyZVBvc3RDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICB9KS5iaW5kKHRoaXMpKS5wbGF5KCk7XG4gICAgICAgICAgIHRoaXMuX3Njcm9sbCA9IG1heFNjcm9sbDtcbiAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm47XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBnZXRDYXJvdXNlbEl0ZW1Db3VudFxuICAgICAgICAqIEBzaWduYXR1cmUgZ2V0Q2Fyb3VzZWxJdGVtQ291bnQpXG4gICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAqICAgW2VuXVRoZSBudW1iZXIgb2YgY2Fyb3VzZWwgaXRlbXMuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vopoHntKDjga7mlbDjgafjgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIGNhcm91c2VsIGl0ZW1zLi5bL2VuXVxuICAgICAgICAqICAgW2phXeePvuWcqOOBruOCq+ODq+ODvOOCu+ODq+imgee0oOOCkuaVsOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2dldENhcm91c2VsSXRlbUNvdW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2Fyb3VzZWxJdGVtQ291bnQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2Fyb3VzZWxJdGVtRWxlbWVudHMoKS5sZW5ndGg7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCByZWZyZXNoXG4gICAgICAgICogQHNpZ25hdHVyZSByZWZyZXNoKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1VcGRhdGUgdGhlIGxheW91dCBvZiB0aGUgY2Fyb3VzZWwuIFVzZWQgd2hlbiBhZGRpbmcgb25zLWNhcm91c2VsLWl0ZW1zIGR5bmFtaWNhbGx5IG9yIHRvIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHRoZSBzaXplLlsvZW5dXG4gICAgICAgICogICBbamFd44Os44Kk44Ki44Km44OI44KE5YaF6YOo44Gu54q25oWL44KS5pyA5paw44Gu44KC44Gu44Gr5pu05paw44GX44G+44GZ44CCb25zLWNhcm91c2VsLWl0ZW3jgpLli5XnmoTjgavlopfjgoTjgZfjgZ/jgorjgIFvbnMtY2Fyb3VzZWzjga7lpKfjgY3jgZXjgpLli5XnmoTjgavlpInjgYjjgovpmpvjgavliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3JlZnJlc2gnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgICAgLy8gQnVnIGZpeFxuICAgICAgICAgaWYgKHRoaXMuX2dldENhcm91c2VsSXRlbVNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX21peGluKHRoaXMuX2lzVmVydGljYWwoKSA/IFZlcnRpY2FsTW9kZVRyYWl0IDogSG9yaXpvbnRhbE1vZGVUcmFpdCk7XG4gICAgICAgICB0aGlzLl9zZXR1cCgpO1xuXG4gICAgICAgICBpZiAodGhpcy5fbGFzdFN0YXRlICYmIHRoaXMuX2xhc3RTdGF0ZS53aWR0aCA+IDApIHtcbiAgICAgICAgICAgdmFyIHNjcm9sbCA9IHRoaXMuX3Njcm9sbDsgLy8gLSB0aGlzLl9vZmZzZXQ7XG5cbiAgICAgICAgICAgaWYgKHRoaXMuX2lzT3ZlclNjcm9sbChzY3JvbGwpKSB7XG4gICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9LaWxsT3ZlclNjcm9sbCgpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIGlmICh0aGlzLmlzQXV0b1Njcm9sbEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgc2Nyb2xsID0gdGhpcy5fbm9ybWFsaXplU2Nyb2xsUG9zaXRpb24oc2Nyb2xsKTtcbiAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICB0aGlzLl9zY3JvbGxUbyhzY3JvbGwpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX3NhdmVMYXN0U3RhdGUoKTtcblxuICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWZyZXNoJywgeyBjYXJvdXNlbDogdGhpcyB9KTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGZpcnN0XG4gICAgICAgICogQHNpZ25hdHVyZSBmaXJzdCgpXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1TaG93IGZpcnN0IG9ucy1jYXJvdXNlbCBpdGVtLlsvZW5dXG4gICAgICAgICogICBbamFd5pyA5Yid44Gub25zLWNhcm91c2VsLWl0ZW3jgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdmaXJzdCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KG9wdGlvbnMpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUNhcm91c2VsSXRlbUluZGV4KDAsIG9wdGlvbnMpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgbGFzdFxuICAgICAgICAqIEBzaWduYXR1cmUgbGFzdCgpXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAgICAgICogICBbamFdUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNob3cgbGFzdCBvbnMtY2Fyb3VzZWwgaXRlbS5bL2VuXVxuICAgICAgICAqICAgW2phXeacgOW+jOOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnbGFzdCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxhc3Qob3B0aW9ucykge1xuICAgICAgICAgdGhpcy5zZXRBY3RpdmVDYXJvdXNlbEl0ZW1JbmRleChNYXRoLm1heCh0aGlzLmdldENhcm91c2VsSXRlbUNvdW50KCkgLSAxLCAwKSwgb3B0aW9ucyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLl9wcmVwYXJlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgICAgdGhpcy5fc2V0dXAoKTtcbiAgICAgICAgIHRoaXMuX3NldHVwSW5pdGlhbEluZGV4KCk7XG5cbiAgICAgICAgIHRoaXMuX3NhdmVMYXN0U3RhdGUoKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgIGNhc2UgJ3N3aXBlYWJsZSc6XG4gICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3dpcGVhYmxlKCk7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgJ2RpcmVjdGlvbic6XG4gICAgICAgICAgICAgdGhpcy5fb25EaXJlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdkZXRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBDYXJvdXNlbEVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNDYXJvdXNlbEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1jYXJvdXNlbCcsIHtcbiAgICAgcHJvdG90eXBlOiBDYXJvdXNlbEVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtY29sXG4gICAgKiBAY2F0ZWdvcnkgZ3JpZFxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1SZXByZXNlbnRzIGEgY29sdW1uIGluIHRoZSBncmlkIHN5c3RlbS4gVXNlIHdpdGggb25zLXJvdyB0byBsYXlvdXQgY29tcG9uZW50cy5bL2VuXVxuICAgICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm5YiX44KS5a6a576p44GX44G+44GZ44CCb25zLXJvd+OBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBruODrOOCpOOCouOCpuODiOOBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAbm90ZVxuICAgICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sdW1uLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgYWxpZ24uWy9lbl1cbiAgICAqICAgW2phXUFuZHJvaWQgNC4z5Lul5YmN44CB44KC44GX44GP44GvaU9TIDbku6XliY3jga5PU+OBruWgtOWQiOOAgW9ucy1yb3fjgahvbnMtY29sdW1u44KS57WE44G/5ZCI44KP44Gb44Gf5aC05ZCI44Gr5o+P55S744GM5bSp44KM44KL5aC05ZCI44GM44GC44KK44G+44GZ44CCWy9qYV1cbiAgICAqIEBjb2RlcGVuIEdndWpDIHt3aWRlfVxuICAgICogQGd1aWRlIGxheW91dGluZyBbZW5dTGF5b3V0aW5nIGd1aWRlWy9lbl1bamFd44Os44Kk44Ki44Km44OI5qmf6IO9Wy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1yb3cgW2VuXW9ucy1yb3cgY29tcG9uZW50Wy9lbl1bamFdb25zLXJvd+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gICAgKiBAZXhhbXBsZVxuICAgICogPG9ucy1yb3c+XG4gICAgKiAgIDxvbnMtY29sIHdpZHRoPVwiNTBweFwiPjxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+PC9vbnMtY29sPlxuICAgICogICA8b25zLWNvbD5UZXh0PC9vbnMtY29sPlxuICAgICogPC9vbnMtcm93PlxuICAgICovXG5cbiAgIC8qKlxuICAgICogQGF0dHJpYnV0ZSB2ZXJ0aWNhbC1hbGlnblxuICAgICogQHR5cGUge1N0cmluZ31cbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dVmVydGljYWwgYWxpZ25tZW50IG9mIHRoZSBjb2x1bW4uIFZhbGlkIHZhbHVlcyBhcmUgXCJ0b3BcIiwgXCJjZW50ZXJcIiwgYW5kIFwiYm90dG9tXCIuWy9lbl1cbiAgICAqICAgW2phXee4puOBrumFjee9ruOCkuaMh+WumuOBmeOCi+OAglwidG9wXCIsIFwiY2VudGVyXCIsIFwiYm90dG9tXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICovXG5cbiAgIC8qKlxuICAgICogQGF0dHJpYnV0ZSB3aWR0aFxuICAgICogQHR5cGUge1N0cmluZ31cbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dVGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4uIFZhbGlkIHZhbHVlcyBhcmUgY3NzIHdpZHRoIHZhbHVlcyAoXCIxMCVcIiwgXCI1MHB4XCIpLlsvZW5dXG4gICAgKiAgIFtqYV3jgqvjg6njg6Djga7mqKrluYXjgpLmjIflrprjgZnjgovjgILjg5Hjg7zjgrvjg7Pjg4jjgoLjgZfjgY/jga/jg5Tjgq/jgrvjg6vjgafmjIflrprjgZfjgb7jgZnvvIgxMCXjgoQ1MHB477yJ44CCWy9qYV1cbiAgICAqL1xuXG4gICB2YXIgQ29sdW1uRWxlbWVudCA9IChmdW5jdGlvbiAoX0Jhc2VFbGVtZW50KSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhDb2x1bW5FbGVtZW50LCBfQmFzZUVsZW1lbnQpO1xuXG4gICAgIGZ1bmN0aW9uIENvbHVtbkVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbHVtbkVsZW1lbnQpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29sdW1uRWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoQ29sdW1uRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpIHtcbiAgICAgICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgaWYgKG5hbWUgPT09ICd3aWR0aCcpIHtcbiAgICAgICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfdXBkYXRlV2lkdGgnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlV2lkdGgoKSB7XG4gICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgIGlmICh0eXBlb2Ygd2lkdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgIHdpZHRoID0gKCcnICsgd2lkdGgpLnRyaW0oKTtcbiAgICAgICAgICAgd2lkdGggPSB3aWR0aC5tYXRjaCgvXlxcZCskLykgPyB3aWR0aCArICclJyA6IHdpZHRoO1xuXG4gICAgICAgICAgIHRoaXMuc3R5bGUud2Via2l0Qm94RmxleCA9ICcwJztcbiAgICAgICAgICAgdGhpcy5zdHlsZS53ZWJraXRGbGV4ID0gJzAgMCAnICsgd2lkdGg7XG4gICAgICAgICAgIHRoaXMuc3R5bGUubW96Qm94RmxleCA9ICcwJztcbiAgICAgICAgICAgdGhpcy5zdHlsZS5tb3pGbGV4ID0gJzAgMCAnICsgd2lkdGg7XG4gICAgICAgICAgIHRoaXMuc3R5bGUubXNGbGV4ID0gJzAgMCAnICsgd2lkdGg7XG4gICAgICAgICAgIHRoaXMuc3R5bGUuZmxleCA9ICcwIDAgJyArIHdpZHRoO1xuICAgICAgICAgICB0aGlzLnN0eWxlLm1heFdpZHRoID0gd2lkdGg7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBDb2x1bW5FbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zQ29sRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWNvbCcsIHtcbiAgICAgcHJvdG90eXBlOiBDb2x1bW5FbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIC8qXG4gICBDb3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiAgICovXG5cbiAgIHZhciBEaWFsb2dBbmltYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgIGZ1bmN0aW9uIERpYWxvZ0FuaW1hdG9yKCkge1xuICAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICB2YXIgX3JlZiR0aW1pbmcgPSBfcmVmLnRpbWluZztcbiAgICAgICB2YXIgdGltaW5nID0gX3JlZiR0aW1pbmcgPT09IHVuZGVmaW5lZCA/ICdsaW5lYXInIDogX3JlZiR0aW1pbmc7XG4gICAgICAgdmFyIF9yZWYkZGVsYXkgPSBfcmVmLmRlbGF5O1xuICAgICAgIHZhciBkZWxheSA9IF9yZWYkZGVsYXkgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGRlbGF5O1xuICAgICAgIHZhciBfcmVmJGR1cmF0aW9uID0gX3JlZi5kdXJhdGlvbjtcbiAgICAgICB2YXIgZHVyYXRpb24gPSBfcmVmJGR1cmF0aW9uID09PSB1bmRlZmluZWQgPyAwLjIgOiBfcmVmJGR1cmF0aW9uO1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBEaWFsb2dBbmltYXRvcik7XG5cbiAgICAgICB0aGlzLnRpbWluZyA9IHRpbWluZztcbiAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICB9XG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAgICAqL1xuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhEaWFsb2dBbmltYXRvciwgW3tcbiAgICAgICBrZXk6ICdzaG93JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdyhkaWFsb2csIGRvbmUpIHtcbiAgICAgICAgIGRvbmUoKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2hpZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgICAgICAgZG9uZSgpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gRGlhbG9nQW5pbWF0b3I7XG4gICB9KSgpO1xuXG4gICAvKipcbiAgICAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAgICAqL1xuICAgdmFyIEFuZHJvaWREaWFsb2dBbmltYXRvciA9IChmdW5jdGlvbiAoX0RpYWxvZ0FuaW1hdG9yKSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhBbmRyb2lkRGlhbG9nQW5pbWF0b3IsIF9EaWFsb2dBbmltYXRvcik7XG5cbiAgICAgZnVuY3Rpb24gQW5kcm9pZERpYWxvZ0FuaW1hdG9yKCkge1xuICAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgdmFyIF9yZWYyJHRpbWluZyA9IF9yZWYyLnRpbWluZztcbiAgICAgICB2YXIgdGltaW5nID0gX3JlZjIkdGltaW5nID09PSB1bmRlZmluZWQgPyAnZWFzZS1pbi1vdXQnIDogX3JlZjIkdGltaW5nO1xuICAgICAgIHZhciBfcmVmMiRkZWxheSA9IF9yZWYyLmRlbGF5O1xuICAgICAgIHZhciBkZWxheSA9IF9yZWYyJGRlbGF5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjIkZGVsYXk7XG4gICAgICAgdmFyIF9yZWYyJGR1cmF0aW9uID0gX3JlZjIuZHVyYXRpb247XG4gICAgICAgdmFyIGR1cmF0aW9uID0gX3JlZjIkZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IDAuMyA6IF9yZWYyJGR1cmF0aW9uO1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBBbmRyb2lkRGlhbG9nQW5pbWF0b3IpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQW5kcm9pZERpYWxvZ0FuaW1hdG9yKS5jYWxsKHRoaXMsIHsgdGltaW5nOiB0aW1pbmcsIGRlbGF5OiBkZWxheSwgZHVyYXRpb246IGR1cmF0aW9uIH0pKTtcbiAgICAgfVxuXG4gICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAqL1xuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhBbmRyb2lkRGlhbG9nQW5pbWF0b3IsIFt7XG4gICAgICAga2V5OiAnc2hvdycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgIGFuaW1pdC5ydW5BbGwoYW5pbWl0KGRpYWxvZy5fbWFzaykucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICB9LCB7XG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KSwgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC02MCUsIDApJyxcbiAgICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScsXG4gICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KS5yZXN0b3JlU3R5bGUoKS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICB9KSk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2hpZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICBhbmltaXQucnVuQWxsKGFuaW1pdChkaWFsb2cuX21hc2spLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgfSwge1xuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSksIGFuaW1pdChkaWFsb2cuX2RpYWxvZykuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScsXG4gICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLFxuICAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkucmVzdG9yZVN0eWxlKCkucXVldWUoZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgfSkpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gQW5kcm9pZERpYWxvZ0FuaW1hdG9yO1xuICAgfSkoRGlhbG9nQW5pbWF0b3IpO1xuXG4gICAvKipcbiAgICAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICAgICovXG4gICB2YXIgSU9TRGlhbG9nQW5pbWF0b3IgPSAoZnVuY3Rpb24gKF9EaWFsb2dBbmltYXRvcjIpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKElPU0RpYWxvZ0FuaW1hdG9yLCBfRGlhbG9nQW5pbWF0b3IyKTtcblxuICAgICBmdW5jdGlvbiBJT1NEaWFsb2dBbmltYXRvcigpIHtcbiAgICAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgIHZhciBfcmVmMyR0aW1pbmcgPSBfcmVmMy50aW1pbmc7XG4gICAgICAgdmFyIHRpbWluZyA9IF9yZWYzJHRpbWluZyA9PT0gdW5kZWZpbmVkID8gJ2Vhc2UtaW4tb3V0JyA6IF9yZWYzJHRpbWluZztcbiAgICAgICB2YXIgX3JlZjMkZGVsYXkgPSBfcmVmMy5kZWxheTtcbiAgICAgICB2YXIgZGVsYXkgPSBfcmVmMyRkZWxheSA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYzJGRlbGF5O1xuICAgICAgIHZhciBfcmVmMyRkdXJhdGlvbiA9IF9yZWYzLmR1cmF0aW9uO1xuICAgICAgIHZhciBkdXJhdGlvbiA9IF9yZWYzJGR1cmF0aW9uID09PSB1bmRlZmluZWQgPyAwLjMgOiBfcmVmMyRkdXJhdGlvbjtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgSU9TRGlhbG9nQW5pbWF0b3IpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSU9TRGlhbG9nQW5pbWF0b3IpLmNhbGwodGhpcywgeyB0aW1pbmc6IHRpbWluZywgZGVsYXk6IGRlbGF5LCBkdXJhdGlvbjogZHVyYXRpb24gfSkpO1xuICAgICB9XG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICovXG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKElPU0RpYWxvZ0FuaW1hdG9yLCBbe1xuICAgICAgIGtleTogJ3Nob3cnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICBhbmltaXQucnVuQWxsKGFuaW1pdChkaWFsb2cuX21hc2spLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgfSwge1xuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSksIGFuaW1pdChkaWFsb2cuX2RpYWxvZykuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAzMDAlLCAwKSdcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSdcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaGlkZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgIGFuaW1pdC5ydW5BbGwoYW5pbWl0KGRpYWxvZy5fbWFzaykucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICB9LCB7XG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KSwgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIDMwMCUsIDApJ1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkucmVzdG9yZVN0eWxlKCkucXVldWUoZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgfSkpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gSU9TRGlhbG9nQW5pbWF0b3I7XG4gICB9KShEaWFsb2dBbmltYXRvcik7XG5cbiAgIC8qKlxuICAgICogU2xpZGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAgICAqL1xuICAgdmFyIFNsaWRlRGlhbG9nQW5pbWF0b3IgPSAoZnVuY3Rpb24gKF9EaWFsb2dBbmltYXRvcjMpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKFNsaWRlRGlhbG9nQW5pbWF0b3IsIF9EaWFsb2dBbmltYXRvcjMpO1xuXG4gICAgIGZ1bmN0aW9uIFNsaWRlRGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgICAgdmFyIF9yZWY0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICB2YXIgX3JlZjQkdGltaW5nID0gX3JlZjQudGltaW5nO1xuICAgICAgIHZhciB0aW1pbmcgPSBfcmVmNCR0aW1pbmcgPT09IHVuZGVmaW5lZCA/ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknIDogX3JlZjQkdGltaW5nO1xuICAgICAgIHZhciBfcmVmNCRkZWxheSA9IF9yZWY0LmRlbGF5O1xuICAgICAgIHZhciBkZWxheSA9IF9yZWY0JGRlbGF5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjQkZGVsYXk7XG4gICAgICAgdmFyIF9yZWY0JGR1cmF0aW9uID0gX3JlZjQuZHVyYXRpb247XG4gICAgICAgdmFyIGR1cmF0aW9uID0gX3JlZjQkZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWY0JGR1cmF0aW9uO1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBTbGlkZURpYWxvZ0FuaW1hdG9yKTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNsaWRlRGlhbG9nQW5pbWF0b3IpLmNhbGwodGhpcywgeyB0aW1pbmc6IHRpbWluZywgZGVsYXk6IGRlbGF5LCBkdXJhdGlvbjogZHVyYXRpb24gfSkpO1xuICAgICB9XG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICovXG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKFNsaWRlRGlhbG9nQW5pbWF0b3IsIFt7XG4gICAgICAga2V5OiAnc2hvdycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgIGFuaW1pdC5ydW5BbGwoYW5pbWl0KGRpYWxvZy5fbWFzaykucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICB9LCB7XG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KSwgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC0zNTAlLCAwKSdcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtNTAlLCAwKSdcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaGlkZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgIGFuaW1pdC5ydW5BbGwoYW5pbWl0KGRpYWxvZy5fbWFzaykucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICB9LCB7XG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KSwgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC0zNTAlLCAwKSdcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFNsaWRlRGlhbG9nQW5pbWF0b3I7XG4gICB9KShEaWFsb2dBbmltYXRvcik7XG5cbiAgIHZhciBzY2hlbWUkNiA9IHtcbiAgICAgJy5kaWFsb2cnOiAnZGlhbG9nLS0qJyxcbiAgICAgJy5kaWFsb2ctY29udGFpbmVyJzogJ2RpYWxvZy1jb250YWluZXItLSonLFxuICAgICAnLmRpYWxvZy1tYXNrJzogJ2RpYWxvZy1tYXNrLS0qJ1xuICAgfTtcblxuICAgdmFyIHRlbXBsYXRlU291cmNlJDEgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoJ1xcbiAgPGRpdj5cXG4gICAgPGRpdiBjbGFzcz1cImRpYWxvZy1tYXNrXCI+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XCJkaWFsb2dcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLWNvbnRhaW5lclwiPjwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbicpO1xuXG4gICB2YXIgX2FuaW1hdG9yRGljdCQxID0ge1xuICAgICAnZGVmYXVsdCc6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgIHJldHVybiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWREaWFsb2dBbmltYXRvciA6IElPU0RpYWxvZ0FuaW1hdG9yO1xuICAgICB9LFxuICAgICAnZmFkZSc6IGZ1bmN0aW9uIGZhZGUoKSB7XG4gICAgICAgcmV0dXJuIHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZERpYWxvZ0FuaW1hdG9yIDogSU9TRGlhbG9nQW5pbWF0b3I7XG4gICAgIH0sXG4gICAgICdzbGlkZSc6IFNsaWRlRGlhbG9nQW5pbWF0b3IsXG4gICAgICdub25lJzogRGlhbG9nQW5pbWF0b3JcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLWRpYWxvZ1xuICAgICogQGNhdGVnb3J5IGRpYWxvZ1xuICAgICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gICAgKiAgIFtlbl1EaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGRpYWxvZy5bL2VuXVxuICAgICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogIFtlbl1EaWFsb2cgdGhhdCBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIGN1cnJlbnQgc2NyZWVuLlsvZW5dXG4gICAgKiAgW2phXeePvuWcqOOBruOCueOCr+ODquODvOODs+OBq+ODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAY29kZXBlbiB6eHhhR2FcbiAgICAqIEBndWlkZSBVc2luZ0RpYWxvZ1xuICAgICogICBbZW5dTGVhcm4gaG93IHRvIHVzZSB0aGUgZGlhbG9nIGNvbXBvbmVudC5bL2VuXVxuICAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44Kz44Oz44Od44O844ON44Oz44OI44Gu5L2/44GE5pa5Wy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAgICAqICAgW2VuXW9ucy1hbGVydC1kaWFsb2cgY29tcG9uZW50Wy9lbl1cbiAgICAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICAgICogQHNlZWFsc28gb25zLXBvcG92ZXJcbiAgICAqICAgW2VuXW9ucy1wb3BvdmVyIGNvbXBvbmVudFsvZW5dXG4gICAgKiAgIFtqYV1vbnMtcG9wb3ZlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gICAgKiBAZXhhbXBsZVxuICAgICogPHNjcmlwdD5cbiAgICAqICAgb25zLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICogICAgIG9ucy5jcmVhdGVEaWFsb2coJ2RpYWxvZy5odG1sJykudGhlbihmdW5jdGlvbihkaWFsb2cpIHtcbiAgICAqICAgICAgIGRpYWxvZy5zaG93KCk7XG4gICAgKiAgICAgfSk7XG4gICAgKiAgIH0pO1xuICAgICogPC9zY3JpcHQ+XG4gICAgKlxuICAgICogPHNjcmlwdCB0eXBlPVwidGV4dC9vbnMtdGVtcGxhdGVcIiBpZD1cImRpYWxvZy5odG1sXCI+XG4gICAgKiAgIDxvbnMtZGlhbG9nIGNhbmNlbGFibGU+XG4gICAgKiAgICAgLi4uXG4gICAgKiAgIDwvb25zLWRpYWxvZz5cbiAgICAqIDwvc2NyaXB0PlxuICAgICovXG5cbiAgIHZhciBEaWFsb2dFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKERpYWxvZ0VsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gRGlhbG9nRWxlbWVudCgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlhbG9nRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihEaWFsb2dFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhEaWFsb2dFbGVtZW50LCBbe1xuICAgICAgIGtleTogJ2NyZWF0ZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICAgICAgIHRoaXMuX2JvdW5kQ2FuY2VsID0gdGhpcy5fY2FuY2VsLmJpbmQodGhpcyk7XG5cbiAgICAgICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QkMSxcbiAgICAgICAgICAgYmFzZUNsYXNzOiBEaWFsb2dBbmltYXRvcixcbiAgICAgICAgICAgYmFzZUNsYXNzTmFtZTogJ0RpYWxvZ0FuaW1hdG9yJyxcbiAgICAgICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRlbXBsYXRlU291cmNlJDEuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgdmFyIGRpYWxvZyA9IHRlbXBsYXRlLmNoaWxkcmVuWzFdO1xuXG4gICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgZGlhbG9nLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgZGlhbG9nLmNoaWxkcmVuWzBdLmFwcGVuZENoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHdoaWxlICh0ZW1wbGF0ZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICAgICAgIHRoaXMuX21hc2suc3R5bGUuekluZGV4ID0gMjAwMDA7XG5cbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCduby1zdGF0dXMtYmFyLWZpbGwnLCAnJyk7XG5cbiAgICAgICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lJDYpO1xuXG4gICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgZ2V0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbiAgICAgICAgKiBAc2lnbmF0dXJlIGdldERldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAgICAgICAgKiBAcmV0dXJuIHtPYmplY3QvbnVsbH1cbiAgICAgICAgKiAgIFtlbl1EZXZpY2UgYmFjayBidXR0b24gaGFuZGxlci5bL2VuXVxuICAgICAgICAqICAgW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0cmlldmUgdGhlIGJhY2sgYnV0dG9uIGhhbmRsZXIgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3IuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgpLlj5blvpfjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga7mjJnli5XjgpLlpInmm7TjgZnjgovjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdnZXREZXZpY2VCYWNrQnV0dG9uSGFuZGxlcicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERldmljZUJhY2tCdXR0b25IYW5kbGVyKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2RldmljZUJhY2tCdXR0b25IYW5kbGVyO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkRldmljZUJhY2tCdXR0b24nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGFibGUoKSkge1xuICAgICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2NhbmNlbCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYW5jZWwoKSB7XG4gICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxhYmxlKCkgJiYgIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgICAgICAgIHRoaXMuaGlkZSh7XG4gICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgX3RoaXMyLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQoX3RoaXMyLCAnY2FuY2VsJyk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9KTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHNob3dcbiAgICAgICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgICAgICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJub25lXCIsIFwiZmFkZVwiIGFuZCBcInNsaWRlXCIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAgICAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICAgICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXVNob3cgdGhlIGRpYWxvZy5bL2VuXVxuICAgICAgICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnQuXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3Nob3cnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgIHZhciBfY2FuY2VsMiA9IGZhbHNlO1xuICAgICAgICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQob3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LCBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSk7XG5cbiAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlc2hvdycsIHtcbiAgICAgICAgICAgZGlhbG9nOiB0aGlzLFxuICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICBfY2FuY2VsMiA9IHRydWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuXG4gICAgICAgICBpZiAoIV9jYW5jZWwyKSB7XG4gICAgICAgICAgIHZhciBfcmV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICB2YXIgdHJ5U2hvdyA9IGZ1bmN0aW9uIHRyeVNob3coKSB7XG4gICAgICAgICAgICAgICB2YXIgdW5sb2NrID0gX3RoaXMzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBfdGhpczMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgX3RoaXMzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgX3RoaXMzLl9tYXNrLnN0eWxlLm9wYWNpdHkgPSAnMSc7XG5cbiAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICBhbmltYXRvci5zaG93KF90aGlzMywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgIF90aGlzMy5fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQoX3RoaXMzLCAncG9zdHNob3cnLCB7IGRpYWxvZzogX3RoaXMzIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzMyk7XG4gICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICB2OiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICBfdGhpczMuX2Rvb3JMb2NrLndhaXRVbmxvY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRyeVNob3coKSk7XG4gICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICB9O1xuICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBiYWJlbEhlbHBlcnMudHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlc2hvdyBldmVudC4nKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGhpZGVcbiAgICAgICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgICAgICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJub25lXCIsIFwiZmFkZVwiIGFuZCBcInNsaWRlXCIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAgICAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICAgICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUhpZGUgdGhlIGRpYWxvZy5bL2VuXVxuICAgICAgICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2hpZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgIHZhciBfY2FuY2VsMyA9IGZhbHNlO1xuICAgICAgICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQob3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LCBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSk7XG5cbiAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlaGlkZScsIHtcbiAgICAgICAgICAgZGlhbG9nOiB0aGlzLFxuICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICBfY2FuY2VsMyA9IHRydWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuXG4gICAgICAgICBpZiAoIV9jYW5jZWwzKSB7XG4gICAgICAgICAgIHZhciBfcmV0MiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIHRyeUhpZGUgPSBmdW5jdGlvbiB0cnlIaWRlKCkge1xuICAgICAgICAgICAgICAgdmFyIHVubG9jayA9IF90aGlzNC5fZG9vckxvY2subG9jaygpO1xuICAgICAgICAgICAgICAgdmFyIGFuaW1hdG9yID0gX3RoaXM0Ll9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICBhbmltYXRvci5oaWRlKF90aGlzNCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgIF90aGlzNC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgIF90aGlzNC5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KF90aGlzNCwgJ3Bvc3RoaWRlJywgeyBkaWFsb2c6IF90aGlzNCB9KTtcblxuICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpczQpO1xuICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgdjogbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgX3RoaXM0Ll9kb29yTG9jay53YWl0VW5sb2NrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnlIaWRlKCkpO1xuICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgfTtcbiAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICBpZiAoKHR5cGVvZiBfcmV0MiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IGJhYmVsSGVscGVycy50eXBlb2YoX3JldDIpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQyLnY7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZWhpZGUgZXZlbnQuJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBkZXN0cm95XG4gICAgICAgICogQHNpZ25hdHVyZSBkZXN0cm95KClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXURlc3Ryb3kgdGhlIGRpYWxvZyBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIERPTSB0cmVlLlsvZW5dXG4gICAgICAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLnoLTmo4TjgZfjgabjgIFET03jg4Tjg6rjg7zjgYvjgonlj5bjgorpmaTjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdkZXN0cm95JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgIGlmICh0aGlzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaXNTaG93blxuICAgICAgICAqIEBzaWduYXR1cmUgaXNTaG93bigpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkaWFsb2cgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogICBbZW5ddHJ1ZSBpZiB0aGUgZGlhbG9nIGlzIHZpc2libGUuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgabjgYTjgovloLTlkIjjgat0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNTaG93bicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2hvd24oKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzQ2FuY2VsYWJsZVxuICAgICAgICAqIEBzaWduYXR1cmUgaXNDYW5jZWxhYmxlKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBruODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+WPr+iDveOBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKiAgIFtlbl10cnVlIGlmIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZS5bL2VuXVxuICAgICAgICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+WPr+iDveOBquWgtOWQiHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdpc0NhbmNlbGFibGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NhbmNlbGFibGUoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2NhbmNlbGFibGUnKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHNldERpc2FibGVkXG4gICAgICAgICogQHNpZ25hdHVyZSBzZXREaXNhYmxlZChkaXNhYmxlZClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1EaXNhYmxlIG9yIGVuYWJsZSB0aGUgZGlhbG9nLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu44OA44Kk44Ki44Ot44Kw44KSZGlzYWJsZWTnirbmhYvjgavjgZnjgovjgYvjganjgYbjgYvjgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWRcbiAgICAgICAgKiAgIFtlbl1JZiB0cnVlIHRoZSBkaWFsb2cgd2lsbCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgICAgICAqICAgW2phXXRydWXjgpLmjIflrprjgZnjgovjgajjg4DjgqTjgqLjg63jgrDjgpJkaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldERpc2FibGVkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgICAgIGlmICh0eXBlb2YgZGlzYWJsZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuLicpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJycpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc0Rpc2FibGVkXG4gICAgICAgICogQHNpZ25hdHVyZSBpc0Rpc2FibGVkKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZCBvciBlbmFibGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu44OA44Kk44Ki44Ot44Kw44GMZGlzYWJsZWTnirbmhYvjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogICBbZW5ddHJ1ZSBpZiB0aGUgZGlhbG9nIGlzIGRpc2FibGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GMZGlzYWJsZWTnirbmhYvjga7loLTlkIh0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNEaXNhYmxlZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGlzYWJsZWQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBzZXRDYW5jZWxhYmxlXG4gICAgICAgICogQHNpZ25hdHVyZSBzZXRDYW5jZWxhYmxlKGNhbmNlbGFibGUpXG4gICAgICAgICogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxhYmxlXG4gICAgICAgICogICBbZW5dSWYgdHJ1ZSB0aGUgZGlhbG9nIHdpbGwgYmUgY2FuY2VsYWJsZS5bL2VuXVxuICAgICAgICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkuOCreODo+ODs+OCu+ODq+WPr+iDveOBq+OBmeOCi+WgtOWQiHRydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXURlZmluZSB3aGV0aGVyIHRoZSBkaWFsb2cgY2FuIGJlIGNhbmNlbGVkIGJ5IHRoZSB1c2VyIG9yIG5vdC5bL2VuXVxuICAgICAgICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBn+mam+OBq+OAgeODpuODvOOCtuOBjOOBneOBruODgOOCpOOCouODreOCsOOCkuOCreODo+ODs+OCu+ODq+OBp+OBjeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldENhbmNlbGFibGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYW5jZWxhYmxlKGNhbmNlbGFibGUpIHtcbiAgICAgICAgIGlmICh0eXBlb2YgY2FuY2VsYWJsZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4uJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChjYW5jZWxhYmxlKSB7XG4gICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjYW5jZWxhYmxlJywgJycpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2NhbmNlbGFibGUnKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuX2RldmljZUJhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKSk7XG4gICAgICAgICB0aGlzLl9tYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwsIGZhbHNlKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdkZXRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuX2RldmljZUJhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgIHRoaXMuX2RldmljZUJhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgdGhpcy5fbWFzay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUkNik7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX21hc2snLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQGV2ZW50IHByZXNob3dcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICAgICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICAgICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICAgICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gYmVpbmcgc2hvd24uWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGV2ZW50IHBvc3RzaG93XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICAgICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICAgICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBwcmVoaWRlXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAgICAgICogW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAgICAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAgICAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBrumdnuihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgICAgICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgICAgICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgZGlhbG9nLlsvZW5dXG4gICAgICAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlsvZW5dXG4gICAgICAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgZ/mmYLjgavjgIHog4zmma/jgoTjg5Djg4Pjgq/jg5zjgr/jg7PjgpLjgr/jg4Pjg5fjgZfjgZ/mmYLjgavjg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICAgICAgKiAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeODgOOCpOOCouODreOCsOOBr2Rpc2FibGVk54q25oWL44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGRpYWxvZy4gQ2FuIGJlIGVpdGhlciBcIm5vbmVcIiBvciBcImRlZmF1bHRcIi5bL2VuXVxuICAgICAgICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCLjgoLjgZfjgY/jga9cImRlZmF1bHRcIuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAgICAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvZW5dXG4gICAgICAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlZmF1bHQgcmdiYSgwLCAwLCAwLCAwLjIpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIFwicmdiYSgwLCAwLCAwLCAwLjIpXCIuWy9lbl1cbiAgICAgICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgICAgKi9cbiAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZy1tYXNrJyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2RpYWxvZycsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5kaWFsb2cnKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIERpYWxvZ0VsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHZhciBPbnNEaWFsb2dFbGVtZW50ID0gd2luZG93Lk9uc0RpYWxvZ0VsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1kaWFsb2cnLCB7XG4gICAgIHByb3RvdHlwZTogRGlhbG9nRWxlbWVudC5wcm90b3R5cGVcbiAgIH0pO1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgKiBAcGFyYW0ge0RpYWxvZ0FuaW1hdG9yfSBBbmltYXRvclxuICAgICovXG4gICBPbnNEaWFsb2dFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbiAobmFtZSwgQW5pbWF0b3IpIHtcbiAgICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRGlhbG9nQW5pbWF0b3IpKSB7XG4gICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc0RpYWxvZ0VsZW1lbnQuRGlhbG9nQW5pbWF0b3InKTtcbiAgICAgfVxuICAgICBfYW5pbWF0b3JEaWN0JDFbbmFtZV0gPSBBbmltYXRvcjtcbiAgIH07XG5cbiAgIE9uc0RpYWxvZ0VsZW1lbnQuRGlhbG9nQW5pbWF0b3IgPSBEaWFsb2dBbmltYXRvcjtcblxuICAgdmFyIHNjaGVtZSQ3ID0ge1xuICAgICAnJzogJ2ZhYi0tKidcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLWZhYlxuICAgICogQGNhdGVnb3J5IGZhYlxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1bL2VuXVxuICAgICogICBbamFdWy9qYV1cbiAgICAqL1xuXG4gICB2YXIgRmFiRWxlbWVudCA9IChmdW5jdGlvbiAoX0Jhc2VFbGVtZW50KSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhGYWJFbGVtZW50LCBfQmFzZUVsZW1lbnQpO1xuXG4gICAgIGZ1bmN0aW9uIEZhYkVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIEZhYkVsZW1lbnQpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRmFiRWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoRmFiRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAgICAgICogIFtqYV3jg5zjgr/jg7Pjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1bL2VuXVxuICAgICAgICAqICBbamFdZmFi44Kz44Oz44Od44O844ON44Oz44OI44KS6KGo56S644GZ44KL5L2N572u44KS5oyH5a6a44GX44G+44GZ44CCIOS4iuS4i+S9jee9ruOBqOW3puWPs+S9jee9ruOCkuaMh+WumuOBl+OBvuOBmeOAgiDkuIrkuIvkvY3nva7jgavmjIflrprjgafjgY3jgovjga7jga9gdG9wYOOBi2Bib3R0b21g44Gn44GZ44CC5bem5Y+z5L2N572u44Gn5oyH5a6a44Gn44GN44KL44Gu44GvYGxlZnRg44GLYHJpZ2h0YOOBi2BjZW50ZXJg44Gn44GZ44CCYHRvcCBsZWZ0YOOBqOaMh+WumuOBmeOCi+OBqOOAgeW3puS4iuOBq+ihqOekuuOBleOCjOOBvuOBmeOAgmBib3R0b20gY2VudGVyYOOBqOaMh+WumuOBmeOCi+OBqOOAgeS4i+mDqOS4reWkruOBq+ihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGlubGluZVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICBbZW5dWy9lbl1cbiAgICAgICAgKiAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOCi+OBqOOAgeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBr3Bvc2l0aW9u5bGe5oCn44KS54Sh6KaW44GX44Gm44Kk44Oz44Op44Kk44Oz44Gr6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiJyk7XG5cbiAgICAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdmYWJfX2ljb24nKTtcblxuICAgICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgIGlmICghZWxlbWVudC50YWdOYW1lIHx8IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25zLXJpcHBsZScpIHtcbiAgICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9KTtcblxuICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICAgICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lJDcpO1xuXG4gICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgICAgICB0aGlzLmhpZGUoKTtcblxuICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lJDcpO1xuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfc2hvdycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93KCkge1xuICAgICAgICAgaWYgKCF0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2hpZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZSgpIHtcbiAgICAgICAgIGlmICghdGhpcy5pc0lubGluZSgpKSB7XG4gICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGVSaXBwbGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUmlwcGxlKCkge1xuICAgICAgICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZVBvc2l0aW9uJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2ZhYi0tdG9wX19sZWZ0JywgJ2ZhYi0tYm90dG9tX19yaWdodCcsICdmYWItLWJvdHRvbV9fbGVmdCcsICdmYWItLXRvcF9fcmlnaHQnLCAnZmFiLS10b3BfX2NlbnRlcicsICdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgICAgIGNhc2UgJ3RvcCByaWdodCc6XG4gICAgICAgICAgIGNhc2UgJ3JpZ2h0IHRvcCc6XG4gICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fcmlnaHQnKTtcbiAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAndG9wIGxlZnQnOlxuICAgICAgICAgICBjYXNlICdsZWZ0IHRvcCc6XG4gICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fbGVmdCcpO1xuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlICdib3R0b20gcmlnaHQnOlxuICAgICAgICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX3JpZ2h0Jyk7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgJ2JvdHRvbSBsZWZ0JzpcbiAgICAgICAgICAgY2FzZSAnbGVmdCBib3R0b20nOlxuICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2xlZnQnKTtcbiAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAnY2VudGVyIHRvcCc6XG4gICAgICAgICAgIGNhc2UgJ3RvcCBjZW50ZXInOlxuICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2NlbnRlcicpO1xuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlICdjZW50ZXIgYm90dG9tJzpcbiAgICAgICAgICAgY2FzZSAnYm90dG9tIGNlbnRlcic6XG4gICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBzaG93XG4gICAgICAgICogQHNpZ25hdHVyZSBzaG93KClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXVsvZW5dXG4gICAgICAgICogIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdzaG93JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgIHRoaXMuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICAgICAgIHRoaXMuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGhpZGVcbiAgICAgICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICBbZW5dWy9lbl1cbiAgICAgICAgKiAgW2phXVsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2hpZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoMCknO1xuICAgICAgICAgdGhpcy5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMCknO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgc2V0RGlzYWJsZWRcbiAgICAgICAgKiBAc2lnbmF0dXJlIHNldERpc2FibGVkKGRpc2FibGVkKVxuICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWRcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXURpc2FibGVkIG9mIGVuYWJsZSBmYWIuWy9lbl1cbiAgICAgICAgKiAgW2phXVsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldERpc2FibGVkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgICAgIGlmICh0eXBlb2YgZGlzYWJsZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuLicpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJycpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc0Rpc2FibGVkXG4gICAgICAgICogQHNpZ25hdHVyZSBpc0Rpc2FibGVkKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1UcnVlIGlmIGZhYiBpcyBkaXNhYmxlZC5bL2VuXVxuICAgICAgICAqICAgW2phXWRpc2FibGVk54q25oWL44Gn44GC44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdpc0Rpc2FibGVkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNEaXNhYmxlZCgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBUcnVlIGlmIGZhYiBpcyBpbmxpbmUgZWxlbWVudC5cbiAgICAgICAgKlxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICovXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc0lubGluZVxuICAgICAgICAqIEBzaWduYXR1cmUgaXNJbmxpbmUoKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVRydWUgaWYgZmFiIGlzIGlubGluZS5bL2VuXVxuICAgICAgICAqICAgW2phXWlubGluZeWxnuaAp+OBjOOBguOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNJbmxpbmUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0lubGluZSgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc1Nob3duXG4gICAgICAgICogQHNpZ25hdHVyZSBpc1Nob3duKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1UcnVlIGlmIGZhYiBpcyBzaG93bi5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBjOihqOekuuOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNTaG93bicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2hvd24oKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS50cmFuc2Zvcm0gPT09ICdzY2FsZSgxKScgJiYgdGhpcy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCB0b2dnbGVcbiAgICAgICAgKiBAc2lnbmF0dXJlIHRvZ2dsZSgpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICd0b2dnbGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICAgICBpZiAodGhpcy5pc1Nob3duKCkpIHtcbiAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIEZhYkVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNGYWJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtZmFiJywge1xuICAgICBwcm90b3R5cGU6IEZhYkVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtZ2VzdHVyZS1kZXRlY3RvclxuICAgICogQGNhdGVnb3J5IGlucHV0XG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXUNvbXBvbmVudCB0byBkZXRlY3QgZmluZ2VyIGdlc3R1cmVzIHdpdGhpbiB0aGUgd3JhcHBlZCBlbGVtZW50LiBTZWUgdGhlIGd1aWRlIGZvciBtb3JlIGRldGFpbHMuWy9lbl1cbiAgICAqICAgW2phXeimgee0oOWGheOBruOCuOOCp+OCueODgeODo+ODvOaTjeS9nOOCkuaknOefpeOBl+OBvuOBmeOAguips+OBl+OBj+OBr+OCrOOCpOODieOCkuWPgueFp+OBl+OBpuOBj+OBoOOBleOBhOOAglsvamFdXG4gICAgKiBAZ3VpZGUgRGV0ZWN0aW5nRmluZ2VyR2VzdHVyZXNcbiAgICAqICAgW2VuXURldGVjdGluZyBmaW5nZXIgZ2VzdHVyZXNbL2VuXVxuICAgICogICBbamFd44K444Kn44K544OB44Oj44O85pON5L2c44Gu5qSc55+lWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8b25zLWdlc3R1cmUtZGV0ZWN0b3Igc3R5bGU9XCJoZWlnaHQ6IDEwMCU7IHdpZHRoOiAxMDAlO1wiPlxuICAgICogICAuLi5cbiAgICAqIDwvb25zLWdlc3R1cmUtZGV0ZWN0b3I+XG4gICAgKi9cblxuICAgdmFyIEdlc3R1cmVEZXRlY3RvckVsZW1lbnQgPSAoZnVuY3Rpb24gKF9CYXNlRWxlbWVudCkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoR2VzdHVyZURldGVjdG9yRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50KTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdlc3R1cmVEZXRlY3RvckVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKEdlc3R1cmVEZXRlY3RvckVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIEdlc3R1cmVEZXRlY3RvckVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNHZXN0dXJlRGV0ZWN0b3JFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtZ2VzdHVyZS1kZXRlY3RvcicsIHtcbiAgICAgcHJvdG90eXBlOiBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLWljb25cbiAgICAqIEBjYXRlZ29yeSBpY29uXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXURpc3BsYXlzIGFuIGljb24uIEZvbnQgQXdlc29tZShodHRwczovL2ZvcnRhd2Vzb21lLmdpdGh1Yi5pby9Gb250LUF3ZXNvbWUvKSBhbmQgSW9uaWNvbiBpY29ucyhodHRwOi8vaW9uaWNvbnMuY29tKSBhbmQgTWF0ZXJpYWwgRGVzaWduIEljb25pYyBGb250KGh0dHA6Ly96YXZvbG9rbG9tLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbmljLWZvbnQvKSBhcmUgc3VwcG9ydGVkLlsvZW5dXG4gICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJGb250IEF3ZXNvbWUoaHR0cHM6Ly9mb3J0YXdlc29tZS5naXRodWIuaW8vRm9udC1Bd2Vzb21lLynjgoLjgZfjgY/jga9Jb25pY29ucyhodHRwOi8vaW9uaWNvbnMuY29tKeOCguOBl+OBj+OBr01hdGVyaWFsIERlc2lnbiBJY29uaWMgRm9udChodHRwOi8vemF2b2xva2xvbS5naXRodWIuaW8vbWF0ZXJpYWwtZGVzaWduLWljb25pYy1mb250LynjgYvjgonpgbjmip7jgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICogQGNvZGVwZW4geEFodmdcbiAgICAqIEBndWlkZSBVc2luZ0ljb25zIFtlbl1Vc2luZyBpY29uc1svZW5dW2phXeOCouOCpOOCs+ODs+OCkuS9v+OBhlsvamFdXG4gICAgKiBAZXhhbXBsZVxuICAgICogPG9ucy1pY29uXG4gICAgKiAgIGljb249XCJtZC1jYXJcIlxuICAgICogICBzaXplPVwiMjBweFwiXG4gICAgKiAgIGZpeGVkLXdpZHRoPVwiZmFsc2VcIlxuICAgICogICBzdHlsZT1cImNvbG9yOiByZWRcIj5cbiAgICAqIDwvb25zLWljb24+XG4gICAgKi9cblxuICAgdmFyIEljb25FbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKEljb25FbGVtZW50LCBfQmFzZUVsZW1lbnQpO1xuXG4gICAgIGZ1bmN0aW9uIEljb25FbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBJY29uRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihJY29uRWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoSWNvbkVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dVGhlIGljb24gbmFtZS4gXCJtZC1cIiBwcmVmaXggZm9yIE1hdGVyaWFsIEljb25zLCBcImZhLVwiIGZvciBGb250IEF3ZXNvbWUgYW5kIFwiaW9uLVwiIHByZWZpeCBmb3IgSW9uaWNvbnMgaWNvbnMuIFNlZSBhbGwgaWNvbnMgYXQgaHR0cDovL3phdm9sb2tsb20uZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29uaWMtZm9udC9pY29ucy5odG1sLCBodHRwOi8vZm9udGF3ZXNvbWUuaW8vaWNvbnMvIGFuZCBodHRwOi8vaW9uaWNvbnMuY29tLlsvZW5dXG4gICAgICAgICogICBbamFd44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCPGNvZGU+bWQtPC9jb2RlPuOBp+Wni+OBvuOCi+OCguOBruOBr01hdGVyaWFsIEljb25z44Go44GX44Gm44CBPGNvZGU+ZmEtPC9jb2RlPuOBp+Wni+OBvuOCi+OCguOBruOBr0ZvbnQgQXdlc29tZeOBqOOBl+OBpuOAgTxjb2RlPmlvbi08L2NvZGU+44Gn5aeL44G+44KL44KC44Gu44GvSW9uaWNvbnPjgajjgZfjgabmibHjgo/jgozjgb7jgZnjgILkvb/nlKjjgafjgY3jgovjgqLjgqTjgrPjg7Pjga/jgZPjgaHjgok6IGh0dHA6Ly96YXZvbG9rbG9tLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbmljLWZvbnQvaWNvbnMuaHRtbCBodHRwOi8vZm9udGF3ZXNvbWUuaW8vaWNvbnMvIGh0dHA6Ly9pb25pY29ucy5jb21bL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBzaXplXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1UaGUgc2l6ZXMgb2YgdGhlIGljb24uIFZhbGlkIHZhbHVlcyBhcmUgbGcsIDJ4LCAzeCwgNHgsIDV4LCBvciBpbiBwaXhlbHMuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjgqTjgrPjg7Pjga7jgrXjgqTjgrrjgpLmjIflrprjgZfjgb7jgZnjgILlgKTjga/jgIFsZywgMngsIDN4LCA0eCwgNXjjgoLjgZfjgY/jga/jg5Tjgq/jgrvjg6vljZjkvY3jgafmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSByb3RhdGVcbiAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXU51bWJlciBvZiBkZWdyZWVzIHRvIHJvdGF0ZSB0aGUgaWNvbi4gVmFsaWQgdmFsdWVzIGFyZSA5MCwgMTgwLCBvciAyNzAuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlm57ou6LjgZfjgabooajnpLrjgZfjgb7jgZnjgII5MCwgMTgwLCAyNzDjgYvjgonmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBmbGlwXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1GbGlwIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIFwiaG9yaXpvbnRhbFwiIGFuZCBcInZlcnRpY2FsXCIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlj43ou6LjgZfjgb7jgZnjgIJob3Jpem9udGFs44KC44GX44GP44GvdmVydGljYWzjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBmaXhlZC13aWR0aFxuICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1XaGVuIHVzZWQgaW4gdGhlIGxpc3QsIHlvdSB3YW50IHRoZSBpY29ucyB0byBoYXZlIHRoZSBzYW1lIHdpZHRoIHNvIHRoYXQgdGhleSBhbGlnbiB2ZXJ0aWNhbGx5IGJ5IHNldHRpbmcgdGhlIHZhbHVlIHRvIHRydWUuIFZhbGlkIHZhbHVlcyBhcmUgdHJ1ZSwgZmFsc2UuIERlZmF1bHQgaXMgZmFsc2UuWy9lbl1cbiAgICAgICAgKiAgW2phXeetieW5heOBq+OBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAgnRydWXjgoLjgZfjgY/jga9mYWxzZeOCkuaMh+WumuOBp+OBjeOBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr2ZhbHNl44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgc3BpblxuICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU3BlY2lmeSB3aGV0aGVyIHRoZSBpY29uIHNob3VsZCBiZSBzcGlubmluZy4gVmFsaWQgdmFsdWVzIGFyZSB0cnVlIGFuZCBmYWxzZS5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouOCpOOCs+ODs+OCkuWbnui7ouOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAgnRydWXjgoLjgZfjgY/jga9mYWxzZeOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICAgICAgIGlmIChbJ2ljb24nLCAnc2l6ZSddLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgIHRoaXMuX2NsZWFuQ2xhc3NBdHRyaWJ1dGUoKTtcblxuICAgICAgICAgdmFyIGJ1aWxkZWQgPSB0aGlzLl9idWlsZENsYXNzQW5kU3R5bGUodGhpcyk7XG5cbiAgICAgICAgIGZvciAodmFyIGtleSBpbiBidWlsZGVkLnN0eWxlKSB7XG4gICAgICAgICAgIGlmIChidWlsZGVkLnN0eWxlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICB0aGlzLnN0eWxlW2tleV0gPSBidWlsZGVkLnN0eWxlW2tleV07XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cblxuICAgICAgICAgYnVpbGRlZC5jbGFzc0xpc3QuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgIHJldHVybiBfdGhpczIuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2NsZWFuQ2xhc3NBdHRyaWJ1dGUnLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogUmVtb3ZlIHVubmVlZGVkIGNsYXNzIHZhbHVlLlxuICAgICAgICAqL1xuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW5DbGFzc0F0dHJpYnV0ZSgpIHtcbiAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNsYXNzTGlzdCkuZmlsdGVyKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgcmV0dXJuICgvXihmYSR8ZmEtfGlvbi18em1kaS0pLy50ZXN0KGNsYXNzTmFtZSlcbiAgICAgICAgICAgKTtcbiAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAgICByZXR1cm4gX3RoaXMzLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgIH0pO1xuXG4gICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3ptZGknKTtcbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnb25zLWljb24tLWlvbicpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19idWlsZENsYXNzQW5kU3R5bGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYnVpbGRDbGFzc0FuZFN0eWxlKCkge1xuICAgICAgICAgdmFyIGNsYXNzTGlzdCA9IFsnb25zLWljb24nXTtcbiAgICAgICAgIHZhciBzdHlsZSA9IHt9O1xuXG4gICAgICAgICAvLyBpY29uXG4gICAgICAgICB2YXIgaWNvbk5hbWUgPSB0aGlzLl9pY29uTmFtZTtcbiAgICAgICAgIGlmIChpY29uTmFtZS5pbmRleE9mKCdpb24tJykgPT09IDApIHtcbiAgICAgICAgICAgY2xhc3NMaXN0LnB1c2goaWNvbk5hbWUpO1xuICAgICAgICAgICBjbGFzc0xpc3QucHVzaCgnb25zLWljb24tLWlvbicpO1xuICAgICAgICAgfSBlbHNlIGlmIChpY29uTmFtZS5pbmRleE9mKCdmYS0nKSA9PT0gMCkge1xuICAgICAgICAgICBjbGFzc0xpc3QucHVzaChpY29uTmFtZSk7XG4gICAgICAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYScpO1xuICAgICAgICAgfSBlbHNlIGlmIChpY29uTmFtZS5pbmRleE9mKCdtZC0nKSA9PT0gMCkge1xuICAgICAgICAgICBjbGFzc0xpc3QucHVzaCgnem1kaScpO1xuICAgICAgICAgICBjbGFzc0xpc3QucHVzaCgnem1kaS0nICsgaWNvbk5hbWUuc3BsaXQoL1xcLSguKyk/LylbMV0pO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgY2xhc3NMaXN0LnB1c2goJ2ZhJyk7XG4gICAgICAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYS0nICsgaWNvbk5hbWUpO1xuICAgICAgICAgfVxuXG4gICAgICAgICAvLyBzaXplXG4gICAgICAgICB2YXIgc2l6ZSA9ICcnICsgdGhpcy5nZXRBdHRyaWJ1dGUoJ3NpemUnKTtcbiAgICAgICAgIGlmIChzaXplLm1hdGNoKC9eWzEtNV14fGxnJC8pKSB7XG4gICAgICAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYS0nICsgc2l6ZSk7XG4gICAgICAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2ZvbnQtc2l6ZScpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgc3R5bGUuZm9udFNpemUgPSBzaXplO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICBjbGFzc0xpc3Q6IGNsYXNzTGlzdCxcbiAgICAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICAgICB9O1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19pY29uTmFtZScsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gJycgKyB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gSWNvbkVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNJY29uRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWljb24nLCB7XG4gICAgIHByb3RvdHlwZTogSWNvbkVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtbGF6eS1yZXBlYXRcbiAgICAqIEBjYXRlZ29yeSBjb250cm9sXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXVxuICAgICogICAgIFVzaW5nIHRoaXMgY29tcG9uZW50IGEgbGlzdCB3aXRoIG1pbGxpb25zIG9mIGl0ZW1zIGNhbiBiZSByZW5kZXJlZCB3aXRob3V0IGEgZHJvcCBpbiBwZXJmb3JtYW5jZS5cbiAgICAqICAgICBJdCBkb2VzIHRoYXQgYnkgXCJsYXppbHlcIiBsb2FkaW5nIGVsZW1lbnRzIGludG8gdGhlIERPTSB3aGVuIHRoZXkgY29tZSBpbnRvIHZpZXcgYW5kXG4gICAgKiAgICAgcmVtb3ZpbmcgaXRlbXMgZnJvbSB0aGUgRE9NIHdoZW4gdGhleSBhcmUgbm90IHZpc2libGUuXG4gICAgKiAgIFsvZW5dXG4gICAgKiAgIFtqYV1cbiAgICAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jlhoXjgafmj4/nlLvjgZXjgozjgovjgqLjgqTjg4bjg6Djga5ET03opoHntKDjga7oqq3jgb/ovrzjgb/jga/jgIHnlLvpnaLjgavopovjgYjjgZ3jgYbjgavjgarjgaPjgZ/mmYLjgb7jgafoh6rli5XnmoTjgavpgYXlu7bjgZXjgozjgIFcbiAgICAqICAgICDnlLvpnaLjgYvjgonopovjgYjjgarjgY/jgarjgaPjgZ/loLTlkIjjgavjga/jgZ3jga7opoHntKDjga/li5XnmoTjgavjgqLjg7Pjg63jg7zjg4njgZXjgozjgb7jgZnjgIJcbiAgICAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLkvb/jgYbjgZPjgajjgafjgIHjg5Hjg5Xjgqnjg7zjg57jg7PjgrnjgpLliqPljJbjgZXjgZvjgovjgZPjgajnhKHjgZfjgavlt6jlpKfjgarmlbDjga7opoHntKDjgpLmj4/nlLvjgafjgY3jgb7jgZnjgIJcbiAgICAqICAgWy9qYV1cbiAgICAqIEBjb2RlcGVuIFF3ckdCbVxuICAgICogQGd1aWRlIFVzaW5nTGF6eVJlcGVhdFxuICAgICogICBbZW5dSG93IHRvIHVzZSBMYXp5IFJlcGVhdFsvZW5dXG4gICAgKiAgIFtqYV3jg6zjgqTjgrjjg7zjg6rjg5Tjg7zjg4jjga7kvb/jgYTmlrlbL2phXVxuICAgICogQGV4YW1wbGVcbiAgICAqIDxzY3JpcHQ+XG4gICAgKiAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgKiAgICAgdmFyIGxhenlSZXBlYXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbGlzdCcpO1xuICAgICogICAgIGxhenlSZXBlYXQuZGVsZWdhdGUgPSB7XG4gICAgKiAgICAgIC8vIGNhbGN1bGF0ZUl0ZW1IZWlnaHQ6IGZ1bmN0aW9uKGkpIHtcbiAgICAqICAgICAgLy8gIC8vIHNwZWNpZnkgdGhpcyBpZiB0aGUgaGVpZ2h0IGRlcGVuZHMgb24gdGhlIGVsZW1lbnRcbiAgICAqICAgICAgLy8gIHJldHVybiBNYXRoLmZsb29yKDQyICogTWF0aC5yYW5kb20oKSk7XG4gICAgKiAgICAgIC8vIH0sXG4gICAgKiAgICAgIGNyZWF0ZUl0ZW1Db250ZW50OiBmdW5jdGlvbihpLCB0ZW1wbGF0ZSkge1xuICAgICogICAgICAgIHZhciBkb20gPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgKiAgICAgICAgZG9tLmlubmVyVGV4dCA9IGk7XG4gICAgKlxuICAgICogICAgICAgIHJldHVybiBkb207XG4gICAgKiAgICAgIH0sXG4gICAgKiAgICAgIGNvdW50SXRlbXM6IGZ1bmN0aW9uKCkge1xuICAgICogICAgICAgICAvLyBSZXR1cm4gbnVtYmVyIG9mIGl0ZW1zLlxuICAgICogICAgICAgIHJldHVybiAxMDAwMDAwMDtcbiAgICAqICAgICAgfSxcbiAgICAqICAgICAgZGVzdHJveUl0ZW06IGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG4gICAgKiAgICAgICAgLy8gT3B0aW9uYWwgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gYW4gaXRlbSBpcyB1bmxvYWRlZC5cbiAgICAqICAgICAgICBjb25zb2xlLmxvZygnRGVzdHJveWVkIGl0ZW0gd2l0aCBpbmRleDogJyArIGluZGV4KTtcbiAgICAqICAgICAgfVxuICAgICogICAgIH07XG4gICAgKiAgIH0pO1xuICAgICogPC9zY3JpcHQ+XG4gICAgKlxuICAgICogPG9ucy1saXN0IGlkPVwibGlzdFwiPlxuICAgICogICA8b25zLWxhenktcmVwZWF0PlxuICAgICogICAgIDxvbnMtbGlzdC1pdGVtPjwvb25zLWxpc3QtaXRlbT5cbiAgICAqICAgPC9vbnMtbGF6eS1yZXBlYXQ+XG4gICAgKiA8L29ucy1saXN0PlxuICAgICovXG5cbiAgIHZhciBMYXp5UmVwZWF0RWxlbWVudCA9IChmdW5jdGlvbiAoX0Jhc2VFbGVtZW50KSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhMYXp5UmVwZWF0RWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBMYXp5UmVwZWF0RWxlbWVudCgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF6eVJlcGVhdEVsZW1lbnQpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGF6eVJlcGVhdEVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKExhenlSZXBlYXRFbGVtZW50LCBbe1xuICAgICAgIGtleTogJ2NyZWF0ZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24odGhpcyk7XG5cbiAgICAgICAgIC8vIG5vdCB2ZXJ5IGdvb2QgaWRlYVxuICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkZWxlZ2F0ZScpKSB7XG4gICAgICAgICAgIHRoaXMuc2V0RGVsZWdhdGUod2luZG93W3RoaXMuZ2V0QXR0cmlidXRlKCdkZWxlZ2F0ZScpXSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBzZXREZWxlZ2F0ZVxuICAgICAgICAqIEBzaWduYXR1cmUgc2V0RGVsZWdhdGUodXNlckRlbGVnYXRlKVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyRGVsZWdhdGVcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXVNwZWNpZnkgYSBkZWxlZ2F0ZSBvYmplY3QgdG8gbG9hZCBhbmQgdW5sb2FkIGl0ZW0gZWxlbWVudHMuWy9lbl1cbiAgICAgICAgKiAgW2phXeimgee0oOOBruODreODvOODieOAgeOCouODs+ODreODvOODieOBquOBqeOBruWHpueQhuOCkuWnlOitsuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldERlbGVnYXRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVsZWdhdGUodXNlckRlbGVnYXRlKSB7XG4gICAgICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLmRlc3Ryb3koKTtcblxuICAgICAgICAgaWYgKCF0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgJiYgdGhpcy5jaGlsZHJlblswXSkge1xuICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgPSB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgZGVsZWdhdGUgPSBuZXcgTGF6eVJlcGVhdERlbGVnYXRlKHVzZXJEZWxlZ2F0ZSwgdGhpcy5fdGVtcGxhdGVFbGVtZW50IHx8IG51bGwpO1xuICAgICAgICAgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyID0gbmV3IExhenlSZXBlYXRQcm92aWRlcih0aGlzLnBhcmVudEVsZW1lbnQsIGRlbGVnYXRlKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcHJvcGVydHkgZGVsZWdhdGVcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXVNwZWNpZnkgYSBkZWxlZ2F0ZSBvYmplY3QgdG8gbG9hZCBhbmQgdW5sb2FkIGl0ZW0gZWxlbWVudHMuWy9lbl1cbiAgICAgICAgKiAgW2phXeimgee0oOOBruODreODvOODieOAgeOCouODs+ODreODvOODieOBquOBqeOBruWHpueQhuOCkuWnlOitsuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3JlZnJlc2gnLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCByZWZyZXNoXG4gICAgICAgICogQHNpZ25hdHVyZSByZWZyZXNoKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICovXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLnJlZnJlc2goKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge31cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RldGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgaWYgKHRoaXMuX2xhenlSZXBlYXRQcm92aWRlcikge1xuICAgICAgICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIuZGVzdHJveSgpO1xuICAgICAgICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBudWxsO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RlbGVnYXRlJyxcbiAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh1c2VyRGVsZWdhdGUpIHtcbiAgICAgICAgIHRoaXMuc2V0RGVsZWdhdGUodXNlckRlbGVnYXRlKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIExhenlSZXBlYXRFbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zTGF6eVJlcGVhdEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1sYXp5LXJlcGVhdCcsIHtcbiAgICAgcHJvdG90eXBlOiBMYXp5UmVwZWF0RWxlbWVudC5wcm90b3R5cGVcbiAgIH0pO1xuXG4gICB2YXIgc2NoZW1lJDggPSB7ICcnOiAnbGlzdF9faGVhZGVyLS0qJyB9O1xuXG4gICAvKipcbiAgICAqIEBlbGVtZW50IG9ucy1saXN0LWhlYWRlclxuICAgICogQGNhdGVnb3J5IGxpc3RcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dSGVhZGVyIGVsZW1lbnQgZm9yIGxpc3QgaXRlbXMuIE11c3QgYmUgcHV0IGluc2lkZSBvbnMtbGlzdCBjb21wb25lbnQuWy9lbl1cbiAgICAqICAgW2phXeODquOCueODiOimgee0oOOBq+S9v+eUqOOBmeOCi+ODmOODg+ODgOODvOeUqOOCs+ODs+ODneODvOODjeODs+ODiOOAgm9ucy1saXN044Go5YWx44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1saXN0XG4gICAgKiAgIFtlbl1vbnMtbGlzdCBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICAgICogQHNlZWFsc28gb25zLWxpc3QtaXRlbSBbZW5db25zLWxpc3QtaXRlbSBjb21wb25lbnRbL2VuXVtqYV1vbnMtbGlzdC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBndWlkZSBVc2luZ0xpc3QgW2VuXVVzaW5nIGxpc3RzWy9lbl1bamFd44Oq44K544OI44KS5L2/44GGWy9qYV1cbiAgICAqIEBjb2RlcGVuIHl4Y0N0XG4gICAgKiBAZXhhbXBsZVxuICAgICogPG9ucy1saXN0PlxuICAgICogICA8b25zLWxpc3QtaGVhZGVyPkhlYWRlciBUZXh0PC9vbnMtbGlzdC1oZWFkZXI+XG4gICAgKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gICAgKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gICAgKiA8L29ucy1saXN0PlxuICAgICovXG5cbiAgIHZhciBMaXN0SGVhZGVyRWxlbWVudCA9IChmdW5jdGlvbiAoX0Jhc2VFbGVtZW50KSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhMaXN0SGVhZGVyRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBMaXN0SGVhZGVyRWxlbWVudCgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgTGlzdEhlYWRlckVsZW1lbnQpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdEhlYWRlckVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKExpc3RIZWFkZXJFbGVtZW50LCBbe1xuICAgICAgIGtleTogJ2NyZWF0ZWRDYWxsYmFjaycsXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdCBoZWFkZXIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg5jjg4Pjg4Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdF9faGVhZGVyJyk7XG4gICAgICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSQ4KTtcblxuICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUkOCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBMaXN0SGVhZGVyRWxlbWVudDtcbiAgIH0pKEJhc2VFbGVtZW50KTtcblxuICAgd2luZG93Lk9uc0xpc3RIZWFkZXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtbGlzdC1oZWFkZXInLCB7XG4gICAgIHByb3RvdHlwZTogTGlzdEhlYWRlckVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgdmFyIHNjaGVtZSQ5ID0ge1xuICAgICAnLmxpc3RfX2l0ZW0nOiAnbGlzdF9faXRlbS0tKicsXG4gICAgICcubGlzdF9faXRlbV9fbGVmdCc6ICdsaXN0X19pdGVtLS0qX19sZWZ0JyxcbiAgICAgJy5saXN0X19pdGVtX19jZW50ZXInOiAnbGlzdF9faXRlbS0tKl9fY2VudGVyJyxcbiAgICAgJy5saXN0X19pdGVtX19yaWdodCc6ICdsaXN0X19pdGVtLS0qX19yaWdodCcsXG4gICAgICcubGlzdF9faXRlbV9fbGFiZWwnOiAnbGlzdF9faXRlbS0tKl9fbGFiZWwnLFxuICAgICAnLmxpc3RfX2l0ZW1fX3RpdGxlJzogJ2xpc3RfX2l0ZW0tLSpfX3RpdGxlJyxcbiAgICAgJy5saXN0X19pdGVtX19zdWJ0aXRsZSc6ICdsaXN0X19pdGVtLS0qX19zdWJ0aXRsZScsXG4gICAgICcubGlzdF9faXRlbV9fdGh1bWJuYWlsJzogJ2xpc3RfX2l0ZW0tLSpfX3RodW1ibmFpbCcsXG4gICAgICcubGlzdF9faXRlbV9faWNvbic6ICdsaXN0X19pdGVtLS0qX19pY29uJ1xuICAgfTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtbGlzdC1pdGVtXG4gICAgKiBAY2F0ZWdvcnkgbGlzdFxuICAgICogQG1vZGlmaWVyIHRpZ2h0XG4gICAgKiAgIFtlbl1SZW1vdmUgdGhlIHNwYWNlIGFib3ZlIGFuZCBiZWxvdyB0aGUgaXRlbSBjb250ZW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktbGluZSBjb250ZW50LlsvZW5dXG4gICAgKiAgIFtqYV3ooYzplpPjga7jgrnjg5rjg7zjgrnjgpLlj5bjgorpmaTjgY3jgb7jgZnjgILopIfmlbDooYzjga7lhoXlrrnjgpLjg6rjgrnjg4jjgafmibHjgYbloLTlkIjjgavkvr/liKnjgafjgZnjgIJbL2phXVxuICAgICogQG1vZGlmaWVyIHRhcHBhYmxlXG4gICAgKiAgIFtlbl1NYWtlIHRoZSBsaXN0IGl0ZW0gY2hhbmdlIGFwcGVhcmFuY2Ugd2hlbiBpdCdzIHRhcHBlZC4gT24gaU9TIGl0IGlzIGJldHRlciB0byB1c2UgdGhlIFwidGFwcGFibGVcIiBhdHRyaWJ1dGUgZm9yIGJldHRlciBiZWhhdmlvciB3aGVuIHNjcm9sbGluZy5bL2VuXVxuICAgICogICBbamFd44K/44OD44OX44KE44Kv44Oq44OD44Kv44GX44Gf5pmC44Gr5Yq55p6c44GM6KGo56S644GV44KM44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAqIEBtb2RpZmllciBjaGV2cm9uXG4gICAgKiAgIFtlbl1EaXNwbGF5IGEgY2hldnJvbiBhdCB0aGUgcmlnaHQgZW5kIG9mIHRoZSBsaXN0IGl0ZW0gYW5kIG1ha2UgaXQgY2hhbmdlIGFwcGVhcmFuY2Ugd2hlbiB0YXBwZWQuWy9lbl1cbiAgICAqICAgW2phXeimgee0oOOBruWPs+WBtOOBq+WPs+efouWNsOOBjOihqOekuuOBleOCjOOBvuOBmeOAguOBvuOBn+OAgeOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBl+OBn+aZguOBq+WKueaenOOBjOihqOekuuOBleOCjOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXUNvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgZWFjaCBpdGVtIGluIHRoZSBsaXN0LiBNdXN0IGJlIHB1dCBpbnNpZGUgdGhlIG9ucy1saXN0IGNvbXBvbmVudC5bL2VuXVxuICAgICogICBbamFd44Oq44K544OI44Gu5ZCE6KaB57Sg44KS6KGo54++44GZ44KL44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgajlhbHjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQHNlZWFsc28gb25zLWxpc3RcbiAgICAqICAgW2VuXW9ucy1saXN0IGNvbXBvbmVudFsvZW5dXG4gICAgKiAgIFtqYV1vbnMtbGlzdOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gICAgKiBAc2VlYWxzbyBvbnMtbGlzdC1oZWFkZXJcbiAgICAqICAgW2VuXW9ucy1saXN0LWhlYWRlciBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLWxpc3QtaGVhZGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBndWlkZSBVc2luZ0xpc3RcbiAgICAqICAgW2VuXVVzaW5nIGxpc3RzWy9lbl1cbiAgICAqICAgW2phXeODquOCueODiOOCkuS9v+OBhlsvamFdXG4gICAgKiBAY29kZXBlbiB5eGNDdFxuICAgICogQGV4YW1wbGVcbiAgICAqIDxvbnMtbGlzdD5cbiAgICAqICAgPG9ucy1saXN0LWhlYWRlcj5IZWFkZXIgVGV4dDwvb25zLWxpc3QtaGVhZGVyPlxuICAgICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICAgICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICAgICogPC9vbnMtbGlzdD5cbiAgICAqL1xuXG4gICB2YXIgTGlzdEl0ZW1FbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKExpc3RJdGVtRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBMaXN0SXRlbUVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIExpc3RJdGVtRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihMaXN0SXRlbUVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKExpc3RJdGVtRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QgaXRlbS5bL2VuXVxuICAgICAgICAqICAgW2phXeWQhOimgee0oOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGxvY2stb24tZHJhZ1xuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUHJldmVudCB2ZXJ0aWNhbCBzY3JvbGxpbmcgd2hlbiB0aGUgdXNlciBkcmFncyBob3Jpem9udGFsbHkuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg6bjg7zjgrbjg7zjgYzjgZPjga7opoHntKDjgpLmqKrmlrnlkJHjgavjg4njg6njg4PjgrDjgZfjgabjgYTjgovmmYLjgavjgIHnuKbmlrnlkJHjga7jgrnjgq/jg63jg7zjg6vjgYzotbfjgY3jgarjgYTjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSB0YXBwYWJsZVxuICAgICAgICAqIEB0eXBlIHtDb2xvcn1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1DaGFuZ2VzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIHdoZW4gdGFwcGVkLiBBbiBvcHRpb25hbCBjb2xvciB2YWx1ZSBjYW4gYmUgZGVmaW5lZC4gRGVmYXVsdCBjb2xvciBpcyBcIiNkOWQ5ZDlcIi5bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICovXG5cbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jb21waWxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBpbGUoKSB7XG4gICAgICAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdF9faXRlbScpO1xuXG4gICAgICAgICB2YXIgbGVmdCA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICBjZW50ZXIgPSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgcmlnaHQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2xlZnQnKSkge1xuICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2xpc3RfX2l0ZW1fX2xlZnQnKTtcbiAgICAgICAgICAgICBsZWZ0ID0gZWw7XG4gICAgICAgICAgIH0gZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKSkge1xuICAgICAgICAgICAgIGNlbnRlciA9IGVsO1xuICAgICAgICAgICB9IGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygncmlnaHQnKSkge1xuICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2xpc3RfX2l0ZW1fX3JpZ2h0Jyk7XG4gICAgICAgICAgICAgcmlnaHQgPSBlbDtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAoIWNlbnRlcikge1xuICAgICAgICAgICBjZW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICBpZiAoIWxlZnQgJiYgIXJpZ2h0KSB7XG4gICAgICAgICAgICAgY2VudGVyLmlubmVySFRNTCA9IHRoaXMuaW5uZXJIVE1MO1xuICAgICAgICAgICAgIHRoaXMuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICAgICBpZiAoZWwgIT09IGxlZnQgJiYgZWwgIT09IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgIGNlbnRlci5pbnNlcnRCZWZvcmUoZWwsIGNlbnRlci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShjZW50ZXIsIHJpZ2h0IHx8IG51bGwpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgnY2VudGVyJyk7XG4gICAgICAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgnbGlzdF9faXRlbV9fY2VudGVyJyk7XG5cbiAgICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSQ5KTtcblxuICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lJDkpO1xuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2gpO1xuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblRvdWNoKTtcbiAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuXG4gICAgICAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICAgICB0aGlzLnRhcHBlZCA9IGZhbHNlO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RldGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2gpO1xuICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblRvdWNoKTtcbiAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGVSaXBwbGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUmlwcGxlKCkge1xuICAgICAgICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRHJhZycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRyYWcoZXZlbnQpIHtcbiAgICAgICAgIHZhciBnZXN0dXJlID0gZXZlbnQuZ2VzdHVyZTtcbiAgICAgICAgIC8vIFByZXZlbnQgdmVydGljYWwgc2Nyb2xsaW5nIGlmIHRoZSB1c2VycyBwYW5zIGxlZnQgb3IgcmlnaHQuXG4gICAgICAgICBpZiAodGhpcy5fc2hvdWxkTG9ja09uRHJhZygpICYmIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZ2VzdHVyZS5kaXJlY3Rpb24pID4gLTEpIHtcbiAgICAgICAgICAgZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vblRvdWNoJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uVG91Y2goKSB7XG4gICAgICAgICBpZiAodGhpcy50YXBwZWQpIHtcbiAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLnRhcHBlZCA9IHRydWU7XG5cbiAgICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbiA9IHRoaXMuX3RyYW5zaXRpb247XG4gICAgICAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSB0aGlzLl90cmFuc2l0aW9uO1xuICAgICAgICAgdGhpcy5zdHlsZS5Nb3pUcmFuc2l0aW9uID0gdGhpcy5fdHJhbnNpdGlvbjtcblxuICAgICAgICAgaWYgKHRoaXMuX3RhcHBhYmxlKSB7XG4gICAgICAgICAgIGlmICh0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsQmFja2dyb3VuZENvbG9yID0gdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX3RhcENvbG9yO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vblJlbGVhc2UnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25SZWxlYXNlKCkge1xuICAgICAgICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcblxuICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgICAgICB0aGlzLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJztcbiAgICAgICAgIHRoaXMuc3R5bGUuTW96VHJhbnNpdGlvbiA9ICcnO1xuXG4gICAgICAgICB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX29yaWdpbmFsQmFja2dyb3VuZENvbG9yIHx8ICcnO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19zaG91bGRMb2NrT25EcmFnJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3VsZExvY2tPbkRyYWcoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2xvY2stb24tZHJhZycpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ190cmFuc2l0aW9uJyxcbiAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgIHJldHVybiAnYmFja2dyb3VuZC1jb2xvciAwLjBzIGxpbmVhciAwLjAycyc7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3RhcHBhYmxlJyxcbiAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgndGFwcGFibGUnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfdGFwQ29sb3InLFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0YXBwYWJsZScpIHx8ICcjZDlkOWQ5JztcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIExpc3RJdGVtRWxlbWVudDtcbiAgIH0pKEJhc2VFbGVtZW50KTtcblxuICAgd2luZG93Lk9uc0xpc3RJdGVtRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLWxpc3QtaXRlbScsIHtcbiAgICAgcHJvdG90eXBlOiBMaXN0SXRlbUVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgdmFyIHNjaGVtZSQxMCA9IHsgJyc6ICdsaXN0LS0qJyB9O1xuXG4gICAvKipcbiAgICAqIEBlbGVtZW50IG9ucy1saXN0XG4gICAgKiBAY2F0ZWdvcnkgbGlzdFxuICAgICogQG1vZGlmaWVyIGluc2V0XG4gICAgKiAgIFtlbl1JbnNldCBsaXN0IHRoYXQgZG9lc24ndCBjb3ZlciB0aGUgd2hvbGUgd2lkdGggb2YgdGhlIHBhcmVudC5bL2VuXVxuICAgICogICBbamFd6Kaq6KaB57Sg44Gu55S76Z2i44GE44Gj44Gx44GE44Gr5bqD44GM44KJ44Gq44GE44Oq44K544OI44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBtb2RpZmllciBub2JvcmRlclxuICAgICogICBbZW5dQSBsaXN0IHdpdGggbm8gYm9yZGVycyBhdCB0aGUgdG9wIGFuZCBib3R0b20uWy9lbl1cbiAgICAqICAgW2phXeODquOCueODiOOBruS4iuS4i+OBruODnOODvOODgOODvOOBjOeEoeOBhOODquOCueODiOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXUNvbXBvbmVudCB0byBkZWZpbmUgYSBsaXN0LCBhbmQgdGhlIGNvbnRhaW5lciBmb3Igb25zLWxpc3QtaXRlbShzKS5bL2VuXVxuICAgICogICBbamFd44Oq44K544OI44KS6KGo54++44GZ44KL44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44CCb25zLWxpc3QtaXRlbeOBruOCs+ODs+ODhuODiuOBqOOBl+OBpuS9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAc2VlYWxzbyBvbnMtbGlzdC1pdGVtXG4gICAgKiAgIFtlbl1vbnMtbGlzdC1pdGVtIGNvbXBvbmVudFsvZW5dXG4gICAgKiAgIFtqYV1vbnMtbGlzdC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1saXN0LWhlYWRlclxuICAgICogICBbZW5db25zLWxpc3QtaGVhZGVyIGNvbXBvbmVudFsvZW5dXG4gICAgKiAgIFtqYV1vbnMtbGlzdC1oZWFkZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICAgICogQGd1aWRlIFVzaW5nTGlzdFxuICAgICogICBbZW5dVXNpbmcgbGlzdHNbL2VuXVxuICAgICogICBbamFd44Oq44K544OI44KS5L2/44GGWy9qYV1cbiAgICAqIEBjb2RlcGVuIHl4Y0N0XG4gICAgKiBAZXhhbXBsZVxuICAgICogPG9ucy1saXN0PlxuICAgICogICA8b25zLWxpc3QtaGVhZGVyPkhlYWRlciBUZXh0PC9vbnMtbGlzdC1oZWFkZXI+XG4gICAgKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gICAgKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gICAgKiA8L29ucy1saXN0PlxuICAgICovXG5cbiAgIHZhciBMaXN0RWxlbWVudCA9IChmdW5jdGlvbiAoX0Jhc2VFbGVtZW50KSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhMaXN0RWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBMaXN0RWxlbWVudCgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgTGlzdEVsZW1lbnQpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTGlzdEVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKExpc3RFbGVtZW50LCBbe1xuICAgICAgIGtleTogJ2NyZWF0ZWRDYWxsYmFjaycsXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdC5bL2VuXVxuICAgICAgICAqICAgW2phXeODquOCueODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jb21waWxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBpbGUoKSB7XG4gICAgICAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdsaXN0Jyk7XG4gICAgICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSQxMCk7XG5cbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICAgICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lJDEwKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIExpc3RFbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zTGlzdEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1saXN0Jywge1xuICAgICBwcm90b3R5cGU6IExpc3RFbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIHZhciBzY2hlbWUkMTEgPSB7XG4gICAgICcudGV4dC1pbnB1dCc6ICd0ZXh0LWlucHV0LS0qJyxcbiAgICAgJy50ZXh0LWlucHV0X19sYWJlbCc6ICd0ZXh0LWlucHV0LS0qX19sYWJlbCcsXG4gICAgICcucmFkaW8tYnV0dG9uJzogJ3JhZGlvLWJ1dHRvbi0tKicsXG4gICAgICcucmFkaW8tYnV0dG9uX19pbnB1dCc6ICdyYWRpby1idXR0b24tLSpfX2lucHV0JyxcbiAgICAgJy5yYWRpby1idXR0b25fX2NoZWNrbWFyayc6ICdyYWRpby1idXR0b24tLSpfX2NoZWNrbWFyaycsXG4gICAgICcuY2hlY2tib3gnOiAnY2hlY2tib3gtLSonLFxuICAgICAnLmNoZWNrYm94X19pbnB1dCc6ICdjaGVja2JveC0tKl9faW5wdXQnLFxuICAgICAnLmNoZWNrYm94X19jaGVja21hcmsnOiAnY2hlY2tib3gtLSpfX2NoZWNrbWFyaydcbiAgIH07XG5cbiAgIHZhciBJTlBVVF9BVFRSSUJVVEVTID0gWydhdXRvY2FwaXRhbGl6ZScsICdhdXRvY29tcGxldGUnLCAnYXV0b2NvcnJlY3QnLCAnYXV0b2ZvY3VzJywgJ2NoZWNrZWQnLCAnZGlzYWJsZWQnLCAnaW5wdXRtb2RlJywgJ21heCcsICdtYXhsZW5ndGgnLCAnbWluJywgJ21pbmxlbmd0aCcsICduYW1lJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncmVhZG9ubHknLCAnc2l6ZScsICdzdGVwJywgJ3R5cGUnLCAndmFsaWRhdG9yJywgJ3ZhbHVlJ107XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLW1hdGVyaWFsLWlucHV0XG4gICAgKiBAY2F0ZWdvcnkgZm9ybVxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgW2VuXU1hdGVyaWFsIERlc2lnbiBpbnB1dCBjb21wb25lbnQuWy9lbl1cbiAgICAqICBbamFdTWF0ZXJpYWwgRGVzaWdu44GuaW5wdXTjgrPjg7Pjg53igJXjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICAgICogQGNvZGVwZW4gb2pReExqXG4gICAgKiBAZ3VpZGUgVXNpbmdGb3JtQ29tcG9uZW50c1xuICAgICogICBbZW5dVXNpbmcgZm9ybSBjb21wb25lbnRzWy9lbl1cbiAgICAqICAgW2phXeODleOCqeODvOODoOOCkuS9v+OBhlsvamFdXG4gICAgKiBAZ3VpZGUgRXZlbnRIYW5kbGluZ1xuICAgICogICBbZW5dRXZlbnQgaGFuZGxpbmcgZGVzY3JpcHRpb25zWy9lbl1cbiAgICAqICAgW2phXeOCpOODmeODs+ODiOWHpueQhuOBruS9v+OBhOaWuVsvamFdXG4gICAgKiBAZXhhbXBsZVxuICAgICogPG9ucy1tYXRlcmlhbC1pbnB1dCBsYWJlbD1cIlVzZXJuYW1lXCI+PC9vbnMtbWF0ZXJpYWwtaW5wdXQ+XG4gICAgKi9cblxuICAgdmFyIE1hdGVyaWFsSW5wdXRFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKE1hdGVyaWFsSW5wdXRFbGVtZW50LCBfQmFzZUVsZW1lbnQpO1xuXG4gICAgIGZ1bmN0aW9uIE1hdGVyaWFsSW5wdXRFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXRlcmlhbElucHV0RWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXRlcmlhbElucHV0RWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoTWF0ZXJpYWxJbnB1dEVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgbGFiZWxcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVRleHQgZm9yIGFuaW1hdGVkIGZsb2F0aW5nIGxhYmVsLlsvZW5dXG4gICAgICAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44GV44Gb44KL44OV44Ot44O844OG44Kj44Oz44Kw44Op44OZ44Or44Gu44OG44Kt44K544OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgbm8tZmxvYXRcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHByZXNlbnQsIHRoZSBsYWJlbCB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgICAgICAqICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5pmC44CB44Op44OZ44Or44Gv44Ki44OL44Oh44O844K344On44Oz44GX44Gq44GE44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2NvbXBpbGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcGlsZSgpIHtcbiAgICAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgICAgICB2YXIgaGVscGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgaGVscGVyLmNsYXNzTGlzdC5hZGQoJ19oZWxwZXInKTtcblxuICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSk7XG4gICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVscGVyKTtcblxuICAgICAgICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnaW5wdXQtbGFiZWwnKTtcblxuICAgICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgIHJldHVybiBsYWJlbC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgIH0pO1xuICAgICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQtbGVmdCcpID8gY29udGFpbmVyLmluc2VydEJlZm9yZShsYWJlbCwgY29udGFpbmVyLmZpcnN0Q2hpbGQpIDogY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJykpIHtcbiAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnY2hlY2tib3gnKTtcbiAgICAgICAgICAgICB0aGlzLl9pbnB1dC5jbGFzc0xpc3QuYWRkKCdjaGVja2JveF9faW5wdXQnKTtcbiAgICAgICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgnY2hlY2tib3hfX2NoZWNrbWFyaycpO1xuICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpO1xuICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3JhZGlvLWJ1dHRvbicpO1xuICAgICAgICAgICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoJ3JhZGlvLWJ1dHRvbl9faW5wdXQnKTtcbiAgICAgICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgncmFkaW8tYnV0dG9uX19jaGVja21hcmsnKTtcbiAgICAgICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXQnKTtcbiAgICAgICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dF9fbGFiZWwnKTtcbiAgICAgICAgICAgICB0aGlzLl9pbnB1dC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXRfX2NvbnRhaW5lcicpO1xuXG4gICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWwoKTtcbiAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYWJlbENvbG9yKCk7XG4gICAgICAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGFiZWxDbGFzcygpO1xuXG4gICAgICAgICAgICAgdGhpcy5fYm91bmRPbklucHV0ID0gdGhpcy5fb25JbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgIHRoaXMuX2JvdW5kT25Gb2N1c2luID0gdGhpcy5fb25Gb2N1c2luLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgdGhpcy5fYm91bmRPbkZvY3Vzb3V0ID0gdGhpcy5fb25Gb2N1c291dC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQgPSB0aGlzLl9kZWxlZ2F0ZUV2ZW50LmJpbmQodGhpcyk7XG5cbiAgICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaW5wdXQtaWQnKSkge1xuICAgICAgICAgICB0aGlzLl9pbnB1dC5pZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpbnB1dC1pZCcpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSQxMSk7XG5cbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICAgICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lJDExKTtcbiAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3BsYWNlaG9sZGVyJykge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTGFiZWwoKTtcbiAgICAgICAgIH1pZiAobmFtZSA9PT0gJ2lucHV0LWlkJykge1xuICAgICAgICAgICB0aGlzLl9pbnB1dC5pZCA9IGN1cnJlbnQ7XG4gICAgICAgICB9IGVsc2UgaWYgKElOUFVUX0FUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIGlmICh0aGlzLl9pbnB1dC50eXBlICE9PSAnY2hlY2tib3gnICYmIHRoaXMuX2lucHV0LnR5cGUgIT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICAgICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fYm91bmRPbkZvY3VzaW4pO1xuICAgICAgICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMuX2JvdW5kT25Gb2N1c291dCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RldGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX2JvdW5kT25Gb2N1c2luKTtcbiAgICAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5fYm91bmRPbkZvY3Vzb3V0KTtcbiAgICAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19zZXRMYWJlbCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRMYWJlbCh2YWx1ZSkge1xuICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9oZWxwZXIudGV4dENvbnRlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgIHRoaXMuX2hlbHBlci50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5faGVscGVyLmlubmVyVGV4dCA9IHZhbHVlO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGVMYWJlbCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVMYWJlbCgpIHtcbiAgICAgICAgIHRoaXMuX3NldExhYmVsKHRoaXMuaGFzQXR0cmlidXRlKCdwbGFjZWhvbGRlcicpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykgOiAnJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZUJvdW5kQXR0cmlidXRlcycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgSU5QVVRfQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgIGlmIChfdGhpczIuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgICAgICAgX3RoaXMyLl9pbnB1dC5zZXRBdHRyaWJ1dGUoYXR0ciwgX3RoaXMyLmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgX3RoaXMyLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGVMYWJlbENvbG9yJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUxhYmVsQ29sb3IoKSB7XG4gICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAwICYmIHRoaXMuX2lucHV0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgIHRoaXMuX2hlbHBlci5zdHlsZS5jb2xvciA9ICcnO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5faGVscGVyLnN0eWxlLmNvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMC41KSc7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZUxhYmVsQ2xhc3MnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTGFiZWxDbGFzcygpIHtcbiAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1pbnB1dF9fbGFiZWwtLWFjdGl2ZScpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXRfX2xhYmVsLS1hY3RpdmUnKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZGVsZWdhdGVFdmVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxlZ2F0ZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgICB2YXIgZSA9IG5ldyBDdXN0b21FdmVudChldmVudC50eXBlLCB7XG4gICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICB9KTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25JbnB1dCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbklucHV0KGV2ZW50KSB7XG4gICAgICAgICB0aGlzLl91cGRhdGVMYWJlbENsYXNzKCk7XG4gICAgICAgICB0aGlzLl91cGRhdGVMYWJlbENvbG9yKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRm9jdXNpbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkZvY3VzaW4oZXZlbnQpIHtcbiAgICAgICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcbiAgICAgICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ29sb3IoKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25Gb2N1c291dCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkZvY3Vzb3V0KGV2ZW50KSB7XG4gICAgICAgICB0aGlzLl91cGRhdGVMYWJlbENvbG9yKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2lucHV0JyxcbiAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2hlbHBlcicsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcuX2hlbHBlcicpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3ZhbHVlJyxcbiAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWx1ZTtcbiAgICAgICB9LFxuICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgICAgdGhpcy5faW5wdXQudmFsdWUgPSB2YWw7XG4gICAgICAgICB0aGlzLl9vbklucHV0KCk7XG5cbiAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWw7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnY2hlY2tlZCcsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5faW5wdXQuY2hlY2tlZDtcbiAgICAgICB9LFxuICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgICAgdGhpcy5faW5wdXQuY2hlY2tlZCA9IHZhbDtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfaXNUZXh0SW5wdXQnLFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5jb250YWlucygndGV4dC1pbnB1dCcpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gTWF0ZXJpYWxJbnB1dEVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNJbnB1dEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1pbnB1dCcsIHtcbiAgICAgcHJvdG90eXBlOiBNYXRlcmlhbElucHV0RWxlbWVudC5wcm90b3R5cGVcbiAgIH0pO1xuXG4gICAvKlxuICAgQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG4gICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gICAqL1xuXG4gICB2YXIgTW9kYWxBbmltYXRvciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgICAgKi9cblxuICAgICBmdW5jdGlvbiBNb2RhbEFuaW1hdG9yKCkge1xuICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGFsQW5pbWF0b3IpO1xuXG4gICAgICAgdGhpcy5kZWxheSA9IDA7XG4gICAgICAgdGhpcy5kdXJhdGlvbiA9IDAuMjtcblxuICAgICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgdGhpcy50aW1pbmc7XG4gICAgICAgdGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiB0aGlzLmR1cmF0aW9uO1xuICAgICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlbGF5IDogdGhpcy5kZWxheTtcbiAgICAgfVxuXG4gICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgKi9cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoTW9kYWxBbmltYXRvciwgW3tcbiAgICAgICBrZXk6IFwic2hvd1wiLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KG1vZGFsLCBjYWxsYmFjaykge1xuICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogXCJoaWRlXCIsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gTW9kYWxBbmltYXRvcjtcbiAgIH0pKCk7XG5cbiAgIC8qKlxuICAgICogaU9TIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gICAgKi9cblxuICAgdmFyIEZhZGVNb2RhbEFuaW1hdG9yID0gKGZ1bmN0aW9uIChfTW9kYWxBbmltYXRvcikge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoRmFkZU1vZGFsQW5pbWF0b3IsIF9Nb2RhbEFuaW1hdG9yKTtcblxuICAgICBmdW5jdGlvbiBGYWRlTW9kYWxBbmltYXRvcihvcHRpb25zKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIEZhZGVNb2RhbEFuaW1hdG9yKTtcblxuICAgICAgIG9wdGlvbnMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgJzAuMyc7XG4gICAgICAgb3B0aW9ucy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDtcblxuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRmFkZU1vZGFsQW5pbWF0b3IpLmNhbGwodGhpcywgb3B0aW9ucykpO1xuICAgICB9XG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAqL1xuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhGYWRlTW9kYWxBbmltYXRvciwgW3tcbiAgICAgICBrZXk6ICdzaG93JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICBhbmltaXQobW9kYWwpLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgfSwge1xuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkucXVldWUoZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgfSkucGxheSgpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaGlkZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICAgYW5pbWl0KG1vZGFsKS5xdWV1ZSh7XG4gICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICB9LCB7XG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICB9KS5wbGF5KCk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBGYWRlTW9kYWxBbmltYXRvcjtcbiAgIH0pKE1vZGFsQW5pbWF0b3IpO1xuXG4gICB2YXIgc2NoZW1lJDEyID0ge1xuICAgICAnJzogJ21vZGFsLS0qJyxcbiAgICAgJ21vZGFsX19jb250ZW50JzogJ21vZGFsLS0qX19jb250ZW50J1xuICAgfTtcblxuICAgdmFyIF9hbmltYXRvckRpY3QkMiA9IHtcbiAgICAgJ2RlZmF1bHQnOiBNb2RhbEFuaW1hdG9yLFxuICAgICAnZmFkZSc6IEZhZGVNb2RhbEFuaW1hdG9yLFxuICAgICAnbm9uZSc6IE1vZGFsQW5pbWF0b3JcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLW1vZGFsXG4gICAgKiBAY2F0ZWdvcnkgbW9kYWxcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dXG4gICAgKiAgICAgTW9kYWwgY29tcG9uZW50IHRoYXQgbWFza3MgY3VycmVudCBzY3JlZW4uXG4gICAgKiAgICAgVW5kZXJseWluZyBjb21wb25lbnRzIGFyZSBub3Qgc3ViamVjdCB0byBhbnkgZXZlbnRzIHdoaWxlIHRoZSBtb2RhbCBjb21wb25lbnQgaXMgc2hvd24uXG4gICAgKiAgIFsvZW5dXG4gICAgKiAgIFtqYV1cbiAgICAqICAgICDnlLvpnaLlhajkvZPjgpLjg57jgrnjgq/jgZnjgovjg6Ljg7zjg4Djg6vnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILkuIvlgbTjgavjgYLjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga/jgIFcbiAgICAqICAgICDjg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozjgabjgYTjgovplpPjga/jgqTjg5njg7Pjg4jpgJrnn6XjgYzooYzjgo/jgozjgb7jgZvjgpPjgIJcbiAgICAqICAgWy9qYV1cbiAgICAqIEBndWlkZSBVc2luZ01vZGFsXG4gICAgKiAgIFtlbl1Vc2luZyBvbnMtbW9kYWwgY29tcG9uZW50Wy9lbl1cbiAgICAqICAgW2phXeODouODvOODgOODq+OBruS9v+OBhOaWuVsvamFdXG4gICAgKiBAZ3VpZGUgQ2FsbGluZ0NvbXBvbmVudEFQSXNmcm9tSmF2YVNjcmlwdFxuICAgICogICBbZW5dVXNpbmcgbmF2aWdhdG9yIGZyb20gSmF2YVNjcmlwdFsvZW5dXG4gICAgKiAgIFtqYV1KYXZhU2NyaXB044GL44KJ44Kz44Oz44Od44O844ON44Oz44OI44KS5ZG844Gz5Ye644GZWy9qYV1cbiAgICAqIEBjb2RlcGVuIGRldklnXG4gICAgKiBAZXhhbXBsZVxuICAgICogPG9ucy1tb2RhbD5cbiAgICAqICAgLi4uXG4gICAgKiA8L29ucy1tb2RhbD5cbiAgICAqL1xuXG4gICB2YXIgTW9kYWxFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKE1vZGFsRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBNb2RhbEVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGFsRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihNb2RhbEVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKE1vZGFsRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgbW9kYWwuIENhbiBiZSBlaXRoZXIgXCJub25lXCIgb3IgXCJmYWRlXCIuWy9lbl1cbiAgICAgICAgKiAgW2phXeODouODvOODgOODq+OCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJmYWRlXCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgICAgICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2VuXVxuICAgICAgICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvamFdXG4gICAgICAgICovXG5cbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuXG4gICAgICAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0JDIsXG4gICAgICAgICAgIGJhc2VDbGFzczogTW9kYWxBbmltYXRvcixcbiAgICAgICAgICAgYmFzZUNsYXNzTmFtZTogJ01vZGFsQW5pbWF0b3InLFxuICAgICAgICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICAgICAgIH0pO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgZ2V0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbiAgICAgICAgKiBAc2lnbmF0dXJlIGdldERldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICogICBbZW5dRGV2aWNlIGJhY2sgYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHJpZXZlIHRoZSBiYWNrIGJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAgICAgICogICBbamFdb25zLW1vZGFs44Gr57SQ5LuY44GE44Gm44GE44KL44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44KS5Y+W5b6X44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZ2V0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXInLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcjtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHNldERldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gICAgICAgICogQHNpZ25hdHVyZSBzZXREZXZpY2VCYWNrQnV0dG9uSGFuZGxlcihjYWxsYmFjaylcbiAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgKiAgIFtlbl1bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdzZXREZXZpY2VCYWNrQnV0dG9uSGFuZGxlcicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldERldmljZUJhY2tCdXR0b25IYW5kbGVyKGNhbGxiYWNrKSB7XG4gICAgICAgICBpZiAodGhpcy5fZGV2aWNlQmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgdGhpcy5fZGV2aWNlQmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICAgICAgICAgdGhpcy5fb25EZXZpY2VCYWNrQnV0dG9uID0gY2FsbGJhY2s7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRGV2aWNlQmFja0J1dHRvbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgICAgICAvLyBEbyBub3RoaW5nIGFuZCBzdG9wIGRldmljZS1iYWNrYnV0dG9uIGhhbmRsZXIgY2hhaW4uXG4gICAgICAgICByZXR1cm47XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2NvbXBpbGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcGlsZSgpIHtcbiAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbW9kYWwnKTtcblxuICAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnbW9kYWxfX2NvbnRlbnQnKTtcblxuICAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgd3JhcHBlci5pbnNlcnRCZWZvcmUobm9kZSwgbnVsbCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG5cbiAgICAgICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lJDEyKTtcblxuICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdkZXRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIGlmICh0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgICAgICB0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICBzZXRJbW1lZGlhdGUodGhpcy5fZW5zdXJlTm9kZVBvc2l0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICAgdGhpcy5fZGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZW5zdXJlTm9kZVBvc2l0aW9uJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Vuc3VyZU5vZGVQb3NpdGlvbigpIHtcbiAgICAgICAgIGlmICghdGhpcy5wYXJlbnROb2RlIHx8IHRoaXMuaGFzQXR0cmlidXRlKCdpbmxpbmUnKSkge1xuICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1wYWdlJykge1xuICAgICAgICAgICB2YXIgcGFnZSA9IHRoaXM7XG4gICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICBwYWdlID0gcGFnZS5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgaWYgKHBhZ2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1wYWdlJykge1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIHBhZ2UuX3JlZ2lzdGVyRXh0cmFFbGVtZW50KHRoaXMpO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaXNTaG93blxuICAgICAgICAqIEBzaWduYXR1cmUgaXNTaG93bigpXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKiAgIFtlbl10cnVlIGlmIHRoZSBtb2RhbCBpcyB2aXNpYmxlLlsvZW5dXG4gICAgICAgICogICBbamFd44Oi44O844OA44Or44GM6KGo56S644GV44KM44Gm44GE44KL5aC05ZCI44GrdHJ1ZeOBqOOBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBtb2RhbCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgICAgICAqICAgW2phXeODouODvOODgOODq+OBjOihqOekuuOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzU2hvd24nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Nob3duKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgc2hvd1xuICAgICAgICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAgICAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBcIm5vbmVcIiBhbmQgXCJmYWRlXCIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgICAgICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuICA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvZW5dXG4gICAgICAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+IFsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU2hvdyBtb2RhbC5bL2VuXVxuICAgICAgICAqICAgW2phXeODouODvOODgOODq+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3Nob3cnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSwgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkpO1xuXG4gICAgICAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICB2YXIgdHJ5U2hvdyA9IGZ1bmN0aW9uIHRyeVNob3coKSB7XG4gICAgICAgICAgIHZhciB1bmxvY2sgPSBfdGhpczIuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgICAgICAgdmFyIGFuaW1hdG9yID0gX3RoaXMyLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgICAgX3RoaXMyLnN0eWxlLmRpc3BsYXkgPSAndGFibGUnO1xuICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICBhbmltYXRvci5zaG93KF90aGlzMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICByZXNvbHZlKF90aGlzMik7XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgfTtcblxuICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgIF90aGlzMi5fZG9vckxvY2sud2FpdFVubG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ5U2hvdygpKTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgICAgICAqIEBzaWduYXR1cmUgdG9nZ2xlKFtvcHRpb25zXSlcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICAgICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIFwibm9uZVwiIGFuZCBcImZhZGVcIi5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAgICAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1Ub2dnbGUgbW9kYWwgdmlzaWJpbGl0eS5bL2VuXVxuICAgICAgICAqICAgW2phXeODouODvOODgOODq+OBruihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3RvZ2dsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgICAgIGlmICh0aGlzLmlzU2hvd24oKSkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5zaG93LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBoaWRlXG4gICAgICAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICAgICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIFwibm9uZVwiIGFuZCBcImZhZGVcIi5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAgICAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1IaWRlIG1vZGFsLlsvZW5dXG4gICAgICAgICogICBbamFd44Oi44O844OA44Or44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaGlkZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQob3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LCBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSk7XG5cbiAgICAgICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgIHZhciB0cnlIaWRlID0gZnVuY3Rpb24gdHJ5SGlkZSgpIHtcbiAgICAgICAgICAgdmFyIHVubG9jayA9IF90aGlzMy5fZG9vckxvY2subG9jaygpO1xuICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBfdGhpczMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICBhbmltYXRvci5oaWRlKF90aGlzMywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgX3RoaXMzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMzKTtcbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9O1xuXG4gICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgX3RoaXMzLl9kb29yTG9jay53YWl0VW5sb2NrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnlIaWRlKCkpO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgIH0pO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSQxMik7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBNb2RhbEVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNNb2RhbEVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1tb2RhbCcsIHtcbiAgICAgcHJvdG90eXBlOiBNb2RhbEVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQW5pbWF0b3JcbiAgICAqL1xuICAgd2luZG93Lk9uc01vZGFsRWxlbWVudC5yZWdpc3RlckFuaW1hdG9yID0gZnVuY3Rpb24gKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGFsQW5pbWF0b3IpKSB7XG4gICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc01vZGFsRWxlbWVudC5Nb2RhbEFuaW1hdG9yJyk7XG4gICAgIH1cbiAgICAgX2FuaW1hdG9yRGljdCQyW25hbWVdID0gQW5pbWF0b3I7XG4gICB9O1xuXG4gICB3aW5kb3cuT25zTW9kYWxFbGVtZW50Lk1vZGFsQW5pbWF0b3IgPSBNb2RhbEFuaW1hdG9yO1xuXG4gICB2YXIgTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAvKipcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAgICAqL1xuXG4gICAgIGZ1bmN0aW9uIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcihvcHRpb25zKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcik7XG5cbiAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgICAgIGR1cmF0aW9uOiAnMC40JyxcbiAgICAgICAgIGRlbGF5OiAnMCdcbiAgICAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmc7XG4gICAgICAgdGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG4gICAgICAgdGhpcy5kZWxheSA9IG9wdGlvbnMuZGVsYXk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLCBbe1xuICAgICAgIGtleTogJ3B1c2gnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdwb3AnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yO1xuICAgfSkoKTtcblxuICAgLyoqXG4gICAgKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24gbGlrZSBpT1MncyBzY3JlZW4gc2xpZGUgdHJhbnNpdGlvbi5cbiAgICAqL1xuXG4gICB2YXIgSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgPSAoZnVuY3Rpb24gKF9OYXZpZ2F0b3JUcmFuc2l0aW9uQSkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsIF9OYXZpZ2F0b3JUcmFuc2l0aW9uQSk7XG5cbiAgICAgZnVuY3Rpb24gSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3Iob3B0aW9ucykge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcik7XG5cbiAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgZHVyYXRpb246IDAuNCxcbiAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsXG4gICAgICAgICBkZWxheTogMFxuICAgICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgICAgdmFyIF90aGlzID0gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yKS5jYWxsKHRoaXMsIG9wdGlvbnMpKTtcblxuICAgICAgIF90aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KCdcXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IG9wYWNpdHk6IDA7IHotaW5kZXg6IDJcIj48L2Rpdj5cXG4gICAgJyk7XG4gICAgICAgcmV0dXJuIF90aGlzO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLCBbe1xuICAgICAgIGtleTogJ19kZWNvbXBvc2UnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjb21wb3NlKHBhZ2UpIHtcbiAgICAgICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUocGFnZSk7XG4gICAgICAgICB2YXIgdG9vbGJhciA9IHBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCk7XG4gICAgICAgICBDdXN0b21FbGVtZW50cy51cGdyYWRlKHRvb2xiYXIpO1xuICAgICAgICAgdmFyIGxlZnQgPSB0b29sYmFyLl9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpO1xuICAgICAgICAgdmFyIHJpZ2h0ID0gdG9vbGJhci5fZ2V0VG9vbGJhclJpZ2h0SXRlbXNFbGVtZW50KCk7XG5cbiAgICAgICAgIHZhciBleGNsdWRlQmFja0J1dHRvbkxhYmVsID0gZnVuY3Rpb24gZXhjbHVkZUJhY2tCdXR0b25MYWJlbChlbGVtZW50cykge1xuICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgIGlmIChlbGVtZW50c1tpXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWJhY2stYnV0dG9uJykge1xuICAgICAgICAgICAgICAgdmFyIGljb25FbGVtZW50ID0gZWxlbWVudHNbaV0ucXVlcnlTZWxlY3RvcignLmJhY2stYnV0dG9uX19pY29uJyk7XG4gICAgICAgICAgICAgICBpZiAoaWNvbkVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaWNvbkVsZW1lbnQpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgIH07XG5cbiAgICAgICAgIHZhciBvdGhlciA9IFtdLmNvbmNhdChsZWZ0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IGxlZnQgOiBleGNsdWRlQmFja0J1dHRvbkxhYmVsKGxlZnQuY2hpbGRyZW4pKS5jb25jYXQocmlnaHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gcmlnaHQgOiBleGNsdWRlQmFja0J1dHRvbkxhYmVsKHJpZ2h0LmNoaWxkcmVuKSk7XG5cbiAgICAgICAgIHZhciBwYWdlTGFiZWxzID0gW3Rvb2xiYXIuX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQoKSwgdG9vbGJhci5fZ2V0VG9vbGJhckJhY2tCdXR0b25MYWJlbEVsZW1lbnQoKV07XG5cbiAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgIHBhZ2VMYWJlbHM6IHBhZ2VMYWJlbHMsXG4gICAgICAgICAgIG90aGVyOiBvdGhlcixcbiAgICAgICAgICAgY29udGVudDogcGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSxcbiAgICAgICAgICAgYmFja2dyb3VuZDogcGFnZS5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSxcbiAgICAgICAgICAgdG9vbGJhcjogdG9vbGJhcixcbiAgICAgICAgICAgYm90dG9tVG9vbGJhcjogcGFnZS5fZ2V0Qm90dG9tVG9vbGJhckVsZW1lbnQoKVxuICAgICAgICAgfTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfc2hvdWxkQW5pbWF0ZVRvb2xiYXInLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpIHtcbiAgICAgICAgIHZhciBib3RoUGFnZUhhc1Rvb2xiYXIgPSBlbnRlclBhZ2UuX2NhbkFuaW1hdGVUb29sYmFyKCkgJiYgbGVhdmVQYWdlLl9jYW5BbmltYXRlVG9vbGJhcigpO1xuXG4gICAgICAgICB2YXIgbm9NYXRlcmlhbFRvb2xiYXIgPSAhZW50ZXJQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucygnbmF2aWdhdGlvbi1iYXItLW1hdGVyaWFsJykgJiYgIWxlYXZlUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKS5jbGFzc0xpc3QuY29udGFpbnMoJ25hdmlnYXRpb24tYmFyLS1tYXRlcmlhbCcpO1xuXG4gICAgICAgICByZXR1cm4gYm90aFBhZ2VIYXNUb29sYmFyICYmIG5vTWF0ZXJpYWxUb29sYmFyO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAncHVzaCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgIGxlYXZlUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgICAgICB2YXIgZW50ZXJQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShlbnRlclBhZ2UpO1xuICAgICAgICAgdmFyIGxlYXZlUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UobGVhdmVQYWdlKTtcblxuICAgICAgICAgdmFyIGRlbHRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgdmFyIHJlY3QgPSBsZWF2ZVBhZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDIgKiAwLjYpO1xuICAgICAgICAgfSkoKTtcblxuICAgICAgICAgdmFyIG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIG9wYWNpdHk6IDAuMVxuICAgICAgICAgfSwge1xuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkucmVzdG9yZVN0eWxlKCkucXVldWUoZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgX3RoaXMyLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICB9KTtcblxuICAgICAgICAgdmFyIHNob3VsZEFuaW1hdGVUb29sYmFyID0gdGhpcy5fc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpO1xuXG4gICAgICAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgICAgICAgYW5pbWl0LnJ1bkFsbChtYXNrQ2xlYXIsIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pLnNhdmVTdHlsZSgpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLCBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5wYWdlTGFiZWxzKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnICsgZGVsdGEgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLCBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5vdGhlcikuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICAgIGNzczogeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgICAgY3NzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLCBhbmltaXQoW2xlYXZlUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICB9KS5yZXN0b3JlU3R5bGUoKS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICB9KSwgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24ucGFnZUxhYmVscykuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgfSkucmVzdG9yZVN0eWxlKCksIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgICAgY3NzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgfSkucmVzdG9yZVN0eWxlKCkpO1xuICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICBhbmltaXQucnVuQWxsKG1hc2tDbGVhciwgYW5pbWl0KGVudGVyUGFnZSkuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KSdcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgfSkucmVzdG9yZVN0eWxlKCksIGFuaW1pdChsZWF2ZVBhZ2UpLnNhdmVTdHlsZSgpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgIH0pKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAncG9wJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBkb25lKSB7XG4gICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICAgICAgIHZhciBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGVudGVyUGFnZSk7XG4gICAgICAgICB2YXIgbGVhdmVQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShsZWF2ZVBhZ2UpO1xuXG4gICAgICAgICB2YXIgZGVsdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICB2YXIgcmVjdCA9IGxlYXZlUGFnZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMiAqIDAuNik7XG4gICAgICAgICB9KSgpO1xuXG4gICAgICAgICB2YXIgbWFza0NsZWFyID0gYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spLnNhdmVTdHlsZSgpLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogMC4xLFxuICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICB9LCB7XG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KS5yZXN0b3JlU3R5bGUoKS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICB9KTtcblxuICAgICAgICAgdmFyIHNob3VsZEFuaW1hdGVUb29sYmFyID0gdGhpcy5fc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpO1xuXG4gICAgICAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgICAgICAgYW5pbWl0LnJ1bkFsbChtYXNrQ2xlYXIsIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pLnNhdmVTdHlsZSgpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC0yNSUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLCBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5wYWdlTGFiZWxzKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtJyArIGRlbHRhICsgJ3B4LCAwLCAwKScsXG4gICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICB9KS5yZXN0b3JlU3R5bGUoKSwgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhcikuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICB9KS5yZXN0b3JlU3R5bGUoKSwgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24ub3RoZXIpLnNhdmVTdHlsZSgpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHsgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICAgIGNzczogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICB9KS5yZXN0b3JlU3R5bGUoKSwgYW5pbWl0KFtsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSkucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgfSkud2FpdCgwKS5xdWV1ZSgoZnVuY3Rpb24gKGZpbmlzaCkge1xuICAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICAgICB9KS5iaW5kKHRoaXMpKSwgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24ub3RoZXIpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICB9KSwgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24udG9vbGJhcikucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwKScsXG4gICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMCknXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICB9KSwgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24ucGFnZUxhYmVscykucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBkZWx0YSArICdweCwgMCwgMCknLFxuICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICB9KSk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBhbmltaXQucnVuQWxsKG1hc2tDbGVhciwgYW5pbWl0KGVudGVyUGFnZSkuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwcHgsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgfSkucmVzdG9yZVN0eWxlKCksIGFuaW1pdChsZWF2ZVBhZ2UpLnF1ZXVlKHtcbiAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgIH0pLnF1ZXVlKChmdW5jdGlvbiAoZmluaXNoKSB7XG4gICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgIH0pLmJpbmQodGhpcykpKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIElPU1NsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yO1xuICAgfSkoTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yKTtcblxuICAgLyoqXG4gICAgKiBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICAgICovXG5cbiAgIHZhciBJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yID0gKGZ1bmN0aW9uIChfTmF2aWdhdG9yVHJhbnNpdGlvbkEpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsIF9OYXZpZ2F0b3JUcmFuc2l0aW9uQSk7XG5cbiAgICAgZnVuY3Rpb24gSU9TTGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcihvcHRpb25zKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IpO1xuXG4gICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLFxuICAgICAgICAgZGVsYXk6IDBcbiAgICAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgICAgIHZhciBfdGhpcyA9IGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihJT1NMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yKS5jYWxsKHRoaXMsIG9wdGlvbnMpKTtcblxuICAgICAgIF90aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KCdcXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KGJsYWNrLCB3aGl0ZSk7XCI+PC9kaXY+XFxuICAgICcpO1xuICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgfVxuXG4gICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICovXG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsIFt7XG4gICAgICAga2V5OiAncHVzaCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgIGxlYXZlUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UpO1xuXG4gICAgICAgICB2YXIgbWFza0NsZWFyID0gYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spLndhaXQoMC42KS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICBfdGhpczIuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pO1xuXG4gICAgICAgICBhbmltaXQucnVuQWxsKG1hc2tDbGVhciwgYW5pbWl0KGVudGVyUGFnZSkuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKSdcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLndhaXQoMC4yKS5yZXN0b3JlU3R5bGUoKS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICB9KSwgYW5pbWl0KGxlYXZlUGFnZSkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgLTEwJSwgMCknLFxuICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAncG9wJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgICAgICAgYW5pbWl0LnJ1bkFsbChhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaykud2FpdCgwLjQpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgIF90aGlzMy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgfSksIGFuaW1pdChlbnRlclBhZ2UpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgLTEwJSwgMCknLFxuICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLndhaXQoMC40KS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICB9KSwgYW5pbWl0KGxlYXZlUGFnZSkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKSdcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3I7XG4gICB9KShOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IpO1xuXG4gICAvKipcbiAgICAqIEZhZGUtaW4gc2NyZWVuIHRyYW5zaXRpb24uXG4gICAgKi9cblxuICAgdmFyIElPU0ZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgPSAoZnVuY3Rpb24gKF9OYXZpZ2F0b3JUcmFuc2l0aW9uQSkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciwgX05hdmlnYXRvclRyYW5zaXRpb25BKTtcblxuICAgICBmdW5jdGlvbiBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yKG9wdGlvbnMpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcik7XG5cbiAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgICAgIGR1cmF0aW9uOiAnMC40JyxcbiAgICAgICAgIGRlbGF5OiAnMCdcbiAgICAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSU9TRmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcikuY2FsbCh0aGlzLCBvcHRpb25zKSk7XG4gICAgIH1cblxuICAgICAvKipcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAqL1xuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLCBbe1xuICAgICAgIGtleTogJ3B1c2gnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuXG4gICAgICAgICBhbmltaXQucnVuQWxsKGFuaW1pdChbZW50ZXJQYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBlbnRlclBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCldKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pLCBhbmltaXQoZW50ZXJQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAncG9wJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgICAgICAgYW5pbWl0LnJ1bkFsbChhbmltaXQoW2xlYXZlUGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSwgbGVhdmVQYWdlLl9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpXSkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICB9KSwgYW5pbWl0KGxlYXZlUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKSkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KSk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yO1xuICAgfSkoTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yKTtcblxuICAgLyoqXG4gICAgKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24uXG4gICAgKi9cblxuICAgdmFyIE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgPSAoZnVuY3Rpb24gKF9OYXZpZ2F0b3JUcmFuc2l0aW9uQSkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciwgX05hdmlnYXRvclRyYW5zaXRpb25BKTtcblxuICAgICBmdW5jdGlvbiBNRFNsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yKG9wdGlvbnMpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgTURTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcik7XG5cbiAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsXG4gICAgICAgICBkZWxheTogMFxuICAgICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgICAgdmFyIF90aGlzID0gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IpLmNhbGwodGhpcywgb3B0aW9ucykpO1xuXG4gICAgICAgX3RoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoJ1xcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDI7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjazsgb3BhY2l0eTogMDtcIj48L2Rpdj5cXG4gICAgJyk7XG4gICAgICAgX3RoaXMuYmxhY2tNYXNrT3BhY2l0eSA9IDAuNDtcbiAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgIH1cblxuICAgICAvKipcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAqL1xuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhNRFNsaWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLCBbe1xuICAgICAgIGtleTogJ3B1c2gnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICBsZWF2ZVBhZ2UucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlLm5leHRTaWJsaW5nKTtcblxuICAgICAgICAgYW5pbWl0LnJ1bkFsbChhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaykuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiB0aGlzLmJsYWNrTWFza09wYWNpdHlcbiAgICAgICAgIH0sIHtcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgIF90aGlzMi5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgfSksIGFuaW1pdChlbnRlclBhZ2UpLnNhdmVTdHlsZSgpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMCwgMCknXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KS5yZXN0b3JlU3R5bGUoKSwgYW5pbWl0KGxlYXZlUGFnZSkuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNDUlLCAwcHgsIDBweCknXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KS5yZXN0b3JlU3R5bGUoKS53YWl0KDAuMikucXVldWUoZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgfSkpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdwb3AnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGRvbmUpIHtcbiAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICAgICAgIGFuaW1pdC5ydW5BbGwoYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spLnNhdmVTdHlsZSgpLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogdGhpcy5ibGFja01hc2tPcGFjaXR5LFxuICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICB9LCB7XG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KS5yZXN0b3JlU3R5bGUoKS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICBfdGhpczMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pLCBhbmltaXQoZW50ZXJQYWdlKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC00NSUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkucmVzdG9yZVN0eWxlKCksIGFuaW1pdChsZWF2ZVBhZ2UpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJ1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkud2FpdCgwLjIpLnF1ZXVlKGZ1bmN0aW9uIChmaW5pc2gpIHtcbiAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3I7XG4gICB9KShOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IpO1xuXG4gICAvKipcbiAgICAqIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gICAgKi9cblxuICAgdmFyIE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA9IChmdW5jdGlvbiAoX05hdmlnYXRvclRyYW5zaXRpb25BKSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhNRExpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsIF9OYXZpZ2F0b3JUcmFuc2l0aW9uQSk7XG5cbiAgICAgZnVuY3Rpb24gTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yKG9wdGlvbnMpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yKTtcblxuICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICBkdXJhdGlvbjogMC40LFxuICAgICAgICAgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyxcbiAgICAgICAgIGRlbGF5OiAwLjA1XG4gICAgICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICAgICB2YXIgX3RoaXMgPSBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yKS5jYWxsKHRoaXMsIG9wdGlvbnMpKTtcblxuICAgICAgIF90aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KCdcXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XCI+PC9kaXY+XFxuICAgICcpO1xuICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgfVxuXG4gICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICovXG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciwgW3tcbiAgICAgICBrZXk6ICdwdXNoJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgbGVhdmVQYWdlLmVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlLmVsZW1lbnQpO1xuXG4gICAgICAgICB2YXIgbWFza0NsZWFyID0gYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spLndhaXQoMC42KS5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICBfdGhpczIuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pO1xuXG4gICAgICAgICBhbmltaXQucnVuQWxsKG1hc2tDbGVhciwgYW5pbWl0KGVudGVyUGFnZS5lbGVtZW50KS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJ1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkud2FpdCgwLjUpLnJlc3RvcmVTdHlsZSgpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pLCBhbmltaXQobGVhdmVQYWdlLmVsZW1lbnQpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KDApLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgb3BhY2l0eTogMC40XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KSk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdwb3AnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgIGVudGVyUGFnZS5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5lbGVtZW50KTtcblxuICAgICAgICAgYW5pbWl0LnJ1bkFsbChhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaykud2FpdCgwLjQpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgIF90aGlzMy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgfSksIGFuaW1pdChlbnRlclBhZ2UuZWxlbWVudCkucXVldWUoe1xuICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgb3BhY2l0eTogMC40XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkud2FpdCgwLjQpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pLCBhbmltaXQobGVhdmVQYWdlLmVsZW1lbnQpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMTAwJSwgMCknXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICB9KSk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBNRExpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3I7XG4gICB9KShOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IpO1xuXG4gICAvKipcbiAgICAqIEZhZGUtaW4gKyBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICAgICovXG5cbiAgIHZhciBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgPSAoZnVuY3Rpb24gKF9OYXZpZ2F0b3JUcmFuc2l0aW9uQSkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLCBfTmF2aWdhdG9yVHJhbnNpdGlvbkEpO1xuXG4gICAgIGZ1bmN0aW9uIE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcihvcHRpb25zKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcik7XG5cbiAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgdGltaW5nOiAnZWFzZS1vdXQnLFxuICAgICAgICAgZHVyYXRpb246ICcwLjI1JyxcbiAgICAgICAgIGRlbGF5OiAnMC4yMCdcbiAgICAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yKS5jYWxsKHRoaXMsIG9wdGlvbnMpKTtcbiAgICAgfVxuXG4gICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICovXG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciwgW3tcbiAgICAgICBrZXk6ICdwdXNoJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcblxuICAgICAgICAgYW5pbWl0LnJ1bkFsbChhbmltaXQoZW50ZXJQYWdlKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDQycHgsIDApJyxcbiAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICB9KS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLnF1ZXVlKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAncG9wJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgICAgICAgYW5pbWl0LnJ1bkFsbChhbmltaXQobGVhdmVQYWdlKS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgfSkud2FpdCgwLjE1KS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDM4cHgsIDApJ1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkucXVldWUoZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgfSksIGFuaW1pdChsZWF2ZVBhZ2UpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICB9LFxuICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgfSkud2FpdCgwLjA0KS5xdWV1ZSh7XG4gICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcjtcbiAgIH0pKE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcik7XG5cbiAgIHZhciBOb25lTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yID0gKGZ1bmN0aW9uIChfTmF2aWdhdG9yVHJhbnNpdGlvbkEpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKE5vbmVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsIF9OYXZpZ2F0b3JUcmFuc2l0aW9uQSk7XG5cbiAgICAgZnVuY3Rpb24gTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcihvcHRpb25zKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIE5vbmVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcikuY2FsbCh0aGlzLCBvcHRpb25zKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoTm9uZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciwgW3tcbiAgICAgICBrZXk6ICdwdXNoJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAncG9wJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIE5vbmVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3I7XG4gICB9KShOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IpO1xuXG4gICB2YXIgTmF2aWdhdG9yUGFnZSA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5wYWdlXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMuZWxlbWVudFxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLm9wdGlvbnNcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5uYXZpZ2F0b3JcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5pbml0aWFsQ29udGVudFxuICAgICAgKi9cblxuICAgICBmdW5jdGlvbiBOYXZpZ2F0b3JQYWdlKHBhcmFtcykge1xuICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgTmF2aWdhdG9yUGFnZSk7XG5cbiAgICAgICB0aGlzLnBhZ2UgPSBwYXJhbXMucGFnZTtcbiAgICAgICB0aGlzLm5hbWUgPSBwYXJhbXMucGFnZTtcbiAgICAgICB0aGlzLmVsZW1lbnQgPSBwYXJhbXMuZWxlbWVudDtcbiAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcbiAgICAgICB0aGlzLm5hdmlnYXRvciA9IHBhcmFtcy5uYXZpZ2F0b3I7XG4gICAgICAgdGhpcy5pbml0aWFsQ29udGVudCA9IHBhcmFtcy5pbml0aWFsQ29udGVudDtcbiAgICAgICB0aGlzLmJhY2tCdXR0b24gPSB1dGlsLmZpbmRDaGlsZFJlY3Vyc2l2ZWx5KHRoaXMuZWxlbWVudCwgJ29ucy1iYWNrLWJ1dHRvbicpO1xuXG4gICAgICAgaWYgKHRoaXMuYmFja0J1dHRvbikge1xuICAgICAgICAgQ3VzdG9tRWxlbWVudHMudXBncmFkZSh0aGlzLmJhY2tCdXR0b24pO1xuICAgICAgIH1cblxuICAgICAgIC8vIEJsb2NrIGV2ZW50cyB3aGlsZSBwYWdlIGlzIGJlaW5nIGFuaW1hdGVkIHRvIHN0b3Agc2Nyb2xsaW5nLCBwcmVzc2luZyBidXR0b25zLCBldGMuXG4gICAgICAgdGhpcy5fYmxvY2tFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgIGlmIChfdGhpcy5uYXZpZ2F0b3IuX2lzUG9wcGluZyB8fCBfdGhpcy5uYXZpZ2F0b3IuX2lzUHVzaGluZykge1xuICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgIH1cbiAgICAgICB9O1xuXG4gICAgICAgdGhpcy5fcG9pbnRlckV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgcmV0dXJuIF90aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX2Jsb2NrRXZlbnRzKTtcbiAgICAgICB9LCBmYWxzZSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoTmF2aWdhdG9yUGFnZSwgW3tcbiAgICAgICBrZXk6ICdnZXREZXZpY2VCYWNrQnV0dG9uSGFuZGxlcicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERldmljZUJhY2tCdXR0b25IYW5kbGVyKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2RldmljZUJhY2tCdXR0b25IYW5kbGVyO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge1BhZ2VWaWV3fVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdnZXRQYWdlVmlldycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VWaWV3KCkge1xuICAgICAgICAgaWYgKCF0aGlzLl9wYWdlKSB7XG4gICAgICAgICAgIHRoaXMuX3BhZ2UgPSB1dGlsLmZpbmRQYXJlbnQoJ29ucy1wYWdlJyk7XG4gICAgICAgICAgIGlmICghdGhpcy5fcGFnZSkge1xuICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbCB0byBmZXRjaCBvbnMtcGFnZSBlbGVtZW50LicpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICd1cGRhdGVCYWNrQnV0dG9uJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQmFja0J1dHRvbigpIHtcbiAgICAgICAgIGlmICh0aGlzLmJhY2tCdXR0b24pIHtcbiAgICAgICAgICAgaWYgKHRoaXMubmF2aWdhdG9yLl9wYWdlcy5sZW5ndGggPT09IDEgfHwgdGhpcy5vcHRpb25zLl9mb3JjZUhpZGVCYWNrQnV0dG9uKSB7XG4gICAgICAgICAgICAgdGhpcy5iYWNrQnV0dG9uLmhpZGUoKTtcbiAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuX2ZvcmNlSGlkZUJhY2tCdXR0b24gPSBmYWxzZTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICB0aGlzLmJhY2tCdXR0b24uc2hvdygpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgdGhpcy5fcG9pbnRlckV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICByZXR1cm4gX3RoaXMyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMyLl9ibG9ja0V2ZW50cyk7XG4gICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICB0aGlzLmVsZW1lbnQuX2Rlc3Ryb3koKTtcblxuICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5uYXZpZ2F0b3IuX3BhZ2VzLmluZGV4T2YodGhpcyk7XG4gICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgIHRoaXMubmF2aWdhdG9yLl9wYWdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLl9wYWdlID0gdGhpcy5vcHRpb25zID0gdGhpcy5uYXZpZ2F0b3IgPSBudWxsO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19wb2ludGVyRXZlbnRzJyxcbiAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgIHJldHVybiBbJ3RvdWNobW92ZSddO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gTmF2aWdhdG9yUGFnZTtcbiAgIH0pKCk7XG5cbiAgIHZhciBfYW5pbWF0b3JEaWN0JDMgPSB7XG4gICAgICdkZWZhdWx0JzogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgcmV0dXJuIHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3I7XG4gICAgIH0sXG4gICAgICdzbGlkZSc6IGZ1bmN0aW9uIHNsaWRlKCkge1xuICAgICAgIHJldHVybiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgOiBJT1NTbGlkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcjtcbiAgICAgfSxcbiAgICAgJ2xpZnQnOiBmdW5jdGlvbiBsaWZ0KCkge1xuICAgICAgIHJldHVybiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ETGlmdE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvciA6IElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3I7XG4gICAgIH0sXG4gICAgICdmYWRlJzogZnVuY3Rpb24gZmFkZSgpIHtcbiAgICAgICByZXR1cm4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREZhZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgOiBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yO1xuICAgICB9LFxuICAgICAnc2xpZGUtaW9zJzogSU9TU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICAgICdzbGlkZS1tZCc6IE1EU2xpZGVOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICAgICdsaWZ0LWlvcyc6IElPU0xpZnROYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IsXG4gICAgICdsaWZ0LW1kJzogTURMaWZ0TmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAgICAnZmFkZS1pb3MnOiBJT1NGYWRlTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yLFxuICAgICAnZmFkZS1tZCc6IE1ERmFkZU5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgICAgJ25vbmUnOiBOb25lTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yXG4gICB9O1xuXG4gICB2YXIgcmV3cml0YWJsZXMgPSB7XG4gICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5hdmlnYXRvclNpZGVFbGVtZW50XG4gICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAqL1xuXG4gICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeShuYXZpZ2F0b3JFbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgIGNhbGxiYWNrKCk7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbmF2aWdhdG9yRWxlbWVudFxuICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgKi9cbiAgICAgbGluazogZnVuY3Rpb24gbGluayhuYXZpZ2F0b3JFbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgY2FsbGJhY2sodGFyZ2V0KTtcbiAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtbmF2aWdhdG9yXG4gICAgKiBAY2F0ZWdvcnkgbmF2aWdhdGlvblxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1BIGNvbXBvbmVudCB0aGF0IHByb3ZpZGVzIHBhZ2Ugc3RhY2sgbWFuYWdlbWVudCBhbmQgbmF2aWdhdGlvbi4gVGhpcyBjb21wb25lbnQgZG9lcyBub3QgaGF2ZSBhIHZpc2libGUgY29udGVudC5bL2VuXVxuICAgICogICBbamFd44Oa44O844K444K544K/44OD44Kv44Gu566h55CG44Go44OK44OT44Ky44O844K344On44Oz5qmf6IO944KS5o+Q5L6b44GZ44KL44Kz44Oz44Od44O844ON44Oz44OI44CC55S76Z2i5LiK44G444Gu5Ye65Yqb44Gv44GC44KK44G+44Gb44KT44CCWy9qYV1cbiAgICAqIEBjb2RlcGVuIHlyaHR2XG4gICAgKiBAZ3VpZGUgUGFnZU5hdmlnYXRpb25cbiAgICAqICAgW2VuXUd1aWRlIGZvciBwYWdlIG5hdmlnYXRpb25bL2VuXVxuICAgICogICBbamFd44Oa44O844K444OK44OT44Ky44O844K344On44Oz44Gu5qaC6KaBWy9qYV1cbiAgICAqIEBndWlkZSBDYWxsaW5nQ29tcG9uZW50QVBJc2Zyb21KYXZhU2NyaXB0XG4gICAgKiAgIFtlbl1Vc2luZyBuYXZpZ2F0b3IgZnJvbSBKYXZhU2NyaXB0Wy9lbl1cbiAgICAqICAgW2phXUphdmFTY3JpcHTjgYvjgonjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLlkbzjgbPlh7rjgZlbL2phXVxuICAgICogQGd1aWRlIEV2ZW50SGFuZGxpbmdcbiAgICAqICAgW2VuXUV2ZW50IGhhbmRsaW5nIGRlc2NyaXB0aW9uc1svZW5dXG4gICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlh6bnkIbjga7kvb/jgYTmlrlbL2phXVxuICAgICogQGd1aWRlIERlZmluaW5nTXVsdGlwbGVQYWdlc2luU2luZ2xlSFRNTFxuICAgICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICAgICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICAgICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAgICAqICAgW2VuXW9ucy10b29sYmFyIGNvbXBvbmVudFsvZW5dXG4gICAgKiAgIFtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gICAgKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAgICAqICAgW2VuXW9ucy1iYWNrLWJ1dHRvbiBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLWJhY2stYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8b25zLW5hdmlnYXRvciBhbmltYXRpb249XCJzbGlkZVwiIHZhcj1cImFwcC5uYXZpXCI+XG4gICAgKiAgIDxvbnMtcGFnZT5cbiAgICAqICAgICA8b25zLXRvb2xiYXI+XG4gICAgKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+VGl0bGU8L2Rpdj5cbiAgICAqICAgICA8L29ucy10b29sYmFyPlxuICAgICpcbiAgICAqICAgICA8cCBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlclwiPlxuICAgICogICAgICAgPG9ucy1idXR0b24gbW9kaWZpZXI9XCJsaWdodFwiIG5nLWNsaWNrPVwiYXBwLm5hdmkucHVzaFBhZ2UoJ3BhZ2UuaHRtbCcpO1wiPlB1c2g8L29ucy1idXR0b24+XG4gICAgKiAgICAgPC9wPlxuICAgICogICA8L29ucy1wYWdlPlxuICAgICogPC9vbnMtbmF2aWdhdG9yPlxuICAgICpcbiAgICAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJwYWdlLmh0bWxcIj5cbiAgICAqICAgPG9ucy1wYWdlPlxuICAgICogICAgIDxvbnMtdG9vbGJhcj5cbiAgICAqICAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5UaXRsZTwvZGl2PlxuICAgICogICAgIDwvb25zLXRvb2xiYXI+XG4gICAgKlxuICAgICogICAgIDxwIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyXCI+XG4gICAgKiAgICAgICA8b25zLWJ1dHRvbiBtb2RpZmllcj1cImxpZ2h0XCIgbmctY2xpY2s9XCJhcHAubmF2aS5wb3BQYWdlKCk7XCI+UG9wPC9vbnMtYnV0dG9uPlxuICAgICogICAgIDwvcD5cbiAgICAqICAgPC9vbnMtcGFnZT5cbiAgICAqIDwvb25zLXRlbXBsYXRlPlxuICAgICovXG5cbiAgIHZhciBOYXZpZ2F0b3JFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKE5hdmlnYXRvckVsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gTmF2aWdhdG9yRWxlbWVudCgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgTmF2aWdhdG9yRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihOYXZpZ2F0b3JFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhOYXZpZ2F0b3JFbGVtZW50LCBbe1xuICAgICAgIGtleTogJ2NyZWF0ZWRDYWxsYmFjaycsXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAgICAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvZW5dXG4gICAgICAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgICAgICAqIEBpbml0b25seVxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyc3QgcGFnZSB0byBzaG93IHdoZW4gbmF2aWdhdG9yIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gICAgICAgICogICBbamFd44OK44OT44Ky44O844K/44O844GM5Yid5pyf5YyW44GV44KM44Gf5pmC44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1TcGVjaWZ5IHRoZSB0cmFuc2l0aW9uIGFuaW1hdGlvbi4gVXNlIG9uZSBvZiBcInNsaWRlXCIsIFwic2ltcGxlc2xpZGVcIiwgXCJmYWRlXCIsIFwibGlmdFwiLCBcIm5vbmVcIiBhbmQgXCJkZWZhdWx0XCIuWy9lbl1cbiAgICAgICAgKiAgW2phXeeUu+mdoumBt+enu+OBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglwic2xpZGVcIiwgXCJzaW1wbGVzbGlkZVwiLCBcImZhZGVcIiwgXCJsaWZ0XCIsIFwibm9uZVwiLCBcImRlZmF1bHRcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIHByZXB1c2hcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAgICAgICogICBbamFdcGFnZeOBjHB1c2jjgZXjgozjgovnm7TliY3jgavnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgICAgICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jdXJyZW50UGFnZVxuICAgICAgICAqICAgW2VuXUN1cnJlbnQgcGFnZSBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3nj77lnKjjga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICAgICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSBwdXNoLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CBcHVzaOWHpueQhuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIHByZXBvcFxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1wYWdl44GMcG9w44GV44KM44KL55u05YmN44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICAgICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY3VycmVudFBhZ2VcbiAgICAgICAgKiAgIFtlbl1DdXJyZW50IHBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd54++5Zyo44GucGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAgICAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgcG9wLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CBcGFnZeOBrnBvcOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIHBvc3RwdXNoXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAgICAgICogICBbamFdcGFnZeOBjHB1c2jjgZXjgozjgabjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzntYLkuobjgZfjgabjgYvjgonnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgICAgICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5lbnRlclBhZ2VcbiAgICAgICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIG5leHQgcGFnZS5bL2VuXVxuICAgICAgICAqICAgW2phXXB1c2jjgZXjgozjgZ9wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubGVhdmVQYWdlXG4gICAgICAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gICAgICAgICogICBbamFd5Lul5YmN44GucGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAZXZlbnQgcG9zdHBvcFxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgYSBwYWdlIGlzIHBvcHBlZC5bL2VuXVxuICAgICAgICAqICAgW2phXXBhZ2XjgYxwb3DjgZXjgozjgabjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzntYLjgo/jgaPjgZ/lvozjgavnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgICAgICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5lbnRlclBhZ2VcbiAgICAgICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIG5leHQgcGFnZS5bL2VuXVxuICAgICAgICAqICAgW2phXXBvcOOBleOCjOOBpuihqOekuuOBleOCjOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmxlYXZlUGFnZVxuICAgICAgICAqICAgW2VuXU9iamVjdCBvZiB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICAgICAgICAqICAgW2phXXBvcOOBleOCjOOBpua2iOOBiOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICovXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuX2JvdW5kT25EZXZpY2VCYWNrQnV0dG9uID0gdGhpcy5fb25EZXZpY2VCYWNrQnV0dG9uLmJpbmQodGhpcyk7XG4gICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCQzLFxuICAgICAgICAgICBiYXNlQ2xhc3M6IE5hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcixcbiAgICAgICAgICAgYmFzZUNsYXNzTmFtZTogJ05hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcicsXG4gICAgICAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgICAgICAgfSk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXURlZmF1bHQgb3B0aW9ucyBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdjYW5Qb3BQYWdlJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICovXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhblBvcFBhZ2UoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5wYWdlcy5sZW5ndGggPiAxO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgcmVwbGFjZVBhZ2VcbiAgICAgICAgKiBAc2lnbmF0dXJlIHJlcGxhY2VQYWdlKHBhZ2VVcmwsIFtvcHRpb25zXSlcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhZ2VVcmxdXG4gICAgICAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYSBIVE1MIGRvY3VtZW50IG9yIGFuIDxjb2RlPiZsdDtvbnMtdGVtcGxhdGUmZ3Q7PC9jb2RlPi5bL2VuXVxuICAgICAgICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlXVxuICAgICAgICAqICAgW2VuXVBhZ2VVUkwuIE9ubHkgbmVjc3NhcnkgaWYgYHBhZ2VgIHBhcmFtZXRlciBpcyBvbWl0dGVkLlsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFnZUhUTUxdXG4gICAgICAgICogICBbZW5dSFRNTCBjb2RlIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBhcyBhIG5ldyBwYWdlLiBPdmVyd3JpdGVzIGBwYWdlYCBwYXJhbWV0ZXIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAgICAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBcInNsaWRlXCIsIFwic2ltcGxlc2xpZGVcIiwgXCJsaWZ0XCIsIFwiZmFkZVwiIGFuZCBcIm5vbmVcIi5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglwic2xpZGVcIiwgXCJzaW1wbGVzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIsIFwibm9uZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uVHJhbnNpdGlvbkVuZF1cbiAgICAgICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmVwbGFjZXMgdGhlIGN1cnJlbnQgcGFnZSB3aXRoIHRoZSBzcGVjaWZpZWQgb25lLlsvZW5dXG4gICAgICAgICogICBbamFd54++5Zyo6KGo56S65Lit44Gu44Oa44O844K444KS44KS5oyH5a6a44GX44Gf44Oa44O844K444Gr572u44GN5o+b44GI44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IHBhZ2Ugd2l0aCB0aGUgc3BlY2lmaWVkIG9uZS5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdyZXBsYWNlUGFnZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VQYWdlKHBhZ2UpIHtcbiAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICBpZiAoKHR5cGVvZiBwYWdlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogYmFiZWxIZWxwZXJzLnR5cGVvZihwYWdlKSkgPT09ICdvYmplY3QnICYmIHBhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgb3B0aW9ucyA9IHBhZ2U7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBvcHRpb25zLnBhZ2UgPSBwYWdlO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAob3B0aW9ucyAmJiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBiYWJlbEhlbHBlcnMudHlwZW9mKG9wdGlvbnMpKSAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHZhciBvblRyYW5zaXRpb25FbmQgPSBvcHRpb25zLm9uVHJhbnNpdGlvbkVuZCB8fCBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICAgb3B0aW9ucy5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIGlmIChfdGhpczIucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgIF90aGlzMi5wYWdlc1tfdGhpczIucGFnZXMubGVuZ3RoIC0gMl0uX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIF90aGlzMi5fdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCk7XG5cbiAgICAgICAgICAgb25UcmFuc2l0aW9uRW5kKCk7XG4gICAgICAgICB9O1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShvcHRpb25zLnBhZ2UsIG9wdGlvbnMpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCkge1xuICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuICAgICAgICAgdGhpcy5wYWdlc1tpbmRleF0udXBkYXRlQmFja0J1dHRvbihpbmRleCA+IDApO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgcG9wUGFnZVxuICAgICAgICAqIEBzaWduYXR1cmUgcG9wUGFnZShbb3B0aW9uc10pXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAgICAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBcInNsaWRlXCIsIFwic2ltcGxlc2xpZGVcIiwgXCJsaWZ0XCIsIFwiZmFkZVwiIGFuZCBcIm5vbmVcIi5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwic2xpZGVcIiwgXCJzaW1wbGVzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIsIFwibm9uZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVmcmVzaF1cbiAgICAgICAgKiAgIFtlbl1UaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIHJlZnJlc2hlZCAoZGVzdHJveWVkIGFuZCBjcmVhdGVkIGFnYWluKSBiZWZvcmUgcG9wUGFnZSBhY3Rpb24uWy9lbl1cbiAgICAgICAgKiAgIFtqYV1wb3BQYWdl44GZ44KL5YmN44Gr44CB5YmN44Gr44GC44KL44Oa44O844K444KS55Sf5oiQ44GX44Gq44GK44GX44Gm5pu05paw44GZ44KL5aC05ZCI44GrdHJ1ZeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25UcmFuc2l0aW9uRW5kXVxuICAgICAgICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu44Oh44K944OD44OJ44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1Qb3BzIHRoZSBjdXJyZW50IHBhZ2UgZnJvbSB0aGUgcGFnZSBzdGFjay4gVGhlIHByZXZpb3VzIHBhZ2Ugd2lsbCBiZSBkaXNwbGF5ZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgYvjgonlj5bjgorpmaTjgY3jgb7jgZnjgILkuIDjgaTliY3jga7jg5rjg7zjgrjjgavmiLvjgorjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogUG9wcyBjdXJyZW50IHBhZ2UgZnJvbSB0aGUgcGFnZSBzdGFjay5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVmcmVzaF1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vblRyYW5zaXRpb25FbmRdXG4gICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxJZlJ1bm5pbmddXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIG5ldyB0b3AgcGFnZSBvYmplY3QuXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3BvcFBhZ2UnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwb3BQYWdlKCkge1xuICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgIHZhciBsYXN0UGFnZSA9IHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgIGlmIChvcHRpb25zLnJlZnJlc2gpIHtcbiAgICAgICAgICAgdmFyIHBvcFVwZGF0ZTtcbiAgICAgICAgICAgdmFyIHByZUZ1bjtcblxuICAgICAgICAgICB2YXIgX3JldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMzLnBhZ2VzLmxlbmd0aCAtIDI7XG5cbiAgICAgICAgICAgICBpZiAoIV90aGlzMy5wYWdlc1tpbmRleF0ubmFtZSkge1xuICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZyZXNoIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIHBhZ2VzIGRpcmVjdGx5IGluc2lkZSB0aGUgTmF2aWdhdG9yLiBVc2Ugb25zLXRlbXBsYXRlIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgcG9wVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgIF90aGlzMy5wYWdlc1tfdGhpczMucGFnZXMubGVuZ3RoIC0gMV0uX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgIHByZUZ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKF90aGlzMy5wYWdlc1tpbmRleF0ubmFtZSkudGhlbihmdW5jdGlvbiAodGVtcGxhdGVIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpczMuX2NyZWF0ZVBhZ2VFbGVtZW50KHRlbXBsYXRlSFRNTCk7XG5cbiAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm5hbWUgPSBfdGhpczMubmFtZTtcbiAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgcmV3cml0YWJsZXMubGluayhfdGhpczMsIGVsZW1lbnQsIF90aGlzMy5wYWdlc1tpbmRleF0ub3B0aW9ucywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgIF90aGlzMy5pbnNlcnRCZWZvcmUoZWxlbWVudCwgX3RoaXMzLnBhZ2VzW2luZGV4XSA/IF90aGlzMy5wYWdlc1tpbmRleF0gOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgIF90aGlzMy5wYWdlc1tpbmRleCArIDFdLl9kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICB2OiBwcmVGdW4oKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fcG9wUGFnZShvcHRpb25zLCBwb3BVcGRhdGUpO1xuICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICB9O1xuICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBiYWJlbEhlbHBlcnMudHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHZhciBwb3BVcGRhdGUgPSBmdW5jdGlvbiBwb3BVcGRhdGUoKSB7XG4gICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICBsYXN0UGFnZS5fZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICB9O1xuXG4gICAgICAgICAgIHJldHVybiB0aGlzLl9wb3BQYWdlKG9wdGlvbnMsIHBvcFVwZGF0ZSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3BvcFBhZ2UnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9wUGFnZShvcHRpb25zKSB7XG4gICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICAgdmFyIHVwZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgfSA6IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgIHZhciBwYWdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAgICBpZiAoKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogYmFiZWxIZWxwZXJzLnR5cGVvZihvcHRpb25zKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3BvcFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ29ucy1uYXZpZ2F0b3JcXCdzIHBhZ2Ugc3RhY2sgaXMgZW1wdHkuJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zKTtcblxuICAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQob3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LCBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSk7XG5cbiAgICAgICAgIHZhciBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcbiAgICAgICAgIHZhciBsID0gdGhpcy5wYWdlcy5sZW5ndGg7XG5cbiAgICAgICAgIHZhciB0cnlQb3BQYWdlID0gZnVuY3Rpb24gdHJ5UG9wUGFnZSgpIHtcblxuICAgICAgICAgICBfdGhpczQuX2lzUnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgaWYgKF90aGlzNC5fZW1pdFByZVBvcEV2ZW50KCkpIHtcbiAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXBvcCBldmVudC4nKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICBfdGhpczQucGFnZXNbbCAtIDJdLnVwZGF0ZUJhY2tCdXR0b24obCAtIDIgPiAwKTtcblxuICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICB2YXIgbGVhdmVQYWdlID0gX3RoaXM0LnBhZ2VzW2wgLSAxXTtcbiAgICAgICAgICAgICB2YXIgZW50ZXJQYWdlID0gX3RoaXM0LnBhZ2VzW2wgLSAyXTtcbiAgICAgICAgICAgICBlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgIGVudGVyUGFnZS5fc2hvdygpO1xuICAgICAgICAgICAgICAgbGVhdmVQYWdlLl9oaWRlKCk7XG5cbiAgICAgICAgICAgICAgIHZhciBldmVudERldGFpbCA9IHtcbiAgICAgICAgICAgICAgICAgbGVhdmVQYWdlOiBsZWF2ZVBhZ2UsXG4gICAgICAgICAgICAgICAgIGVudGVyUGFnZTogZW50ZXJQYWdlLFxuICAgICAgICAgICAgICAgICBuYXZpZ2F0b3I6IF90aGlzNFxuICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgdXBkYXRlKHBhZ2VzLCBfdGhpczQpLnRoZW4oZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgIF90aGlzNC5faXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KF90aGlzNCwgJ3Bvc3Rwb3AnLCBldmVudERldGFpbCk7XG5cbiAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9uVHJhbnNpdGlvbkVuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25UcmFuc2l0aW9uRW5kKCk7XG4gICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgYW5pbWF0b3IucG9wKF90aGlzNC5wYWdlc1tsIC0gMl0sIF90aGlzNC5wYWdlc1tsIC0gMV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9O1xuXG4gICAgICAgICByZXR1cm4gdHJ5UG9wUGFnZSgpLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgX3RoaXM0Ll9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgIH0pO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaW5zZXJ0UGFnZVxuICAgICAgICAqIEBzaWduYXR1cmUgaW5zZXJ0UGFnZShpbmRleCwgcGFnZVVybCwgW29wdGlvbnNdKVxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAgICAqICAgW2VuXVRoZSBpbmRleCB3aGVyZSBpdCBzaG91bGQgYmUgaW5zZXJ0ZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrnjgr/jg4Pjgq/jgavmjL/lhaXjgZnjgovkvY3nva7jga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlVXJsXG4gICAgICAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYSBIVE1MIGRvY3VtZW50IG9yIGEgPGNvZGU+Jmx0O29ucy10ZW1wbGF0ZSZndDs8L2NvZGU+LlsvZW5dXG4gICAgICAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICAgICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIFwic2xpZGVcIiwgXCJzaW1wbGVzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIgYW5kIFwibm9uZVwiLlsvZW5dXG4gICAgICAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJzbGlkZVwiLCBcInNpbXBsZXNsaWRlXCIsIFwibGlmdFwiLCBcImZhZGVcIiwgXCJub25lXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUluc2VydCB0aGUgc3BlY2lmaWVkIHBhZ2VVcmwgaW50byB0aGUgcGFnZSBzdGFjayB3aXRoIHNwZWNpZmllZCBpbmRleC5bL2VuXVxuICAgICAgICAqICAgW2phXeaMh+WumuOBl+OBn3BhZ2VVcmzjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jga5pbmRleOOBp+aMh+WumuOBl+OBn+S9jee9ruOBq+i/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBJbnNlcnQgcGFnZSBvYmplY3QgdGhhdCBoYXMgdGhlIHNwZWNpZmllZCBwYWdlVXJsIGludG8gdGhlIHBhZ2Ugc3RhY2sgYW5kXG4gICAgICAgICogaWYgb3B0aW9ucyBvYmplY3QgaXMgc3BlY2lmaWVkLCBhcHBseSB0aGUgb3B0aW9ucy5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nL05hdmlnYXRvclRyYW5zaXRpb25BbmltYXRvcn0gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBpbnNlcnRlZCBwYWdlIG9iamVjdFxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdpbnNlcnRQYWdlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0UGFnZShpbmRleCwgcGFnZSkge1xuICAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgIGlmICgodHlwZW9mIHBhZ2UgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBiYWJlbEhlbHBlcnMudHlwZW9mKHBhZ2UpKSA9PT0gJ29iamVjdCcgJiYgcGFnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICBvcHRpb25zID0gcGFnZTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIG9wdGlvbnMucGFnZSA9IHBhZ2U7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChvcHRpb25zICYmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IGJhYmVsSGVscGVycy50eXBlb2Yob3B0aW9ucykpICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaW5kZXggPSB0aGlzLl9ub3JtYWxpemVJbmRleChpbmRleCk7XG5cbiAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLnBhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZS5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgdHJ5SW5zZXJ0UGFnZSA9IGZ1bmN0aW9uIHRyeUluc2VydFBhZ2UoKSB7XG4gICAgICAgICAgIHZhciBydW4gPSBmdW5jdGlvbiBydW4odGVtcGxhdGVIVE1MKSB7XG4gICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpczUuX2NyZWF0ZVBhZ2VFbGVtZW50KHRlbXBsYXRlSFRNTCk7XG4gICAgICAgICAgICAgQ3VzdG9tRWxlbWVudHMudXBncmFkZShlbGVtZW50KTtcblxuICAgICAgICAgICAgIGVsZW1lbnQubmFtZSA9IHBhZ2U7XG4gICAgICAgICAgICAgZWxlbWVudC5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgX3RoaXM1Lmluc2VydEJlZm9yZShlbGVtZW50LCBfdGhpczUucGFnZXNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgIF90aGlzNS5nZXRDdXJyZW50UGFnZSgpLnVwZGF0ZUJhY2tCdXR0b24odHJ1ZSk7XG5cbiAgICAgICAgICAgICAgIHJld3JpdGFibGVzLmxpbmsoX3RoaXM1LCBlbGVtZW50LCBvcHRpb25zLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzNS5wYWdlc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgICB9LCAxMDAwIC8gNjApO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH07XG5cbiAgICAgICAgICAgaWYgKG9wdGlvbnMucGFnZUhUTUwpIHtcbiAgICAgICAgICAgICByZXR1cm4gcnVuKG9wdGlvbnMucGFnZUhUTUwpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4ocnVuKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfTtcblxuICAgICAgICAgcmV0dXJuIHRyeUluc2VydFBhZ2UoKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfbm9ybWFsaXplSW5kZXgnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbm9ybWFsaXplSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgaW5kZXggPSBNYXRoLmFicyh0aGlzLnBhZ2VzLmxlbmd0aCArIGluZGV4KSAlIHRoaXMucGFnZXMubGVuZ3RoO1xuICAgICAgICAgfVxuICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgZ2V0Q3VycmVudFBhZ2VcbiAgICAgICAgKiBAc2lnbmF0dXJlIGdldEN1cnJlbnRQYWdlKClcbiAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICogICBbZW5dQ3VycmVudCBwYWdlIG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeePvuWcqOOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUdldCBjdXJyZW50IHBhZ2UncyBuYXZpZ2F0b3IgaXRlbS4gVXNlIHRoaXMgbWV0aG9kIHRvIGFjY2VzcyBvcHRpb25zIHBhc3NlZCBieSBwdXNoUGFnZSgpIG9yIHJlc2V0VG9QYWdlKCkgbWV0aG9kLlsvZW5dXG4gICAgICAgICogICBbamFd54++5Zyo44Gu44Oa44O844K444KS5Y+W5b6X44GX44G+44GZ44CCcHVzaFBhZ2UoKeOChHJlc2V0VG9QYWdlKCnjg6Hjgr3jg4Pjg4njga7lvJXmlbDjgpLlj5blvpfjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogR2V0IGN1cnJlbnQgcGFnZSdzIG5hdmlnYXRvciBpdGVtLlxuICAgICAgICAqXG4gICAgICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIGFjY2VzcyBvcHRpb25zIHBhc3NlZCBieSBwdXNoUGFnZSgpIG9yIHJlc2V0VG9QYWdlKCkgbWV0aG9kLlxuICAgICAgICAqIGVnLiBvbnMubmF2aWdhdG9yLmdldEN1cnJlbnRQYWdlKCkub3B0aW9uc1xuICAgICAgICAqXG4gICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdnZXRDdXJyZW50UGFnZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRQYWdlKCkge1xuICAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19zaG93JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3coKSB7XG4gICAgICAgICBpZiAodGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgIHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXS5fc2hvdygpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19oaWRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoKSB7XG4gICAgICAgICBpZiAodGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgIHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXS5faGlkZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19kZXN0cm95JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICAgICAvLyB0aGVzZSBhcmUgY2hpbGRyZW4gYW55bW9yZVxuICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgdGhpcy5wYWdlc1tpXS5fZGVzdHJveSgpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkRldmljZUJhY2tCdXR0b24nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgIHRoaXMucG9wUGFnZSgpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgZXZlbnQuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHJlc2V0VG9QYWdlXG4gICAgICAgICogQHNpZ25hdHVyZSByZXNldFRvUGFnZShwYWdlVXJsLCBbb3B0aW9uc10pXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmcvdW5kZWZpbmVkfSBbcGFnZVVybF1cbiAgICAgICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhIEhUTUwgZG9jdW1lbnQgb3IgYW4gPGNvZGU+Jmx0O29ucy10ZW1wbGF0ZSZndDs8L2NvZGU+LiBJZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkIG9yICcnLCB0aGUgbmF2aWdhdG9yIHdpbGwgYmUgcmVzZXQgdG8gdGhlIHBhZ2UgdGhhdCB3YXMgZmlyc3QgZGlzcGxheWVkLlsvZW5dXG4gICAgICAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCdW5kZWZpbmVk44KEJyfjgpLmjIflrprjgZnjgovjgajjgIFvbnMtbmF2aWdhdG9y44GM5pyA5Yid44Gr6KGo56S644GX44Gf44Oa44O844K444KS5oyH5a6a44GX44Gf44GT44Go44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhZ2VdXG4gICAgICAgICogICBbZW5dUGFnZVVSTC4gT25seSBuZWNzc2FyeSBpZiBgcGFnZWAgcGFyYW1ldGVyIGlzIG9taXR0ZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlSFRNTF1cbiAgICAgICAgKiAgIFtlbl1IVE1MIGNvZGUgdGhhdCB3aWxsIGJlIGNvbXB1dGVkIGFzIGEgbmV3IHBhZ2UuIE92ZXJ3cml0ZXMgYHBhZ2VgIHBhcmFtZXRlci5bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICAgICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIFwic2xpZGVcIiwgXCJzaW1wbGVzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIgYW5kIFwibm9uZVwiLlsvZW5dXG4gICAgICAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44Gn44GN44G+44GZ44CCXCJzbGlkZVwiLCBcInNpbXBsZXNsaWRlXCIsIFwibGlmdFwiLCBcImZhZGVcIiwgXCJub25lXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uVHJhbnNpdGlvbkVuZF1cbiAgICAgICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dQ2xlYXJzIHBhZ2Ugc3RhY2sgYW5kIGFkZHMgdGhlIHNwZWNpZmllZCBwYWdlVXJsIHRvIHRoZSBwYWdlIHN0YWNrLlsvZW5dXG4gICAgICAgICogICBbamFd44Oa44O844K444K544K/44OD44Kv44KS44Oq44K744OD44OI44GX44CB5oyH5a6a44GX44Gf44Oa44O844K444KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIENsZWFycyBwYWdlIHN0YWNrIGFuZCBhZGQgdGhlIHNwZWNpZmllZCBwYWdlVXJsIHRvIHRoZSBwYWdlIHN0YWNrLlxuICAgICAgICAqIElmIG9wdGlvbnMgb2JqZWN0IGlzIHNwZWNpZmllZCwgYXBwbHkgdGhlIG9wdGlvbnMuXG4gICAgICAgICogdGhlIG9wdGlvbnMgb2JqZWN0IGluY2x1ZGUgYWxsIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgbmF2aWdhdG9yLlxuICAgICAgICAqXG4gICAgICAgICogSWYgcGFnZSBpcyB1bmRlZmluZWQsIG5hdmlnYXRvciB3aWxsIHB1c2ggaW5pdGlhbCBwYWdlIGNvbnRlbnRzIGluc3RlYWQgb2YuXG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZy91bmRlZmluZWR9IHBhZ2VcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIG5ldyB0b3AgcGFnZSBvYmplY3QuXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3Jlc2V0VG9QYWdlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRUb1BhZ2UocGFnZSkge1xuICAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgIGlmICgodHlwZW9mIHBhZ2UgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBiYWJlbEhlbHBlcnMudHlwZW9mKHBhZ2UpKSA9PT0gJ29iamVjdCcgJiYgcGFnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICBvcHRpb25zID0gcGFnZTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIG9wdGlvbnMucGFnZSA9IHBhZ2U7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChvcHRpb25zICYmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IGJhYmVsSGVscGVycy50eXBlb2Yob3B0aW9ucykpICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdC4gWW91IHN1cHBsaWVkICcgKyBvcHRpb25zKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKCFvcHRpb25zLmFuaW1hdG9yICYmICFvcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9ICdub25lJztcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IG9wdGlvbnMub25UcmFuc2l0aW9uRW5kIHx8IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICBvcHRpb25zLm9uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgd2hpbGUgKF90aGlzNi5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgX3RoaXM2LnBhZ2VzWzBdLl9kZXN0cm95KCk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBfdGhpczYucGFnZXNbMF0udXBkYXRlQmFja0J1dHRvbihmYWxzZSk7XG4gICAgICAgICAgIG9uVHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICAgfTtcblxuICAgICAgICAgaWYgKCFvcHRpb25zLnBhZ2VIVE1MICYmIChvcHRpb25zLnBhZ2UgPT09IHVuZGVmaW5lZCB8fCBwYWdlID09PSAnJykpIHtcbiAgICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdwYWdlJykpIHtcbiAgICAgICAgICAgICBvcHRpb25zLnBhZ2UgPSB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIG9wdGlvbnMucGFnZUhUTUwgPSB0aGlzLl9pbml0aWFsSFRNTDtcbiAgICAgICAgICAgICBvcHRpb25zLnBhZ2UgPSAnJztcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShvcHRpb25zLnBhZ2UsIG9wdGlvbnMpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7fVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgICAgdGhpcy5fZGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIHRoaXMuX2JvdW5kT25EZXZpY2VCYWNrQnV0dG9uKTtcblxuICAgICAgICAgcmV3cml0YWJsZXMucmVhZHkodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICBpZiAoX3RoaXM3LnBhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgIGlmIChfdGhpczcuaGFzQXR0cmlidXRlKCdwYWdlJykpIHtcbiAgICAgICAgICAgICAgIF90aGlzNy5wdXNoUGFnZShfdGhpczcuZ2V0QXR0cmlidXRlKCdwYWdlJyksIHsgYW5pbWF0aW9uOiAnbm9uZScgfSk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXM3LnBhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICBpZiAoX3RoaXM3LnBhZ2VzW2ldLm5vZGVOYW1lICE9PSAnT05TLVBBR0UnKSB7XG4gICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNoaWxkcmVuIG9mIDxvbnMtbmF2aWdhdG9yPiBuZWVkIHRvIGJlIG9mIHR5cGUgPG9ucy1wYWdlPicpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBfdGhpczcuX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbigpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdkZXRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuX2RldmljZUJhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgIHRoaXMuX2RldmljZUJhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHB1c2hQYWdlXG4gICAgICAgICogQHNpZ25hdHVyZSBwdXNoUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtwYWdlXVxuICAgICAgICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGEgSFRNTCBkb2N1bWVudCBvciBhIDxjb2RlPiZsdDtvbnMtdGVtcGxhdGUmZ3Q7PC9jb2RlPi5bL2VuXVxuICAgICAgICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlXVxuICAgICAgICAqICAgW2VuXVBhZ2VVUkwuIE9ubHkgbmVjc3NhcnkgaWYgYHBhZ2VgIHBhcmFtZXRlciBpcyBvbWl0dGVkLlsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFnZUhUTUxdXG4gICAgICAgICogICBbZW5dSFRNTCBjb2RlIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBhcyBhIG5ldyBwYWdlLiBPdmVyd3JpdGVzIGBwYWdlYCBwYXJhbWV0ZXIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAgICAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBcInNsaWRlXCIsIFwic2ltcGxlc2xpZGVcIiwgXCJsaWZ0XCIsIFwiZmFkZVwiIGFuZCBcIm5vbmVcIi5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwic2xpZGVcIiwgXCJzaW1wbGVzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIsIFwibm9uZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uVHJhbnNpdGlvbkVuZF1cbiAgICAgICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgICAgICAqICAgW2phXXB1c2hQYWdlKCnjgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVB1c2hlcyB0aGUgc3BlY2lmaWVkIHBhZ2VVcmwgaW50byB0aGUgcGFnZSBzdGFjay5bL2VuXVxuICAgICAgICAqICAgW2phXeaMh+WumuOBl+OBn3BhZ2VVcmzjgpLmlrDjgZfjgYTjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgavov73liqDjgZfjgb7jgZnjgILmlrDjgZfjgYTjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogUHVzaGVzIHRoZSBzcGVjaWZpZWQgcGFnZVVybCBpbnRvIHRoZSBwYWdlIHN0YWNrIGFuZFxuICAgICAgICAqIGlmIG9wdGlvbnMgb2JqZWN0IGlzIHNwZWNpZmllZCwgYXBwbHkgdGhlIG9wdGlvbnMuXG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZy9OYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3J9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vblRyYW5zaXRpb25FbmRdXG4gICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxJZlJ1bm5pbmddXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhZ2VIVE1MXVxuICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBuZXcgdG9wIHBhZ2Ugb2JqZWN0LlxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdwdXNoUGFnZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2hQYWdlKHBhZ2UpIHtcbiAgICAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICBpZiAoKHR5cGVvZiBwYWdlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogYmFiZWxIZWxwZXJzLnR5cGVvZihwYWdlKSkgPT09ICdvYmplY3QnICYmIHBhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgb3B0aW9ucyA9IHBhZ2U7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBvcHRpb25zLnBhZ2UgPSBwYWdlO1xuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgcnVuID0gZnVuY3Rpb24gcnVuKHRlbXBsYXRlSFRNTCkge1xuICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IF90aGlzOC5fY3JlYXRlUGFnZUVsZW1lbnQodGVtcGxhdGVIVE1MKTtcbiAgICAgICAgICAgICBDdXN0b21FbGVtZW50cy51cGdyYWRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgIF90aGlzOC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgfTtcblxuICAgICAgICAgdmFyIHVwZGF0ZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgaWYgKG9wdGlvbnMucGFnZUhUTUwpIHtcbiAgICAgICAgICAgdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIHJldHVybiBydW4ob3B0aW9ucy5wYWdlSFRNTCk7XG4gICAgICAgICAgIH07XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgcmV0dXJuIGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihydW4pO1xuICAgICAgICAgICB9O1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucywgdXBkYXRlKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfcHVzaFBhZ2UnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHVzaFBhZ2UoKSB7XG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgICAgICAgdmFyIHVwZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgfSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgICAgIHZhciBwYWdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJndW1lbnRzWzJdO1xuICAgICAgICAgdmFyIHBhZ2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1szXTtcblxuICAgICAgICAgaWYgKCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IGJhYmVsSGVscGVycy50eXBlb2Yob3B0aW9ucykpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwdXNoUGFnZSBpcyBhbHJlYWR5IHJ1bm5pbmcuJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICh0aGlzLl9lbWl0UHJlUHVzaEV2ZW50KCkpIHtcbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwdXNoIGV2ZW50LicpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgdHJ5UHVzaFBhZ2UgPSBmdW5jdGlvbiB0cnlQdXNoUGFnZSgpIHtcbiAgICAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBfdGhpczkub3B0aW9ucyB8fCB7fSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQob3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LCBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKF90aGlzOS5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpKTtcblxuICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBfdGhpczkuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgICAgICBwYWdlcy5wdXNoKHBhZ2UpO1xuXG4gICAgICAgICAgIHJldHVybiB1cGRhdGUocGFnZXMsIF90aGlzOSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIHBhZ2VMZW5ndGggPSBfdGhpczkucGFnZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgdmFyIGVudGVyUGFnZSA9IF90aGlzOS5wYWdlc1tfdGhpczkucGFnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgdmFyIGxlYXZlUGFnZSA9IF90aGlzOS5wYWdlc1tfdGhpczkucGFnZXMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgZW50ZXJQYWdlLnVwZGF0ZUJhY2tCdXR0b24oX3RoaXM5LnBhZ2VzLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgICAgICAgX3RoaXM5LnBhZ2VzW3BhZ2VMZW5ndGggLSAxXS5uYW1lID0gb3B0aW9ucy5wYWdlO1xuICAgICAgICAgICAgIF90aGlzOS5wYWdlc1twYWdlTGVuZ3RoIC0gMV0ub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgICAgICAgX3RoaXM5Ll9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgbGVhdmVQYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgdmFyIGV2ZW50RGV0YWlsID0ge1xuICAgICAgICAgICAgICAgICAgIGxlYXZlUGFnZTogbGVhdmVQYWdlLFxuICAgICAgICAgICAgICAgICAgIGVudGVyUGFnZTogZW50ZXJQYWdlLFxuICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvcjogX3RoaXM5XG4gICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KF90aGlzOSwgJ3Bvc3RwdXNoJywgZXZlbnREZXRhaWwpO1xuXG4gICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vblRyYW5zaXRpb25FbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uVHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRlclBhZ2UpO1xuICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICByZXdyaXRhYmxlcy5saW5rKF90aGlzOSwgZW50ZXJQYWdlLCBvcHRpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgIGVudGVyUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICAgaWYgKHBhZ2VMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgbGVhdmVQYWdlLl9oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgZW50ZXJQYWdlLl9zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgYW5pbWF0b3IucHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZG9uZSk7XG4gICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgZW50ZXJQYWdlLl9zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9O1xuXG4gICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAgICByZXR1cm4gdHJ5UHVzaFBhZ2UoKS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIF90aGlzOS5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAqIEBtZXRob2QgYnJpbmdQYWdlVG9wXG4gICAgICAgKiBAc2lnbmF0dXJlIGJyaW5nUGFnZVRvcChpdGVtLCBbb3B0aW9uc10pXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGl0ZW1cbiAgICAgICAqICAgW2VuXVBhZ2UgVVJMIG9yIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UgaW4gbmF2aWdhdG9yJ3Mgc3RhY2suWy9lbl1cbiAgICAgICAqICAgW2phXeODmuODvOOCuOOBrlVSTOOBi+OCguOBl+OBj+OBr29ucy1uYXZpZ2F0b3Ljga7jg5rjg7zjgrjjgrnjgr/jg4Pjgq/jga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgICAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAgICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIFwic2xpZGVcIiwgXCJzaW1wbGVzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIgYW5kIFwibm9uZVwiLlsvZW5dXG4gICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcInNsaWRlXCIsIFwic2ltcGxlc2xpZGVcIiwgXCJsaWZ0XCIsIFwiZmFkZVwiLCBcIm5vbmVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICAgICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuICA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvZW5dXG4gICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uVHJhbnNpdGlvbkVuZF1cbiAgICAgICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAgICAgKiAgIFtqYV1wdXNoUGFnZSgp44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogICBbZW5dQnJpbmdzIHRoZSBnaXZlbiBwYWdlIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2Utc3RhY2sgaWYgYWxyZWFkeSBleGlzdHMgb3IgcHVzaGVzIGl0IGludG8gdGhlIHN0YWNrIGlmIGRvZXNuJ3QuWy9lbl1cbiAgICAgICAqICAgW2phXeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBruS4gOeVquS4iuOBq+enu+WLleOBl+OBvuOBmeOAguOCguOBl+aMh+WumuOBl+OBn+ODmuODvOOCuOOBjOeEoeOBi+OBo+OBn+WgtOWQiOaWsOOBl+OBj3B1c2jjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBCcmluZ3MgdGhlIGdpdmVuIHBhZ2VVcmwgb3IgaW5kZXggdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSBzdGFja1xuICAgICAgICAqIGlmIGFscmVhZHkgZXhpc3RzIG9yIHB1c2hlcyB0aGUgcGFnZSBpbnRvIHRoZSBzdGFjayBpZiBkb2Vzbid0LlxuICAgICAgICAqIElmIG9wdGlvbnMgb2JqZWN0IGlzIHNwZWNpZmllZCwgYXBwbHkgdGhlIG9wdGlvbnMuXG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGl0ZW0gUGFnZSBuYW1lIG9yIHZhbGlkIGluZGV4LlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIG5ldyB0b3AgcGFnZSBvYmplY3QuXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2JyaW5nUGFnZVRvcCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJyaW5nUGFnZVRvcChpdGVtKSB7XG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICBpZiAob3B0aW9ucyAmJiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBiYWJlbEhlbHBlcnMudHlwZW9mKG9wdGlvbnMpKSAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zKTtcblxuICAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgncHVzaFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAodGhpcy5fZW1pdFByZVB1c2hFdmVudCgpKSB7XG4gICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlcHVzaCBldmVudC4nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIGluZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICBvcHRpb25zLnBhZ2UgPSBpdGVtO1xuICAgICAgICAgICBpbmRleCA9IHRoaXMuX2xhc3RJbmRleE9mUGFnZShvcHRpb25zLnBhZ2UpO1xuICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgaW5kZXggPSB0aGlzLl9ub3JtYWxpemVJbmRleChpdGVtKTtcbiAgICAgICAgICAgaWYgKGl0ZW0gPj0gdGhpcy5wYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBpbmRleCBkb2VzIG5vdCBtYXRjaCBhbiBleGlzdGluZyBwYWdlLicpO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIG9wdGlvbnMucGFnZSA9IHRoaXMucGFnZXNbaW5kZXhdLm5hbWU7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwYWdlIG5hbWUgb3IgdGhlIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UuIFlvdSBzdXBwbGllZCAnICsgaXRlbSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgLy8gRmFsbGJhY2sgcHVzaFBhZ2VcbiAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFBhZ2Uob3B0aW9ucy5wYWdlLCBvcHRpb25zKTtcbiAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IHRoaXMucGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAvLyBQYWdlIGlzIGFscmVhZHkgdGhlIHRvcFxuICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucGFnZXNbaW5kZXhdKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIC8vIEJyaW5nIHRvIHRvcFxuICAgICAgICAgICB2YXIgc2VsZWN0ZWRQYWdlID0gdGhpcy5wYWdlc1tpbmRleF07XG4gICAgICAgICAgIHNlbGVjdGVkUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgc2VsZWN0ZWRQYWdlLnNldEF0dHJpYnV0ZSgnX3NraXBpbml0JywgJycpO1xuXG4gICAgICAgICAgIC8vIG1vdmUgZWxlbWVudCB0byB0aGUgbGFzdCBjaGlsZFxuICAgICAgICAgICBzZWxlY3RlZFBhZ2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChzZWxlY3RlZFBhZ2UpO1xuICAgICAgICAgICBzZWxlY3RlZFBhZ2Uub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgIHJldHVybiB0aGlzLl9wdXNoUGFnZShvcHRpb25zKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgbGFzdCBpbmRleCBhdCB3aGljaCB0aGUgZ2l2ZW4gcGFnZVxuICAgICAgICAqIGlzIGZvdW5kIGluIHRoZSBwYWdlLXN0YWNrLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2xhc3RJbmRleE9mUGFnZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sYXN0SW5kZXhPZlBhZ2UocGFnZU5hbWUpIHtcbiAgICAgICAgIHZhciBpbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgIGZvciAoaW5kZXggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgICAgICAgaWYgKHRoaXMucGFnZXNbaW5kZXhdLm5hbWUgPT09IHBhZ2VOYW1lKSB7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGlmIGV2ZW50IGlzIGNhbmNlbGVkLlxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZW1pdFByZVB1c2hFdmVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0UHJlUHVzaEV2ZW50KCkge1xuICAgICAgICAgdmFyIGlzQ2FuY2VsZWQgPSBmYWxzZTtcblxuICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVwdXNoJywge1xuICAgICAgICAgICBuYXZpZ2F0b3I6IHRoaXMsXG4gICAgICAgICAgIGN1cnJlbnRQYWdlOiB0aGlzLnBhZ2VzLmxlbmd0aCA+IDAgPyB0aGlzLmdldEN1cnJlbnRQYWdlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICAgICAgIGlzQ2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICB9XG4gICAgICAgICB9KTtcblxuICAgICAgICAgcmV0dXJuIGlzQ2FuY2VsZWQ7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBpZiBldmVudCBpcyBjYW5jZWxlZC5cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2VtaXRQcmVQb3BFdmVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0UHJlUG9wRXZlbnQoKSB7XG4gICAgICAgICB2YXIgaXNDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgICAgICB2YXIgbGVhdmVQYWdlID0gdGhpcy5nZXRDdXJyZW50UGFnZSgpO1xuICAgICAgICAgdmFyIGVudGVyUGFnZSA9IHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAyXTtcblxuICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVwb3AnLCB7XG4gICAgICAgICAgIG5hdmlnYXRvcjogdGhpcyxcbiAgICAgICAgICAgY3VycmVudFBhZ2U6IGxlYXZlUGFnZSxcbiAgICAgICAgICAgbGVhdmVQYWdlOiBsZWF2ZVBhZ2UsXG4gICAgICAgICAgIGVudGVyUGFnZTogZW50ZXJQYWdlLFxuICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICBpc0NhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIHJldHVybiBpc0NhbmNlbGVkO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2NyZWF0ZVBhZ2VPYmplY3QnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlUGFnZU9iamVjdChwYWdlLCBlbGVtZW50LCBvcHRpb25zKSB7XG5cbiAgICAgICAgIG9wdGlvbnMuYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgIHJldHVybiBuZXcgTmF2aWdhdG9yUGFnZSh7XG4gICAgICAgICAgIHBhZ2U6IHBhZ2UsXG4gICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgIG5hdmlnYXRvcjogdGhpc1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2NyZWF0ZVBhZ2VFbGVtZW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVBhZ2VFbGVtZW50KHRlbXBsYXRlSFRNTCkge1xuICAgICAgICAgdmFyIHBhZ2VFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKHRlbXBsYXRlSFRNTCkpO1xuXG4gICAgICAgICBpZiAocGFnZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1wYWdlJykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhbiBcIm9ucy1wYWdlXCIgZWxlbWVudCB0byBcIm9ucy1uYXZpZ2F0b3JcIi4nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHBhZ2VFbGVtZW50O1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ29wdGlvbnMnLFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgICAgfSxcbiAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChvYmplY3QpIHtcbiAgICAgICAgIHRoaXMuX29wdGlvbnMgPSBvYmplY3Q7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2lzUnVubmluZycsXG4gICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2lzLXJ1bm5pbmcnLCAndHJ1ZScpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19pcy1ydW5uaW5nJywgJ2ZhbHNlJyk7XG4gICAgICAgICB9XG4gICAgICAgfSxcbiAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKCdfaXMtcnVubmluZycpKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdwYWdlcycsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIE5hdmlnYXRvckVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNOYXZpZ2F0b3JFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtbmF2aWdhdG9yJywge1xuICAgICBwcm90b3R5cGU6IE5hdmlnYXRvckVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQW5pbWF0b3JcbiAgICAqL1xuICAgd2luZG93Lk9uc05hdmlnYXRvckVsZW1lbnQucmVnaXN0ZXJBbmltYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBBbmltYXRvcikge1xuICAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IpKSB7XG4gICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc05hdmlnYXRvckVsZW1lbnQuTmF2aWdhdG9yVHJhbnNpdGlvbkFuaW1hdG9yJyk7XG4gICAgIH1cblxuICAgICBfYW5pbWF0b3JEaWN0JDNbbmFtZV0gPSBBbmltYXRvcjtcbiAgIH07XG5cbiAgIHdpbmRvdy5PbnNOYXZpZ2F0b3JFbGVtZW50LnJld3JpdGFibGVzID0gcmV3cml0YWJsZXM7XG4gICB3aW5kb3cuT25zTmF2aWdhdG9yRWxlbWVudC5OYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3IgPSBOYXZpZ2F0b3JUcmFuc2l0aW9uQW5pbWF0b3I7XG5cbiAgIHZhciBzY2hlbWUkMTMgPSB7XG4gICAgICcnOiAncGFnZS0tKicsXG4gICAgICcucGFnZV9fY29udGVudCc6ICdwYWdlLS0qX19jb250ZW50JyxcbiAgICAgJy5wYWdlX19iYWNrZ3JvdW5kJzogJ3BhZ2UtLSpfX2JhY2tncm91bmQnXG4gICB9O1xuXG4gICB2YXIgbnVsbFRvb2xiYXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXRvb2xiYXInKTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtcGFnZVxuICAgICogQGNhdGVnb3J5IHBhZ2VcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dU2hvdWxkIGJlIHVzZWQgYXMgcm9vdCBjb21wb25lbnQgb2YgZWFjaCBwYWdlLiBUaGUgY29udGVudCBpbnNpZGUgcGFnZSBjb21wb25lbnQgaXMgc2Nyb2xsYWJsZS5bL2VuXVxuICAgICogICBbamFd44Oa44O844K45a6a576p44Gu44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu5YaF5a6544Gv44K544Kv44Ot44O844Or44GM6Kix5Y+v44GV44KM44G+44GZ44CCWy9qYV1cbiAgICAqIEBndWlkZSBNYW5hZ2luZ011bHRpcGxlUGFnZXNcbiAgICAqICAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzWy9lbl1cbiAgICAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXG4gICAgKiBAZ3VpZGUgUGFnZWxpZmVjeWNsZVxuICAgICogICBbZW5dUGFnZSBsaWZlIGN5Y2xlIGV2ZW50c1svZW5dXG4gICAgKiAgIFtqYV3jg5rjg7zjgrjjg6njgqTjg5XjgrXjgqTjgq/jg6vjgqTjg5njg7Pjg4hbL2phXVxuICAgICogQGd1aWRlIEhhbmRsaW5nQmFja0J1dHRvblxuICAgICogICBbZW5dSGFuZGxpbmcgYmFjayBidXR0b25bL2VuXVxuICAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44Gr5a++5b+c44GZ44KLWy9qYV1cbiAgICAqIEBndWlkZSBPdmVycmlkaW5nQ1NTc3R5bGVzXG4gICAgKiAgIFtlbl1PdmVycmlkaW5nIENTUyBzdHlsZXNbL2VuXVxuICAgICogICBbamFdQ1NT44K544K/44Kk44Or44Gu44Kq44O844OQ44O844Op44Kk44OJWy9qYV1cbiAgICAqIEBndWlkZSBEZWZpbmluZ011bHRpcGxlUGFnZXNpblNpbmdsZUhUTUxcbiAgICAqICAgW2VuXURlZmluaW5nIG11bHRpcGxlIHBhZ2VzIGluIHNpbmdsZSBodG1sWy9lbl1cbiAgICAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkjHjgaTjga5IVE1M44Gr6KiY6L+w44GZ44KLWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8b25zLXBhZ2U+XG4gICAgKiAgIDxvbnMtdG9vbGJhcj5cbiAgICAqICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+VGl0bGU8L2Rpdj5cbiAgICAqICAgPC9vbnMtdG9vbGJhcj5cbiAgICAqXG4gICAgKiAgIC4uLlxuICAgICogPC9vbnMtcGFnZT5cbiAgICAqXG4gICAgKlxuICAgICogLy8gSW5maW5pdGUgU2Nyb2xsIGhhbmRsZXJcbiAgICAqIHBhZ2Uub25JbmZpbml0ZVNjcm9sbCA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAqICAgLy8gbG9hZCBtb3JlIGNvbnRlbnQgYW5kIGNhbGwgZG9uZVxuICAgICogfTtcbiAgICAqL1xuXG4gICB2YXIgUGFnZUVsZW1lbnQgPSAoZnVuY3Rpb24gKF9CYXNlRWxlbWVudCkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoUGFnZUVsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gUGFnZUVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFBhZ2VFbGVtZW50KTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBhZ2VFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhQYWdlRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQGV2ZW50IGluaXRcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBhdHRhY2hlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeODmuODvOOCuOOBjOOCouOCv+ODg+ODgeOBleOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucGFnZVxuICAgICAgICAqICAgW2VuXVBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Oa44O844K444Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBzaG93XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgc2hvd24uWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBhZ2VcbiAgICAgICAgKiAgIFtlbl1QYWdlIG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAZXZlbnQgaGlkZVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIGhpZGRlbi5bL2VuXVxuICAgICAgICAqICAgW2phXeODmuODvOOCuOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucGFnZVxuICAgICAgICAqICAgW2VuXVBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Oa44O844K444Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBkZXN0cm95XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQgcmlnaHQgYmVmb3JlIHRoZSBwYWdlIGlzIGRlc3Ryb3llZC5bL2VuXVxuICAgICAgICAqICAgW2phXeODmuODvOOCuOOBjOegtOajhOOBleOCjOOCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucGFnZVxuICAgICAgICAqICAgW2VuXVBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Oa44O844K444Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNwZWNpZnkgbW9kaWZpZXIgbmFtZSB0byBzcGVjaWZ5IGN1c3RvbSBzdHlsZXMuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrnjgr/jgqTjg6vlrprnvqnjgpLjgqvjgrnjgr/jg57jgqTjgrrjgZnjgovjgZ/jgoHjga7lkI3liY3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBvblstXWluZmluaXRlWy1dc2Nyb2xsXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1QYXRoIG9mIHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiBpbmZpbml0ZSBzY3JvbGxpbmcuIEV4YW1wbGU6IGFwcC5sb2FkRGF0YVsvZW5dXG4gICAgICAgICogICBbamFd5qmf6IO944K544Kv44Ot44O844Or5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL6Zai5pWw44Gu44OR44K544CC5L6L77yaYXBwLmxvYWREYXRhWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwcm9wZXJ0eSBvbkluZmluaXRlU2Nyb2xsXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1GdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiBpbmZpbml0ZSBzY3JvbGwuIFsvZW5dXG4gICAgICAgICogIFtqYV3mqZ/og73jgrnjgq/jg63jg7zjg6vkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovplqLmlbDjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncGFnZScpO1xuXG4gICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50ID0gdGhpcy5fZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAgICAgIHRoaXMuX2lzTXV0ZWQgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnX211dGVkJyk7XG4gICAgICAgICB0aGlzLl9za2lwSW5pdCA9IHRoaXMuaGFzQXR0cmlidXRlKCdfc2tpcGluaXQnKTtcbiAgICAgICAgIHRoaXMuZXZlbnREZXRhaWwgPSB7XG4gICAgICAgICAgIHBhZ2U6IHRoaXNcbiAgICAgICAgIH07XG4gICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICBpZiAoIXRoaXMuX2lzTXV0ZWQpIHtcbiAgICAgICAgICAgaWYgKHRoaXMuX3NraXBJbml0KSB7XG4gICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ19za2lwaW5pdCcpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnaW5pdCcsIHRoaXMuZXZlbnREZXRhaWwpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICghdXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCh0aGlzKSkge1xuICAgICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIHJldHVybiBfdGhpczIuX3Nob3coKTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX3RyeVRvRmlsbFN0YXR1c0JhcigpO1xuXG4gICAgICAgICB2YXIgaW5maW5pdGVTY3JvbGwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnb24taW5maW5pdGUtc2Nyb2xsJykgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ29uaW5maW5pdGVzY3JvbGwnKTtcbiAgICAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdvbmluZmluaXRlc2Nyb2xsJywgbnVsbCwgaW5maW5pdGVTY3JvbGwpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3VwZGF0ZUJhY2tCdXR0b24nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCYWNrQnV0dG9uKHNob3VsZFNob3dCdXR0b24pIHtcbiAgICAgICAgIGlmICh0aGlzLmJhY2tCdXR0b24pIHtcbiAgICAgICAgICAgaWYgKHNob3VsZFNob3dCdXR0b24pIHtcbiAgICAgICAgICAgICB0aGlzLmJhY2tCdXR0b24uc2hvdygpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIHRoaXMuYmFja0J1dHRvbi5oaWRlKCk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25TY3JvbGwnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25TY3JvbGwoKSB7XG4gICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgdmFyIGMgPSB0aGlzLl9jb250ZW50RWxlbWVudCxcbiAgICAgICAgICAgICBvdmVyTGltaXQgPSAoYy5zY3JvbGxUb3AgKyBjLmNsaWVudEhlaWdodCkgLyBjLnNjcm9sbEhlaWdodCA+PSB0aGlzLl9pbmZpbml0ZVNjcm9sbExpbWl0O1xuXG4gICAgICAgICBpZiAodGhpcy5fb25JbmZpbml0ZVNjcm9sbCAmJiAhdGhpcy5fbG9hZGluZ0NvbnRlbnQgJiYgb3ZlckxpbWl0KSB7XG4gICAgICAgICAgIHRoaXMuX2xvYWRpbmdDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fbG9hZGluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBnZXREZXZpY2VCYWNrQnV0dG9uSGFuZGxlclxuICAgICAgICAqIEBzaWduYXR1cmUgZ2V0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIoKVxuICAgICAgICAqIEByZXR1cm4ge09iamVjdC9udWxsfVxuICAgICAgICAqICAgW2VuXURldmljZSBiYWNrIGJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAgICAgICogICBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1HZXQgdGhlIGFzc29jaWF0ZWQgYmFjayBidXR0b24gaGFuZGxlci4gVGhpcyBtZXRob2QgbWF5IHJldHVybiBudWxsIGlmIG5vIGhhbmRsZXIgaXMgYXNzaWduZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgpLlj5blvpfjgZfjgb7jgZnjgILjgZPjga7jg6Hjgr3jg4Pjg4njga9udWxs44KS6L+U44GZ5aC05ZCI44GM44GC44KK44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZ2V0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXInLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlciB8fCBudWxsO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldERldmljZUJhY2tCdXR0b25IYW5kbGVyJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIoY2FsbGJhY2spIHtcbiAgICAgICAgIGlmICh0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgICAgICB0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2RldmljZUJhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19nZXRDb250ZW50RWxlbWVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb250ZW50RWxlbWVudCgpIHtcbiAgICAgICAgIHZhciByZXN1bHQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2NvbnRlbnQnKTtcbiAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgIH1cbiAgICAgICAgIHRocm93IEVycm9yKCdmYWlsIHRvIGdldCBcIi5wYWdlX19jb250ZW50XCIgZWxlbWVudC4nKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY2FuQW5pbWF0ZVRvb2xiYXInLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FuQW5pbWF0ZVRvb2xiYXIoKSB7XG4gICAgICAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJykpIHtcbiAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gISF1dGlsLmZpbmRDaGlsZCh0aGlzLl9jb250ZW50RWxlbWVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgcmV0dXJuIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10b29sYmFyJyAmJiAhZS5oYXNBdHRyaWJ1dGUoJ2lubGluZScpO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19nZXRCYWNrZ3JvdW5kRWxlbWVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpIHtcbiAgICAgICAgIHZhciByZXN1bHQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2JhY2tncm91bmQnKTtcbiAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgIH1cbiAgICAgICAgIHRocm93IEVycm9yKCdmYWlsIHRvIGdldCBcIi5wYWdlX19iYWNrZ3JvdW5kXCIgZWxlbWVudC4nKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50KCkge1xuICAgICAgICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtYm90dG9tLXRvb2xiYXInKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2dldFRvb2xiYXJFbGVtZW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRvb2xiYXJFbGVtZW50KCkge1xuICAgICAgICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtdG9vbGJhcicpIHx8IG51bGxUb29sYmFyRWxlbWVudDtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBSZWdpc3RlciB0b29sYmFyIGVsZW1lbnQgdG8gdGhpcyBwYWdlLlxuICAgICAgICAqXG4gICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfcmVnaXN0ZXJUb29sYmFyJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVyVG9vbGJhcihlbGVtZW50KSB7XG4gICAgICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25vLXN0YXR1cy1iYXItZmlsbCcsICcnKTtcblxuICAgICAgICAgaWYgKHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fc3RhdHVzLWJhci1maWxsJykpIHtcbiAgICAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoZWxlbWVudCwgdGhpcy5jaGlsZHJlblsxXSk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShlbGVtZW50LCB0aGlzLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBSZWdpc3RlciB0b29sYmFyIGVsZW1lbnQgdG8gdGhpcyBwYWdlLlxuICAgICAgICAqXG4gICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfcmVnaXN0ZXJCb3R0b21Ub29sYmFyJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVyQm90dG9tVG9vbGJhcihlbGVtZW50KSB7XG4gICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3BhZ2Utd2l0aC1ib3R0b20tdG9vbGJhcicpO1xuICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lJDEzKTtcbiAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ19tdXRlZCcpIHtcbiAgICAgICAgICAgdGhpcy5faXNNdXRlZCA9IHRoaXMuaGFzQXR0cmlidXRlKCdfbXV0ZWQnKTtcbiAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ19za2lwaW5pdCcpIHtcbiAgICAgICAgICAgdGhpcy5fc2tpcEluaXQgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnX3NraXBpbml0Jyk7XG4gICAgICAgICB9IGVsc2UgaWYgKG5hbWUubWF0Y2goL29uLT9pbmZpbml0ZS0/c2Nyb2xsL2kpKSB7XG4gICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgdGhpcy5vbkluZmluaXRlU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgICAgdmFyIGYgPSB1dGlsLmZpbmRGcm9tUGF0aChjdXJyZW50KTtcbiAgICAgICAgICAgICAgIF90aGlzNC5vbkluZmluaXRlU2Nyb2xsID0gZjtcbiAgICAgICAgICAgICAgIGYoZG9uZSk7XG4gICAgICAgICAgICAgfTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jb21waWxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBpbGUoKSB7XG4gICAgICAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgICAgICAgdmFyIGJhY2tncm91bmQgPSB1dGlsLmNyZWF0ZSgnLnBhZ2VfX2JhY2tncm91bmQnKTtcbiAgICAgICAgIHZhciBjb250ZW50ID0gdXRpbC5jcmVhdGUoJy5wYWdlX19jb250ZW50Jyk7XG5cbiAgICAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGJhY2tncm91bmQpO1xuICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgICAgICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUkMTMpO1xuXG4gICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19yZWdpc3RlckV4dHJhRWxlbWVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3RlckV4dHJhRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICB2YXIgZXh0cmEgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2V4dHJhJyk7XG4gICAgICAgICBpZiAoIWV4dHJhKSB7XG4gICAgICAgICAgIGV4dHJhID0gdXRpbC5jcmVhdGUoJy5wYWdlX19leHRyYScsIHsgekluZGV4OiAxMDAwMSB9KTtcbiAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChleHRyYSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGV4dHJhLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ190cnlUb0ZpbGxTdGF0dXNCYXInLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJ5VG9GaWxsU3RhdHVzQmFyKCkge1xuICAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgIHJldHVybiBpbnRlcm5hbC5zaG91bGRGaWxsU3RhdHVzQmFyKHRoaXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICB2YXIgZmlsbCA9IF90aGlzNS5xdWVyeVNlbGVjdG9yKCcucGFnZV9fc3RhdHVzLWJhci1maWxsJyk7XG5cbiAgICAgICAgICAgaWYgKCFmaWxsKSB7XG4gICAgICAgICAgICAgZmlsbCA9IHV0aWwuY3JlYXRlKCcucGFnZV9fc3RhdHVzLWJhci1maWxsJyk7XG5cbiAgICAgICAgICAgICBfdGhpczUuaW5zZXJ0QmVmb3JlKGZpbGwsIF90aGlzNS5jaGlsZHJlblswXSk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICByZXR1cm4gZmlsbDtcbiAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgdmFyIGVsID0gX3RoaXM1LnF1ZXJ5U2VsZWN0b3IoJy5wYWdlX19zdGF0dXMtYmFyLWZpbGwnKTtcbiAgICAgICAgICAgZWwgJiYgZWwucmVtb3ZlKCk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfc2hvdycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93KCkge1xuICAgICAgICAgaWYgKCF0aGlzLmlzU2hvd24gJiYgdXRpbC5pc0F0dGFjaGVkKHRoaXMpKSB7XG4gICAgICAgICAgIHRoaXMuaXNTaG93biA9IHRydWU7XG5cbiAgICAgICAgICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XG4gICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdzaG93JywgdGhpcy5ldmVudERldGFpbCk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLl9jb250ZW50RWxlbWVudCwgJ19zaG93Jyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2hpZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZSgpIHtcbiAgICAgICAgIGlmICh0aGlzLmlzU2hvd24pIHtcbiAgICAgICAgICAgdGhpcy5pc1Nob3duID0gZmFsc2U7XG5cbiAgICAgICAgICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XG4gICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdoaWRlJywgdGhpcy5ldmVudERldGFpbCk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLl9jb250ZW50RWxlbWVudCwgJ19oaWRlJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2Rlc3Ryb3knLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgICAgIHRoaXMuX2hpZGUoKTtcblxuICAgICAgICAgaWYgKCF0aGlzLl9pc011dGVkKSB7XG4gICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGVzdHJveScsIHRoaXMuZXZlbnREZXRhaWwpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAodGhpcy5nZXREZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpKSB7XG4gICAgICAgICAgIHRoaXMuZ2V0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIoKS5kZXN0cm95KCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMuX2NvbnRlbnRFbGVtZW50LCAnX2Rlc3Ryb3knKTtcblxuICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICduYW1lJyxcbiAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdHIpIHtcbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJywgc3RyKTtcbiAgICAgICB9LFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYmFja0J1dHRvbicsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGRSZWN1cnNpdmVseSh0aGlzLCAnb25zLWJhY2stYnV0dG9uJyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNTaG93bicsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5faXNTaG93bjtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59XG4gICAgICAgICovXG4gICAgICAgLFxuICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICB0aGlzLl9pc1Nob3duID0gdmFsdWU7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnb25JbmZpbml0ZVNjcm9sbCcsXG4gICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICB0aGlzLl9vbkluZmluaXRlU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCk7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb25JbmZpbml0ZVNjcm9sbCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgbnVsbCcpO1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKCF0aGlzLl9vbkluZmluaXRlU2Nyb2xsKSB7XG4gICAgICAgICAgIHRoaXMuX2luZmluaXRlU2Nyb2xsTGltaXQgPSAwLjk7XG4gICAgICAgICAgIHRoaXMuX2JvdW5kT25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsKTtcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMuX29uSW5maW5pdGVTY3JvbGwgPSB2YWx1ZTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFBhZ2VFbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zUGFnZUVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1wYWdlJywge1xuICAgICBwcm90b3R5cGU6IFBhZ2VFbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIHZhciBQb3BvdmVyQW5pbWF0b3IgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICAgICovXG5cbiAgICAgZnVuY3Rpb24gUG9wb3ZlckFuaW1hdG9yKCkge1xuICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcG92ZXJBbmltYXRvcik7XG5cbiAgICAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLFxuICAgICAgICAgZHVyYXRpb246IDAuMixcbiAgICAgICAgIGRlbGF5OiAwXG4gICAgICAgfSwgb3B0aW9ucyk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoUG9wb3ZlckFuaW1hdG9yLCBbe1xuICAgICAgIGtleTogJ3Nob3cnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2hpZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19hbmltYXRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2FuaW1hdGUoZWxlbWVudCwgX3JlZikge1xuICAgICAgICAgdmFyIGZyb20gPSBfcmVmLmZyb207XG4gICAgICAgICB2YXIgdG8gPSBfcmVmLnRvO1xuICAgICAgICAgdmFyIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gICAgICAgICB2YXIgY2FsbGJhY2sgPSBfcmVmLmNhbGxiYWNrO1xuICAgICAgICAgdmFyIF9yZWYkcmVzdG9yZSA9IF9yZWYucmVzdG9yZTtcbiAgICAgICAgIHZhciByZXN0b3JlID0gX3JlZiRyZXN0b3JlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkcmVzdG9yZTtcbiAgICAgICAgIHZhciBhbmltYXRpb24gPSBfcmVmLmFuaW1hdGlvbjtcblxuICAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgIGZyb20gPSBhbmltYXRpb24uZnJvbTtcbiAgICAgICAgICAgdG8gPSBhbmltYXRpb24udG87XG4gICAgICAgICB9XG5cbiAgICAgICAgIGFuaW1hdGlvbiA9IGFuaW1pdChlbGVtZW50KTtcbiAgICAgICAgIGlmIChyZXN0b3JlKSB7XG4gICAgICAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5zYXZlU3R5bGUoKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZShmcm9tKS53YWl0KG9wdGlvbnMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgY3NzOiB0byxcbiAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogb3B0aW9ucy50aW1pbmdcbiAgICAgICAgIH0pO1xuICAgICAgICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnJlc3RvcmVTdHlsZSgpO1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZShmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2FuaW1hdGVBbGwnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYW5pbWF0ZUFsbChlbGVtZW50LCBhbmltYXRpb25zKSB7XG4gICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICBPYmplY3Qua2V5cyhhbmltYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgcmV0dXJuIF90aGlzLl9hbmltYXRlKGVsZW1lbnRba2V5XSwgYW5pbWF0aW9uc1trZXldKS5wbGF5KCk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFBvcG92ZXJBbmltYXRvcjtcbiAgIH0pKCk7XG5cbiAgIHZhciBmYWRlID0ge1xuICAgICBvdXQ6IHtcbiAgICAgICBmcm9tOiB7IG9wYWNpdHk6IDEuMCB9LFxuICAgICAgIHRvOiB7IG9wYWNpdHk6IDAgfVxuICAgICB9LFxuICAgICBpbjoge1xuICAgICAgIGZyb206IHsgb3BhY2l0eTogMCB9LFxuICAgICAgIHRvOiB7IG9wYWNpdHk6IDEuMCB9XG4gICAgIH1cbiAgIH07XG5cbiAgIHZhciBNREZhZGVQb3BvdmVyQW5pbWF0b3IgPSAoZnVuY3Rpb24gKF9Qb3BvdmVyQW5pbWF0b3IpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKE1ERmFkZVBvcG92ZXJBbmltYXRvciwgX1BvcG92ZXJBbmltYXRvcik7XG5cbiAgICAgZnVuY3Rpb24gTURGYWRlUG9wb3ZlckFuaW1hdG9yKCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBNREZhZGVQb3BvdmVyQW5pbWF0b3IpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTURGYWRlUG9wb3ZlckFuaW1hdG9yKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhNREZhZGVQb3BvdmVyQW5pbWF0b3IsIFt7XG4gICAgICAga2V5OiAnc2hvdycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3cocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICAgICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgICAgICBfbWFzazogZmFkZS5pbixcbiAgICAgICAgICAgX3BvcG92ZXI6IHsgYW5pbWF0aW9uOiBmYWRlLmluLCByZXN0b3JlOiB0cnVlLCBjYWxsYmFjazogY2FsbGJhY2sgfVxuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaGlkZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICAgICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgICAgICBfbWFzazogZmFkZS5vdXQsXG4gICAgICAgICAgIF9wb3BvdmVyOiB7IGFuaW1hdGlvbjogZmFkZS5vdXQsIHJlc3RvcmU6IHRydWUsIGNhbGxiYWNrOiBjYWxsYmFjayB9XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIE1ERmFkZVBvcG92ZXJBbmltYXRvcjtcbiAgIH0pKFBvcG92ZXJBbmltYXRvcik7XG5cbiAgIHZhciBJT1NGYWRlUG9wb3ZlckFuaW1hdG9yID0gKGZ1bmN0aW9uIChfTURGYWRlUG9wb3ZlckFuaW1hdG8pIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsIF9NREZhZGVQb3BvdmVyQW5pbWF0byk7XG5cbiAgICAgZnVuY3Rpb24gSU9TRmFkZVBvcG92ZXJBbmltYXRvcigpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgSU9TRmFkZVBvcG92ZXJBbmltYXRvcik7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihJT1NGYWRlUG9wb3ZlckFuaW1hdG9yKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhJT1NGYWRlUG9wb3ZlckFuaW1hdG9yLCBbe1xuICAgICAgIGtleTogJ3Nob3cnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgICB0aGlzLl9hbmltYXRlQWxsKHBvcG92ZXIsIHtcbiAgICAgICAgICAgX21hc2s6IGZhZGUuaW4sXG4gICAgICAgICAgIF9wb3BvdmVyOiB7XG4gICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLjMsIDEuMywgMS4wKScsXG4gICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLjAsIDEuMCwgIDEuMCknLFxuICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICByZXN0b3JlOiB0cnVlLFxuICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICB9XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIElPU0ZhZGVQb3BvdmVyQW5pbWF0b3I7XG4gICB9KShNREZhZGVQb3BvdmVyQW5pbWF0b3IpO1xuXG4gICB2YXIgYW5pbWF0b3JzID0geyBQb3BvdmVyQW5pbWF0b3I6IFBvcG92ZXJBbmltYXRvciwgSU9TRmFkZVBvcG92ZXJBbmltYXRvcjogSU9TRmFkZVBvcG92ZXJBbmltYXRvciwgTURGYWRlUG9wb3ZlckFuaW1hdG9yOiBNREZhZGVQb3BvdmVyQW5pbWF0b3IgfTtcblxuICAgdmFyIHNjaGVtZSQxNCA9IHtcbiAgICAgJy5wb3BvdmVyJzogJ3BvcG92ZXItLSonLFxuICAgICAnLnBvcG92ZXItbWFzayc6ICdwb3BvdmVyLW1hc2stLSonLFxuICAgICAnLnBvcG92ZXJfX2NvbnRhaW5lcic6ICdwb3BvdmVyX19jb250YWluZXItLSonLFxuICAgICAnLnBvcG92ZXJfX2NvbnRlbnQnOiAncG9wb3Zlcl9fY29udGVudC0tKicsXG4gICAgICcucG9wb3Zlcl9fYXJyb3cnOiAncG9wb3Zlcl9fYXJyb3ctLSonXG4gICB9O1xuXG4gICB2YXIgX2FuaW1hdG9yRGljdCQ0ID0ge1xuICAgICAnZGVmYXVsdCc6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgIHJldHVybiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IGFuaW1hdG9ycy5NREZhZGVQb3BvdmVyQW5pbWF0b3IgOiBhbmltYXRvcnMuSU9TRmFkZVBvcG92ZXJBbmltYXRvcjtcbiAgICAgfSxcbiAgICAgJ25vbmUnOiBhbmltYXRvcnMuUG9wb3ZlckFuaW1hdG9yLFxuICAgICAnZmFkZS1pb3MnOiBhbmltYXRvcnMuSU9TRmFkZVBvcG92ZXJBbmltYXRvcixcbiAgICAgJ2ZhZGUtbWQnOiBhbmltYXRvcnMuTURGYWRlUG9wb3ZlckFuaW1hdG9yXG4gICB9O1xuXG4gICB2YXIgdGVtcGxhdGVTb3VyY2UkMiA9IHV0aWwuY3JlYXRlRnJhZ21lbnQoJ1xcbiAgPGRpdiBjbGFzcz1cInBvcG92ZXItbWFza1wiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cInBvcG92ZXJfX2NvbnRhaW5lclwiPlxcbiAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fY29udGVudFwiPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fYXJyb3dcIj48L2Rpdj5cXG4gIDwvZGl2PlxcbicpO1xuXG4gICB2YXIgcG9zaXRpb25zID0ge1xuICAgICB1cDogJ2JvdHRvbScsXG4gICAgIGxlZnQ6ICdyaWdodCcsXG4gICAgIGRvd246ICd0b3AnLFxuICAgICByaWdodDogJ2xlZnQnXG4gICB9O1xuXG4gICB2YXIgZGlyZWN0aW9ucyA9IE9iamVjdC5rZXlzKHBvc2l0aW9ucyk7XG4gICAvKipcbiAgICAqIEBlbGVtZW50IG9ucy1wb3BvdmVyXG4gICAgKiBAY2F0ZWdvcnkgcG9wb3ZlclxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgW2VuXUEgY29tcG9uZW50IHRoYXQgZGlzcGxheXMgYSBwb3BvdmVyIG5leHQgdG8gYW4gZWxlbWVudC5bL2VuXVxuICAgICogIFtqYV3jgYLjgovopoHntKDjgpLlr77osaHjgajjgZnjgovjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICAgICogQGNvZGVwZW4gWllZUktvXG4gICAgKiBAZXhhbXBsZVxuICAgICogPHNjcmlwdD5cbiAgICAqIG9ucy5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAqICAgb25zLmNyZWF0ZVBvcG92ZXIoJ3BvcG92ZXIuaHRtbCcpLnRoZW4oZnVuY3Rpb24ocG9wb3Zlcikge1xuICAgICogICAgIHBvcG92ZXIuc2hvdygnI215YnV0dG9uJyk7XG4gICAgKiAgIH0pO1xuICAgICogfSk7XG4gICAgKiA8L3NjcmlwdD5cbiAgICAqXG4gICAgKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L29ucy10ZW1wbGF0ZVwiIGlkPVwicG9wb3Zlci5odG1sXCI+XG4gICAgKiAgIDxvbnMtcG9wb3ZlciBjYW5jZWxhYmxlPlxuICAgICogICAgIDxwIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyOyBvcGFjaXR5OiAwLjU7XCI+VGhpcyBwb3BvdmVyIHdpbGwgY2hvb3NlIHdoaWNoIHNpZGUgaXQncyBkaXNwbGF5ZWQgb24gYXV0b21hdGljYWxseS48L3A+XG4gICAgKiAgIDwvb25zLXBvcG92ZXI+XG4gICAgKiA8L3NjcmlwdD5cbiAgICAqL1xuXG4gICB2YXIgUG9wb3ZlckVsZW1lbnQgPSAoZnVuY3Rpb24gKF9CYXNlRWxlbWVudCkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoUG9wb3ZlckVsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gUG9wb3ZlckVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcG92ZXJFbGVtZW50KTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvcG92ZXJFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhQb3BvdmVyRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgICAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgIHRoaXMuX2JvdW5kQ2FuY2VsID0gdGhpcy5fY2FuY2VsLmJpbmQodGhpcyk7XG5cbiAgICAgICAgIHRoaXMuX2luaXRBbmltYXRvckZhY3RvcnkoKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfaW5pdEFuaW1hdG9yRmFjdG9yeScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0QW5pbWF0b3JGYWN0b3J5KCkge1xuICAgICAgICAgdmFyIGZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0JDQsXG4gICAgICAgICAgIGJhc2VDbGFzczogYW5pbWF0b3JzLlBvcG92ZXJBbmltYXRvcixcbiAgICAgICAgICAgYmFzZUNsYXNzTmFtZTogJ1BvcG92ZXJBbmltYXRvcicsXG4gICAgICAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSB8fCAnZGVmYXVsdCdcbiAgICAgICAgIH0pO1xuICAgICAgICAgdGhpcy5fYW5pbWF0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICByZXR1cm4gZmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcbiAgICAgICAgIH07XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRGV2aWNlQmFja0J1dHRvbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRldmljZUJhY2tCdXR0b24oZXZlbnQpIHtcbiAgICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsYWJsZSgpKSB7XG4gICAgICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgZXZlbnQuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfcG9zaXRpb25Qb3BvdmVyJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvc2l0aW9uUG9wb3Zlcih0YXJnZXQpIHtcbiAgICAgICAgIHZhciByYWRpdXMgPSB0aGlzLl9yYWRpdXM7XG4gICAgICAgICB2YXIgZWwgPSB0aGlzLl9jb250ZW50O1xuICAgICAgICAgdmFyIG1hcmdpbiA9IHRoaXMuX21hcmdpbjtcblxuICAgICAgICAgdmFyIHBvcyA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgIHZhciBpc01EID0gdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKTtcbiAgICAgICAgIHZhciBjb3ZlciA9IGlzTUQgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2NvdmVyLXRhcmdldCcpO1xuXG4gICAgICAgICB2YXIgZGlzdGFuY2UgPSB7XG4gICAgICAgICAgIHRvcDogcG9zLnRvcCAtIG1hcmdpbixcbiAgICAgICAgICAgbGVmdDogcG9zLmxlZnQgLSBtYXJnaW4sXG4gICAgICAgICAgIHJpZ2h0OiB3aW5kb3cuaW5uZXJXaWR0aCAtIHBvcy5yaWdodCAtIG1hcmdpbixcbiAgICAgICAgICAgYm90dG9tOiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBwb3MuYm90dG9tIC0gbWFyZ2luXG4gICAgICAgICB9O1xuXG4gICAgICAgICB2YXIgX2NhbGN1bGF0ZURpcmVjdGlvbnMyID0gdGhpcy5fY2FsY3VsYXRlRGlyZWN0aW9ucyhkaXN0YW5jZSk7XG5cbiAgICAgICAgIHZhciB2ZXJ0aWNhbCA9IF9jYWxjdWxhdGVEaXJlY3Rpb25zMi52ZXJ0aWNhbDtcbiAgICAgICAgIHZhciBwcmltYXJ5ID0gX2NhbGN1bGF0ZURpcmVjdGlvbnMyLnByaW1hcnk7XG4gICAgICAgICB2YXIgc2Vjb25kYXJ5ID0gX2NhbGN1bGF0ZURpcmVjdGlvbnMyLnNlY29uZGFyeTtcblxuICAgICAgICAgdGhpcy5fcG9wb3Zlci5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyLS0nICsgcHJpbWFyeSk7XG5cbiAgICAgICAgIHZhciBvZmZzZXQgPSBjb3ZlciA/IDAgOiAodmVydGljYWwgPyBwb3MuaGVpZ2h0IDogcG9zLndpZHRoKSArIChpc01EID8gMCA6IDE0KTtcbiAgICAgICAgIHRoaXMuc3R5bGVbcHJpbWFyeV0gPSBNYXRoLm1heCgwLCBkaXN0YW5jZVtwcmltYXJ5XSArIG9mZnNldCkgKyBtYXJnaW4gKyAncHgnO1xuICAgICAgICAgZWwuc3R5bGVbcHJpbWFyeV0gPSAwO1xuXG4gICAgICAgICB2YXIgbCA9IHZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICAgdmFyIHNpemVzID0gKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgIHdpZHRoOiBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpKSxcbiAgICAgICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpKVxuICAgICAgICAgICB9O1xuICAgICAgICAgfSkod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpKTtcblxuICAgICAgICAgZWwuc3R5bGVbc2Vjb25kYXJ5XSA9IE1hdGgubWF4KDAsIGRpc3RhbmNlW3NlY29uZGFyeV0gLSAoc2l6ZXNbbF0gLSBwb3NbbF0pIC8gMikgKyAncHgnO1xuICAgICAgICAgdGhpcy5fYXJyb3cuc3R5bGVbc2Vjb25kYXJ5XSA9IE1hdGgubWF4KHJhZGl1cywgZGlzdGFuY2Vbc2Vjb25kYXJ5XSArIHBvc1tsXSAvIDIpICsgJ3B4JztcblxuICAgICAgICAgdGhpcy5fc2V0VHJhbnNmb3JtT3JpZ2luKGRpc3RhbmNlLCBzaXplcywgcG9zLCBwcmltYXJ5KTtcblxuICAgICAgICAgLy8gUHJldmVudCBhbmltaXQgZnJvbSByZXN0b3JpbmcgdGhlIHN0eWxlLlxuICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWFuaW1pdC1vcmlnLXN0eWxlJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3NldFRyYW5zZm9ybU9yaWdpbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRUcmFuc2Zvcm1PcmlnaW4oZGlzdGFuY2UsIHNpemVzLCBwb3MsIHByaW1hcnkpIHtcbiAgICAgICAgIHZhciBjYWxjID0gZnVuY3Rpb24gY2FsYyhhLCBvLCBsKSB7XG4gICAgICAgICAgIHJldHVybiBwcmltYXJ5ID09PSBhID8gc2l6ZXNbbF0gLyAyIDogZGlzdGFuY2VbYV0gKyAocHJpbWFyeSA9PT0gbyA/IC1zaXplc1tsXSA6IHNpemVzW2xdIC0gcG9zW2xdKSAvIDI7XG4gICAgICAgICB9O1xuICAgICAgICAgdmFyIHggPSBjYWxjKCdsZWZ0JywgJ3JpZ2h0JywgJ3dpZHRoJykgKyAncHgnO1xuICAgICAgICAgdmFyIHkgPSBjYWxjKCd0b3AnLCAnYm90dG9tJywgJ2hlaWdodCcpICsgJ3B4JztcblxuICAgICAgICAgdXRpbC5leHRlbmQodGhpcy5fcG9wb3Zlci5zdHlsZSwge1xuICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IHggKyAnICcgKyB5LFxuICAgICAgICAgICB3ZWJraXRUcmFuc2Zvcm1PcmlnaW5YOiB4LFxuICAgICAgICAgICB3ZWJraXRUcmFuc2Zvcm1PcmlnaW5ZOiB5XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY2FsY3VsYXRlRGlyZWN0aW9ucycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVEaXJlY3Rpb25zKGRpc3RhbmNlKSB7XG4gICAgICAgICB2YXIgb3B0aW9ucyA9ICh0aGlzLmdldEF0dHJpYnV0ZSgnZGlyZWN0aW9uJykgfHwgJ3VwIGRvd24gbGVmdCByaWdodCcpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgIHJldHVybiBwb3NpdGlvbnNbZV07XG4gICAgICAgICB9KTtcbiAgICAgICAgIHZhciBwcmltYXJ5ID0gb3B0aW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgIHJldHVybiBkaXN0YW5jZVthXSAtIGRpc3RhbmNlW2JdO1xuICAgICAgICAgfSlbMF07XG4gICAgICAgICB2YXIgdmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHByaW1hcnkpICE9PSAtMTtcbiAgICAgICAgIHZhciBzZWNvbmRhcnkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgICBzZWNvbmRhcnkgPSBkaXN0YW5jZS5sZWZ0IDwgZGlzdGFuY2UucmlnaHQgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UudG9wIDwgZGlzdGFuY2UuYm90dG9tID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHsgdmVydGljYWw6IHZlcnRpY2FsLCBwcmltYXJ5OiBwcmltYXJ5LCBzZWNvbmRhcnk6IHNlY29uZGFyeSB9O1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jbGVhclN0eWxlcycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhclN0eWxlcygpIHtcbiAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCddLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgX3RoaXMyLl9hcnJvdy5zdHlsZVtlXSA9IF90aGlzMi5fY29udGVudC5zdHlsZVtlXSA9IF90aGlzMi5zdHlsZVtlXSA9ICcnO1xuICAgICAgICAgICBfdGhpczIuX3BvcG92ZXIuY2xhc3NMaXN0LnJlbW92ZSgncG9wb3Zlci0tJyArIGUpO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uQ2hhbmdlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2hhbmdlKCkge1xuICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIGlmIChfdGhpczMuX2N1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICBfdGhpczMuX3Bvc2l0aW9uUG9wb3ZlcihfdGhpczMuX2N1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncG9wb3ZlcicpO1xuXG4gICAgICAgICB2YXIgdGVtcGxhdGUgPSB0ZW1wbGF0ZVNvdXJjZSQyLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgIHZhciBjb250ZW50ID0gdGVtcGxhdGUucXVlcnlTZWxlY3RvcignLnBvcG92ZXJfX2NvbnRlbnQnKTtcblxuICAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUpO1xuXG4gICAgICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdtYXNrLWNvbG9yJykpIHtcbiAgICAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSQxNCk7XG5cbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3ByZXBhcmVBbmltYXRpb25PcHRpb25zJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbiAmJiAhKG9wdGlvbnMuYW5pbWF0aW9uIGluIF9hbmltYXRvckRpY3QkNCkpIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbmltYXRvciAnICsgb3B0aW9ucy5hbmltYXRpb24gKyAnIGlzIG5vdCByZWdpc3RlcmVkLicpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSwgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZXhlY3V0ZUFjdGlvbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9leGVjdXRlQWN0aW9uKGFjdGlvbnMpIHtcbiAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnMuYWN0aW9uO1xuICAgICAgICAgdmFyIGJlZm9yZSA9IGFjdGlvbnMuYmVmb3JlO1xuICAgICAgICAgdmFyIGFmdGVyID0gYWN0aW9ucy5hZnRlcjtcblxuICAgICAgICAgdGhpcy5fcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgIHZhciBjYW5jZWxlZCA9IGZhbHNlO1xuICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmUnICsgYWN0aW9uLCB7IC8vIHN5bmNocm9ub3VzXG4gICAgICAgICAgIHBvcG92ZXI6IHRoaXMsXG4gICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICAgICAgIHJldHVybiBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuXG4gICAgICAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmUnICsgYWN0aW9uICsgJyBldmVudC4nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgIF90aGlzNC5fZG9vckxvY2sud2FpdFVubG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIHVubG9jayA9IF90aGlzNC5fZG9vckxvY2subG9jaygpO1xuXG4gICAgICAgICAgICAgYmVmb3JlICYmIGJlZm9yZSgpO1xuXG4gICAgICAgICAgICAgX3RoaXM0Ll9hbmltYXRvcihvcHRpb25zKVthY3Rpb25dKF90aGlzNCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgYWZ0ZXIgJiYgYWZ0ZXIoKTtcblxuICAgICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudChfdGhpczQsICdwb3N0JyArIGFjdGlvbiwgeyBwb3BvdmVyOiBfdGhpczQgfSk7XG5cbiAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICByZXNvbHZlKF90aGlzNCk7XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBzaG93XG4gICAgICAgICogQHNpZ25hdHVyZSBzaG93KHRhcmdldCwgW29wdGlvbnNdKVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfEV2ZW50fEhUTUxFbGVtZW50fSB0YXJnZXRcbiAgICAgICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC4gQ2FuIGJlIGVpdGhlciBhIENTUyBzZWxlY3RvciwgYW4gZXZlbnQgb2JqZWN0IG9yIGEgRE9NIGVsZW1lbnQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgr/jg7zjgrLjg4Pjg4jjgajjgarjgovopoHntKDjgpLmjIflrprjgZfjgb7jgZnjgIJDU1Pjgrvjg6zjgq/jgr/jgYtldmVudOOCquODluOCuOOCp+OCr+ODiOOBi0RPTeimgee0oOOBruOBhOOBmuOCjOOBi+OCkua4oeOBm+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAgICAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuICBVc2Ugb25lIG9mIFwiZmFkZS1pb3NcIiwgXCJmYWRlLW1kXCIsIFwibm9uZVwiIGFuZCBcImRlZmF1bHRcIi5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwiZmFkZS1pb3NcIiwgXCJmYWRlLW1kXCIsIFwibm9uZVwiLCBcImRlZmF1bHRcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAgICAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICAgICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgcG9wb3ZlciBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dT3BlbiB0aGUgcG9wb3ZlciBhbmQgcG9pbnQgaXQgYXQgYSB0YXJnZXQuIFRoZSB0YXJnZXQgY2FuIGJlIGVpdGhlciBhbiBldmVudCwgYSBjc3Mgc2VsZWN0b3Igb3IgYSBET00gZWxlbWVudC4uWy9lbl1cbiAgICAgICAgKiAgIFtqYV3lr77osaHjgajjgZnjgovopoHntKDjgavjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJ0YXJnZXTlvJXmlbDjgavjga/jgIEkZXZlbnTjgqrjg5bjgrjjgqfjgq/jg4jjgoRET03jgqjjg6zjg6Hjg7Pjg4jjgoRDU1Pjgrvjg6zjgq/jgr/jgpLmuKHjgZnjgZPjgajjgYzlh7rmnaXjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50Wy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdzaG93JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdyh0YXJnZXQpIHtcbiAgICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQudGFyZ2V0O1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YXJnZXQnKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHRoaXMuX2V4ZWN1dGVBY3Rpb24oe1xuICAgICAgICAgICBhY3Rpb246ICdzaG93JyxcbiAgICAgICAgICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUoKSB7XG4gICAgICAgICAgICAgX3RoaXM1LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgIF90aGlzNS5fY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgICBfdGhpczUuX3Bvc2l0aW9uUG9wb3Zlcih0YXJnZXQpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGhpZGVcbiAgICAgICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgICAgICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiAgVXNlIG9uZSBvZiBcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiBhbmQgXCJkZWZhdWx0XCIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgICAgICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuICA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvZW5dXG4gICAgICAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+IFsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAgICAgICogICBbZW5dVGhpcyBmdW5jdGlvbnMgaXMgY2FsbGVkIGFmdGVyIHRoZSBwb3BvdmVyIGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxuICAgICAgICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dQ2xvc2UgdGhlIHBvcG92ZXIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdoaWRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZUFjdGlvbih7XG4gICAgICAgICAgIGFjdGlvbjogJ2hpZGUnLFxuICAgICAgICAgICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoKSB7XG4gICAgICAgICAgICAgX3RoaXM2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgX3RoaXM2Ll9jbGVhclN0eWxlcygpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzU2hvd25cbiAgICAgICAgKiBAc2lnbmF0dXJlIGlzU2hvd24oKVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogICBbZW5ddHJ1ZSBpZiB0aGUgcG9wb3ZlciBpcyB2aXNpYmxlLlsvZW5dXG4gICAgICAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44Gm44GE44KL5aC05ZCI44GrdHJ1ZeOBqOOBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAgICAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNTaG93bicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2hvd24oKSB7XG4gICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpICE9PSAnbm9uZSc7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLl9tYXJnaW4gPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5nZXRQcm9wZXJ0eVZhbHVlKCd0b3AnKSk7XG4gICAgICAgICB0aGlzLl9yYWRpdXMgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9jb250ZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItcmFkaXVzJykpO1xuXG4gICAgICAgICB0aGlzLl9tYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRDYW5jZWwsIGZhbHNlKTtcblxuICAgICAgICAgdGhpcy5fZGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgdGhpcy5fcG9wb3Zlci5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgICAgICB0aGlzLl9wb3BvdmVyLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuXG4gICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RldGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5fbWFzay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kQ2FuY2VsLCBmYWxzZSk7XG5cbiAgICAgICAgIHRoaXMuX2RldmljZUJhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgIHRoaXMuX2RldmljZUJhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgdGhpcy5fcG9wb3Zlci5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgICAgICB0aGlzLl9wb3BvdmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuXG4gICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSQxNCk7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAobmFtZSA9PT0gJ2RpcmVjdGlvbicpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kT25DaGFuZ2UoKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgICAgICB0aGlzLl9pbml0QW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBzZXRDYW5jZWxhYmxlXG4gICAgICAgICogQHNpZ25hdHVyZSBzZXRDYW5jZWxhYmxlKGNhbmNlbGFibGUpXG4gICAgICAgICogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxhYmxlXG4gICAgICAgICogICBbZW5dSWYgdHJ1ZSB0aGUgcG9wb3ZlciB3aWxsIGJlIGNhbmNlbGFibGUuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgavjgZfjgZ/jgYTloLTlkIjjgat0cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1TZXQgd2hldGhlciB0aGUgcG9wb3ZlciBjYW4gYmUgY2FuY2VsZWQgYnkgdGhlIHVzZXIgd2hlbiBpdCBpcyBzaG93bi5bL2VuXVxuICAgICAgICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBl+OBn+mam+OBq+OAgeODpuODvOOCtuOBjOOBneOBruODneODg+ODl+OCquODvOODkOODvOOCkuOCreODo+ODs+OCu+ODq+OBp+OBjeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldENhbmNlbGFibGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYW5jZWxhYmxlKGNhbmNlbGFibGUpIHtcbiAgICAgICAgIGlmICh0eXBlb2YgY2FuY2VsYWJsZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4uJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChjYW5jZWxhYmxlKSB7XG4gICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjYW5jZWxhYmxlJywgJycpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2NhbmNlbGFibGUnKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzQ2FuY2VsYWJsZVxuICAgICAgICAqIEBzaWduYXR1cmUgaXNDYW5jZWxhYmxlKClcbiAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAqICAgW2VuXXRydWUgaWYgdGhlIHBvcG92ZXIgaXMgY2FuY2VsYWJsZS5bL2VuXVxuICAgICAgICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOOCreODo+ODs+OCu+ODq+WPr+iDveOBp+OBguOCjOOBsHRydWXjgajjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgcG9wb3ZlciBpcyBjYW5jZWxhYmxlIG9yIG5vdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBruODneODg+ODl+OCquODvOODkOODvOOBjOOCreODo+ODs+OCu+ODq+WPr+iDveOBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzQ2FuY2VsYWJsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ2FuY2VsYWJsZSgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgZGVzdHJveVxuICAgICAgICAqIEBzaWduYXR1cmUgZGVzdHJveSgpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRGVzdHJveSB0aGUgcG9wb3ZlciBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIERPTSB0cmVlLlsvZW5dXG4gICAgICAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844KS56C05qOE44GX44Gm44CBRE9N44OE44Oq44O844GL44KJ5Y+W44KK6Zmk44GN44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICBpZiAodGhpcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY2FuY2VsJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbmNlbCgpIHtcbiAgICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGFibGUoKSkge1xuICAgICAgICAgICB0aGlzLmhpZGUoe1xuICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudChfdGhpczcsICdjYW5jZWwnKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19tYXNrJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBwcmVzaG93XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHBvcG92ZXIgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAgICAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAgICAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAgICAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgICAgICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgICAgICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGV2ZW50IHByZWhpZGVcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBoaWRkZW4uWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICAgICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICAgICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgcG9wb3ZlciBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+WHpueQhuOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBwb3BvdmVyIGlzIGhpZGRlbi5bL2VuXVxuICAgICAgICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgICAgICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgcG9wb3Zlci5bL2VuXVxuICAgICAgICAqICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgZGlyZWN0aW9uXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXVxuICAgICAgICAqICAgIEEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZGlyZWN0aW9ucy4gSWYgbW9yZSB0aGFuIG9uZSBkaXJlY3Rpb24gaXMgc3BlY2lmaWVkLFxuICAgICAgICAqICAgIGl0IHdpbGwgYmUgY2hvc2VuIGF1dG9tYXRpY2FsbHkuIFZhbGlkIGRpcmVjdGlvbnMgYXJlIFwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiIGFuZCBcInJpZ2h0XCIuXG4gICAgICAgICogIFsvZW5dXG4gICAgICAgICogIFtqYV1cbiAgICAgICAgKiAgICDjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovmlrnlkJHjgpLnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICAgICAgKiAgICDmjIflrprjgafjgY3jgovmlrnlkJHjga/jgIFcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiwgXCJyaWdodFwi44GuNOOBpOOBp+OBmeOAguepuueZveWMuuWIh+OCiuOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOCguOBp+OBjeOBvuOBmeOAglxuICAgICAgICAqICAgIOikh+aVsOaMh+WumuOBleOCjOOBn+WgtOWQiOOAgeWvvuixoeOBqOOBmeOCi+imgee0oOOBq+WQiOOCj+OBm+OBpuaMh+WumuOBl+OBn+WApOOBi+OCieiHquWLleeahOOBq+mBuOaKnuOBleOCjOOBvuOBmeOAglxuICAgICAgICAqICBbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBwb3BvdmVyIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24uWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/mmYLjgavjgIHog4zmma/jgoTjg5Djg4Pjgq/jg5zjgr/jg7PjgpLjgr/jg4Pjg5fjgZfjgZ/mmYLjgavjgpLjg53jg4Pjg5fjgqrjg7zjg5Djg7zplonjgZjjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBjb3Zlci10YXJnZXRcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1JZiBzZXQgdGhlIHBvcG92ZXIgd2lsbCBjb3ZlciB0aGUgdGFyZ2V0IG9uIHRoZSBzY3JlZW4uWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW4gaGlkaW5nIHRoZSBwb3BvdmVyLiBDYW4gYmUgZWl0aGVyIFwibm9uZVwiIG9yIFwiZmFkZVwiLlsvZW5dXG4gICAgICAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICAgICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9lbl1cbiAgICAgICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAgICAgICogQHR5cGUge0NvbG9yfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG1hc2suIERlZmF1bHQgaXMgXCJyZ2JhKDAsIDAsIDAsIDAuMilcIi5bL2VuXVxuICAgICAgICAqICAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr1wicmdiYSgwLCAwLCAwLCAwLjIpXCLjgafjgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfcG9wb3ZlcicsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblsxXTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29udGVudCcsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcG9wb3Zlci5jaGlsZHJlblswXTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfYXJyb3cnLFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3BvcG92ZXIuY2hpbGRyZW5bMV07XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBQb3BvdmVyRWxlbWVudDtcbiAgIH0pKEJhc2VFbGVtZW50KTtcblxuICAgd2luZG93Lk9uc1BvcG92ZXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcG9wb3ZlcicsIHtcbiAgICAgcHJvdG90eXBlOiBQb3BvdmVyRWxlbWVudC5wcm90b3R5cGVcbiAgIH0pO1xuXG4gICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgKiBAcGFyYW0ge1BvcG92ZXJBbmltYXRvcn0gQW5pbWF0b3JcbiAgICAqL1xuICAgd2luZG93Lk9uc1BvcG92ZXJFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbiAobmFtZSwgQW5pbWF0b3IpIHtcbiAgICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgYW5pbWF0b3JzLlBvcG92ZXJBbmltYXRvcikpIHtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgUG9wb3ZlckFuaW1hdG9yJyk7XG4gICAgIH1cbiAgICAgX2FuaW1hdG9yRGljdCQ0W25hbWVdID0gQW5pbWF0b3I7XG4gICB9O1xuXG4gICB3aW5kb3cuT25zUG9wb3ZlckVsZW1lbnQuUG9wb3ZlckFuaW1hdG9yID0gYW5pbWF0b3JzLlBvcG92ZXJBbmltYXRvcjtcblxuICAgdmFyIHNjaGVtZSQxNSA9IHtcbiAgICAgJy5wcm9ncmVzcy1iYXInOiAncHJvZ3Jlc3MtYmFyLS0qJyxcbiAgICAgJy5wcm9ncmVzcy1iYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtYmFyX19wcmltYXJ5LS0qJyxcbiAgICAgJy5wcm9ncmVzcy1iYXJfX3NlY29uZGFyeSc6ICdwcm9ncmVzcy1iYXJfX3NlY29uZGFyeS0tKidcbiAgIH07XG5cbiAgIHZhciB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRWxlbWVudCgnXFxuICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyXCI+XFxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3NlY29uZGFyeVwiPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyX19wcmltYXJ5XCI+PC9kaXY+XFxuICA8L2Rpdj5cXG4nKTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtYmFyXG4gICAgKiBAY2F0ZWdvcnkgcHJvZ3Jlc3NcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dQSBtYXRlcmlhbCBkZXNpZ24gcHJvZ3Jlc3MgY29tcG9uZW50LiBJdCdzIGRpc3BsYXllZCBhcyBhIGxpbmVhciBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAgICAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBrnByb2dyZXNz44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCbGluZWFy44Gq44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBjb2RlcGVuIHp2UWJHalxuICAgICogQGV4YW1wbGVcbiAgICAqIDxvbnMtcHJvZ3Jlc3MtYmFyXG4gICAgKiAgdmFsdWU9XCI1NVwiXG4gICAgKiAgc2Vjb25kYXJ5LXZhbHVlPVwiODdcIj5cbiAgICAqIDwvb25zLXByb2dyZXNzLWJhcj5cbiAgICAqL1xuXG4gICB2YXIgUHJvZ3Jlc3NCYXJFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKFByb2dyZXNzQmFyRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBQcm9ncmVzc0JhckVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFByb2dyZXNzQmFyRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihQcm9ncmVzc0JhckVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKFByb2dyZXNzQmFyRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dQ2hhbmdlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg5fjg63jgrDjg6zjgrnjgqTjg7PjgrjjgrHjg7zjgr/jga7opovjgZ/nm67jgpLlpInmm7TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgc2Vjb25kYXJ5LXZhbHVlXG4gICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgaW5kZXRlcm1pbmF0ZVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgICAgICByZXR1cm4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSQxNSk7XG4gICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2YWx1ZScgfHwgbmFtZSA9PT0gJ3NlY29uZGFyeS12YWx1ZScpIHtcbiAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2luZGV0ZXJtaW5hdGUnKSB7XG4gICAgICAgICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZURldGVybWluYXRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZURldGVybWluYXRlKCkge1xuICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpbmRldGVybWluYXRlJykpIHtcbiAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCgncHJvZ3Jlc3MtYmFyLS1pbmRldGVybWluYXRlJyk7XG4gICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoJ3Byb2dyZXNzLWJhci0tZGV0ZXJtaW5hdGUnKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5hZGQoJ3Byb2dyZXNzLWJhci0tZGV0ZXJtaW5hdGUnKTtcbiAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LnJlbW92ZSgncHJvZ3Jlc3MtYmFyLS1pbmRldGVybWluYXRlJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZVZhbHVlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVZhbHVlKCkge1xuICAgICAgICAgdGhpcy5fcHJpbWFyeS5zdHlsZS53aWR0aCA9IHRoaXMuaGFzQXR0cmlidXRlKCd2YWx1ZScpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgKyAnJScgOiAnMCUnO1xuICAgICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlLndpZHRoID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpICsgJyUnIDogJzAlJztcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgICAgIHRoaXMuX3ByaW1hcnkgPSB0aGlzLl90ZW1wbGF0ZS5jaGlsZE5vZGVzWzNdO1xuICAgICAgICAgdGhpcy5fc2Vjb25kYXJ5ID0gdGhpcy5fdGVtcGxhdGUuY2hpbGROb2Rlc1sxXTtcblxuICAgICAgICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG5cbiAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSQxNSk7XG5cbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBQcm9ncmVzc0JhckVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNQcm9ncmVzc0JhckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1wcm9ncmVzcy1iYXInLCB7XG4gICAgIHByb3RvdHlwZTogUHJvZ3Jlc3NCYXJFbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIHZhciBzY2hlbWUkMTYgPSB7XG4gICAgICcucHJvZ3Jlc3MtY2lyY3VsYXInOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSonLFxuICAgICAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5LS0qJyxcbiAgICAgJy5wcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnktLSonXG4gICB9O1xuXG4gICB2YXIgdGVtcGxhdGUkMSA9IHV0aWwuY3JlYXRlRWxlbWVudCgnXFxuICA8c3ZnIGNsYXNzPVwicHJvZ3Jlc3MtY2lyY3VsYXJcIj5cXG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnlcIiBjeD1cIjUwJVwiIGN5PVwiNTAlXCIgcj1cIjQwJVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMTAlXCIgc3Ryb2tlLW1pdGVybGltaXQ9XCIxMFwiLz5cXG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5XCIgY3g9XCI1MCVcIiBjeT1cIjUwJVwiIHI9XCI0MCVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjEwJVwiIHN0cm9rZS1taXRlcmxpbWl0PVwiMTBcIi8+XFxuICA8L3N2Zz5cXG4nKTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAgICAqIEBjYXRlZ29yeSBwcm9ncmVzc1xuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1BIG1hdGVyaWFsIGRlc2lnbiBwcm9ncmVzcyBjb21wb25lbnQuIEl0J3MgZGlzcGxheWVkIGFzIGEgY2lyY3VsYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gICAgKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga5wcm9ncmVzc+OCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAgmNpcmN1bGFy44Gq44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBjb2RlcGVuIEVWek1qUlxuICAgICogQGV4YW1wbGVcbiAgICAqIDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAgICAqICB2YWx1ZT1cIjU1XCJcbiAgICAqICBzZWNvbmRhcnktdmFsdWU9XCI4N1wiPlxuICAgICogPC9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+XG4gICAgKi9cblxuICAgdmFyIFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50LCBfQmFzZUVsZW1lbnQpO1xuXG4gICAgIGZ1bmN0aW9uIFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihQcm9ncmVzc0NpcmN1bGFyRWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gICAgICAgICogICBbamFd44OX44Ot44Kw44Os44K544Kk44Oz44K444Kx44O844K/44Gu6KaL44Gf55uu44KS5aSJ5pu044GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAgICAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIHNlY29uZGFyeS12YWx1ZVxuICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAgICAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGluZGV0ZXJtaW5hdGVcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUkMTYpO1xuICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdzZWNvbmRhcnktdmFsdWUnKSB7XG4gICAgICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpbmRldGVybWluYXRlJykge1xuICAgICAgICAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGVEZXRlcm1pbmF0ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVEZXRlcm1pbmF0ZSgpIHtcbiAgICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaW5kZXRlcm1pbmF0ZScpKSB7XG4gICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5hZGQoJ3Byb2dyZXNzLWNpcmN1bGFyLS1pbmRldGVybWluYXRlJyk7XG4gICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoJ3Byb2dyZXNzLWNpcmN1bGFyLS1kZXRlcm1pbmF0ZScpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCgncHJvZ3Jlc3MtY2lyY3VsYXItLWRldGVybWluYXRlJyk7XG4gICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLmNsYXNzTGlzdC5yZW1vdmUoJ3Byb2dyZXNzLWNpcmN1bGFyLS1pbmRldGVybWluYXRlJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZVZhbHVlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVZhbHVlKCkge1xuICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgIHZhciBwZXIgPSBNYXRoLmNlaWwodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgKiAyNTEuMzIgKiAwLjAxKTtcbiAgICAgICAgICAgdGhpcy5fcHJpbWFyeS5zdHlsZVsnc3Ryb2tlLWRhc2hhcnJheSddID0gcGVyICsgJyUsIDI1MS4zMiUnO1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSkge1xuICAgICAgICAgICB2YXIgcGVyID0gTWF0aC5jZWlsKHRoaXMuZ2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSAqIDI1MS4zMiAqIDAuMDEpO1xuICAgICAgICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGVbJ3N0cm9rZS1kYXNoYXJyYXknXSA9IHBlciArICclLCAyNTEuMzIlJztcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZSQxLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICAgdGhpcy5fcHJpbWFyeSA9IHRoaXMuX3RlbXBsYXRlLmNoaWxkTm9kZXNbM107XG4gICAgICAgICB0aGlzLl9zZWNvbmRhcnkgPSB0aGlzLl90ZW1wbGF0ZS5jaGlsZE5vZGVzWzFdO1xuXG4gICAgICAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcblxuICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl90ZW1wbGF0ZSk7XG5cbiAgICAgICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lJDE2KTtcblxuICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgPSBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoJ29ucy1wcm9ncmVzcy1jaXJjdWxhcicsIHtcbiAgICAgcHJvdG90eXBlOiBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudC5wcm90b3R5cGVcbiAgIH0pO1xuXG4gICB2YXIgU1RBVEVfSU5JVElBTCA9ICdpbml0aWFsJztcbiAgIHZhciBTVEFURV9QUkVBQ1RJT04gPSAncHJlYWN0aW9uJztcbiAgIHZhciBTVEFURV9BQ1RJT04gPSAnYWN0aW9uJztcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtcHVsbC1ob29rXG4gICAgKiBAY2F0ZWdvcnkgY29udHJvbFxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1Db21wb25lbnQgdGhhdCBhZGRzIFwicHVsbC10by1yZWZyZXNoXCIgdG8gYW4gPG9ucy1wYWdlPiBlbGVtZW50LlsvZW5dXG4gICAgKiAgIFtqYV1vbnMtcGFnZeimgee0oOS7peS4i+OBp+OBhOOCj+OChuOCi3B1bGwgdG8gcmVmcmVzaOOCkuWun+ijheOBmeOCi+OBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gICAgKiBAY29kZXBlbiBXYkpvZ01cbiAgICAqIEBndWlkZSBVc2luZ1B1bGxIb29rXG4gICAgKiAgIFtlbl1Ib3cgdG8gdXNlIFB1bGwgSG9va1svZW5dXG4gICAgKiAgIFtqYV3jg5fjg6vjg5Xjg4Pjgq/jgpLkvb/jgYZbL2phXVxuICAgICogQGV4YW1wbGVcbiAgICAqIDxvbnMtcGFnZT5cbiAgICAqICAgPG9ucy1wdWxsLWhvb2s+XG4gICAgKiAgICAgUmVsZWFzZSB0byByZWZyZXNoXG4gICAgKiAgIDwvb25zLXB1bGwtaG9vaz5cbiAgICAqIDwvb25zLXBhZ2U+XG4gICAgKlxuICAgICogPHNjcmlwdD5cbiAgICAqICAgdmFyIGxvYWRTdHVmZiA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAqICAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDApO1xuICAgICogICB9O1xuICAgICpcbiAgICAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignb25zLXB1bGwtaG9vaycpLnNldEFjdGlvbkNhbGxiYWNrKGxvYWRTdHVmZik7XG4gICAgKiA8L3NjcmlwdD5cbiAgICAqL1xuXG4gICB2YXIgUHVsbEhvb2tFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKFB1bGxIb29rRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBQdWxsSG9va0VsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFB1bGxIb29rRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihQdWxsSG9va0VsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKFB1bGxIb29rRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQGV2ZW50IGNoYW5nZXN0YXRlXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgc3RhdGUgaXMgY2hhbmdlZC4gVGhlIHN0YXRlIGNhbiBiZSBlaXRoZXIgXCJpbml0aWFsXCIsIFwicHJlYWN0aW9uXCIgb3IgXCJhY3Rpb25cIi5bL2VuXVxuICAgICAgICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBrueKtuaFi+OBjOWkieOCj+OBo+OBn+WgtOWQiOOBq+eZuueBq+OBl+OBvuOBmeOAgueKtuaFi+OBr+OAgVwiaW5pdGlhbFwiLCBcInByZWFjdGlvblwiLCBcImFjdGlvblwi44Gu44GE44Ga44KM44GL44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wdWxsSG9va1xuICAgICAgICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5zdGF0ZVxuICAgICAgICAqICAgW2VuXUN1cnJlbnQgc3RhdGUuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3nj77lnKjjga7nirbmhYvlkI3jgpLlj4LnhafjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgXCJwdWxsLXRvLXJlZnJlc2hcIiBmdW5jdGlvbmFsaXR5IGlzIGRpc2FibGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CBZGlzYWJsZWTnirbmhYvjgavjgarjgorjgqLjgq/jgrfjg6fjg7PjgYzlrp/ooYzjgZXjgozjgarjgY/jgarjgorjgb7jgZlbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBoZWlnaHRcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNwZWNpZnkgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50LiBXaGVuIHB1bGxlZCBkb3duIGZ1cnRoZXIgdGhhbiB0aGlzIHZhbHVlIGl0IHdpbGwgc3dpdGNoIHRvIHRoZSBcInByZWFjdGlvblwiIHN0YXRlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIjY0cHhcIi5bL2VuXVxuICAgICAgICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBrumrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBrumrmOOBleS7peS4iuOBq3B1bGwgZG93buOBmeOCi+OBqFwicHJlYWN0aW9uXCLnirbmhYvjgavnp7vooYzjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga7lgKTjga9cIjY0cHhcIuOBp+OBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIHRocmVzaG9sZC1oZWlnaHRcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNwZWNpZnkgdGhlIHRocmVzaG9sZCBoZWlnaHQuIFRoZSBjb21wb25lbnQgYXV0b21hdGljYWxseSBzd2l0Y2hlcyB0byB0aGUgXCJhY3Rpb25cIiBzdGF0ZSB3aGVuIHB1bGxlZCBmdXJ0aGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCI5NnB4XCIuIEEgbmVnYXRpdmUgdmFsdWUgb3IgYSB2YWx1ZSBsZXNzIHRoYW4gdGhlIGhlaWdodCB3aWxsIGRpc2FibGUgdGhpcyBwcm9wZXJ0eS5bL2VuXVxuICAgICAgICAqICAgW2phXemWvuWApOOBqOOBquOCi+mrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWApOOBp+aMh+WumuOBl+OBn+mrmOOBleOCiOOCiuOCgnB1bGwgZG93buOBmeOCi+OBqOOAgeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBr+iHquWLleeahOOBq1wiYWN0aW9uXCLnirbmhYvjgavnp7vooYzjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBmaXhlZC1jb250ZW50XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjb250ZW50IG9mIHRoZSBwYWdlIHdpbGwgbm90IG1vdmUgd2hlbiBwdWxsaW5nLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OX44Or44OV44OD44Kv44GM5byV44GN5Ye644GV44KM44Gm44GE44KL5pmC44Gr44KC44Kz44Oz44OG44Oz44OE44Gv5YuV44GN44G+44Gb44KT44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gdGhpcy5fY3JlYXRlU2Nyb2xsRWxlbWVudCgpO1xuICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5fcGFnZUVsZW1lbnQgPSB0aGlzLl9zY3JvbGxFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgICAgIGlmICghdGhpcy5fcGFnZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdwYWdlX19jb250ZW50JykgJiYgIXRoaXMuX3BhZ2VFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnb25zLXNjcm9sbGVyX19jb250ZW50JykpIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8b25zLXB1bGwtaG9vaz4gbXVzdCBiZSBhIGRpcmVjdCBkZXNjZW5kYW50IG9mIGFuIDxvbnMtcGFnZT4gb3IgYW4gPG9ucy1zY3JvbGxlcj4gZWxlbWVudC4nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5fYm91bmRPbkRyYWcgPSB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKTtcbiAgICAgICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICAgdGhpcy5fYm91bmRPbkRyYWdFbmQgPSB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICAgICAgIHRoaXMuX2JvdW5kT25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuXG4gICAgICAgICB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPSAwO1xuXG4gICAgICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMLCB0cnVlKTtcbiAgICAgICAgIHRoaXMuX3NldFN0eWxlKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2NyZWF0ZVNjcm9sbEVsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlU2Nyb2xsRWxlbWVudCgpIHtcbiAgICAgICAgIHZhciBzY3JvbGxFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2IGNsYXNzPVwic2Nyb2xsXCI+PGRpdj4nKTtcblxuICAgICAgICAgdmFyIHBhZ2VFbGVtZW50ID0gdGhpcy5wYXJlbnRFbGVtZW50O1xuXG4gICAgICAgICBzY3JvbGxFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgICAgICAgd2hpbGUgKHBhZ2VFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgc2Nyb2xsRWxlbWVudC5hcHBlbmRDaGlsZChwYWdlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgIH1cbiAgICAgICAgIHBhZ2VFbGVtZW50LmFwcGVuZENoaWxkKHNjcm9sbEVsZW1lbnQpO1xuXG4gICAgICAgICByZXR1cm4gc2Nyb2xsRWxlbWVudDtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfc2V0U3R5bGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U3R5bGUoKSB7XG4gICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgICAgICAgdGhpcy5zdHlsZS50b3AgPSAnLScgKyBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgdGhpcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgdGhpcy5zdHlsZS5saW5lSGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25TY3JvbGwnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25TY3JvbGwoZXZlbnQpIHtcbiAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fcGFnZUVsZW1lbnQ7XG5cbiAgICAgICAgIGlmIChlbGVtZW50LnNjcm9sbFRvcCA8IDApIHtcbiAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19nZW5lcmF0ZVRyYW5zbGF0aW9uVHJhbnNmb3JtJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlVHJhbnNsYXRpb25UcmFuc2Zvcm0oc2Nyb2xsKSB7XG4gICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKDBweCwgJyArIHNjcm9sbCArICdweCwgMHB4KSc7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRHJhZycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRyYWcoZXZlbnQpIHtcbiAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICBpZiAodGhpcy5pc0Rpc2FibGVkKCkpIHtcbiAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuXG4gICAgICAgICAvLyBJZ25vcmUgd2hlbiBkcmFnZ2luZyBsZWZ0IGFuZCByaWdodC5cbiAgICAgICAgIGlmIChldmVudC5nZXN0dXJlLmRpcmVjdGlvbiA9PT0gJ2xlZnQnIHx8IGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cblxuICAgICAgICAgLy8gSGFjayB0byBtYWtlIGl0IHdvcmsgb24gQW5kcm9pZCA0LjQgV2ViVmlldy4gU2Nyb2xscyBtYW51YWxseSBuZWFyIHRoZSB0b3Agb2YgdGhlIHBhZ2Ugc29cbiAgICAgICAgIC8vIHRoZXJlIHdpbGwgYmUgbm8gaW5lcnRpYWwgc2Nyb2xsIHdoZW4gc2Nyb2xsaW5nIGRvd24uIEFsbG93aW5nIGRlZmF1bHQgc2Nyb2xsaW5nIHdpbGxcbiAgICAgICAgIC8vIGtpbGwgYWxsICd0b3VjaG1vdmUnIGV2ZW50cy5cbiAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fcGFnZUVsZW1lbnQ7XG4gICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHRoaXMuX3N0YXJ0U2Nyb2xsIC0gZXZlbnQuZ2VzdHVyZS5kZWx0YVk7XG4gICAgICAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gIT09ICd1cCcpIHtcbiAgICAgICAgICAgZXZlbnQuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID09PSAwICYmIHRoaXMuX2dldEN1cnJlbnRTY3JvbGwoKSA9PT0gMCkge1xuICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uRHJhZ0xlbmd0aCA9IGV2ZW50Lmdlc3R1cmUuZGVsdGFZO1xuXG4gICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XG4gICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25EcmFnTGVuZ3RoIC09IDE7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkRyYWdMZW5ndGggKz0gMTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgc2Nyb2xsID0gTWF0aC5tYXgoZXZlbnQuZ2VzdHVyZS5kZWx0YVkgLSB0aGlzLl9zdGFydFNjcm9sbCwgMCk7XG5cbiAgICAgICAgIGlmICh0aGlzLl90aHJlc2hvbGRIZWlnaHRFbmFibGVkKCkgJiYgc2Nyb2xsID49IHRoaXMuZ2V0VGhyZXNob2xkSGVpZ2h0KCkpIHtcbiAgICAgICAgICAgZXZlbnQuZ2VzdHVyZS5zdG9wRGV0ZWN0KCk7XG5cbiAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICBfdGhpczIuX3NldFN0YXRlKFNUQVRFX0FDVElPTik7XG4gICAgICAgICAgICAgX3RoaXMyLl90cmFuc2xhdGVUbyhfdGhpczIuZ2V0SGVpZ2h0KCksIHsgYW5pbWF0ZTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgIF90aGlzMi5fd2FpdEZvckFjdGlvbihfdGhpczIuX29uRG9uZS5iaW5kKF90aGlzMikpO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsID49IHRoaXMuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfUFJFQUNUSU9OKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKHNjcm9sbCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRHJhZ1N0YXJ0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgICAgICBpZiAodGhpcy5pc0Rpc2FibGVkKCkpIHtcbiAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLl9zdGFydFNjcm9sbCA9IHRoaXMuX2dldEN1cnJlbnRTY3JvbGwoKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25EcmFnRW5kJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJhZ0VuZChldmVudCkge1xuICAgICAgICAgaWYgKHRoaXMuaXNEaXNhYmxlZCgpKSB7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA+IDApIHtcbiAgICAgICAgICAgdmFyIHNjcm9sbCA9IHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbjtcblxuICAgICAgICAgICBpZiAoc2Nyb2xsID4gdGhpcy5nZXRIZWlnaHQoKSkge1xuICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0FDVElPTik7XG5cbiAgICAgICAgICAgICB0aGlzLl90cmFuc2xhdGVUbyh0aGlzLmdldEhlaWdodCgpLCB7IGFuaW1hdGU6IHRydWUgfSk7XG5cbiAgICAgICAgICAgICB0aGlzLl93YWl0Rm9yQWN0aW9uKHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICB0aGlzLl90cmFuc2xhdGVUbygwLCB7IGFuaW1hdGU6IHRydWUgfSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdzZXRBY3Rpb25DYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEFjdGlvbkNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ193YWl0Rm9yQWN0aW9uJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhaXRGb3JBY3Rpb24oZG9uZSkge1xuICAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgdGhpcy5fY2FsbGJhY2suY2FsbChudWxsLCBkb25lKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25Eb25lJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9uZShkb25lKSB7XG4gICAgICAgICAvLyBDaGVjayBpZiB0aGUgcHVsbCBob29rIHN0aWxsIGV4aXN0cy5cbiAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKDAsIHsgYW5pbWF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgZ2V0SGVpZ2h0XG4gICAgICAgICogQHNpZ25hdHVyZSBnZXRIZWlnaHQoKVxuICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHB1bGwgaG9vayBpbiBwaXhlbHMuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg5fjg6vjg5Xjg4Pjgq/jga7pq5jjgZXjgpLjg5Tjgq/jgrvjg6vmlbDjgafov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdnZXRIZWlnaHQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWlnaHQoKSB7XG4gICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8ICc2NCcsIDEwKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHNldEhlaWdodFxuICAgICAgICAqIEBzaWduYXR1cmUgc2V0SGVpZ2h0KGhlaWdodClcbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICAgICogICBbZW5dRGVzaXJlZCBoZWlnaHQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3opoHntKDjga7pq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNwZWNpZnkgdGhlIGhlaWdodC5bL2VuXVxuICAgICAgICAqICAgW2phXemrmOOBleOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldEhlaWdodCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKTtcblxuICAgICAgICAgdGhpcy5fc2V0U3R5bGUoKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHNldFRocmVzaG9sZEhlaWdodFxuICAgICAgICAqIEBzaWduYXR1cmUgc2V0VGhyZXNob2xkSGVpZ2h0KHRocmVzaG9sZEhlaWdodClcbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkSGVpZ2h0XG4gICAgICAgICogICBbZW5dRGVzaXJlZCB0aHJlc2hvbGQgaGVpZ2h0LlsvZW5dXG4gICAgICAgICogICBbamFd44OX44Or44OV44OD44Kv44Gu44Ki44Kv44K344On44Oz44KS6LW344GT44GZ6Za+5YCk44Go44Gq44KL6auY44GV44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSB0aHJlc2hvbGQgaGVpZ2h0LlsvZW5dXG4gICAgICAgICogICBbamFd6Za+5YCk44Go44Gq44KL6auY44GV44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnc2V0VGhyZXNob2xkSGVpZ2h0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGhyZXNob2xkSGVpZ2h0KHRocmVzaG9sZEhlaWdodCkge1xuICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RocmVzaG9sZC1oZWlnaHQnLCB0aHJlc2hvbGRIZWlnaHQgKyAncHgnKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGdldFRocmVzaG9sZEhlaWdodFxuICAgICAgICAqIEBzaWduYXR1cmUgZ2V0VGhyZXNob2xkSGVpZ2h0KClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIHRocmVzaG9sZCBpbiBwaXhlbHMuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3plr7lgKTjgIHjgajjgarjgovpq5jjgZXjgpLjg5Tjgq/jgrvjg6vmlbDjgafov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZ2V0VGhyZXNob2xkSGVpZ2h0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGhyZXNob2xkSGVpZ2h0KCkge1xuICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JykgfHwgJzk2JywgMTApO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ190aHJlc2hvbGRIZWlnaHRFbmFibGVkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3RocmVzaG9sZEhlaWdodEVuYWJsZWQoKSB7XG4gICAgICAgICB2YXIgdGggPSB0aGlzLmdldFRocmVzaG9sZEhlaWdodCgpO1xuICAgICAgICAgcmV0dXJuIHRoID4gMCAmJiB0aCA+PSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19zZXRTdGF0ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTdGF0ZShzdGF0ZSwgbm9FdmVudCkge1xuICAgICAgICAgdmFyIGxhc3RTdGF0ZSA9IHRoaXMuX2dldFN0YXRlKCk7XG5cbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHN0YXRlKTtcblxuICAgICAgICAgaWYgKCFub0V2ZW50ICYmIGxhc3RTdGF0ZSAhPT0gdGhpcy5fZ2V0U3RhdGUoKSkge1xuICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2NoYW5nZXN0YXRlJywge1xuICAgICAgICAgICAgIHB1bGxIb29rOiB0aGlzLFxuICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICBsYXN0U3RhdGU6IGxhc3RTdGF0ZVxuICAgICAgICAgICB9KTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0U3RhdGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RhdGUoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0YXRlJyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBnZXRDdXJyZW50U3RhdGVcbiAgICAgICAgKiBAc2lnbmF0dXJlIGdldEN1cnJlbnRTdGF0ZSgpXG4gICAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3opoHntKDjga7nj77lnKjjga7nirbmhYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdnZXRDdXJyZW50U3RhdGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXJyZW50U3RhdGUoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0Q3VycmVudFNjcm9sbCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDdXJyZW50U2Nyb2xsKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGdldFB1bGxEaXN0YW5jZVxuICAgICAgICAqIEBzaWduYXR1cmUgZ2V0UHVsbERpc3RhbmNlKClcbiAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB0aGUgY3VycmVudCBudW1iZXIgb2YgcGl4ZWxzIHRoZSBwdWxsIGhvb2sgaGFzIG1vdmVkLlsvZW5dXG4gICAgICAgICogICBbamFd54++5Zyo44Gu44OX44Or44OV44OD44Kv44GM5byV44GN5Ye644GV44KM44Gf6Led6Zui44KS44OU44Kv44K744Or5pWw44Gn6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZ2V0UHVsbERpc3RhbmNlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHVsbERpc3RhbmNlKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbjtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGlzRGlzYWJsZWRcbiAgICAgICAgKiBAc2lnbmF0dXJlIGlzRGlzYWJsZWQoKVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogICBbZW5ddHJ1ZSBpZiB0aGUgcHVsbCBob29rIGlzIGRpc2FibGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44OX44Or44OV44OD44Kv44GMZGlzYWJsZWTnirbmhYvjga7loLTlkIjjgIF0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZCBvciBlbmFibGVkLlsvZW5dXG4gICAgICAgICogICBbamFdZGlzYWJsZWTnirbmhYvjgavjgarjgaPjgabjgYTjgovjgYvjgpLlvpfjgovjgZPjgajjgYzlh7rmnaXjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdpc0Rpc2FibGVkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNEaXNhYmxlZCgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfaXNDb250ZW50Rml4ZWQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNDb250ZW50Rml4ZWQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2ZpeGVkLWNvbnRlbnQnKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHNldERpc2FibGVkXG4gICAgICAgICogQHNpZ25hdHVyZSBzZXREaXNhYmxlZChkaXNhYmxlZClcbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkXG4gICAgICAgICogICBbZW5dSWYgdHJ1ZSB0aGUgcHVsbCBob29rIHdpbGwgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV10cnVl44KS5oyH5a6a44GZ44KL44Go44CB44OX44Or44OV44OD44Kv44GMZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXURpc2FibGUgb3IgZW5hYmxlIHRoZSBjb21wb25lbnQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1kaXNhYmxlZOeKtuaFi+OBq+OBmeOCi+OBi+OBqeOBhuOBi+OCkuioreWumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldERpc2FibGVkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnJyk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0U2Nyb2xsYWJsZUVsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoKSB7XG4gICAgICAgICBpZiAodGhpcy5faXNDb250ZW50Rml4ZWQoKSkge1xuICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50O1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfdHJhbnNsYXRlVG8nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJhbnNsYXRlVG8oc2Nyb2xsKSB7XG4gICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9PSAwICYmIHNjcm9sbCA9PSAwKSB7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICAgICBpZiAoc2Nyb2xsID09PSAwKSB7XG4gICAgICAgICAgICAgX3RoaXMzLl9nZXRTY3JvbGxhYmxlRWxlbWVudCgpLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9O1xuXG4gICAgICAgICB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPSBzY3JvbGw7XG5cbiAgICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgICAgICAgYW5pbWl0KHRoaXMuX2dldFNjcm9sbGFibGVFbGVtZW50KCkpLnF1ZXVlKHtcbiAgICAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlVHJhbnNsYXRpb25UcmFuc2Zvcm0oc2Nyb2xsKVxuICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgZHVyYXRpb246IDAuMyxcbiAgICAgICAgICAgICB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknXG4gICAgICAgICAgIH0pLnBsYXkoZG9uZSk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBhbmltaXQodGhpcy5fZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoKSkucXVldWUoe1xuICAgICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVUcmFuc2xhdGlvblRyYW5zZm9ybShzY3JvbGwpXG4gICAgICAgICAgIH0pLnBsYXkoZG9uZSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2dldE1pbmltdW1TY3JvbGwnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWluaW11bVNjcm9sbCgpIHtcbiAgICAgICAgIHZhciBzY3JvbGxIZWlnaHQgPSB0aGlzLl9zY3JvbGxFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgIHZhciBwYWdlSGVpZ2h0ID0gdGhpcy5fcGFnZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuXG4gICAgICAgICByZXR1cm4gc2Nyb2xsSGVpZ2h0ID4gcGFnZUhlaWdodCA/IC0oc2Nyb2xsSGVpZ2h0IC0gcGFnZUhlaWdodCkgOiAwO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jcmVhdGVFdmVudExpc3RlbmVycycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5fcGFnZUVsZW1lbnQsIHtcbiAgICAgICAgICAgZHJhZ01pbkRpc3RhbmNlOiAxLFxuICAgICAgICAgICBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uOiBmYWxzZVxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIC8vIEJpbmQgbGlzdGVuZXJzXG4gICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWcnLCB0aGlzLl9ib3VuZE9uRHJhZyk7XG4gICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3Iub24oJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdFbmQpO1xuXG4gICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50LnBhcmVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCwgZmFsc2UpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19kZXN0cm95RXZlbnRMaXN0ZW5lcnMnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveUV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9mZignZHJhZycsIHRoaXMuX2JvdW5kT25EcmFnKTtcbiAgICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9mZignZHJhZ2VuZCcsIHRoaXMuX2JvdW5kT25EcmFnRW5kKTtcblxuICAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcbiAgICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG51bGw7XG5cbiAgICAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsLCBmYWxzZSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLl9jcmVhdGVFdmVudExpc3RlbmVycygpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RldGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5fZGVzdHJveUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHt9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFB1bGxIb29rRWxlbWVudDtcbiAgIH0pKEJhc2VFbGVtZW50KTtcblxuICAgd2luZG93Lk9uc1B1bGxIb29rRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXB1bGwtaG9vaycsIHtcbiAgICAgcHJvdG90eXBlOiBQdWxsSG9va0VsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgd2luZG93Lk9uc1B1bGxIb29rRWxlbWVudC5TVEFURV9BQ1RJT04gPSBTVEFURV9BQ1RJT047XG4gICB3aW5kb3cuT25zUHVsbEhvb2tFbGVtZW50LlNUQVRFX0lOSVRJQUwgPSBTVEFURV9JTklUSUFMO1xuICAgd2luZG93Lk9uc1B1bGxIb29rRWxlbWVudC5TVEFURV9QUkVBQ1RJT04gPSBTVEFURV9QUkVBQ1RJT047XG5cbiAgIC8qKlxuICAgICogQGNsYXNzIEFuaW1hdG9yQ1NTIC0gaW1wbGVtZW50YXRpb24gb2YgQW5pbWF0b3IgY2xhc3MgdXNpbmcgY3NzIHRyYW5zaXRpb25zXG4gICAgKi9cblxuICAgdmFyIEFuaW1hdG9yQ1NTID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKEFuaW1hdG9yQ1NTLCBbe1xuICAgICAgIGtleTogJ2FuaW1hdGUnLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBhbmltYXRlXG4gICAgICAgICogQGRlc2MgbWFpbiBhbmltYXRpb24gZnVuY3Rpb25cbiAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmluYWxDU1NcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF0gLSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdFxuICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQudGhlbihjYWxsYmFjaykgLSBzZXRzIGEgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgc3RvcHBlZFxuICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3RvcChvcHRpb25zKSAtIHN0b3BzIHRoZSBhbmltYXRpb247IGlmIG9wdGlvbnMuc3RvcE5leHQgaXMgdHJ1ZSB0aGVuIGl0IGRvZXNuJ3QgY2FsbCB0aGUgY2FsbGJhY2tcbiAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LmZpbmlzaChtcykgLSBmaW5pc2hlcyB0aGUgYW5pbWF0aW9uIGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LnNwZWVkKG1zKSAtIHNldHMgdGhlIGFuaW1hdGlvbiBzcGVlZCBzbyB0aGF0IGl0IGZpbmlzaGVzIGFzIGlmIHRoZSBvcmlnaW5hbCBkdXJhdGlvbiB3YXMgdGhlIG9uZSBzcGVjaWZpZWQgaGVyZVxuICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICogYGBgYFxuICAgICAgICAqICB2YXIgcmVzdWx0ID0gYW5pbWF0b3IuYW5pbWF0ZShlbCwge29wYWNpdHk6IDAuNX0sIDEwMDApO1xuICAgICAgICAqXG4gICAgICAgICogIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICogICAgcmVzdWx0LnNwZWVkKDIwMCkudGhlbihmdW5jdGlvbigpe1xuICAgICAgICAqICAgICAgY29uc29sZS5sb2coJ2RvbmUnKTtcbiAgICAgICAgKiAgICB9KTtcbiAgICAgICAgKiAgfSwgMzAwKTtcbiAgICAgICAgKiBgYGBgXG4gICAgICAgICovXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGUoZWwsIGZpbmFsKSB7XG4gICAgICAgICB2YXIgZHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAyMDAgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgIGluaXRpYWwgPSB7fSxcbiAgICAgICAgICAgICBzdG9wcGVkID0gZmFsc2UsXG4gICAgICAgICAgICAgbmV4dCA9IGZhbHNlLFxuICAgICAgICAgICAgIHRpbWVvdXQgPSBmYWxzZSxcbiAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoZmluYWwpO1xuXG4gICAgICAgICB2YXIgdXBkYXRlU3R5bGVzID0gZnVuY3Rpb24gdXBkYXRlU3R5bGVzKCkge1xuICAgICAgICAgICB2YXIgcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKHMuZ2V0UHJvcGVydHlWYWx1ZS5iaW5kKHMpKTtcbiAgICAgICAgICAgcyA9IGVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgIH07XG5cbiAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgIHZhciBrID0gTWF0aC5taW4oMSwgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgZWwuc3R5bGVbaV0gPSAoMSAtIGspICogaW5pdGlhbFtpXSArIGsgKiBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcblxuICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0b3BOZXh0KSB7XG4gICAgICAgICAgICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgfSBlbHNlIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgdGhlbjogZnVuY3Rpb24gdGhlbihjYikge1xuICAgICAgICAgICAgIG5leHQgPSBjYjtcbiAgICAgICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgbmV4dCAmJiBuZXh0KCk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIHNwZWVkOiBmdW5jdGlvbiBzcGVlZChuZXdEdXJhdGlvbikge1xuICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICBuZXdEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cbiAgICAgICAgICAgICAgICAgdmFyIHBhc3NlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgIHZhciBrID0gcGFzc2VkIC8gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSBuZXdEdXJhdGlvbiAqICgxIC0gayk7XG5cbiAgICAgICAgICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgZWwuc3R5bGVbaV0gPSAoMSAtIGspICogaW5pdGlhbFtpXSArIGsgKiBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgIHVwZGF0ZVN0eWxlcygpO1xuXG4gICAgICAgICAgICAgICAgIHN0YXJ0ID0gZWwuc3BlZWRVcFRpbWU7XG4gICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gcmVtYWluaW5nO1xuXG4gICAgICAgICAgICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uIC8gMTAwMCArICdzJztcblxuICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICBlbC5zdHlsZVtpXSA9IGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocmVzdWx0LnN0b3AsIHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gNTAgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgICAgICB2YXIgayA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xuXG4gICAgICAgICAgICAgcmVzdWx0LnNwZWVkKG1pbGxpc2Vjb25kcyAvICgxIC0gaykpO1xuICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH07XG5cbiAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgc3RvcHBlZCB8fCBpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICB2YXIgdiA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShlKSk7XG4gICAgICAgICAgIGluaXRpYWxbZV0gPSBpc05hTih2KSA/IDAgOiB2O1xuICAgICAgICAgfSk7XG5cbiAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBwcm9wZXJ0aWVzLmpvaW4oJywnKTtcbiAgICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gLyAxMDAwICsgJ3MnO1xuXG4gICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgIGVsLnN0eWxlW2VdID0gZmluYWxbZV0gKyAoZSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocmVzdWx0LnN0b3AsIGR1cmF0aW9uKTtcbiAgICAgICAgIHRoaXMuX29uU3RvcEFuaW1hdGlvbnMoZWwsIHJlc3VsdC5zdG9wKTtcblxuICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICB9XG4gICAgIH1dKTtcblxuICAgICBmdW5jdGlvbiBBbmltYXRvckNTUygpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5pbWF0b3JDU1MpO1xuXG4gICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICB0aGlzLl9pbmRleCA9IDA7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoQW5pbWF0b3JDU1MsIFt7XG4gICAgICAga2V5OiAnX29uU3RvcEFuaW1hdGlvbnMnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25TdG9wQW5pbWF0aW9ucyhlbCwgbGlzdGVuZXIpIHtcbiAgICAgICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgICAgICAgdmFyIGkgPSB0aGlzLl9pbmRleCsrO1xuICAgICAgICAgcXVldWVbZWxdID0gcXVldWVbZWxdIHx8IFtdO1xuICAgICAgICAgcXVldWVbZWxdW2ldID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgZGVsZXRlIHF1ZXVlW2VsXVtpXTtcbiAgICAgICAgICAgaWYgKHF1ZXVlW2VsXSAmJiBxdWV1ZVtlbF0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICBkZWxldGUgcXVldWVbZWxdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiBsaXN0ZW5lcihvcHRpb25zKTtcbiAgICAgICAgIH07XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIHN0b3BBbmltYXRpb25zXG4gICAgICAgKiBAZGVzYyBzdG9wcyBhY3RpdmUgYW5pbWF0aW9ucyBvbiBhIHNwZWNpZmllZCBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXl9IGVsZW1lbnQgLSBlbGVtZW50IG9yIGFycmF5IG9mIGVsZW1lbnRzXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3BOZXh0XSAtIHRoZSBjYWxsYmFja3MgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgd29uJ3QgYmUgY2FsbGVkIGlmIHRoaXMgb3B0aW9uIGlzIHRydWVcbiAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdzdG9wQW5pbWF0aW9ucycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BBbmltYXRpb25zKGVsKSB7XG4gICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgICAgICAgcmV0dXJuIGVsLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgX3RoaXMuc3RvcEFuaW1hdGlvbnMoZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgIH1cblxuICAgICAgICAgKHRoaXMuX3F1ZXVlW2VsXSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICBlKG9wdGlvbnMgfHwge30pO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIHN0b3BBbGxcbiAgICAgICAqIEBkZXNjIHN0b3BzIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdG9wTmV4dF0gLSB0aGUgY2FsbGJhY2tzIGFmdGVyIHRoZSBhbmltYXRpb25zIHdvbid0IGJlIGNhbGxlZCBpZiB0aGlzIG9wdGlvbiBpcyB0cnVlXG4gICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnc3RvcEFsbCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BBbGwoKSB7XG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgICB0aGlzLnN0b3BBbmltYXRpb25zKE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlKSwgb3B0aW9ucyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIGZhZGVcbiAgICAgICAqIEBkZXNjIGZhZGVzIHRoZSBlbGVtZW50IChzaG9ydCB2ZXJzaW9uIGZvciBhbmltYXRlKGVsLCB7b3BhY2l0eTogMH0pKVxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF1cbiAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdmYWRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmFkZShlbCkge1xuICAgICAgICAgdmFyIGR1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMjAwIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKGVsLCB7IG9wYWNpdHk6IDAgfSwgZHVyYXRpb24pO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gQW5pbWF0b3JDU1M7XG4gICB9KSgpO1xuXG4gICAvKipcbiAgICAqIEBlbGVtZW50IG9ucy1yaXBwbGVcbiAgICAqIEBjYXRlZ29yeSBmb3JtXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXUFkZHMgYSBNYXRlcmlhbCBEZXNpZ24gXCJyaXBwbGVcIiBlZmZlY3QgdG8gYW4gZWxlbWVudC5bL2VuXVxuICAgICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oq44OD44OX44Or5Yq55p6c44KSRE9N6KaB57Sg44Gr6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICAqIEBjb2RlcGVuIHdLUVdkWlxuICAgICogQGV4YW1wbGVcbiAgICAqIDxvbnMtbGlzdD5cbiAgICAqICAgPG9ucy1saXN0LWl0ZW0+XG4gICAgKiAgICA8b25zLXJpcHBsZSBjb2xvcj1cInJnYmEoMCwgMCwgMCwgMC4zKVwiPjwvb25zLXJpcHBsZT5cbiAgICAqICAgIENsaWNrIG1lIVxuICAgICogICA8L29ucy1saXN0LWl0ZW0+XG4gICAgKiA8L29ucy1saXN0PlxuICAgICovXG5cbiAgIHZhciBSaXBwbGVFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKFJpcHBsZUVsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gUmlwcGxlRWxlbWVudCgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgUmlwcGxlRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihSaXBwbGVFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhSaXBwbGVFbGVtZW50LCBbe1xuICAgICAgIGtleTogJ2NyZWF0ZWRDYWxsYmFjaycsXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGNvbG9yXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGNvbG9yXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGJhY2tncm91bmRcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZC5bL2VuXVxuICAgICAgICAqICAgW2phXeiDjOaZr+OBruiJsuOCkuioreWumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCB0aGUgcmlwcGxlIGVmZmVjdCB3aWxsIGJlIGRpc2FibGVkLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Oq44OD44OX44Or44Ko44OV44Kn44Kv44OI44Gv54Sh5Yq544Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdyaXBwbGUnKTtcbiAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQgPSB0aGlzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JpcHBsZV9fYmFja2dyb3VuZCcpWzBdO1xuICAgICAgICAgICB0aGlzLl93YXZlID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaXBwbGVfX3dhdmUnKVswXTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5fYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3JDU1MoKTtcblxuICAgICAgICAgWydjb2xvcicsICdjZW50ZXInLCAnc3RhcnQtcmFkaXVzJywgJ2JhY2tncm91bmQnXS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgIF90aGlzMi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZSwgbnVsbCwgX3RoaXMyLmdldEF0dHJpYnV0ZShlKSk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgIFsnX3dhdmUnLCAnX2JhY2tncm91bmQnXS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgIF90aGlzM1tlXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICBfdGhpczNbZV0uY2xhc3NMaXN0LmFkZCgncmlwcGxlXycgKyBlKTtcbiAgICAgICAgICAgX3RoaXMzLmFwcGVuZENoaWxkKF90aGlzM1tlXSk7XG4gICAgICAgICB9KTtcbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2NhbGN1bGF0ZUNvb3JkcycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVDb29yZHMoZSkge1xuICAgICAgICAgdmFyIHgsIHksIGgsIHcsIHI7XG4gICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICBpZiAodGhpcy5fY2VudGVyKSB7XG4gICAgICAgICAgIHggPSBiLndpZHRoIC8gMjtcbiAgICAgICAgICAgeSA9IGIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHggPSAoZS5jbGllbnRYIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCkgLSBiLmxlZnQ7XG4gICAgICAgICAgIHkgPSAoZS5jbGllbnRZIHx8IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSkgLSBiLnRvcDtcbiAgICAgICAgICAgaCA9IE1hdGgubWF4KHksIGIuaGVpZ2h0IC0geSk7XG4gICAgICAgICAgIHcgPSBNYXRoLm1heCh4LCBiLndpZHRoIC0geCk7XG4gICAgICAgICAgIHIgPSBNYXRoLnNxcnQoaCAqIGggKyB3ICogdyk7XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5LCByOiByIH07XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3JpcHBsZUFuaW1hdGlvbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yaXBwbGVBbmltYXRpb24oZSkge1xuICAgICAgICAgdmFyIGR1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMzAwIDogYXJndW1lbnRzWzFdO1xuICAgICAgICAgdmFyIF9hbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yO1xuICAgICAgICAgdmFyIF93YXZlID0gdGhpcy5fd2F2ZTtcbiAgICAgICAgIHZhciBfYmFja2dyb3VuZCA9IHRoaXMuX2JhY2tncm91bmQ7XG5cbiAgICAgICAgIHZhciBfbWluUiA9IHRoaXMuX21pblI7XG5cbiAgICAgICAgIHZhciBfY2FsY3VsYXRlQ29vcmRzMiA9IHRoaXMuX2NhbGN1bGF0ZUNvb3JkcyhlKTtcblxuICAgICAgICAgdmFyIHggPSBfY2FsY3VsYXRlQ29vcmRzMi54O1xuICAgICAgICAgdmFyIHkgPSBfY2FsY3VsYXRlQ29vcmRzMi55O1xuICAgICAgICAgdmFyIHIgPSBfY2FsY3VsYXRlQ29vcmRzMi5yO1xuXG4gICAgICAgICBfYW5pbWF0b3Iuc3RvcEFsbCh7IHN0b3BOZXh0OiAxIH0pO1xuICAgICAgICAgX2FuaW1hdG9yLmFuaW1hdGUoX2JhY2tncm91bmQsIHsgb3BhY2l0eTogMSB9LCBkdXJhdGlvbik7XG5cbiAgICAgICAgIHV0aWwuZXh0ZW5kKF93YXZlLnN0eWxlLCB7XG4gICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgIHRvcDogeSAtIF9taW5SICsgJ3B4JyxcbiAgICAgICAgICAgbGVmdDogeCAtIF9taW5SICsgJ3B4JyxcbiAgICAgICAgICAgd2lkdGg6IDIgKiBfbWluUiArICdweCcsXG4gICAgICAgICAgIGhlaWdodDogMiAqIF9taW5SICsgJ3B4J1xuICAgICAgICAgfSk7XG5cbiAgICAgICAgIHJldHVybiBfYW5pbWF0b3IuYW5pbWF0ZShfd2F2ZSwge1xuICAgICAgICAgICB0b3A6IHkgLSByLFxuICAgICAgICAgICBsZWZ0OiB4IC0gcixcbiAgICAgICAgICAgaGVpZ2h0OiAyICogcixcbiAgICAgICAgICAgd2lkdGg6IDIgKiByXG4gICAgICAgICB9LCBkdXJhdGlvbik7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZVBhcmVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVQYXJlbnQoKSB7XG4gICAgICAgICBpZiAoIXRoaXMuX3BhcmVudFVwZGF0ZWQgJiYgdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHRoaXMuX3BhcmVudFVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vblRhcCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vblRhcChlKSB7XG4gICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQoKSkge1xuICAgICAgICAgICB0aGlzLl91cGRhdGVQYXJlbnQoKTtcbiAgICAgICAgICAgdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgX3RoaXM0Ll9hbmltYXRvci5mYWRlKF90aGlzNC5fd2F2ZSk7XG4gICAgICAgICAgICAgX3RoaXM0Ll9hbmltYXRvci5mYWRlKF90aGlzNC5fYmFja2dyb3VuZCk7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkhvbGQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Ib2xkKGUpIHtcbiAgICAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkKCkpIHtcbiAgICAgICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICAgICAgIHRoaXMuX2hvbGRpbmcgPSB0aGlzLl9yaXBwbGVBbmltYXRpb24oZS5nZXN0dXJlLnNyY0V2ZW50LCAyMDAwKTtcbiAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX2JvdW5kT25SZWxlYXNlKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25SZWxlYXNlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uUmVsZWFzZShlKSB7XG4gICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICAgaWYgKHRoaXMuX2hvbGRpbmcpIHtcbiAgICAgICAgICAgdGhpcy5faG9sZGluZy5zcGVlZCgzMDApLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIF90aGlzNS5fYW5pbWF0b3Iuc3RvcEFsbCh7IHN0b3BOZXh0OiB0cnVlIH0pO1xuICAgICAgICAgICAgIF90aGlzNS5fYW5pbWF0b3IuZmFkZShfdGhpczUuX3dhdmUpO1xuICAgICAgICAgICAgIF90aGlzNS5fYW5pbWF0b3IuZmFkZShfdGhpczUuX2JhY2tncm91bmQpO1xuICAgICAgICAgICB9KTtcblxuICAgICAgICAgICB0aGlzLl9ob2xkaW5nID0gZmFsc2U7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRHJhZ1N0YXJ0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJhZ1N0YXJ0KGUpIHtcbiAgICAgICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLl9vblJlbGVhc2UoZSk7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAoWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSAhPSAtMSkge1xuICAgICAgICAgICB0aGlzLl9vblRhcChlKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuX3BhcmVudE5vZGUgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICAgICB0aGlzLl9ib3VuZE9uVGFwID0gdGhpcy5fb25UYXAuYmluZCh0aGlzKTtcbiAgICAgICAgIHRoaXMuX2JvdW5kT25Ib2xkID0gdGhpcy5fb25Ib2xkLmJpbmQodGhpcyk7XG4gICAgICAgICB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0ID0gdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgIHRoaXMuX2JvdW5kT25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgIGlmIChpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICAgICAgIHRoaXMuc2V0RGlzYWJsZWQodHJ1ZSk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuX2JvdW5kT25UYXApO1xuICAgICAgICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9ib3VuZE9uSG9sZCk7XG4gICAgICAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fYm91bmRPbkRyYWdTdGFydCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZGV0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLl9wYXJlbnROb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuX2JvdW5kT25UYXApO1xuICAgICAgICAgdGhpcy5fcGFyZW50Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fYm91bmRPbkhvbGQpO1xuICAgICAgICAgdGhpcy5fcGFyZW50Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgaWYgKG5hbWUgPT09ICdzdGFydC1yYWRpdXMnKSB7XG4gICAgICAgICAgIHRoaXMuX21pblIgPSBNYXRoLm1heCgwLCBwYXJzZUZsb2F0KGN1cnJlbnQpIHx8IDApO1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKG5hbWUgPT09ICdjb2xvcicgJiYgY3VycmVudCkge1xuICAgICAgICAgICB0aGlzLl93YXZlLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdiYWNrZ3JvdW5kJykpIHtcbiAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBpZiAobmFtZSA9PT0gJ2JhY2tncm91bmQnICYmIChjdXJyZW50IHx8IGxhc3QpKSB7XG4gICAgICAgICAgIGlmIChjdXJyZW50ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChuYW1lID09PSAnY2VudGVyJykge1xuICAgICAgICAgICB0aGlzLl9jZW50ZXIgPSBjdXJyZW50ICE9IG51bGwgJiYgY3VycmVudCAhPSAnZmFsc2UnO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICogRGlzYWJsZSBvciBlbmFibGUgcmlwcGxlLWVmZmVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59XG4gICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnc2V0RGlzYWJsZWQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgICAgICAgaWYgKHR5cGVvZiBkaXNhYmxlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4uJyk7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJycpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogVHJ1ZSBpZiByaXBwbGUtZWZmZWN0IGlzIGRpc2FibGVkLlxuICAgICAgICAqXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNEaXNhYmxlZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGlzYWJsZWQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7IC8vIHx8IHRoaXMucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBSaXBwbGVFbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zUmlwcGxlRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXJpcHBsZScsIHtcbiAgICAgcHJvdG90eXBlOiBSaXBwbGVFbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIC8qXG4gICBDb3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiAgICovXG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLXJvd1xuICAgICogQGNhdGVnb3J5IGdyaWRcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dUmVwcmVzZW50cyBhIHJvdyBpbiB0aGUgZ3JpZCBzeXN0ZW0uIFVzZSB3aXRoIG9ucy1jb2wgdG8gbGF5b3V0IGNvbXBvbmVudHMuWy9lbl1cbiAgICAqICAgW2phXeOCsOODquODg+ODieOCt+OCueODhuODoOOBq+OBpuihjOOCkuWumue+qeOBl+OBvuOBmeOAgm9ucy1jb2zjgajjgajjgoLjgavkvb/nlKjjgZfjgIHjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7phY3nva7jgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQGNvZGVwZW4gR2d1akMge3dpZGV9XG4gICAgKiBAZ3VpZGUgTGF5b3V0aW5nXG4gICAgKiAgIFtlbl1MYXlvdXRpbmcgZ3VpZGVbL2VuXVxuICAgICogICBbamFd44Os44Kk44Ki44Km44OI6Kq/5pW0Wy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1jb2xcbiAgICAqICAgW2VuXW9ucy1jb2wgY29tcG9uZW50Wy9lbl1cbiAgICAqICAgW2phXW9ucy1jb2zjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICAgICogQG5vdGVcbiAgICAqICAgW2VuXUZvciBBbmRyb2lkIDQuMyBhbmQgZWFybGllciwgYW5kIGlPUzYgYW5kIGVhcmxpZXIsIHdoZW4gdXNpbmcgbWl4ZWQgYWxpZ25tZW50IHdpdGggb25zLXJvdyBhbmQgb25zLWNvbCwgdGhleSBtYXkgbm90IGJlIGRpc3BsYXllZCBjb3JyZWN0bHkuIFlvdSBjYW4gdXNlIG9ubHkgb25lIHZlcnRpY2FsLWFsaWduLlsvZW5dXG4gICAgKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbOOCkue1hOOBv+WQiOOCj+OBm+OBpuOBneOCjOOBnuOCjOOBrm9ucy1jb2zopoHntKDjga52ZXJ0aWNhbC1hbGlnbuWxnuaAp+OBruWApOOBq+WIpeOAheOBruWApOOCkuaMh+WumuOBmeOCi+OBqOOAgeaPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAgnZlcnRpY2FsLWFsaWdu5bGe5oCn44Gu5YCk44Gr44Gv5LiA44Gk44Gu5YCk44Gg44GR44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8b25zLXJvdz5cbiAgICAqICAgPG9ucy1jb2wgd2lkdGg9XCI1MHB4XCI+PG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj48L29ucy1jb2w+XG4gICAgKiAgIDxvbnMtY29sPlRleHQ8L29ucy1jb2w+XG4gICAgKiA8L29ucy1yb3c+XG4gICAgKi9cblxuICAgLyoqXG4gICAgKiBAYXR0cmlidXRlIHZlcnRpY2FsLWFsaWduXG4gICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1TaG9ydCBoYW5kIGF0dHJpYnV0ZSBmb3IgYWxpZ25pbmcgdmVydGljYWxseS4gVmFsaWQgdmFsdWVzIGFyZSB0b3AsIGJvdHRvbSwgYW5kIGNlbnRlci5bL2VuXVxuICAgICogICBbamFd57im44Gr5pW05YiX44GZ44KL44Gf44KB44Gr5oyH5a6a44GX44G+44GZ44CCdG9w44CBYm90dG9t44CBY2VudGVy44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAqL1xuICAgd2luZG93Lk9uc1Jvd0VsZW1lbnQgPSB3aW5kb3cuT25zUm93RWxlbWVudCA/IHdpbmRvdy5PbnNSb3dFbGVtZW50IDogZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtcm93Jyk7XG5cbiAgIC8vIFRPRE86IEFkZCBjb2RlcGVuIGV4YW1wbGUuXG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLXJpcHBsZVxuICAgICogQGNhdGVnb3J5IGNvbnRyb2xcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dQWRkcyBzY3JvbGxiYXIgdG8gdGhlIHBhcmVudCBlbGVtZW50LiBOT1RFOiB0aGUgcGFyZW50IHNob3VsZCBoYXZlIGEgZml4ZWQgc2l6ZS5bL2VuXVxuICAgICogICBbamFdWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8ZGl2PlxuICAgICogICBMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldC4uLlxuICAgICogICA8b25zLXNjcm9sbGJhciBkcmFnZ2FibGU+PC9vbnMtc2Nyb2xsYmFyPlxuICAgICogPC9kaXY+XG4gICAgKlxuICAgICogPGRpdj5cbiAgICAqICAgTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQuLi5cbiAgICAqICAgPG9ucy1zY3JvbGxiYXIgYXV0b2hpZGU+PC9vbnMtc2Nyb2xsYmFyPlxuICAgICogPC9kaXY+XG4gICAgKi9cblxuICAgdmFyIFNjcm9sbGJhckVsZW1lbnQgPSAoZnVuY3Rpb24gKF9CYXNlRWxlbWVudCkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoU2Nyb2xsYmFyRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBTY3JvbGxiYXJFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JvbGxiYXJFbGVtZW50KTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNjcm9sbGJhckVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKFNjcm9sbGJhckVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgaGVpZ2h0XG4gICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1JZiBzZXQgdGhlbiB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGxiYXIgd2lsbCBiZSBmaXhlZCB0byB0aGlzIHZhbHVlLiBPdGhlcndpc2UgaXQgd2lsbCBiZSBhIGR5bmFtaWMgdmFsdWUgYmFzZWQgb24gdGhlIHZpc2libGUgcHJvcG9ydGlvbiBvZiB0aGUgY29udGVudC4gVGhlIHZhbHVlIGNhbiBvbmx5IGJlIGluIHB4IGFuZCBpcyBpZ25vcmVkIGlmIGl0J3MgemVyby5bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGRyYWdnYWJsZVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGVuIHRoZSBzY3JvbGxiYXIgd2lsbCBiZSBkcmFnZ2FibGUuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBhdXRvaGlkZVxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZW4gdGhlIHNjcm9sbGJhciB3aWxsIGRpc2FwcGVhciBzaG9ydGx5IGFmdGVyIHNjcm9sbGluZy5bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGF1dG9oaWRlLWRlbGF5XG4gICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1EZWxheSAoaW4gbXMpIGFmdGVyIHdoaWNoIHRoZSBzY3JvbGxiYXIgd2lsbCBkaXNhcHBlYXIgaWYgYXV0b2hpZGUgaXMgc2V0LlsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgaGlkZGVuXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlbiB0aGUgc2Nyb2xsYmFyIHdpbGwgYmUgaGlkZGVuIHdpdGggYGRpc3BsYXk6IG5vbmVgLlsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgbmF0aXZlXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAaW5pdG9ubHlcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlbiBuYXRpdmUgc2Nyb2xsYmFyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBqYXZhc2NyaXB0IG9uZS5bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIHVwZGF0ZS1vbi1zY3JvbGxcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlbiB0aGUgc2Nyb2xsYmFyIHdpbGwgdXBkYXRlIGl0J3Mgc2l6ZSBhbmQgY29udGFpbmVyIG9uIGV2ZXJ5IHNjcm9sbCBldmVudC4gVXNlZnVsIGlmIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IGNoYW5nZXMgZnJlcXVlbnRseS4gT3RoZXJ3aXNlIGB1cGRhdGVTY3JvbGxiYXJgIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIG1hbnVhbGx5IHdoZW4gdGhlIGNvbnRlbnQgc2l6ZSBjaGFuZ2VzLiBbL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICovXG5cbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRoaXMuX3Njcm9sbCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcuc2Nyb2xsYmFyJyk7XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLl90aW1lb3V0ID0gZmFsc2U7XG5cbiAgICAgICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICAgdGhpcy5fYm91bmRPblNjcm9sbCA9IHRoaXMuX29uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICAgICB0aGlzLl9ib3VuZE9uUmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcblxuICAgICAgICAgWydoZWlnaHQnLCAnZHJhZ2dhYmxlJywgJ2F1dG9oaWRlJywgJ2F1dG9oaWRlLWRlbGF5JywgJ2hpZGRlbicsICduYXRpdmUnLCAndXBkYXRlLW9uLXNjcm9sbCddLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgX3RoaXMyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlLCBudWxsLCBfdGhpczIuZ2V0QXR0cmlidXRlKGUpKTtcbiAgICAgICAgIH0pO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jb21waWxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBpbGUoKSB7XG4gICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Njcm9sbGJhci1jb250YWluZXInKTtcbiAgICAgICAgIHRoaXMuX3Njcm9sbCA9IHV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cInNjcm9sbGJhclwiPjxkaXYgY2xhc3M9XCJzY3JvbGxiYXItdG91Y2hcIj48L2Rpdj48L2Rpdj4nKTtcbiAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fc2Nyb2xsKTtcbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2F0dGFjaCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hdHRhY2goKSB7XG4gICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMucGFyZW50Tm9kZSk7XG4gICAgICAgICBpZiAoc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2NvbnRlbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXYgY2xhc3M9XCJzY3JvbGxiYXItY29udGVudFwiPjwvZGl2PicpO1xuICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgaWYgKGUgIT0gX3RoaXMzKSB7XG4gICAgICAgICAgICAgX3RoaXMzLl9jb250ZW50LmFwcGVuZENoaWxkKGUpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9KTtcbiAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5fY29udGVudCwgdGhpcyk7XG4gICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2F0dGFjaGVkJywgJycpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vblNjcm9sbCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vblNjcm9sbChlKSB7XG4gICAgICAgICBpZiAodGhpcy5fdXBkYXRlT25TY3JvbGwpIHtcbiAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxiYXIoKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbGJhckxvY2F0aW9uKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICh0aGlzLl9hdXRvaGlkZSkge1xuICAgICAgICAgICB0aGlzLl91cGRhdGVBdXRvaGlkZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vblJlc2l6ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vblJlc2l6ZShlKSB7XG4gICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbGJhcigpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGVBdXRvaGlkZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVBdXRvaGlkZSgpIHtcbiAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgICBpZiAoIXRoaXMuX3Njcm9sbGluZykge1xuICAgICAgICAgICB0aGlzLl9zY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3Njcm9sbGJhci1hdXRvaGlkZS12aXNpYmxlJyk7XG4gICAgICAgICB9XG4gICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIF90aGlzNC5fc2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgIF90aGlzNC5jbGFzc0xpc3QucmVtb3ZlKCdzY3JvbGxiYXItYXV0b2hpZGUtdmlzaWJsZScpO1xuICAgICAgICAgfSwgdGhpcy5fYXV0b2hpZGVEZWxheSk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCB1cGRhdGVTY3JvbGxiYXJcbiAgICAgICAgKiBAc2lnbmF0dXJlIHVwZGF0ZVNjcm9sbGJhcigpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dVXBkYXRlcyB0aGUgc2Nyb2xsYmFyIHNpemUgYW5kIGxvY2F0aW9uLiBTaG91bGQgYmUgY2FsbGVkIGlmIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IGNoYW5nZXMuIEF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW4gb25JbmZpbml0ZVNjcm9sbCBoYW5kbGVyIGlzIGZpbmlzaGVkLlsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAndXBkYXRlU2Nyb2xsYmFyJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFyKCkge1xuICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9jb250ZW50O1xuICAgICAgICAgdmFyIHNjcm9sbCA9IHRoaXMuX3Njcm9sbDtcbiAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICBpZiAoIXRoaXMuX2hpZGRlbiAmJiAhdGhpcy5fbmF0aXZlKSB7XG4gICAgICAgICAgIHNjcm9sbC5zdHlsZS5kaXNwbGF5ID0gY29udGVudC5jbGllbnRIZWlnaHQgPj0gY29udGVudC5zY3JvbGxIZWlnaHQgPyAnbm9uZScgOiAnYmxvY2snO1xuICAgICAgICAgICBzY3JvbGwuc3R5bGUuaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLl9oZWlnaHQgfHwgY29udGFpbmVyLmNsaWVudEhlaWdodCAqIGNvbnRlbnQuY2xpZW50SGVpZ2h0IC8gY29udGVudC5zY3JvbGxIZWlnaHQpICsgJ3B4JztcbiAgICAgICAgICAgdGhpcy5fY29udGVudE1heCA9IGNvbnRlbnQuc2Nyb2xsSGVpZ2h0IC0gY29udGVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgIHRoaXMuX3Njcm9sbE1heCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgLSBzY3JvbGwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxiYXJMb2NhdGlvbigpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGVTY3JvbGxiYXJMb2NhdGlvbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVTY3JvbGxiYXJMb2NhdGlvbigpIHtcbiAgICAgICAgIHRoaXMuX3Njcm9sbC5zdHlsZS50b3AgPSBNYXRoLnJvdW5kKHRoaXMuX3Njcm9sbE1heCAqIHRoaXMuX2NvbnRlbnQuc2Nyb2xsVG9wIC8gdGhpcy5fY29udGVudE1heCkgKyAncHgnO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkRyYWdTdGFydCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRyYWdTdGFydChlKSB7XG4gICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICAgdmFyIHN0YXJ0WSA9IHRoaXMuX3Njcm9sbC5vZmZzZXRUb3A7XG4gICAgICAgICB2YXIgb25Nb3ZlID0gZnVuY3Rpb24gb25Nb3ZlKGUpIHtcbiAgICAgICAgICAgX3RoaXM1LmNsYXNzTGlzdC5hZGQoJ3Njcm9sbGJhci1kcmFnZ2luZycpO1xuICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCAoc3RhcnRZICsgZS5nZXN0dXJlLmRlbHRhWSkgLyBfdGhpczUuX3Njcm9sbE1heCkpO1xuICAgICAgICAgICBfdGhpczUuX2NvbnRlbnQuc2Nyb2xsVG9wID0gX3RoaXM1Ll9jb250ZW50TWF4ICogcHJvZ3Jlc3M7XG4gICAgICAgICB9O1xuICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZycsIG9uTW92ZSk7XG4gICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICBfdGhpczUuY2xhc3NMaXN0LnJlbW92ZSgnc2Nyb2xsYmFyLWRyYWdnaW5nJyk7XG4gICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWcnLCBvbk1vdmUpO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uVG91Y2hTdGFydCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vblRvdWNoU3RhcnQoZSkge1xuICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2F0dGFjaGVkJykpIHtcbiAgICAgICAgICAgdGhpcy5fYXR0YWNoKCk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5wYXJlbnROb2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3Njcm9sbGJhci1jb250ZW50JylbMF07XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICh0aGlzLl9uYXRpdmUpIHtcbiAgICAgICAgICAgdGhpcy5fY29udGVudC5jbGFzc0xpc3QuYWRkKCdzY3JvbGxiYXItbmF0aXZlJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2NvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCk7XG4gICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPblJlc2l6ZSk7XG4gICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbGJhcigpO1xuXG4gICAgICAgICBpZiAodGhpcy5fZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgIHRoaXMuX3Njcm9sbC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgICAgICAgICAgdGhpcy5fc2Nyb2xsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RldGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5fY29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uU2Nyb2xsKTtcbiAgICAgICAgIHRoaXMuX3Njcm9sbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgICAgICAgIHRoaXMuX3Njcm9sbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0KTtcbiAgICAgICAgIHRoaXMuX3RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25SZXNpemUpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgICBpZiAobmFtZSA9PT0gJ3VwZGF0ZS1vbi1zY3JvbGwnKSB7XG4gICAgICAgICAgIHRoaXMuX3VwZGF0ZU9uU2Nyb2xsID0gY3VycmVudCAhPT0gbnVsbDtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChuYW1lID09PSAnYXV0b2hpZGUtZGVsYXknKSB7XG4gICAgICAgICAgIHRoaXMuX2F1dG9oaWRlRGVsYXkgPSBwYXJzZUludChjdXJyZW50KSB8fCA1MDA7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAobmFtZSA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gcGFyc2VJbnQoY3VycmVudCkgfHwgMDtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChbJ2RyYWdnYWJsZScsICdhdXRvaGlkZScsICdoaWRkZW4nLCAnbmF0aXZlJ10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgdGhpc1snXycgKyBuYW1lXSA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLl9jb250ZW50ICYmIHRoaXMudXBkYXRlU2Nyb2xsYmFyKCk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBTY3JvbGxiYXJFbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zU2Nyb2xsYmFyRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXNjcm9sbGJhcicsIHtcbiAgICAgcHJvdG90eXBlOiBTY3JvbGxiYXJFbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIHZhciBzY2hlbWUkMTcgPSB7XG4gICAgICcnOiAnc3BlZWQtZGlhbF9faXRlbS0tKidcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLXNwZWVkLWRpYWwtaXRlbVxuICAgICogQGNhdGVnb3J5IHNwZWVkZGlhbFxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1UaGlzIGNvbXBvbmVudCBkaXNwbGF5cyB0aGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIE1hdGVyaWFsIERlc2lnbiBTcGVlZCBkaWFsIGNvbXBvbmVudC5bL2VuXVxuICAgICogICBbamFdTWF0ZXJpYWwgRGVzaWdu44GuU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkuihqOePvuOBmeOCi+imgee0oOOBp+OBmeOAglsvamFdXG4gICAgKiBAY29kZXBlbiBkWVFZTGdcbiAgICAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsXG4gICAgKiAgIFtlbl1vbnMtc3BlZWQtZGlhbCBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLXNwZWVkLWRpYWzjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICAgICogQGV4YW1wbGVcbiAgICAqIDxvbnMtc3BlZWQtZGlhbCBwb3NpdGlvbj1cImxlZnQgYm90dG9tXCI+XG4gICAgKiAgIDxvbnMtaWNvblxuICAgICogICAgIGljb249XCJmYS10d2l0dGVyXCJcbiAgICAqICAgICBzaXplPVwiMjZweFwiXG4gICAgKiAgICAgZml4ZWQtd2lkdGg9XCJmYWxzZVwiXG4gICAgKiAgICAgc3R5bGU9XCJ2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7XCI+XG4gICAgKiAgIDwvb25zLWljb24+XG4gICAgKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPjxvbnMtcmlwcGxlPjwvb25zLXJpcHBsZT5DPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICAgICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT48b25zLXJpcHBsZT48L29ucy1yaXBwbGU+Qjwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAgICAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+PG9ucy1yaXBwbGU+PC9vbnMtcmlwcGxlPkE8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gICAgKiA8L29ucy1zcGVlZC1kaWFsPlxuICAgICovXG5cbiAgIHZhciBTcGVlZERpYWxJdGVtRWxlbWVudCA9IChmdW5jdGlvbiAoX0Jhc2VFbGVtZW50KSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhTcGVlZERpYWxJdGVtRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBTcGVlZERpYWxJdGVtRWxlbWVudCgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BlZWREaWFsSXRlbUVsZW1lbnQpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3BlZWREaWFsSXRlbUVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKFNwZWVkRGlhbEl0ZW1FbGVtZW50LCBbe1xuICAgICAgIGtleTogJ2NyZWF0ZWRDYWxsYmFjaycsXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgY29tcG9uZW50LlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lJDE3KTtcbiAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdkZXRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfdXBkYXRlUmlwcGxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICAgICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkNsaWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2xpY2soZSkge1xuICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiJyk7XG4gICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tbWluaScpO1xuICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzcGVlZC1kaWFsX19pdGVtJyk7XG5cbiAgICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSQxNyk7XG5cbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBTcGVlZERpYWxJdGVtRWxlbWVudDtcbiAgIH0pKEJhc2VFbGVtZW50KTtcblxuICAgd2luZG93Lk9uc1NwZWVkRGlhbEl0ZW1FbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BlZWQtZGlhbC1pdGVtJywge1xuICAgICBwcm90b3R5cGU6IFNwZWVkRGlhbEl0ZW1FbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIHZhciBzY2hlbWUkMTggPSB7XG4gICAgICcnOiAnc3BlZWQtZGlhbC0tKidcbiAgIH07XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLXNwZWVkLWRpYWxcbiAgICAqIEBjYXRlZ29yeSBzcGVlZGRpYWxcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogICBbZW5dRWxlbWVudCB0aGF0IGRpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIFNwZWVkIERpYWxvZyBjb21wb25lbnQuWy9lbl1cbiAgICAqICAgW2phXU1hdGVyaWFsIERlc2lnbuOBrlNwZWVkIGRpYWzjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLooajnj77jgZnjgovopoHntKDjgafjgZnjgIJbL2phXVxuICAgICogQGNvZGVwZW4gZFlRWUxnXG4gICAgKiBAc2VlYWxzbyBvbnMtc3BlZWQtZGlhbC1pdGVtXG4gICAgKiAgIFtlbl1vbnMtc3BlZWQtZGlhbC1pdGVtIGNvbXBvbmVudFsvZW5dXG4gICAgKiAgIFtqYV1vbnMtc3BlZWQtZGlhbC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8b25zLXNwZWVkLWRpYWwgcG9zaXRpb249XCJsZWZ0IGJvdHRvbVwiPlxuICAgICogICA8b25zLWljb25cbiAgICAqICAgICBpY29uPVwiZmEtdHdpdHRlclwiXG4gICAgKiAgICAgc2l6ZT1cIjI2cHhcIlxuICAgICogICAgIGZpeGVkLXdpZHRoPVwiZmFsc2VcIlxuICAgICogICAgIHN0eWxlPVwidmVydGljYWwtYWxpZ246bWlkZGxlO1wiPlxuICAgICogICA8L29ucy1pY29uPlxuICAgICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT48b25zLXJpcHBsZT48L29ucy1yaXBwbGU+Qzwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAgICAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+PG9ucy1yaXBwbGU+PC9vbnMtcmlwcGxlPkI8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gICAgKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPjxvbnMtcmlwcGxlPjwvb25zLXJpcHBsZT5BPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICAgICogPC9vbnMtc3BlZWQtZGlhbD5cbiAgICAqL1xuXG4gICB2YXIgU3BlZWREaWFsRWxlbWVudCA9IChmdW5jdGlvbiAoX0Jhc2VFbGVtZW50KSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhTcGVlZERpYWxFbGVtZW50LCBfQmFzZUVsZW1lbnQpO1xuXG4gICAgIGZ1bmN0aW9uIFNwZWVkRGlhbEVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFNwZWVkRGlhbEVsZW1lbnQpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3BlZWREaWFsRWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoU3BlZWREaWFsRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGNvbXBvbmVudC5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1cbiAgICAgICAgKiAgICAgU3BlY2lmeSB0aGUgdmVydGljYWwgYW5kIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgKiAgICAgSS5lLiB0byBkaXNwbGF5IGl0IGluIHRoZSB0b3AgcmlnaHQgY29ybmVyIHNwZWNpZnkgXCJyaWdodCB0b3BcIi5cbiAgICAgICAgKiAgICAgQ2hvb3NlIGZyb20gXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiBhbmQgXCJib3R0b21cIi5cbiAgICAgICAgKiAgIFsvZW5dXG4gICAgICAgICogICBbamFdXG4gICAgICAgICogICAgIOOBk+OBruimgee0oOOCkuihqOekuuOBmeOCi+W3puWPs+OBqOS4iuS4i+OBruS9jee9ruOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgICAgICAqICAgICDkvovjgYjjgbDjgIHlj7PkuIrjgavooajnpLrjgZnjgovloLTlkIjjgavjga9cInJpZ2h0IHRvcFwi44KS5oyH5a6a44GX44G+44GZ44CCXG4gICAgICAgICogICAgIOW3puWPs+OBqOS4iuS4i+OBruS9jee9ruOBruaMh+WumuOBq+OBr+OAgXJpZ2h044GobGVmdOOAgXRvcOOBqGJvdHRvbeOBjOOBneOCjOOBnuOCjOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgICAgICAqICAgWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgZGlyZWN0aW9uXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBkaXJlY3Rpb24gdGhlIGl0ZW1zIGFyZSBkaXNwbGF5ZWQuIFBvc3NpYmxlIHZhbHVlcyBhcmUgXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIgYW5kIFwicmlnaHRcIi5bL2VuXVxuICAgICAgICAqICAgW2phXVxuICAgICAgICAqICAgICDopoHntKDjgYzooajnpLrjgZnjgovmlrnlkJHjgpLmjIflrprjgZfjgb7jgZnjgIJ1cCwgZG93biwgbGVmdCwgcmlnaHTjgYzmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICAgICAgKiAgIFsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAgICAgICogICBbamFd54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG5cbiAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzcGVlZF9fZGlhbCcpO1xuXG4gICAgICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGlyZWN0aW9uJykpIHtcbiAgICAgICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24odGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oJ3VwJyk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuICAgICAgICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgICB0aGlzLnNldERpc2FibGVkKHRydWUpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX3Nob3duID0gdHJ1ZTtcbiAgICAgICAgIHRoaXMuX2l0ZW1TaG93biA9IGZhbHNlO1xuICAgICAgICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jb21waWxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBpbGUoKSB7XG4gICAgICAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgICAgICAgdmFyIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtZmFiJyk7XG5cbiAgICAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSA4IHx8IG5vZGUubm9kZVR5cGUgPT09IDMgJiYgIS9cXFMvLnRlc3Qobm9kZS5ub2RlVmFsdWUpKSB7XG4gICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtc3BlZWQtZGlhbC1pdGVtJykge1xuICAgICAgICAgICAgIHV0aWwuZmluZENoaWxkKGNvbnRlbnQsICdzcGFuJykuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuXG4gICAgICAgICB0aGlzLmluc2VydEJlZm9yZShjb250ZW50LCB0aGlzLmZpcnN0Q2hpbGQpO1xuXG4gICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgICAgICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUkMTgpO1xuXG4gICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUkMTgpO1xuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlICdkaXJlY3Rpb24nOlxuICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbihjdXJyZW50KTtcbiAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgICAgICAgICB0aGlzLnNldERpc2FibGVkKGN1cnJlbnQgIT09IG51bGwpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RldGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkNsaWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2xpY2soZSkge1xuICAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQoKSkge1xuICAgICAgICAgICB0aGlzLnRvZ2dsZUl0ZW1zKCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3Nob3cnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdygpIHtcbiAgICAgICAgIGlmICghdGhpcy5pc0lubGluZSgpKSB7XG4gICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19oaWRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoKSB7XG4gICAgICAgICBpZiAoIXRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfdXBkYXRlUmlwcGxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICAgICAgIHZhciBmYWIgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWZhYicpO1xuICAgICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpID8gZmFiLnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpIDogZmFiLnJlbW92ZUF0dHJpYnV0ZSgncmlwcGxlJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZURpcmVjdGlvbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSAyNSAqIGkgKyAnbXMnO1xuICAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS53ZWJraXRUcmFuc2l0aW9uRGVsYXkgPSAyNSAqIGkgKyAnbXMnO1xuICAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5ib3R0b20gPSAnYXV0byc7XG4gICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSAnYXV0byc7XG4gICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSAnYXV0byc7XG4gICAgICAgICB9XG4gICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICBjYXNlICd1cCc6XG4gICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUuYm90dG9tID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUucmlnaHQgPSAnOHB4JztcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSAnOHB4JztcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xuICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUucmlnaHQgPSA3MiArIDU2ICogaSArICdweCc7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gJzhweCc7XG4gICAgICAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5sZWZ0ID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgb25lIG9mIHVwLCBkb3duLCBsZWZ0IG9yIHJpZ2h0LicpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGVQb3NpdGlvbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdmYWItLXRvcF9fbGVmdCcsICdmYWItLWJvdHRvbV9fcmlnaHQnLCAnZmFiLS1ib3R0b21fX2xlZnQnLCAnZmFiLS10b3BfX3JpZ2h0JywgJ2ZhYi0tdG9wX19jZW50ZXInLCAnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICAgICBjYXNlICd0b3AgcmlnaHQnOlxuICAgICAgICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX3JpZ2h0Jyk7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcbiAgICAgICAgICAgY2FzZSAnbGVmdCB0b3AnOlxuICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2xlZnQnKTtcbiAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAnYm90dG9tIHJpZ2h0JzpcbiAgICAgICAgICAgY2FzZSAncmlnaHQgYm90dG9tJzpcbiAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBjYXNlICdib3R0b20gbGVmdCc6XG4gICAgICAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19sZWZ0Jyk7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgICAgICBjYXNlICd0b3AgY2VudGVyJzpcbiAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19jZW50ZXInKTtcbiAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XG4gICAgICAgICAgIGNhc2UgJ2JvdHRvbSBjZW50ZXInOlxuICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgc2hvd1xuICAgICAgICAqIEBzaWduYXR1cmUgc2hvdygpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU2hvdyB0aGUgc3BlZWQgZGlhbC5bL2VuXVxuICAgICAgICAqICAgW2phXVNwZWVkIGRpYWzjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdzaG93JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWZhYicpLnNob3coKTtcbiAgICAgICAgIHRoaXMuX3Nob3duID0gdHJ1ZTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGhpZGVcbiAgICAgICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUhpZGUgdGhlIHNwZWVkIGRpYWwuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1TcGVlZCBkaWFs44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaGlkZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgdGhpcy5oaWRlSXRlbXMoKTtcbiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICBfdGhpczIucXVlcnlTZWxlY3Rvcignb25zLWZhYicpLmhpZGUoKTtcbiAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICB0aGlzLl9zaG93biA9IGZhbHNlO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgc2hvd0l0ZW1zXG4gICAgICAgICogQHNpZ25hdHVyZSBzaG93SXRlbXMoKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNob3cgdGhlIHNwZWVkIGRpYWwgaXRlbXMuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnc2hvd0l0ZW1zJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd0l0ZW1zKCkge1xuICAgICAgICAgaWYgKCF0aGlzLl9pdGVtU2hvd24pIHtcbiAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5pdGVtcztcbiAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSAyNSAqIGkgKyAnbXMnO1xuICAgICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLndlYmtpdFRyYW5zaXRpb25EZWxheSA9IDI1ICogaSArICdtcyc7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMuX2l0ZW1TaG93biA9IHRydWU7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBoaWRlSXRlbXNcbiAgICAgICAgKiBAc2lnbmF0dXJlIGhpZGVJdGVtcygpXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dSGlkZSB0aGUgc3BlZWQgZGlhbCBpdGVtcy5bL2VuXVxuICAgICAgICAqICAgW2phXVNwZWVkIGRpYWzjga7lrZDopoHntKDjgpLpnZ7ooajnpLrjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdoaWRlSXRlbXMnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlSXRlbXMoKSB7XG4gICAgICAgICBpZiAodGhpcy5faXRlbVNob3duKSB7XG4gICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoMCknO1xuICAgICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdzY2FsZSgwKSc7XG4gICAgICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gMjUgKiAoY2hpbGRyZW4ubGVuZ3RoIC0gaSkgKyAnbXMnO1xuICAgICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLndlYmtpdFRyYW5zaXRpb25EZWxheSA9IDI1ICogKGNoaWxkcmVuLmxlbmd0aCAtIGkpICsgJ21zJztcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgdGhpcy5faXRlbVNob3duID0gZmFsc2U7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBzZXREaXNhYmxlZFxuICAgICAgICAqIEBzaWduYXR1cmUgc2V0RGlzYWJsZWQoZGlzYWJsZWQpXG4gICAgICAgICogQHBhcmFtIHtCb29sZWFufVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXURpc2FibGUgb3IgZW5hYmxlIHRoZSBlbGVtZW50LlsvZW5dXG4gICAgICAgICogICBbamFdZGlzYWJsZWTnirbmhYvjgavjgZnjgovjgYvjganjgYbjgYvjgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdzZXREaXNhYmxlZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgICAgICBpZiAodHlwZW9mIGRpc2FibGVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbi4nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgIHRoaXMuaGlkZUl0ZW1zKCk7XG4gICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICcnKTtcbiAgICAgICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWInKSA/IGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICcnKSA6IHRydWU7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZmFiJykgPyBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKSA6IHRydWU7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaXNEaXNhYmxlZFxuICAgICAgICAqIEBzaWduYXR1cmUgaXNEaXNhYmxlZCgpXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKiAgIFtlbl10cnVlIGlmIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkLlsvZW5dXG4gICAgICAgICogICBbamFdZGlzYWJsZWTnirbmhYvjgavjgarjgaPjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGVuYWJsZWQgb3Igbm90LlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu6KaB57Sg44KS54Sh5Yq55YyW44GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNEaXNhYmxlZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGlzYWJsZWQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc0lubGluZVxuICAgICAgICAqIEBzaWduYXR1cmUgaXNJbmxpbmUoKVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgaW5saW5lIG9yIG5vdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOBk+OBruimgee0oOOBjOOCpOODs+ODqeOCpOODs+imgee0oOOBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzSW5saW5lJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbmxpbmUoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2lubGluZScpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgaXNTaG93blxuICAgICAgICAqIEBzaWduYXR1cmUgaXNTaG93bigpXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKiAgIFtlbl1UcnVlIGlmIHRoZSBjb21wb25lbnQgaXMgdmlzaWJsZS5bL2VuXVxuICAgICAgICAqICAgW2phXeihqOekuuOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJuIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgICAgICAqICAgW2phXeihqOekuuOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzU2hvd24nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1Nob3duKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3duICYmIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzSXRlbVNob3duJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNJdGVtU2hvd24oKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5faXRlbVNob3duO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgdG9nZ2xlXG4gICAgICAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVRvZ2dsZSB2aXNpYmlsaXR5LlsvZW5dXG4gICAgICAgICogICBbamFdU3BlZWQgZGlhbOOBruihqOekuumdnuihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3RvZ2dsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgICAgIGlmICh0aGlzLmlzU2hvd24oKSkge1xuICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgdG9nZ2xlSXRlbXNcbiAgICAgICAgKiBAc2lnbmF0dXJlIHRvZ2dsZUl0ZW1zKClcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1Ub2dnbGUgaXRlbSB2aXNpYmlsaXR5LlsvZW5dXG4gICAgICAgICogICBbamFdU3BlZWQgZGlhbOOBruWtkOimgee0oOOBruihqOekuumdnuihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3RvZ2dsZUl0ZW1zJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlSXRlbXMoKSB7XG4gICAgICAgICBpZiAodGhpcy5pc0l0ZW1TaG93bigpKSB7XG4gICAgICAgICAgIHRoaXMuaGlkZUl0ZW1zKCk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLnNob3dJdGVtcygpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2l0ZW1zJyxcbiAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ29ucy1zcGVlZC1kaWFsLWl0ZW0nKSk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBTcGVlZERpYWxFbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zU3BlZWREaWFsRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXNwZWVkLWRpYWwnLCB7XG4gICAgIHByb3RvdHlwZTogU3BlZWREaWFsRWxlbWVudC5wcm90b3R5cGVcbiAgIH0pO1xuXG4gICB2YXIgcmV3cml0YWJsZXMkMSA9IHtcbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7RWxlbWVudH0gc3BsaXR0ZXJTaWRlRWxlbWVudFxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgKi9cblxuICAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoc3BsaXR0ZXJTaWRlRWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICAgICB9LFxuXG4gICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNwbGl0dGVyU2lkZUVsZW1lbnRcbiAgICAgICogQHBhcmFtIHtIVE1MRnJhZ21lbnR9IHRhcmdldFxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgKi9cbiAgICAgbGluazogZnVuY3Rpb24gbGluayhzcGxpdHRlclNpZGVFbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgY2FsbGJhY2sodGFyZ2V0KTtcbiAgICAgfVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXItY29udGVudFxuICAgICogQGNhdGVnb3J5IGNvbnRyb2xcbiAgICAqIEBkZXNjcmlwdGlvblxuICAgICogIFtlbl1UaGUgXCJvbnMtc3BsaXR0ZXItY29udGVudFwiIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgXCJvbnMtc3BsaXR0ZXJcIi5bL2VuXVxuICAgICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOimgee0oOOBr+OAgW9ucy1zcGxpdHRlcuimgee0oOOBruWtkOimgee0oOOBqOOBl+OBpuWIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAY29kZXBlbiByT1FPTUxcbiAgICAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICAgICogIFtlbl1vbnMtc3BsaXR0ZXIgY29tcG9uZW50Wy9lbl1cbiAgICAqICBbamFdb25zLXNwbGl0dGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1zaWRlXG4gICAgKiAgW2VuXW9ucy1zcGxpdHRlci1zaWRlIGNvbXBvbmVudFsvZW5dXG4gICAgKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8b25zLXNwbGl0dGVyPlxuICAgICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gICAgKiAgICAgLi4uXG4gICAgKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gICAgKlxuICAgICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlPlxuICAgICogICAgIC4uLlxuICAgICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICAgICogPC9vbnMtc3BsaXR0ZXI+XG4gICAgKi9cblxuICAgdmFyIFNwbGl0dGVyQ29udGVudEVsZW1lbnQgPSAoZnVuY3Rpb24gKF9CYXNlRWxlbWVudCkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoU3BsaXR0ZXJDb250ZW50RWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBTcGxpdHRlckNvbnRlbnRFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGxpdHRlckNvbnRlbnRFbGVtZW50KTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNwbGl0dGVyQ29udGVudEVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKFNwbGl0dGVyQ29udGVudEVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5fcGFnZSA9IG51bGw7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBsb2FkXG4gICAgICAgICogQHNpZ25hdHVyZSBsb2FkKHBhZ2VVcmwpXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VVcmxcbiAgICAgICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIDxvbnMtdGVtcGxhdGU+LlsvZW5dXG4gICAgICAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgW9ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU2hvdyB0aGUgcGFnZSBzcGVjaWZpZWQgaW4gcGFnZVVybCBpbiB0aGUgcmlnaHQgc2VjdGlvblsvZW5dXG4gICAgICAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50Wy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdsb2FkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZChwYWdlKSB7XG4gICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG5cbiAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBvcHRpb25zLmNhbGxiYWNrIDogZnVuY3Rpb24gKCkge307XG4gICAgICAgICByZXR1cm4gaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgIHJld3JpdGFibGVzJDEubGluayhfdGhpczIsIHV0aWwuY3JlYXRlRnJhZ21lbnQoaHRtbCksIG9wdGlvbnMsIGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24oX3RoaXMyLCAnX2hpZGUnKTtcbiAgICAgICAgICAgICAgIF90aGlzMi5pbm5lckhUTUwgPSAnJztcblxuICAgICAgICAgICAgICAgX3RoaXMyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblxuICAgICAgICAgICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24oX3RoaXMyLCAnX3Nob3cnKTtcblxuICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpczIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgdGhpcy5fYXNzZXJ0UGFyZW50KCk7XG5cbiAgICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgncGFnZScpKSB7XG4gICAgICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgcmV0dXJuIHJld3JpdGFibGVzJDEucmVhZHkoX3RoaXMzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLmxvYWQoX3RoaXMzLmdldEF0dHJpYnV0ZSgncGFnZScpKTtcbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZGV0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaGVkQ2FsbGJhY2soKSB7fVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3Nob3cnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdygpIHtcbiAgICAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfc2hvdycpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19oaWRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoKSB7XG4gICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZGVzdHJveScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XG4gICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19hc3NlcnRQYXJlbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXNzZXJ0UGFyZW50KCkge1xuICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnROYW1lID0gdGhpcy5wYXJlbnRFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICBpZiAocGFyZW50RWxlbWVudE5hbWUgIT09ICdvbnMtc3BsaXR0ZXInKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgcGFyZW50RWxlbWVudE5hbWUgKyAnXCIgZWxlbWVudCBpcyBub3QgYWxsb3dlZCBhcyBwYXJlbnQgZWxlbWVudC4nKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdwYWdlJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgICAgICAqIEBpbml0b25seVxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dVGhlIHVybCBvZiB0aGUgbWVudSBwYWdlLlsvZW5dXG4gICAgICAgICogICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjgavooajnpLrjgZnjgovjg5rjg7zjgrjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFNwbGl0dGVyQ29udGVudEVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNTcGxpdHRlckNvbnRlbnRFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BsaXR0ZXItY29udGVudCcsIHtcbiAgICAgcHJvdG90eXBlOiBTcGxpdHRlckNvbnRlbnRFbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIHdpbmRvdy5PbnNTcGxpdHRlckNvbnRlbnRFbGVtZW50LnJld3JpdGFibGVzID0gcmV3cml0YWJsZXMkMTtcblxuICAgdmFyIFNwbGl0dGVyTWFza0VsZW1lbnQgPSAoZnVuY3Rpb24gKF9CYXNlRWxlbWVudCkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoU3BsaXR0ZXJNYXNrRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBTcGxpdHRlck1hc2tFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGxpdHRlck1hc2tFbGVtZW50KTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNwbGl0dGVyTWFza0VsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKFNwbGl0dGVyTWFza0VsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkNsaWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgIGlmICh0aGlzLnBhcmVudEVsZW1lbnQgJiYgdGhpcy5wYXJlbnRFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtc3BsaXR0ZXInKSB7XG4gICAgICAgICAgIC8vIGNsb3NlIHNpZGUgbWVudXNcbiAgICAgICAgICAgdGhpcy5wYXJlbnRFbGVtZW50LmNsb3NlUmlnaHQoKS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudC5jbG9zZUxlZnQoKS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICB9XG4gICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge31cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljayk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZGV0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFNwbGl0dGVyTWFza0VsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNTcGxpdHRlck1hc2tFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BsaXR0ZXItbWFzaycsIHtcbiAgICAgcHJvdG90eXBlOiBTcGxpdHRlck1hc2tFbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIHZhciBTcGxpdHRlckFuaW1hdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgZnVuY3Rpb24gU3BsaXR0ZXJBbmltYXRvcigpIHtcbiAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGxpdHRlckFuaW1hdG9yKTtcblxuICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICB0aW1pbmc6ICdsaW5lYXInLFxuICAgICAgICAgZHVyYXRpb246ICcwLjMnLFxuICAgICAgICAgZGVsYXk6ICcwJ1xuICAgICAgIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gICAgICAgdGhpcy5fdGltaW5nID0gb3B0aW9ucy50aW1pbmc7XG4gICAgICAgdGhpcy5fZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICAgICAgIHRoaXMuX2RlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhTcGxpdHRlckFuaW1hdG9yLCBbe1xuICAgICAgIGtleTogJ2xheW91dE9uT3BlbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dE9uT3BlbigpIHt9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdsYXlvdXRPbkNsb3NlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0T25DbG9zZSgpIHt9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICd0cmFuc2xhdGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2xhdGUoZGlzdGFuY2UpIHt9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdvcGVuJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gb3Blbihkb25lKSB7XG4gICAgICAgICBkb25lKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnY2xvc2UnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZShkb25lKSB7XG4gICAgICAgICBkb25lKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYWN0aXZhdGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhY3RpdmF0ZShjb250ZW50RWxlbWVudCwgc2lkZUVsZW1lbnQsIG1hc2tFbGVtZW50KSB7fVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaW5hY3RpdmF0ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluYWN0aXZhdGUoKSB7fVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNBY3RpdmF0ZWQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FjdGl2YXRlZCgpIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gU3BsaXR0ZXJBbmltYXRvcjtcbiAgIH0pKCk7XG5cbiAgIHZhciBTUExJVF9NT0RFID0gJ3NwbGl0JztcbiAgIHZhciBDT0xMQVBTRV9NT0RFID0gJ2NvbGxhcHNlJztcblxuICAgdmFyIENvbGxhcHNlRGV0ZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgZnVuY3Rpb24gQ29sbGFwc2VEZXRlY3Rpb24oKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbGxhcHNlRGV0ZWN0aW9uKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhDb2xsYXBzZURldGVjdGlvbiwgW3tcbiAgICAgICBrZXk6ICdhY3RpdmF0ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGl2YXRlKGVsZW1lbnQpIHt9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdpbmFjdGl2YXRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5hY3RpdmF0ZSgpIHt9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIENvbGxhcHNlRGV0ZWN0aW9uO1xuICAgfSkoKTtcblxuICAgdmFyIHJld3JpdGFibGVzJDIgPSB7XG4gICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNwbGl0dGVyU2lkZUVsZW1lbnRcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICovXG5cbiAgICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KHNwbGl0dGVyU2lkZUVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgfSxcblxuICAgICAvKipcbiAgICAgICogQHBhcmFtIHtFbGVtZW50fSBzcGxpdHRlclNpZGVFbGVtZW50XG4gICAgICAqIEBwYXJhbSB7SFRNTEZyYWdtZW50fSB0YXJnZXRcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICovXG4gICAgIGxpbms6IGZ1bmN0aW9uIGxpbmsoc3BsaXR0ZXJTaWRlRWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgIGNhbGxiYWNrKHRhcmdldCk7XG4gICAgIH1cbiAgIH07XG5cbiAgIHZhciBPcmllbnRhdGlvbkNvbGxhcHNlRGV0ZWN0aW9uID0gKGZ1bmN0aW9uIChfQ29sbGFwc2VEZXRlY3Rpb24pIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKE9yaWVudGF0aW9uQ29sbGFwc2VEZXRlY3Rpb24sIF9Db2xsYXBzZURldGVjdGlvbik7XG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvblxuICAgICAgKi9cblxuICAgICBmdW5jdGlvbiBPcmllbnRhdGlvbkNvbGxhcHNlRGV0ZWN0aW9uKG5ld09yaWVudGF0aW9uKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIE9yaWVudGF0aW9uQ29sbGFwc2VEZXRlY3Rpb24pO1xuXG4gICAgICAgdmFyIF90aGlzID0gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9yaWVudGF0aW9uQ29sbGFwc2VEZXRlY3Rpb24pLmNhbGwodGhpcykpO1xuXG4gICAgICAgaWYgKG5ld09yaWVudGF0aW9uICE9PSAncG9ydHJhaXQnICYmIG5ld09yaWVudGF0aW9uICE9PSAnbGFuZHNjYXBlJykge1xuICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9yaWVudGF0aW9uOiAnICsgbmV3T3JpZW50YXRpb24pO1xuICAgICAgIH1cblxuICAgICAgIF90aGlzLl9ib3VuZE9uT3JpZW50YXRpb25DaGFuZ2UgPSBfdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKF90aGlzKTtcbiAgICAgICBfdGhpcy5fdGFyZ2V0T3JpZW50YXRpb24gPSBuZXdPcmllbnRhdGlvbjtcbiAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoT3JpZW50YXRpb25Db2xsYXBzZURldGVjdGlvbiwgW3tcbiAgICAgICBrZXk6ICdhY3RpdmF0ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGl2YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgb3JpZW50YXRpb24ub24oJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25PcmllbnRhdGlvbkNoYW5nZSk7XG4gICAgICAgICB0aGlzLl91cGRhdGUob3JpZW50YXRpb24uaXNQb3J0cmFpdCgpKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25PcmllbnRhdGlvbkNoYW5nZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk9yaWVudGF0aW9uQ2hhbmdlKGluZm8pIHtcbiAgICAgICAgIHRoaXMuX3VwZGF0ZShpbmZvLmlzUG9ydHJhaXQpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKGlzUG9ydHJhaXQpIHtcbiAgICAgICAgIGlmIChpc1BvcnRyYWl0ICYmIHRoaXMuX3RhcmdldE9yaWVudGF0aW9uID09PSAncG9ydHJhaXQnKSB7XG4gICAgICAgICAgIHRoaXMuX2VsZW1lbnQuX3VwZGF0ZU1vZGUoQ09MTEFQU0VfTU9ERSk7XG4gICAgICAgICB9IGVsc2UgaWYgKCFpc1BvcnRyYWl0ICYmIHRoaXMuX3RhcmdldE9yaWVudGF0aW9uID09PSAnbGFuZHNjYXBlJykge1xuICAgICAgICAgICB0aGlzLl9lbGVtZW50Ll91cGRhdGVNb2RlKENPTExBUFNFX01PREUpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5fZWxlbWVudC5fdXBkYXRlTW9kZShTUExJVF9NT0RFKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdpbmFjdGl2YXRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW5hY3RpdmF0ZSgpIHtcbiAgICAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uT3JpZW50YXRpb25DaGFuZ2UpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gT3JpZW50YXRpb25Db2xsYXBzZURldGVjdGlvbjtcbiAgIH0pKENvbGxhcHNlRGV0ZWN0aW9uKTtcblxuICAgdmFyIFN0YXRpY0NvbGxhcHNlRGV0ZWN0aW9uID0gKGZ1bmN0aW9uIChfQ29sbGFwc2VEZXRlY3Rpb24yKSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhTdGF0aWNDb2xsYXBzZURldGVjdGlvbiwgX0NvbGxhcHNlRGV0ZWN0aW9uMik7XG5cbiAgICAgZnVuY3Rpb24gU3RhdGljQ29sbGFwc2VEZXRlY3Rpb24oKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXRpY0NvbGxhcHNlRGV0ZWN0aW9uKTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0YXRpY0NvbGxhcHNlRGV0ZWN0aW9uKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhTdGF0aWNDb2xsYXBzZURldGVjdGlvbiwgW3tcbiAgICAgICBrZXk6ICdhY3RpdmF0ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGl2YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgIGVsZW1lbnQuX3VwZGF0ZU1vZGUoQ09MTEFQU0VfTU9ERSk7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBTdGF0aWNDb2xsYXBzZURldGVjdGlvbjtcbiAgIH0pKENvbGxhcHNlRGV0ZWN0aW9uKTtcblxuICAgdmFyIE1lZGlhUXVlcnlDb2xsYXBzZURldGVjdGlvbiA9IChmdW5jdGlvbiAoX0NvbGxhcHNlRGV0ZWN0aW9uMykge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoTWVkaWFRdWVyeUNvbGxhcHNlRGV0ZWN0aW9uLCBfQ29sbGFwc2VEZXRlY3Rpb24zKTtcblxuICAgICAvKipcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5XG4gICAgICAqL1xuXG4gICAgIGZ1bmN0aW9uIE1lZGlhUXVlcnlDb2xsYXBzZURldGVjdGlvbihxdWVyeSkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBNZWRpYVF1ZXJ5Q29sbGFwc2VEZXRlY3Rpb24pO1xuXG4gICAgICAgdmFyIF90aGlzMyA9IGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihNZWRpYVF1ZXJ5Q29sbGFwc2VEZXRlY3Rpb24pLmNhbGwodGhpcykpO1xuXG4gICAgICAgX3RoaXMzLl9tZWRpYVF1ZXJ5U3RyaW5nID0gcXVlcnk7XG4gICAgICAgX3RoaXMzLl9ib3VuZE9uQ2hhbmdlID0gX3RoaXMzLl9vbkNoYW5nZS5iaW5kKF90aGlzMyk7XG4gICAgICAgcmV0dXJuIF90aGlzMztcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhNZWRpYVF1ZXJ5Q29sbGFwc2VEZXRlY3Rpb24sIFt7XG4gICAgICAga2V5OiAnX29uQ2hhbmdlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2hhbmdlKHF1ZXJ5TGlzdCkge1xuICAgICAgICAgdGhpcy5fZWxlbWVudC5fdXBkYXRlTW9kZShxdWVyeUxpc3QubWF0Y2hlcyA/IENPTExBUFNFX01PREUgOiBTUExJVF9NT0RFKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhY3RpdmF0ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGl2YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgdGhpcy5fcXVlcnlSZXN1bHQgPSB3aW5kb3cubWF0Y2hNZWRpYSh0aGlzLl9tZWRpYVF1ZXJ5U3RyaW5nKTtcbiAgICAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0LmFkZExpc3RlbmVyKHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgICAgICAgdGhpcy5fb25DaGFuZ2UodGhpcy5fcXVlcnlSZXN1bHQpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2luYWN0aXZhdGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbmFjdGl2YXRlKCkge1xuICAgICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICAgICB0aGlzLl9xdWVyeVJlc3VsdC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0ID0gbnVsbDtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIE1lZGlhUXVlcnlDb2xsYXBzZURldGVjdGlvbjtcbiAgIH0pKENvbGxhcHNlRGV0ZWN0aW9uKTtcblxuICAgdmFyIEJhc2VNb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgZnVuY3Rpb24gQmFzZU1vZGUoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VNb2RlKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhCYXNlTW9kZSwgW3tcbiAgICAgICBrZXk6ICdpc09wZW4nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc09wZW4oKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnb3Blbk1lbnUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuTWVudSgpIHtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdjbG9zZU1lbnUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZU1lbnUoKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZW50ZXJNb2RlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW50ZXJNb2RlKCkge31cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2V4aXRNb2RlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhpdE1vZGUoKSB7fVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaGFuZGxlR2VzdHVyZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUdlc3R1cmUoKSB7fVxuICAgICB9XSk7XG4gICAgIHJldHVybiBCYXNlTW9kZTtcbiAgIH0pKCk7XG5cbiAgIHZhciBTcGxpdE1vZGUgPSAoZnVuY3Rpb24gKF9CYXNlTW9kZSkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoU3BsaXRNb2RlLCBfQmFzZU1vZGUpO1xuXG4gICAgIGZ1bmN0aW9uIFNwbGl0TW9kZShlbGVtZW50KSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFNwbGl0TW9kZSk7XG5cbiAgICAgICB2YXIgX3RoaXM0ID0gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNwbGl0TW9kZSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgICBfdGhpczQuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgIHJldHVybiBfdGhpczQ7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoU3BsaXRNb2RlLCBbe1xuICAgICAgIGtleTogJ2lzT3BlbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3BlbigpIHtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdvcGVuTWVudScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5NZW51KCkge1xuICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2Nsb3NlTWVudScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlTWVudSgpIHtcbiAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnbGF5b3V0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0KCkge1xuICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IGVsZW1lbnQuX2dldFdpZHRoKCk7XG5cbiAgICAgICAgIGlmIChlbGVtZW50Ll9pc0xlZnRTaWRlKCkpIHtcbiAgICAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICAgICBlbGVtZW50LnN0eWxlLnJpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gJ2F1dG8nO1xuICAgICAgICAgICBlbGVtZW50LnN0eWxlLnJpZ2h0ID0gJzAnO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2VudGVyTW9kZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVudGVyTW9kZSgpIHtcbiAgICAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZXhpdE1vZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleGl0TW9kZSgpIHtcbiAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcblxuICAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgICAgICBlbGVtZW50LnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgICBlbGVtZW50LnN0eWxlLnpJbmRleCA9ICcnO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gU3BsaXRNb2RlO1xuICAgfSkoQmFzZU1vZGUpO1xuXG4gICB2YXIgQ29sbGFwc2VNb2RlID0gKGZ1bmN0aW9uIChfQmFzZU1vZGUyKSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhDb2xsYXBzZU1vZGUsIF9CYXNlTW9kZTIpO1xuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoQ29sbGFwc2VNb2RlLCBbe1xuICAgICAgIGtleTogJ19hbmltYXRvcicsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5fZ2V0QW5pbWF0b3IoKTtcbiAgICAgICB9XG4gICAgIH1dLCBbe1xuICAgICAgIGtleTogJ0NMT1NFRF9TVEFURScsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gJ2Nsb3NlZCc7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnT1BFTl9TVEFURScsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gJ29wZW4nO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ0NIQU5HSU5HX1NUQVRFJyxcbiAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgIHJldHVybiAnY2hhbmdpbmcnO1xuICAgICAgIH1cbiAgICAgfV0pO1xuXG4gICAgIGZ1bmN0aW9uIENvbGxhcHNlTW9kZShlbGVtZW50KSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbGxhcHNlTW9kZSk7XG5cbiAgICAgICB2YXIgX3RoaXM1ID0gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbGxhcHNlTW9kZSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgICBfdGhpczUuX3N0YXRlID0gQ29sbGFwc2VNb2RlLkNMT1NFRF9TVEFURTtcbiAgICAgICBfdGhpczUuX2Rpc3RhbmNlID0gMDtcbiAgICAgICBfdGhpczUuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgIF90aGlzNS5fbG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgICAgIHJldHVybiBfdGhpczU7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoQ29sbGFwc2VNb2RlLCBbe1xuICAgICAgIGtleTogJ19pc0xvY2tlZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0xvY2tlZCgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9sb2NrLmlzTG9ja2VkKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNPcGVuJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNPcGVuKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlICE9PSBDb2xsYXBzZU1vZGUuQ0xPU0VEX1NUQVRFO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzQ2xvc2VkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNDbG9zZWQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUgPT09IENvbGxhcHNlTW9kZS5DTE9TRURfU1RBVEU7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaGFuZGxlR2VzdHVyZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUdlc3R1cmUoZXZlbnQpIHtcbiAgICAgICAgIGlmICh0aGlzLl9pc0xvY2tlZCgpKSB7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKHRoaXMuX2lzT3Blbk90aGVyU2lkZU1lbnUoKSkge1xuICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnZHJhZ3N0YXJ0Jykge1xuICAgICAgICAgICB0aGlzLl9vbkRyYWdTdGFydChldmVudCk7XG4gICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdkcmFnbGVmdCcgfHwgZXZlbnQudHlwZSA9PT0gJ2RyYWdyaWdodCcpIHtcbiAgICAgICAgICAgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICAgICAgICAgdGhpcy5fb25EcmFnKGV2ZW50KTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnZHJhZ2VuZCcpIHtcbiAgICAgICAgICAgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICAgICAgICAgdGhpcy5fb25EcmFnRW5kKGV2ZW50KTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRHJhZ1N0YXJ0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgICAgICB0aGlzLl9pZ25vcmVEcmFnID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihldmVudC5nZXN0dXJlLmRpcmVjdGlvbikgPT09IC0xO1xuXG4gICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKCkgJiYgdGhpcy5faXNPcGVuT3RoZXJTaWRlTWVudSgpKSB7XG4gICAgICAgICAgIHRoaXMuX2lnbm9yZURyYWcgPSB0cnVlO1xuICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9lbGVtZW50Ll9zd2lwZVRhcmdldFdpZHRoID4gMCkge1xuICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLl9lbGVtZW50Ll9pc0xlZnRTaWRlKCkgPyBldmVudC5nZXN0dXJlLmNlbnRlci5jbGllbnRYIDogd2luZG93LmlubmVyV2lkdGggLSBldmVudC5nZXN0dXJlLmNlbnRlci5jbGllbnRYO1xuICAgICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKCkgJiYgZGlzdGFuY2UgPiB0aGlzLl9lbGVtZW50Ll9zd2lwZVRhcmdldFdpZHRoKSB7XG4gICAgICAgICAgICAgdGhpcy5faWdub3JlRHJhZyA9IHRydWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25EcmFnJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJhZyhldmVudCkge1xuICAgICAgICAgZXZlbnQuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICB2YXIgZGVsdGFYID0gZXZlbnQuZ2VzdHVyZS5kZWx0YVg7XG4gICAgICAgICB2YXIgZGVsdGFEaXN0YW5jZSA9IHRoaXMuX2VsZW1lbnQuX2lzTGVmdFNpZGUoKSA/IGRlbHRhWCA6IC1kZWx0YVg7XG5cbiAgICAgICAgIHZhciBzdGFydEV2ZW50ID0gZXZlbnQuZ2VzdHVyZS5zdGFydEV2ZW50O1xuXG4gICAgICAgICBpZiAoISgnaXNPcGVuJyBpbiBzdGFydEV2ZW50KSkge1xuICAgICAgICAgICBzdGFydEV2ZW50LmlzT3BlbiA9IHRoaXMuaXNPcGVuKCk7XG4gICAgICAgICAgIHN0YXJ0RXZlbnQuZGlzdGFuY2UgPSBzdGFydEV2ZW50LmlzT3BlbiA/IHRoaXMuX2VsZW1lbnQuX2dldFdpZHRoSW5QaXhlbCgpIDogMDtcbiAgICAgICAgICAgc3RhcnRFdmVudC53aWR0aCA9IHRoaXMuX2VsZW1lbnQuX2dldFdpZHRoSW5QaXhlbCgpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl9lbGVtZW50Ll9nZXRXaWR0aEluUGl4ZWwoKTtcblxuICAgICAgICAgaWYgKGRlbHRhRGlzdGFuY2UgPCAwICYmIHN0YXJ0RXZlbnQuZGlzdGFuY2UgPD0gMCkge1xuICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChkZWx0YURpc3RhbmNlID4gMCAmJiBzdGFydEV2ZW50LmRpc3RhbmNlID49IHdpZHRoKSB7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIGRpc3RhbmNlID0gc3RhcnRFdmVudC5pc09wZW4gPyBkZWx0YURpc3RhbmNlICsgd2lkdGggOiBkZWx0YURpc3RhbmNlO1xuICAgICAgICAgdmFyIG5vcm1hbGl6ZWREaXN0YW5jZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHdpZHRoLCBkaXN0YW5jZSkpO1xuXG4gICAgICAgICBzdGFydEV2ZW50LmRpc3RhbmNlID0gbm9ybWFsaXplZERpc3RhbmNlO1xuXG4gICAgICAgICB0aGlzLl9zdGF0ZSA9IENvbGxhcHNlTW9kZS5DSEFOR0lOR19TVEFURTtcbiAgICAgICAgIHRoaXMuX2FuaW1hdG9yLnRyYW5zbGF0ZShub3JtYWxpemVkRGlzdGFuY2UpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkRyYWdFbmQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgICAgICB2YXIgZGVsdGFYID0gZXZlbnQuZ2VzdHVyZS5kZWx0YVg7XG4gICAgICAgICB2YXIgZGVsdGFEaXN0YW5jZSA9IHRoaXMuX2VsZW1lbnQuX2lzTGVmdFNpZGUoKSA/IGRlbHRhWCA6IC1kZWx0YVg7XG4gICAgICAgICB2YXIgd2lkdGggPSBldmVudC5nZXN0dXJlLnN0YXJ0RXZlbnQud2lkdGg7XG4gICAgICAgICB2YXIgZGlzdGFuY2UgPSBldmVudC5nZXN0dXJlLnN0YXJ0RXZlbnQuaXNPcGVuID8gZGVsdGFEaXN0YW5jZSArIHdpZHRoIDogZGVsdGFEaXN0YW5jZTtcbiAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XG4gICAgICAgICB2YXIgc2hvdWxkT3BlbiA9IHRoaXMuX2VsZW1lbnQuX2lzTGVmdFNpZGUoKSAmJiBkaXJlY3Rpb24gPT09ICdyaWdodCcgJiYgZGlzdGFuY2UgPiB3aWR0aCAqIHRoaXMuX2VsZW1lbnQuX2dldFRocmVzaG9sZFJhdGlvSWZTaG91bGRPcGVuKCkgfHwgIXRoaXMuX2VsZW1lbnQuX2lzTGVmdFNpZGUoKSAmJiBkaXJlY3Rpb24gPT09ICdsZWZ0JyAmJiBkaXN0YW5jZSA+IHdpZHRoICogdGhpcy5fZWxlbWVudC5fZ2V0VGhyZXNob2xkUmF0aW9JZlNob3VsZE9wZW4oKTtcblxuICAgICAgICAgaWYgKHNob3VsZE9wZW4pIHtcbiAgICAgICAgICAgdGhpcy5fb3Blbk1lbnUoKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRoaXMuX2Nsb3NlTWVudSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2xheW91dCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dCgpIHtcblxuICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBDb2xsYXBzZU1vZGUuQ0hBTkdJTkdfU1RBVEUpIHtcbiAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IENvbGxhcHNlTW9kZS5DTE9TRURfU1RBVEUpIHtcbiAgICAgICAgICAgaWYgKHRoaXMuX2FuaW1hdG9yLmlzQWN0aXZhdGVkKCkpIHtcbiAgICAgICAgICAgICB0aGlzLl9hbmltYXRvci5sYXlvdXRPbkNsb3NlKCk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IENvbGxhcHNlTW9kZS5PUEVOX1NUQVRFKSB7XG4gICAgICAgICAgIGlmICh0aGlzLl9hbmltYXRvci5pc0FjdGl2YXRlZCgpKSB7XG4gICAgICAgICAgICAgdGhpcy5fYW5pbWF0b3IubGF5b3V0T25PcGVuKCk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8vIGVudGVyIGNvbGxhcHNlIG1vZGVcblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZW50ZXJNb2RlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW50ZXJNb2RlKCkge1xuICAgICAgICAgdGhpcy5fYW5pbWF0b3IuYWN0aXZhdGUodGhpcy5fZWxlbWVudC5fZ2V0Q29udGVudEVsZW1lbnQoKSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fZWxlbWVudC5fZ2V0TWFza0VsZW1lbnQoKSk7XG5cbiAgICAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgICAgfVxuXG4gICAgICAgLy8gZXhpdCBjb2xsYXBzZSBtb2RlXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2V4aXRNb2RlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhpdE1vZGUoKSB7XG4gICAgICAgICB0aGlzLl9hbmltYXRvci5pbmFjdGl2YXRlKCk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2lzT3Blbk90aGVyU2lkZU1lbnUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNPcGVuT3RoZXJTaWRlTWVudSgpIHtcbiAgICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5fZWxlbWVudC5wYXJlbnRFbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgIHJldHVybiBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXNwbGl0dGVyLXNpZGUnICYmIF90aGlzNi5fZWxlbWVudCAhPT0gY2hpbGQ7XG4gICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgICAgcmV0dXJuIHNpZGUuaXNPcGVuKCk7XG4gICAgICAgICB9KS5sZW5ndGggPiAwO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRBbmltYXRpb25dXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudFxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdvcGVuTWVudScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5NZW51KCkge1xuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBDb2xsYXBzZU1vZGUuQ0xPU0VEX1NUQVRFKSB7XG4gICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHRoaXMuX29wZW5NZW51KG9wdGlvbnMpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRBbmltYXRpb25dXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudFxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb3Blbk1lbnUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb3Blbk1lbnUoKSB7XG4gICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgaWYgKHRoaXMuX2lzTG9ja2VkKCkpIHtcbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAodGhpcy5faXNPcGVuT3RoZXJTaWRlTWVudSgpKSB7XG4gICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQuX2VtaXRQcmVPcGVuRXZlbnQoKSkge1xuICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBvcHRpb25zLmNhbGxiYWNrIDogZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgIHZhciB1bmxvY2sgPSB0aGlzLl9sb2NrLmxvY2soKTtcbiAgICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgdW5sb2NrKCk7XG4gICAgICAgICAgIF90aGlzNy5fZWxlbWVudC5fZW1pdFBvc3RPcGVuRXZlbnQoKTtcbiAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgICAgICAgfTtcblxuICAgICAgICAgaWYgKG9wdGlvbnMud2l0aG91dEFuaW1hdGlvbikge1xuICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IENvbGxhcHNlTW9kZS5PUEVOX1NUQVRFO1xuICAgICAgICAgICB0aGlzLmxheW91dCgpO1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWxlbWVudCk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IENvbGxhcHNlTW9kZS5DSEFOR0lOR19TVEFURTtcbiAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgX3RoaXM3Ll9hbmltYXRvci5vcGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgIF90aGlzNy5fc3RhdGUgPSBDb2xsYXBzZU1vZGUuT1BFTl9TVEFURTtcbiAgICAgICAgICAgICAgIF90aGlzNy5sYXlvdXQoKTtcbiAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXM3Ll9lbGVtZW50KTtcbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnRcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnY2xvc2VNZW51JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VNZW51KCkge1xuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBDb2xsYXBzZU1vZGUuT1BFTl9TVEFURSkge1xuICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZU1lbnUob3B0aW9ucyk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnRcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2Nsb3NlTWVudScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZU1lbnUoKSB7XG4gICAgICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgaWYgKHRoaXMuX2lzTG9ja2VkKCkpIHtcbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAodGhpcy5fZWxlbWVudC5fZW1pdFByZUNsb3NlRXZlbnQoKSkge1xuICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBvcHRpb25zLmNhbGxiYWNrIDogZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgIHZhciB1bmxvY2sgPSB0aGlzLl9sb2NrLmxvY2soKTtcbiAgICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgdW5sb2NrKCk7XG4gICAgICAgICAgIF90aGlzOC5fZWxlbWVudC5fZW1pdFBvc3RDbG9zZUV2ZW50KCk7XG4gICAgICAgICAgIHNldEltbWVkaWF0ZShvcHRpb25zLmNhbGxiYWNrKTtcbiAgICAgICAgIH07XG5cbiAgICAgICAgIGlmIChvcHRpb25zLndpdGhvdXRBbmltYXRpb24pIHtcbiAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBDb2xsYXBzZU1vZGUuQ0xPU0VEX1NUQVRFO1xuICAgICAgICAgICB0aGlzLmxheW91dCgpO1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fZWxlbWVudCk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IENvbGxhcHNlTW9kZS5DSEFOR0lOR19TVEFURTtcbiAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgX3RoaXM4Ll9hbmltYXRvci5jbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICBfdGhpczguX3N0YXRlID0gQ29sbGFwc2VNb2RlLkNMT1NFRF9TVEFURTtcbiAgICAgICAgICAgICAgIF90aGlzOC5sYXlvdXQoKTtcbiAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXM4Ll9lbGVtZW50KTtcbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBDb2xsYXBzZU1vZGU7XG4gICB9KShCYXNlTW9kZSk7XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLXNwbGl0dGVyLXNpZGVcbiAgICAqIEBjYXRlZ29yeSBjb250cm9sXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICBbZW5dVGhlIFwib25zLXNwbGl0dGVyLXNpZGVcIiBlbGVtZW50IGlzIHVzZWQgYXMgYSBjaGlsZCBlbGVtZW50IG9mIFwib25zLXNwbGl0dGVyXCIuWy9lbl1cbiAgICAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjga/jgIFvbnMtc3BsaXR0ZXLopoHntKDjga7lrZDopoHntKDjgajjgZfjgabliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgICogQGNvZGVwZW4gck9RT01MXG4gICAgKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXJcbiAgICAqICBbZW5db25zLXNwbGl0dGVyIGNvbXBvbmVudFsvZW5dXG4gICAgKiAgW2phXW9ucy1zcGxpdHRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gICAgKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItY29udGVudFxuICAgICogIFtlbl1vbnMtc3BsaXR0ZXItY29udGVudCBjb21wb25lbnRbL2VuXVxuICAgICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gICAgKiBAZXhhbXBsZVxuICAgICogPG9ucy1zcGxpdHRlcj5cbiAgICAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICAgICogICAgIC4uLlxuICAgICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICAgICpcbiAgICAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZT5cbiAgICAqICAgICAuLi5cbiAgICAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAgICAqIDwvb25zLXNwbGl0dGVyPlxuICAgICovXG5cbiAgIHZhciBTcGxpdHRlclNpZGVFbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKFNwbGl0dGVyU2lkZUVsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gU3BsaXR0ZXJTaWRlRWxlbWVudCgpIHtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BsaXR0ZXJTaWRlRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihTcGxpdHRlclNpZGVFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhTcGxpdHRlclNpZGVFbGVtZW50LCBbe1xuICAgICAgIGtleTogJ191cGRhdGVGb3JBbmltYXRpb25PcHRpb25zQXR0cmlidXRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUZvckFuaW1hdGlvbk9wdGlvbnNBdHRyaWJ1dGUoKSB7XG4gICAgICAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zID0gdXRpbC5wYXJzZUpTT05PYmplY3RTYWZlbHkodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJyksIHt9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0TWFza0VsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWFza0VsZW1lbnQoKSB7XG4gICAgICAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5wYXJlbnRFbGVtZW50LCAnb25zLXNwbGl0dGVyLW1hc2snKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0Q29udGVudEVsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29udGVudEVsZW1lbnQoKSB7XG4gICAgICAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5wYXJlbnRFbGVtZW50LCAnb25zLXNwbGl0dGVyLWNvbnRlbnQnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0TW9kZVN0cmF0ZWd5JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE1vZGVTdHJhdGVneSgpIHtcbiAgICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBDT0xMQVBTRV9NT0RFKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZU1vZGU7XG4gICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX21vZGUgPT09IFNQTElUX01PREUpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NwbGl0TW9kZTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLl9tb2RlID0gbnVsbDtcbiAgICAgICAgIHRoaXMuX3BhZ2UgPSBudWxsO1xuICAgICAgICAgdGhpcy5faXNBdHRhY2hlZCA9IGZhbHNlO1xuXG4gICAgICAgICB0aGlzLl9jb2xsYXBzZVN0cmF0ZWd5ID0gbmV3IENvbGxhcHNlRGV0ZWN0aW9uKCk7XG4gICAgICAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgICAgICAgYW5pbWF0b3JzOiB3aW5kb3cuT25zU3BsaXR0ZXJFbGVtZW50Ll9hbmltYXRvckRpY3QsXG4gICAgICAgICAgIGJhc2VDbGFzczogU3BsaXR0ZXJBbmltYXRvcixcbiAgICAgICAgICAgYmFzZUNsYXNzTmFtZTogJ1NwbGl0dGVyQW5pbWF0b3InLFxuICAgICAgICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICAgICAgIH0pO1xuXG4gICAgICAgICB0aGlzLl9jb2xsYXBzZU1vZGUgPSBuZXcgQ29sbGFwc2VNb2RlKHRoaXMpO1xuICAgICAgICAgdGhpcy5fc3BsaXRNb2RlID0gbmV3IFNwbGl0TW9kZSh0aGlzKTtcblxuICAgICAgICAgdGhpcy5fYm91bmRIYW5kbGVHZXN0dXJlID0gdGhpcy5faGFuZGxlR2VzdHVyZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICB0aGlzLl9jYW5jZWxNb2RlRGV0ZWN0aW9uID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgIHRoaXMuX3VwZGF0ZU1vZGUoU1BMSVRfTU9ERSk7XG5cbiAgICAgICAgIHRoaXMuX3VwZGF0ZUZvckFuaW1hdGlvbkF0dHJpYnV0ZSgpO1xuICAgICAgICAgdGhpcy5fdXBkYXRlRm9yV2lkdGhBdHRyaWJ1dGUoKTtcbiAgICAgICAgIHRoaXMuaGFzQXR0cmlidXRlKCdzaWRlJykgPyB0aGlzLl91cGRhdGVGb3JTaWRlQXR0cmlidXRlKCkgOiB0aGlzLnNldEF0dHJpYnV0ZSgnc2lkZScsICdsZWZ0Jyk7XG4gICAgICAgICB0aGlzLl91cGRhdGVGb3JDb2xsYXBzZUF0dHJpYnV0ZSgpO1xuICAgICAgICAgdGhpcy5fdXBkYXRlRm9yU3dpcGVhYmxlQXR0cmlidXRlKCk7XG4gICAgICAgICB0aGlzLl91cGRhdGVGb3JTd2lwZVRhcmdldFdpZHRoQXR0cmlidXRlKCk7XG4gICAgICAgICB0aGlzLl91cGRhdGVGb3JBbmltYXRpb25PcHRpb25zQXR0cmlidXRlKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2dldEFuaW1hdG9yJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFuaW1hdG9yKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdG9yO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzU3dpcGVhYmxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNTd2lwZWFibGUoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19lbWl0UG9zdE9wZW5FdmVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0UG9zdE9wZW5FdmVudCgpIHtcbiAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdG9wZW4nLCB7IHNpZGU6IHRoaXMgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2VtaXRQb3N0Q2xvc2VFdmVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0UG9zdENsb3NlRXZlbnQoKSB7XG4gICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RjbG9zZScsIHsgc2lkZTogdGhpcyB9KTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBjYW5jZWxlZCBvciBub3RcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2VtaXRQcmVPcGVuRXZlbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFByZU9wZW5FdmVudCgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9lbWl0Q2FuY2VsYWJsZUV2ZW50KCdwcmVvcGVuJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2VtaXRDYW5jZWxhYmxlRXZlbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdENhbmNlbGFibGVFdmVudChuYW1lKSB7XG4gICAgICAgICB2YXIgaXNDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgbmFtZSwge1xuICAgICAgICAgICBzaWRlOiB0aGlzLFxuICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICByZXR1cm4gaXNDYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuXG4gICAgICAgICByZXR1cm4gaXNDYW5jZWxlZDtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZW1pdFByZUNsb3NlRXZlbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFByZUNsb3NlRXZlbnQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fZW1pdENhbmNlbGFibGVFdmVudCgncHJlY2xvc2UnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfdXBkYXRlRm9yQ29sbGFwc2VBdHRyaWJ1dGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlRm9yQ29sbGFwc2VBdHRyaWJ1dGUoKSB7XG4gICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdjb2xsYXBzZScpKSB7XG4gICAgICAgICAgIHRoaXMuX3VwZGF0ZU1vZGUoU1BMSVRfTU9ERSk7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIGNvbGxhcHNlID0gKCcnICsgdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbGxhcHNlJykpLnRyaW0oKTtcblxuICAgICAgICAgaWYgKGNvbGxhcHNlID09PSAnJyB8fCBjb2xsYXBzZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbGxhcHNlU3RyYXRlZ3kobmV3IFN0YXRpY0NvbGxhcHNlRGV0ZWN0aW9uKCkpO1xuICAgICAgICAgfSBlbHNlIGlmIChjb2xsYXBzZSA9PT0gJ3BvcnRyYWl0JyB8fCBjb2xsYXBzZSA9PT0gJ2xhbmRzY2FwZScpIHtcbiAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sbGFwc2VTdHJhdGVneShuZXcgT3JpZW50YXRpb25Db2xsYXBzZURldGVjdGlvbihjb2xsYXBzZSkpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sbGFwc2VTdHJhdGVneShuZXcgTWVkaWFRdWVyeUNvbGxhcHNlRGV0ZWN0aW9uKGNvbGxhcHNlKSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtDb2xsYXBzZURldGVjdGlvbn0gc3RyYXRlZ3lcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZUNvbGxhcHNlU3RyYXRlZ3knLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQ29sbGFwc2VTdHJhdGVneShzdHJhdGVneSkge1xuICAgICAgICAgaWYgKHRoaXMuX2lzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgdGhpcy5fY29sbGFwc2VTdHJhdGVneS5pbmFjdGl2YXRlKCk7XG4gICAgICAgICAgIHN0cmF0ZWd5LmFjdGl2YXRlKHRoaXMpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLl9jb2xsYXBzZVN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGVcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZU1vZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTW9kZShtb2RlKSB7XG5cbiAgICAgICAgIGlmIChtb2RlICE9PSBDT0xMQVBTRV9NT0RFICYmIG1vZGUgIT09IFNQTElUX01PREUpIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1vZGU6ICcgKyBtb2RlKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKG1vZGUgPT09IHRoaXMuX21vZGUpIHtcbiAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgbGFzdE1vZGUgPSB0aGlzLl9nZXRNb2RlU3RyYXRlZ3koKTtcblxuICAgICAgICAgaWYgKGxhc3RNb2RlKSB7XG4gICAgICAgICAgIGxhc3RNb2RlLmV4aXRNb2RlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX21vZGUgPSBtb2RlO1xuICAgICAgICAgdmFyIGN1cnJlbnRNb2RlID0gdGhpcy5fZ2V0TW9kZVN0cmF0ZWd5KCk7XG5cbiAgICAgICAgIGN1cnJlbnRNb2RlLmVudGVyTW9kZSgpO1xuICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ21vZGUnLCBtb2RlKTtcblxuICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdtb2RlY2hhbmdlJywge1xuICAgICAgICAgICBzaWRlOiB0aGlzLFxuICAgICAgICAgICBtb2RlOiBtb2RlXG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0VGhyZXNob2xkUmF0aW9JZlNob3VsZE9wZW4nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VGhyZXNob2xkUmF0aW9JZlNob3VsZE9wZW4oKSB7XG4gICAgICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3RocmVzaG9sZC1yYXRpby1zaG91bGQtb3BlbicpKSB7XG4gICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3RocmVzaG9sZC1yYXRpby1zaG91bGQtb3BlbicpKTtcbiAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAuMCwgTWF0aC5taW4oMS4wLCB2YWx1ZSkpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgICByZXR1cm4gMC4zO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19sYXlvdXQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbGF5b3V0KCkge1xuICAgICAgICAgdGhpcy5fZ2V0TW9kZVN0cmF0ZWd5KCkubGF5b3V0KCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZUZvclN3aXBlVGFyZ2V0V2lkdGhBdHRyaWJ1dGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlRm9yU3dpcGVUYXJnZXRXaWR0aEF0dHJpYnV0ZSgpIHtcbiAgICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc3dpcGUtdGFyZ2V0LXdpZHRoJykpIHtcbiAgICAgICAgICAgdGhpcy5fc3dpcGVUYXJnZXRXaWR0aCA9IE1hdGgubWF4KDAsIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZS10YXJnZXQtd2lkdGgnKSwgMTApKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHRoaXMuX3N3aXBlVGFyZ2V0V2lkdGggPSAtMTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxcZCsocHh8JSlcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2dldFdpZHRoJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFdpZHRoKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCd3aWR0aCcpID8gbm9ybWFsaXplKHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKSA6ICc4MCUnO1xuXG4gICAgICAgICBmdW5jdGlvbiBub3JtYWxpemUod2lkdGgpIHtcbiAgICAgICAgICAgd2lkdGggPSB3aWR0aC50cmltKCk7XG5cbiAgICAgICAgICAgaWYgKHdpZHRoLm1hdGNoKC9eXFxkKyhweHwlKSQvKSkge1xuICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIHJldHVybiAnODAlJztcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0V2lkdGhJblBpeGVsJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFdpZHRoSW5QaXhlbCgpIHtcbiAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX2dldFdpZHRoKCk7XG5cbiAgICAgICAgIHZhciBfd2lkdGgkbWF0Y2ggPSB3aWR0aC5tYXRjaCgvXihcXGQrKShweHwlKSQvKTtcblxuICAgICAgICAgdmFyIF93aWR0aCRtYXRjaDIgPSBiYWJlbEhlbHBlcnMuc2xpY2VkVG9BcnJheShfd2lkdGgkbWF0Y2gsIDMpO1xuXG4gICAgICAgICB2YXIgbnVtID0gX3dpZHRoJG1hdGNoMlsxXTtcbiAgICAgICAgIHZhciB1bml0ID0gX3dpZHRoJG1hdGNoMlsyXTtcblxuICAgICAgICAgaWYgKHVuaXQgPT09ICdweCcpIHtcbiAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bSwgMTApO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAodW5pdCA9PT0gJyUnKSB7XG4gICAgICAgICAgIHZhciBwZXJjZW50ID0gcGFyc2VJbnQobnVtLCAxMCk7XG5cbiAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoICogcGVyY2VudCAvIDEwMCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gJ2xlZnQnIG9yICdyaWdodCcuXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19nZXRTaWRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNpZGUoKSB7XG4gICAgICAgICByZXR1cm4gbm9ybWFsaXplKHRoaXMuZ2V0QXR0cmlidXRlKCdzaWRlJykpO1xuXG4gICAgICAgICBmdW5jdGlvbiBub3JtYWxpemUoc2lkZSkge1xuICAgICAgICAgICBzaWRlID0gKCcnICsgc2lkZSkudHJpbSgpO1xuICAgICAgICAgICByZXR1cm4gc2lkZSA9PT0gJ2xlZnQnIHx8IHNpZGUgPT09ICdyaWdodCcgPyBzaWRlIDogJ2xlZnQnO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19pc0xlZnRTaWRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzTGVmdFNpZGUoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2lkZSgpID09PSAnbGVmdCc7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZUZvcldpZHRoQXR0cmlidXRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUZvcldpZHRoQXR0cmlidXRlKCkge1xuICAgICAgICAgdGhpcy5fZ2V0TW9kZVN0cmF0ZWd5KCkubGF5b3V0KCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZUZvclNpZGVBdHRyaWJ1dGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlRm9yU2lkZUF0dHJpYnV0ZSgpIHtcbiAgICAgICAgIHRoaXMuX2dldE1vZGVTdHJhdGVneSgpLmxheW91dCgpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgZ2V0Q3VycmVudE1vZGVcbiAgICAgICAgKiBAc2lnbmF0dXJlIGdldEN1cnJlbnRNb2RlKClcbiAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAgICogICBbZW5dR2V0IGN1cnJlbnQgbW9kZS4gUG9zc2libGUgdmFsdWVzIGFyZSBcImNvbGxhcHNlXCIgb3IgXCJzcGxpdFwiLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gub25zLXNwbGl0dGVyLXNpZGXopoHntKDjga7nj77lnKjjga7jg6Ljg7zjg4njgpLov5TjgZfjgb7jgZnjgIJcInNwbGl0XCLjgYvjgoLjgZfjgY/jga9cImNvbGxhcHNlXCLjga7jganjgaHjgonjgYvjgafjgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdnZXRDdXJyZW50TW9kZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRNb2RlKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNPcGVuJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNPcGVuKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1vZGVTdHJhdGVneSgpLmlzT3BlbigpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgb3BlblxuICAgICAgICAqIEBzaWduYXR1cmUgb3Blbihbb3B0aW9uc10pXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgICAgICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gb3BlbmVkLlsvZW5dXG4gICAgICAgICogICBbamFd44Oh44OL44Ol44O844GM6ZaL44GE44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1PcGVuIG1lbnUgaW4gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgICAgICAqICAgW2phXWNvbGxhcHNl44Oi44O844OJ44Gr44Gq44Gj44Gm44GE44KLb25zLXNwbGl0dGVyc2lkZeimgee0oOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50Wy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdvcGVuJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgIHJldHVybiB0aGlzLl9nZXRNb2RlU3RyYXRlZ3koKS5vcGVuTWVudShvcHRpb25zKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGNsb3NlXG4gICAgICAgICogQHNpZ25hdHVyZSBjbG9zZShbb3B0aW9uc10pXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgICAgICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gY2xvc2VkLlsvZW5dXG4gICAgICAgICogICBbamFd44Oh44OL44Ol44O844GM6ZaJ44GY44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1DbG9zZSBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieOBq+OBquOBo+OBpuOBhOOCi29ucy1zcGxpdHRlci1zaWRl6KaB57Sg44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnRbL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2Nsb3NlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TW9kZVN0cmF0ZWd5KCkuY2xvc2VNZW51KG9wdGlvbnMpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgbG9hZFxuICAgICAgICAqIEBzaWduYXR1cmUgbG9hZChwYWdlLCBbb3B0aW9uc10pXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAgICAgICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIDxvbnMtdGVtcGxhdGU+LlsvZW5dXG4gICAgICAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgW9ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU2hvdyB0aGUgcGFnZSBzcGVjaWZpZWQgaW4gcGFnZVVybCBpbiB0aGUgcmlnaHQgc2VjdGlvblsvZW5dXG4gICAgICAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50Wy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdsb2FkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZChwYWdlKSB7XG4gICAgICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuXG4gICAgICAgICBvcHRpb25zLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gb3B0aW9ucy5jYWxsYmFjayA6IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgcmV0dXJuIGludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMocGFnZSkudGhlbihmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICByZXdyaXRhYmxlcyQyLmxpbmsoX3RoaXMxMCwgdXRpbC5jcmVhdGVGcmFnbWVudChodG1sKSwgb3B0aW9ucywgZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbihfdGhpczEwLCAnX2hpZGUnKTtcbiAgICAgICAgICAgICAgIF90aGlzMTAuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgICAgICAgIF90aGlzMTAuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXG4gICAgICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbihfdGhpczEwLCAnX3Nob3cnKTtcblxuICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpczEwLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgIH0pO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAndG9nZ2xlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuaXNPcGVuKCkgPyB0aGlzLmNsb3NlKG9wdGlvbnMpIDogdGhpcy5vcGVuKG9wdGlvbnMpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgICBpZiAobmFtZSA9PT0gJ3dpZHRoJykge1xuICAgICAgICAgICB0aGlzLl91cGRhdGVGb3JXaWR0aEF0dHJpYnV0ZSgpO1xuICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnc2lkZScpIHtcbiAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9yU2lkZUF0dHJpYnV0ZSgpO1xuICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnY29sbGFwc2UnKSB7XG4gICAgICAgICAgIHRoaXMuX3VwZGF0ZUZvckNvbGxhcHNlQXR0cmlidXRlKCk7XG4gICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdzd2lwZWFibGUnKSB7XG4gICAgICAgICAgIHRoaXMuX3VwZGF0ZUZvclN3aXBlYWJsZUF0dHJpYnV0ZSgpO1xuICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnc3dpcGUtdGFyZ2V0LXdpZHRoJykge1xuICAgICAgICAgICB0aGlzLl91cGRhdGVGb3JTd2lwZVRhcmdldFdpZHRoQXR0cmlidXRlKCk7XG4gICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdhbmltYXRpb24tb3B0aW9ucycpIHtcbiAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9yQW5pbWF0aW9uT3B0aW9uc0F0dHJpYnV0ZSgpO1xuICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnYW5pbWF0aW9uJykge1xuICAgICAgICAgICB0aGlzLl91cGRhdGVGb3JBbmltYXRpb25BdHRyaWJ1dGUoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfdXBkYXRlRm9yQW5pbWF0aW9uQXR0cmlidXRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUZvckFuaW1hdGlvbkF0dHJpYnV0ZSgpIHtcbiAgICAgICAgIHZhciBpc0FjdGl2YXRlZCA9IHRoaXMuX2FuaW1hdG9yICYmIHRoaXMuX2FuaW1hdG9yLmlzQWN0aXZhdGVkKCk7XG5cbiAgICAgICAgIGlmIChpc0FjdGl2YXRlZCkge1xuICAgICAgICAgICB0aGlzLl9hbmltYXRvci5pbmFjdGl2YXRlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2FuaW1hdG9yID0gdGhpcy5fY3JlYXRlQW5pbWF0b3IoKTtcblxuICAgICAgICAgaWYgKGlzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgIHRoaXMuX2FuaW1hdG9yLmFjdGl2YXRlKHRoaXMuX2dldENvbnRlbnRFbGVtZW50KCksIHRoaXMsIHRoaXMuX2dldE1hc2tFbGVtZW50KCkpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGVGb3JTd2lwZWFibGVBdHRyaWJ1dGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlRm9yU3dpcGVhYmxlQXR0cmlidXRlKCkge1xuICAgICAgICAgaWYgKHRoaXMuX2dlc3R1cmVEZXRlY3Rvcikge1xuICAgICAgICAgICBpZiAodGhpcy5pc1N3aXBlYWJsZSgpKSB7XG4gICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLm9uKCdkcmFnc3RhcnQgZHJhZ2xlZnQgZHJhZ3JpZ2h0IGRyYWdlbmQnLCB0aGlzLl9ib3VuZEhhbmRsZUdlc3R1cmUpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5vZmYoJ2RyYWdzdGFydCBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ2VuZCcsIHRoaXMuX2JvdW5kSGFuZGxlR2VzdHVyZSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfYXNzZXJ0UGFyZW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fzc2VydFBhcmVudCgpIHtcbiAgICAgICAgIHZhciBwYXJlbnRFbGVtZW50TmFtZSA9IHRoaXMucGFyZW50RWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgaWYgKHBhcmVudEVsZW1lbnROYW1lICE9PSAnb25zLXNwbGl0dGVyJykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIHBhcmVudEVsZW1lbnROYW1lICsgJ1wiIGVsZW1lbnQgaXMgbm90IGFsbG93ZWQgYXMgcGFyZW50IGVsZW1lbnQuJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgdGhpcy5fY29sbGFwc2VTdHJhdGVneS5hY3RpdmF0ZSh0aGlzKTtcbiAgICAgICAgIHRoaXMuX2Fzc2VydFBhcmVudCgpO1xuXG4gICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMucGFyZW50RWxlbWVudCwgeyBkcmFnTWluRGlzdGFuY2U6IDEgfSk7XG4gICAgICAgICB0aGlzLl91cGRhdGVGb3JTd2lwZWFibGVBdHRyaWJ1dGUoKTtcblxuICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdwYWdlJykpIHtcbiAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICByZXR1cm4gcmV3cml0YWJsZXMkMi5yZWFkeShfdGhpczExLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMS5sb2FkKF90aGlzMTEuZ2V0QXR0cmlidXRlKCdwYWdlJykpO1xuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdkZXRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgIHRoaXMuX2NvbGxhcHNlU3RyYXRlZ3kuaW5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbnVsbDtcblxuICAgICAgICAgdGhpcy5fdXBkYXRlRm9yU3dpcGVhYmxlQXR0cmlidXRlKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2hhbmRsZUdlc3R1cmUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlR2VzdHVyZShldmVudCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1vZGVTdHJhdGVneSgpLmhhbmRsZUdlc3R1cmUoZXZlbnQpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19zaG93JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3coKSB7XG4gICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfaGlkZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWRlKCkge1xuICAgICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19oaWRlJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2Rlc3Ryb3knLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfZGVzdHJveScpO1xuICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY3JlYXRlQW5pbWF0b3InLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQW5pbWF0b3IoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKHtcbiAgICAgICAgICAgYW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJyksXG4gICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnM6IEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdwYWdlJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBtb2RlY2hhbmdlXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgY29tcG9uZW50J3MgbW9kZSBjaGFuZ2VzLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu6KaB57Sg44Gu44Oi44O844OJ44GM5aSJ5YyW44GX44Gf6Zqb44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAgICAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50Lm1vZGVcbiAgICAgICAgKiAgIFtlbl1SZXR1cm5zIHRoZSBjdXJyZW50IG1vZGUuIENhbiBiZSBlaXRoZXIgXCJjb2xsYXBzZVwiIG9yIFwic3BsaXRcIi5bL2VuXVxuICAgICAgICAqICAgW2phXeePvuWcqOOBruODouODvOODieOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAZXZlbnQgcHJlb3BlblxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBzbGlkaW5nIG1lbnUgaXMgb3BlbmVkLlsvZW5dXG4gICAgICAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GP5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgICAgICAqICAgW2VuXUNhbGwgdG8gY2FuY2VsIG9wZW5pbmcgc2xpZGluZyBtZW51LlsvZW5dXG4gICAgICAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GP44Gu44KS44Kt44Oj44Oz44K744Or44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgICAgICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGV2ZW50IHBvc3RvcGVuXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgc2xpZGluZyBtZW51IGlzIG9wZW5lZC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBhOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgICAgICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGV2ZW50IHByZWNsb3NlXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHNsaWRpbmcgbWVudSBpcyBjbG9zZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICAgICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICAgICAgKiAgIFtlbl1DYWxsIHRvIGNhbmNlbCBvcGVuaW5nIHNsaWRpbmctbWVudS5bL2VuXVxuICAgICAgICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOCi+OBruOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAZXZlbnQgcG9zdGNsb3NlXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgc2xpZGluZyBtZW51IGlzIGNsb3NlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgICAgICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICAgICAgKiBAaW5pdG9ubHlcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uLiBVc2Ugb25lIG9mIFwib3ZlcmxheVwiLCBhbmQgXCJkZWZhdWx0XCIuWy9lbl1cbiAgICAgICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglwib3ZlcmxheVwiLCBcImRlZmF1bHRcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAgICAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvZW5dXG4gICAgICAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgdGhyZXNob2xkLXJhdGlvLXNob3VsZC1vcGVuXG4gICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXVNwZWNpZnkgaG93IG11Y2ggdGhlIG1lbnUgbmVlZHMgdG8gYmUgc3dpcGVkIGJlZm9yZSBvcGVuaW5nLiBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMS4gRGVmYXVsdCBpcyAwLjMuWy9lbl1cbiAgICAgICAgKiAgW2phXeOBqeOBruOBj+OCieOBhOOCueODr+OCpOODl+OBmeOCjOOBsOOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOCkumWi+OBj+OBi+OBqeOBhuOBi+OBruWJsuWQiOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokx44Gu6ZaT44Gu5pWw5YCk44KS5oyH5a6a44GX44G+44GZ44CC44K544Ov44Kk44OX44Gu6Led6Zui44GM44GT44GT44Gn5oyH5a6a44GX44Gf5pWw5YCk5o6b44GR44KL44GT44Gu6KaB57Sg44Gu5bmF44KI44KK44KC5aSn44GN44GR44KM44Gw44CB44K544Ov44Kk44OX44GM57WC44KP44Gj44Gf5pmC44Gr44GT44Gu6KaB57Sg44KS6ZaL44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvMC4z44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgY29sbGFwc2VcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVxuICAgICAgICAqICAgICBTcGVjaWZ5IHRoZSBjb2xsYXBzZSBiZWhhdmlvci4gVmFsaWQgdmFsdWVzIGFyZSBcInBvcnRyYWl0XCIsIFwibGFuZHNjYXBlXCIgb3IgYSBtZWRpYSBxdWVyeS5cbiAgICAgICAgKiAgICAgXCJwb3J0cmFpdFwiIG9yIFwibGFuZHNjYXBlXCIgbWVhbnMgdGhlIHZpZXcgd2lsbCBjb2xsYXBzZSB3aGVuIGRldmljZSBpcyBpbiBsYW5kc2NhcGUgb3IgcG9ydHJhaXQgb3JpZW50YXRpb24uXG4gICAgICAgICogICAgIElmIHRoZSB2YWx1ZSBpcyBhIG1lZGlhIHF1ZXJ5LCB0aGUgdmlldyB3aWxsIGNvbGxhcHNlIHdoZW4gdGhlIG1lZGlhIHF1ZXJ5IGlzIHRydWUuXG4gICAgICAgICogICAgIElmIHRoZSB2YWx1ZSBpcyBub3QgZGVmaW5lZCwgdGhlIHZpZXcgYWx3YXlzIGJlIGluIFwiY29sbGFwc2VcIiBtb2RlLlxuICAgICAgICAqICAgWy9lbl1cbiAgICAgICAgKiAgIFtqYV1cbiAgICAgICAgKiAgICAg5bem5YG044Gu44Oa44O844K444KS6Z2e6KGo56S644Gr44GZ44KL5p2h5Lu244KS5oyH5a6a44GX44G+44GZ44CCcG9ydHJhaXQsIGxhbmRzY2FwZeOAgXdpZHRoICNweOOCguOBl+OBj+OBr+ODoeODh+OCo+OCouOCr+OCqOODquOBruaMh+WumuOBjOWPr+iDveOBp+OBmeOAglxuICAgICAgICAqICAgICBwb3J0cmFpdOOCguOBl+OBj+OBr2xhbmRzY2FwZeOCkuaMh+WumuOBmeOCi+OBqOOAgeODh+ODkOOCpOOCueOBrueUu+mdouOBjOe4puWQkeOBjeOCguOBl+OBj+OBr+aoquWQkeOBjeOBq+OBquOBo+OBn+aZguOBq+mBqeeUqOOBleOCjOOBvuOBmeOAglxuICAgICAgICAqICAgICDjg6Hjg4fjgqPjgqLjgq/jgqjjg6rjgpLmjIflrprjgZnjgovjgajjgIHmjIflrprjgZfjgZ/jgq/jgqjjg6rjgavpganlkIjjgZfjgabjgYTjgovloLTlkIjjgavpgannlKjjgZXjgozjgb7jgZnjgIJcbiAgICAgICAgKiAgICAg5YCk44Gr5L2V44KC5oyH5a6a44GX44Gq44GE5aC05ZCI44Gr44Gv44CB5bi444GrY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgorjgb7jgZnjgIJcbiAgICAgICAgKiAgIFsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIHN3aXBlLXRhcmdldC13aWR0aFxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dVGhlIHdpZHRoIG9mIHN3aXBlYWJsZSBhcmVhIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZWRnZSAoaW4gcGl4ZWxzKS4gVXNlIHRoaXMgdG8gZW5hYmxlIHN3aXBlIG9ubHkgd2hlbiB0aGUgZmluZ2VyIHRvdWNoIG9uIHRoZSBzY3JlZW4gZWRnZS5bL2VuXVxuICAgICAgICAqICAgW2phXeOCueODr+OCpOODl+OBruWIpOWumumgmOWfn+OCkuODlOOCr+OCu+ODq+WNmOS9jeOBp+aMh+WumuOBl+OBvuOBmeOAgueUu+mdouOBruerr+OBi+OCieaMh+WumuOBl+OBn+i3nembouOBq+mBlOOBmeOCi+OBqOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIHdpZHRoXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1DYW4gYmUgc3BlY2lmaWVkIGluIGVpdGhlciBwaXhlbHMgb3IgYXMgYSBwZXJjZW50YWdlLCBlLmcuIFwiOTAlXCIgb3IgXCIyMDBweFwiLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu6KaB57Sg44Gu5qiq5bmF44KS5oyH5a6a44GX44G+44GZ44CCcHjjgagl44Gn44Gu5oyH5a6a44GM5Y+v6IO944Gn44GZ44CCZWcuIDkwJSwgMjAwcHhbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBzaWRlXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1TcGVjaWZ5IHdoaWNoIHNpZGUgb2YgdGhlIHNjcmVlbiB0aGUgb25zLXNwbGl0dGVyLXNpZGUgZWxlbWVudCBpcyBsb2NhdGVkIG9uLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwibGVmdFwiIChkZWZhdWx0KSBhbmQgXCJyaWdodFwiLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu6KaB57Sg44GM5bem44GL5Y+z44GL44KS5oyH5a6a44GX44G+44GZ44CC5oyH5a6a44Gn44GN44KL5YCk44GvXCJsZWZ0XCLjgYtcInJpZ2h0XCLjga7jgb/jgafjgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBtb2RlXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1DdXJyZW50IG1vZGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgXCJjb2xsYXBzZVwiIG9yIFwic3BsaXRcIi4gVGhpcyBhdHRyaWJ1dGUgaXMgcmVhZCBvbmx5LlsvZW5dXG4gICAgICAgICogICBbamFd54++5Zyo44Gu44Oi44O844OJ44GM6Kit5a6a44GV44KM44G+44GZ44CCXCJjb2xsYXBzZVwi44KC44GX44GP44GvXCJzcGxpdFwi44GM5oyH5a6a44GV44KM44G+44GZ44CC44GT44Gu5bGe5oCn44Gv6Kqt44G/6L6844G/5bCC55So44Gn44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgICAgICAqIEBpbml0b25seVxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dVGhlIHVybCBvZiB0aGUgbWVudSBwYWdlLlsvZW5dXG4gICAgICAgICogICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjgavooajnpLrjgZnjgovjg5rjg7zjgrjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBzd2lwZWFibGVcbiAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1XaGV0aGVyIHRvIGVuYWJsZSBzd2lwZSBpbnRlcmFjdGlvbiBvbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAgICAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4nmmYLjgavjgrnjg6/jgqTjg5fmk43kvZzjgpLmnInlirnjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdtb2RlJyxcbiAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgIHRoaXMuX21vZGU7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBTcGxpdHRlclNpZGVFbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zU3BsaXR0ZXJTaWRlRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXNwbGl0dGVyLXNpZGUnLCB7XG4gICAgIHByb3RvdHlwZTogU3BsaXR0ZXJTaWRlRWxlbWVudC5wcm90b3R5cGVcbiAgIH0pO1xuXG4gICB3aW5kb3cuT25zU3BsaXR0ZXJTaWRlRWxlbWVudC5yZXdyaXRhYmxlcyA9IHJld3JpdGFibGVzJDI7XG5cbiAgIHZhciBPdmVybGF5U3BsaXR0ZXJBbmltYXRvciA9IChmdW5jdGlvbiAoX1NwbGl0dGVyQW5pbWF0b3IpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKE92ZXJsYXlTcGxpdHRlckFuaW1hdG9yLCBfU3BsaXR0ZXJBbmltYXRvcik7XG5cbiAgICAgZnVuY3Rpb24gT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IoKSB7XG4gICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IpO1xuXG4gICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsXG4gICAgICAgICBkdXJhdGlvbjogJzAuMycsXG4gICAgICAgICBkZWxheTogJzAnXG4gICAgICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKE92ZXJsYXlTcGxpdHRlckFuaW1hdG9yKS5jYWxsKHRoaXMsIG9wdGlvbnMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhPdmVybGF5U3BsaXR0ZXJBbmltYXRvciwgW3tcbiAgICAgICBrZXk6ICdpc0FjdGl2YXRlZCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzQWN0aXZhdGVkKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2lzQWN0aXZhdGVkO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2xheW91dE9uQ2xvc2UnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXlvdXRPbkNsb3NlKCkge1xuICAgICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpLnF1ZXVlKHtcbiAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwJSknLFxuICAgICAgICAgICB3aWR0aDogdGhpcy5fc2lkZS5fZ2V0V2lkdGgoKVxuICAgICAgICAgfSkucGxheSgpO1xuXG4gICAgICAgICB0aGlzLl9tYXNrLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnbGF5b3V0T25PcGVuJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0T25PcGVuKCkge1xuICAgICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpLnF1ZXVlKHtcbiAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArICh0aGlzLl9zaWRlLl9pc0xlZnRTaWRlKCkgPyAnJyA6ICctJykgKyAnMTAwJSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgd2lkdGg6IHRoaXMuX3NpZGUuX2dldFdpZHRoKClcbiAgICAgICAgIH0pLnBsYXkoKTtcblxuICAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRlbnRFbGVtZW50XG4gICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBzaWRlRWxlbWVudFxuICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbWFza0VsZW1lbnRcbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYWN0aXZhdGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhY3RpdmF0ZShjb250ZW50RWxlbWVudCwgc2lkZUVsZW1lbnQsIG1hc2tFbGVtZW50KSB7XG4gICAgICAgICB0aGlzLl9pc0FjdGl2YXRlZCA9IHRydWU7XG4gICAgICAgICB0aGlzLl9jb250ZW50ID0gY29udGVudEVsZW1lbnQ7XG4gICAgICAgICB0aGlzLl9zaWRlID0gc2lkZUVsZW1lbnQ7XG4gICAgICAgICB0aGlzLl9tYXNrID0gbWFza0VsZW1lbnQ7XG5cbiAgICAgICAgIHRoaXMuX3NldHVwTGF5b3V0KCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaW5hY3RpdmF0ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluYWN0aXZhdGUoKSB7XG4gICAgICAgICB0aGlzLl9pc0FjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgICAgdGhpcy5fY2xlYXJMYXlvdXQoKTtcbiAgICAgICAgIHRoaXMuX2NvbnRlbnQgPSB0aGlzLl9zaWRlID0gdGhpcy5fbWFzayA9IG51bGw7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3RyYW5zbGF0ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zbGF0ZShkaXN0YW5jZSkge1xuICAgICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpLnF1ZXVlKHtcbiAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArICh0aGlzLl9zaWRlLl9pc0xlZnRTaWRlKCkgPyAnJyA6ICctJykgKyBkaXN0YW5jZSArICdweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgfSkucGxheSgpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jbGVhckxheW91dCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhckxheW91dCgpIHtcbiAgICAgICAgIHZhciBzaWRlID0gdGhpcy5fc2lkZTtcbiAgICAgICAgIHZhciBtYXNrID0gdGhpcy5fbWFzaztcblxuICAgICAgICAgc2lkZS5zdHlsZS56SW5kZXggPSAnJztcbiAgICAgICAgIHNpZGUuc3R5bGUucmlnaHQgPSAnJztcbiAgICAgICAgIHNpZGUuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgICAgc2lkZS5zdHlsZS50cmFuc2Zvcm0gPSBzaWRlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICcnO1xuICAgICAgICAgc2lkZS5zdHlsZS50cmFuc2l0aW9uID0gc2lkZS5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gJyc7XG4gICAgICAgICBzaWRlLnN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgICBzaWRlLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgICAgbWFzay5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19zZXR1cExheW91dCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cExheW91dCgpIHtcbiAgICAgICAgIHZhciBzaWRlID0gdGhpcy5fc2lkZTtcblxuICAgICAgICAgc2lkZS5zdHlsZS56SW5kZXggPSAzO1xuICAgICAgICAgc2lkZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICAgaWYgKHNpZGUuX2lzTGVmdFNpZGUoKSkge1xuICAgICAgICAgICBzaWRlLnN0eWxlLmxlZnQgPSAnYXV0byc7XG4gICAgICAgICAgIHNpZGUuc3R5bGUucmlnaHQgPSAnMTAwJSc7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBzaWRlLnN0eWxlLmxlZnQgPSAnMTAwJSc7XG4gICAgICAgICAgIHNpZGUuc3R5bGUucmlnaHQgPSAnYXV0byc7XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdvcGVuJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gb3Blbihkb25lKSB7XG4gICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5fc2lkZS5faXNMZWZ0U2lkZSgpID8gJ3RyYW5zbGF0ZTNkKDEwMCUsIDBweCwgMHB4KScgOiAndHJhbnNsYXRlM2QoLTEwMCUsIDBweCwgMHB4KSc7XG5cbiAgICAgICAgIGFuaW1pdC5ydW5BbGwoYW5pbWl0KHRoaXMuX3NpZGUpLndhaXQodGhpcy5fZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cbiAgICAgICAgIH0sIHtcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuX2R1cmF0aW9uLFxuICAgICAgICAgICB0aW1pbmc6IHRoaXMuX3RpbWluZ1xuICAgICAgICAgfSkucXVldWUoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgIH0pLCBhbmltaXQodGhpcy5fbWFzaykud2FpdCh0aGlzLl9kZWxheSkucXVldWUoe1xuICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgICB9KS5xdWV1ZSh7XG4gICAgICAgICAgIG9wYWNpdHk6ICcxJ1xuICAgICAgICAgfSwge1xuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5fZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogJ2xpbmVhcidcbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2Nsb3NlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoZG9uZSkge1xuICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgIGFuaW1pdC5ydW5BbGwoYW5pbWl0KHRoaXMuX3NpZGUpLndhaXQodGhpcy5fZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgICB9LCB7XG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLl90aW1pbmdcbiAgICAgICAgIH0pLnF1ZXVlKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICBfdGhpczIuX3NpZGUuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICcnO1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICB9KSwgYW5pbWl0KHRoaXMuX21hc2spLndhaXQodGhpcy5fZGVsYXkpLnF1ZXVlKHtcbiAgICAgICAgICAgb3BhY2l0eTogJzAnXG4gICAgICAgICB9LCB7XG4gICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLl9kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiAnbGluZWFyJ1xuICAgICAgICAgfSkucXVldWUoe1xuICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIE92ZXJsYXlTcGxpdHRlckFuaW1hdG9yO1xuICAgfSkoU3BsaXR0ZXJBbmltYXRvcik7XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLXNwbGl0dGVyXG4gICAgKiBAY2F0ZWdvcnkgY29udHJvbFxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgW2VuXUEgY29tcG9uZW50IHRoYXQgZW5hYmxlcyByZXNwb25zaXZlIGxheW91dCBieSBpbXBsZW1lbnRpbmcgYm90aCBhIHR3by1jb2x1bW4gbGF5b3V0IGFuZCBhIHNsaWRpbmcgbWVudSBsYXlvdXQuWy9lbl1cbiAgICAqICBbamFdc2xpZGluZy1tZW5144Goc3BsaXQtdmlld+S4oeaWueOBruapn+iDveOCkuaMgeOBpOODrOOCpOOCouOCpuODiOOBp+OBmeOAglsvamFdXG4gICAgKiBAY29kZXBlbiByT1FPTUxcbiAgICAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1jb250ZW50XG4gICAgKiAgW2VuXW9ucy1zcGxpdHRlci1jb250ZW50IGNvbXBvbmVudFsvZW5dXG4gICAgKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW5044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1zaWRlXG4gICAgKiAgW2VuXW9ucy1zcGxpdHRlci1zaWRlIGNvbXBvbmVudFsvZW5dXG4gICAgKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBndWlkZSBDYWxsaW5nQ29tcG9uZW50QVBJc2Zyb21KYXZhU2NyaXB0XG4gICAgKiAgIFtlbl1Vc2luZyBjb21wb25lbnRzIGZyb20gSmF2YVNjcmlwdFsvZW5dXG4gICAgKiAgIFtqYV1KYXZhU2NyaXB044GL44KJ44Kz44Oz44Od44O844ON44Oz44OI44KS5ZG844Gz5Ye644GZWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8b25zLXNwbGl0dGVyPlxuICAgICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gICAgKiAgICAgLi4uXG4gICAgKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gICAgKlxuICAgICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlPlxuICAgICogICAgIC4uLlxuICAgICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICAgICogPC9vbnMtc3BsaXR0ZXI+XG4gICAgKi9cblxuICAgdmFyIFNwbGl0dGVyRWxlbWVudCA9IChmdW5jdGlvbiAoX0Jhc2VFbGVtZW50KSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhTcGxpdHRlckVsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gU3BsaXR0ZXJFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGxpdHRlckVsZW1lbnQpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3BsaXR0ZXJFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhTcGxpdHRlckVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5fYm91bmRPbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlID0gdGhpcy5fb25Nb2RlQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uTW9kZUNoYW5nZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk1vZGVDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgIGlmIChldmVudC50YXJnZXQucGFyZW50RWxlbWVudCA9PT0gdGhpcykge1xuICAgICAgICAgICB0aGlzLl9sYXlvdXQoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2lkZSAnbGVmdCcgb3IgJ3JpZ2h0Jy5cbiAgICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0U2lkZUVsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2lkZUVsZW1lbnQoc2lkZSkge1xuICAgICAgICAgdmFyIHJlc3VsdCA9IHV0aWwuZmluZENoaWxkKHRoaXMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtc3BsaXR0ZXItc2lkZScgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSA9PT0gc2lkZTtcbiAgICAgICAgIH0pO1xuXG4gICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGUocmVzdWx0KTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfbGF5b3V0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2xheW91dCgpIHtcbiAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5fZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fZ2V0U2lkZUVsZW1lbnQoJ2xlZnQnKTtcbiAgICAgICAgIHZhciByaWdodCA9IHRoaXMuX2dldFNpZGVFbGVtZW50KCdyaWdodCcpO1xuXG4gICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICBpZiAobGVmdCAmJiBsZWZ0LmdldEN1cnJlbnRNb2RlICYmIGxlZnQuZ2V0Q3VycmVudE1vZGUoKSA9PT0gJ3NwbGl0Jykge1xuICAgICAgICAgICAgIGNvbnRlbnQuc3R5bGUubGVmdCA9IGxlZnQuX2dldFdpZHRoKCk7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgY29udGVudC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBpZiAocmlnaHQgJiYgcmlnaHQuZ2V0Q3VycmVudE1vZGUgJiYgcmlnaHQuZ2V0Q3VycmVudE1vZGUoKSA9PT0gJ3NwbGl0Jykge1xuICAgICAgICAgICAgIGNvbnRlbnQuc3R5bGUucmlnaHQgPSByaWdodC5fZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICBjb250ZW50LnN0eWxlLnJpZ2h0ID0gJzBweCc7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0Q29udGVudEVsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29udGVudEVsZW1lbnQoKSB7XG4gICAgICAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1jb250ZW50Jyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHt9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIG9wZW5SaWdodFxuICAgICAgICAqIEBzaWduYXR1cmUgb3BlblJpZ2h0KFtvcHRpb25zXSlcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAgICAgICogICBbZW5dVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgbWVudSBoYXMgYmVlbiBvcGVuZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg6Hjg4vjg6Xjg7zjgYzplovjgYTjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXU9wZW4gcmlnaHQgb25zLXNwbGl0dGVyLXNpZGUgbWVudSBvbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAgICAgICogICBbamFd5Y+z44GuY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50Wy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdvcGVuUmlnaHQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuUmlnaHQoKSB7XG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5fb3BlbigncmlnaHQnLCBvcHRpb25zKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0TWFza0VsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWFza0VsZW1lbnQoKSB7XG4gICAgICAgICB2YXIgbWFzayA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItbWFzaycpO1xuICAgICAgICAgcmV0dXJuIG1hc2sgfHwgdGhpcy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtc3BsaXR0ZXItbWFzaycpKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIG9wZW5MZWZ0XG4gICAgICAgICogQHNpZ25hdHVyZSBvcGVuTGVmdChbb3B0aW9uc10pXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgICAgICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gb3BlbmVkLlsvZW5dXG4gICAgICAgICogICBbamFd44Oh44OL44Ol44O844GM6ZaL44GE44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1PcGVuIGxlZnQgb25zLXNwbGl0dGVyLXNpZGUgbWVudSBvbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAgICAgICogICBbamFd5bem44GuY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWi+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50Wy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdvcGVuTGVmdCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5MZWZ0KCkge1xuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuX29wZW4oJ2xlZnQnLCBvcHRpb25zKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2lkZVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vcGVuJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW4oc2lkZSkge1xuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgdmFyIG1lbnUgPSB0aGlzLl9nZXRTaWRlRWxlbWVudChzaWRlKTtcblxuICAgICAgICAgcmV0dXJuIG1lbnUgPyBtZW51Lm9wZW4ob3B0aW9ucykgOiBQcm9taXNlLnJlamVjdCgnY2hpbGQgXCJvbnMtc3BsaXR0ZXItc2lkZVwiIGVsZW1lbnQgaXMgbm90IGZvdW5kIGluIHRoaXMgZWxlbWVudC4nKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGNsb3NlUmlnaHRcbiAgICAgICAgKiBAc2lnbmF0dXJlIGNsb3NlUmlnaHQoW29wdGlvbnNdKVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICAgICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBtZW51IGhhcyBiZWVuIGNsb3NlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dQ2xvc2UgcmlnaHQgb25zLXNwbGl0dGVyLXNpZGUgbWVudSBvbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAgICAgICogICBbamFd5Y+z44GuY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50Wy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdjbG9zZVJpZ2h0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VSaWdodCgpIHtcbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZSgncmlnaHQnLCBvcHRpb25zKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGNsb3NlTGVmdFxuICAgICAgICAqIEBzaWduYXR1cmUgY2xvc2VMZWZ0KFtvcHRpb25zXSlcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAgICAgICogICBbZW5dVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgbWVudSBoYXMgYmVlbiBjbG9zZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg6Hjg4vjg6Xjg7zjgYzplonjgZjjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUNsb3NlIGxlZnQgb25zLXNwbGl0dGVyLXNpZGUgbWVudSBvbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAgICAgICogICBbamFd5bem44GuY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50Wy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdjbG9zZUxlZnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZUxlZnQoKSB7XG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2UoJ2xlZnQnLCBvcHRpb25zKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2lkZVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jbG9zZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZShzaWRlKSB7XG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICB2YXIgbWVudSA9IHRoaXMuX2dldFNpZGVFbGVtZW50KHNpZGUpO1xuXG4gICAgICAgICByZXR1cm4gbWVudSA/IG1lbnUuY2xvc2Uob3B0aW9ucykgOiBQcm9taXNlLnJlamVjdCgnY2hpbGQgXCJvbnMtc3BsaXR0ZXItc2lkZVwiIGVsZW1lbnQgaXMgbm90IGZvdW5kIGluIHRoaXMgZWxlbWVudC4nKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudFxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICd0b2dnbGVMZWZ0JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlTGVmdCgpIHtcbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgIHJldHVybiB0aGlzLl90b2dnbGUoJ2xlZnQnLCBvcHRpb25zKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudFxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICd0b2dnbGVSaWdodCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZVJpZ2h0KCkge1xuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3RvZ2dsZSgncmlnaHQnLCBvcHRpb25zKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2lkZVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ190b2dnbGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlKHNpZGUpIHtcbiAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgIHZhciBtZW51ID0gdGhpcy5fZ2V0U2lkZUVsZW1lbnQoc2lkZSk7XG5cbiAgICAgICAgIHJldHVybiBtZW51ID8gbWVudS50b2dnbGUob3B0aW9ucykgOiBQcm9taXNlLnJlamVjdCgnY2hpbGQgXCJvbnMtc3BsaXR0ZXItc2lkZVwiIGVsZW1lbnQgaXMgbm90IGZvdW5kIGluIHRoaXMgZWxlbWVudC4nKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGxlZnRJc09wZW5cbiAgICAgICAgKiBAc2lnbmF0dXJlIGxlZnRJc09wZW4oKVxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICogICBbZW5dV2hldGhlciB0aGUgbGVmdCBvbnMtc3BsaXR0ZXItc2lkZSBvbiBjb2xsYXBzZSBtb2RlIGlzIG9wZW5lZC5bL2VuXVxuICAgICAgICAqICAgW2phXeW3puOBrm9ucy1zcGxpdHRlci1zaWRl44GM6ZaL44GE44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1EZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGxlZnQgb25zLXNwbGl0dGVyLXNpZGUgb24gY29sbGFwc2UgbW9kZSBpcyBvcGVuZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3lt6bjga5vbnMtc3BsaXR0ZXItc2lkZeimgee0oOOBjOmWi+OBhOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2xlZnRJc09wZW4nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsZWZ0SXNPcGVuKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2lzT3BlbignbGVmdCcpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgcmlnaHRJc09wZW5cbiAgICAgICAgKiBAc2lnbmF0dXJlIHJpZ2h0SXNPcGVuKClcbiAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAqICAgW2VuXVdoZXRoZXIgdGhlIHJpZ2h0IG9ucy1zcGxpdHRlci1zaWRlIG9uIGNvbGxhcHNlIG1vZGUgaXMgb3BlbmVkLlsvZW5dXG4gICAgICAgICogICBbamFd5Y+z44Gub25zLXNwbGl0dGVyLXNpZGXjgYzplovjgYTjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXURldGVybWluZXMgd2hldGhlciB0aGUgcmlnaHQgb25zLXNwbGl0dGVyLXNpZGUgb24gY29sbGFwc2UgbW9kZSBpcyBvcGVuZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3lj7Pjga5vbnMtc3BsaXR0ZXItc2lkZeimgee0oOOBjOmWi+OBhOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3JpZ2h0SXNPcGVuJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmlnaHRJc09wZW4oKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuKCdyaWdodCcpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaWRlXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2lzT3BlbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc09wZW4oc2lkZSkge1xuICAgICAgICAgdmFyIG1lbnUgPSB0aGlzLl9nZXRTaWRlRWxlbWVudChzaWRlKTtcblxuICAgICAgICAgaWYgKG1lbnUpIHtcbiAgICAgICAgICAgcmV0dXJuIG1lbnUuaXNPcGVuKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGxvYWRDb250ZW50UGFnZVxuICAgICAgICAqIEBzaWduYXR1cmUgbG9hZENvbnRlbnRQYWdlKHBhZ2VVcmwpXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VVcmxcbiAgICAgICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIDxjb2RlPiZsdDtvbnMtdGVtcGxhdGUmZ3Q7PC9jb2RlPi5bL2VuXVxuICAgICAgICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIFvbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU2hvdyB0aGUgcGFnZSBzcGVjaWZpZWQgaW4gcGFnZVVybCBpbiB0aGUgb25zLXNwbGl0dGVyLWNvbnRlbnQgcGFuZS5bL2VuXVxuICAgICAgICAqICAgW2phXW9ucy1zcGxpdHRlci1jb250ZW506KaB57Sg44Gr6KGo56S644GV44KM44KL44Oa44O844K444KScGFnZVVybOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2xvYWRDb250ZW50UGFnZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRDb250ZW50UGFnZShwYWdlKSB7XG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuX2dldENvbnRlbnRFbGVtZW50KCk7XG5cbiAgICAgICAgIHJldHVybiBjb250ZW50ID8gY29udGVudC5sb2FkKHBhZ2UsIG9wdGlvbnMpIDogUHJvbWlzZS5yZWplY3QoJ2NoaWxkIFwib25zLXNwbGl0dGVyLWNvbnRlbnRcIiBlbGVtZW50IGlzIG5vdCBmb3VuZCBpbiB0aGlzIGVsZW1lbnQuJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRGV2aWNlQmFja0J1dHRvbicsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRldmljZUJhY2tCdXR0b24oaGFuZGxlcikge1xuICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLl9nZXRTaWRlRWxlbWVudCgnbGVmdCcpO1xuICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5fZ2V0U2lkZUVsZW1lbnQoJ3JpZ2h0Jyk7XG5cbiAgICAgICAgIGlmIChsZWZ0ICYmIGxlZnQuaXNPcGVuKCkpIHtcbiAgICAgICAgICAgbGVmdC5jbG9zZSgpO1xuICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChyaWdodCAmJiByaWdodC5pc09wZW4oKSkge1xuICAgICAgICAgICByaWdodC5jbG9zZSgpO1xuICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIGhhbmRsZXIuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRhY2hlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICB0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgdGhpcy5fYm91bmRPbkRldmljZUJhY2tCdXR0b24pO1xuICAgICAgICAgdGhpcy5fYXNzZXJ0Q2hpbGRyZW4oKTtcblxuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgdGhpcy5fYm91bmRPbk1vZGVDaGFuZ2UsIGZhbHNlKTtcblxuICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgcmV0dXJuIF90aGlzMi5fbGF5b3V0KCk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIGdldERldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gICAgICAgICogQHNpZ25hdHVyZSBnZXREZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpXG4gICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAqICAgW2VuXURldmljZSBiYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAgICAgICogICBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1SZXRyaWV2ZSB0aGUgYmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgICAgICAqICAgW2phXW9ucy1zcGxpdHRlcuimgee0oOOBq+e0kOS7mOOBhOOBpuOBhOOCi+ODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOCkuWPluW+l+OBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2dldERldmljZUJhY2tCdXR0b25IYW5kbGVyJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fZGV2aWNlQmFja0J1dHRvbkhhbmRsZXI7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2Fzc2VydENoaWxkcmVuJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fzc2VydENoaWxkcmVuKCkge1xuICAgICAgICAgdmFyIG5hbWVzID0gWydvbnMtc3BsaXR0ZXItY29udGVudCcsICdvbnMtc3BsaXR0ZXItc2lkZScsICdvbnMtc3BsaXR0ZXItbWFzayddO1xuICAgICAgICAgdmFyIGNvbnRlbnRDb3VudCA9IDA7XG4gICAgICAgICB2YXIgc2lkZUNvdW50ID0gMDtcbiAgICAgICAgIHZhciBtYXNrQ291bnQgPSAwO1xuXG4gICAgICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG5hbWUgKyAnXCIgZWxlbWVudCBpcyBub3QgYWxsb3dlZCBpbiBcIm9ucy1zcGxpdHRlclwiIGVsZW1lbnQuJyk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICBpZiAobmFtZSA9PT0gJ29ucy1zcGxpdHRlci1jb250ZW50Jykge1xuICAgICAgICAgICAgIGNvbnRlbnRDb3VudCsrO1xuICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdvbnMtc3BsaXR0ZXItY29udGVudCcpIHtcbiAgICAgICAgICAgICBzaWRlQ291bnQrKztcbiAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnb25zLXNwbGl0dGVyLW1hc2snKSB7XG4gICAgICAgICAgICAgbWFza0NvdW50Kys7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuXG4gICAgICAgICBpZiAoY29udGVudENvdW50ID4gMSkge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBtYW55IDxvbnMtc3BsaXR0ZXItY29udGVudD4gZWxlbWVudHMuJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChzaWRlQ291bnQgPiAyKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndG9vIG1hbnkgPG9ucy1zcGxpdHRlci1zaWRlPiBlbGVtZW50cy4nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKG1hc2tDb3VudCA+IDEpIHtcbiAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b28gbWFueSA8b25zLXNwbGl0dGVyLW1hc2s+IGVsZW1lbnRzLicpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAobWFza0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXNwbGl0dGVyLW1hc2snKSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZGV0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICB0aGlzLl9kZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX2JvdW5kT25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3Nob3cnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdygpIHtcbiAgICAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgIGlmIChjaGlsZC5fc2hvdyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgY2hpbGQuX3Nob3coKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2hpZGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZSgpIHtcbiAgICAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgIGlmIChjaGlsZC5faGlkZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgY2hpbGQuX2hpZGUoKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2Rlc3Ryb3knLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgIGlmIChjaGlsZC5fZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgY2hpbGQuX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG4gICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gU3BsaXR0ZXJFbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zU3BsaXR0ZXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3BsaXR0ZXInLCB7XG4gICAgIHByb3RvdHlwZTogU3BsaXR0ZXJFbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIHdpbmRvdy5PbnNTcGxpdHRlckVsZW1lbnQuX2FuaW1hdG9yRGljdCA9IHtcbiAgICAgZGVmYXVsdDogT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IsXG4gICAgIG92ZXJsYXk6IE92ZXJsYXlTcGxpdHRlckFuaW1hdG9yXG4gICB9O1xuXG4gICB3aW5kb3cuT25zU3BsaXR0ZXJFbGVtZW50LnJlZ2lzdGVyQW5pbWF0b3IgPSBmdW5jdGlvbiAobmFtZSwgQW5pbWF0b3IpIHtcbiAgICAgaWYgKCEoQW5pbWF0b3IgaW5zdGFuY2VvZiBTcGxpdHRlckFuaW1hdG9yKSkge1xuICAgICAgIHRocm93IG5ldyBFcnJvcignQW5pbWF0b3IgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgU3BsaXR0ZXJBbmltYXRvci4nKTtcbiAgICAgfVxuICAgICB3aW5kb3cuT25zU3BsaXR0ZXJFbGVtZW50Ll9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgIH07XG5cbiAgIHdpbmRvdy5PbnNTcGxpdHRlckVsZW1lbnQuU3BsaXR0ZXJBbmltYXRvciA9IFNwbGl0dGVyQW5pbWF0b3I7XG5cbiAgIHZhciBzY2hlbWUkMTkgPSB7XG4gICAgICcnOiAnc3dpdGNoLS0qJyxcbiAgICAgJy5zd2l0Y2hfX2lucHV0JzogJ3N3aXRjaC0tKl9faW5wdXQnLFxuICAgICAnLnN3aXRjaF9faGFuZGxlJzogJ3N3aXRjaC0tKl9faGFuZGxlJyxcbiAgICAgJy5zd2l0Y2hfX3RvZ2dsZSc6ICdzd2l0Y2gtLSpfX3RvZ2dsZSdcbiAgIH07XG5cbiAgIHZhciB0ZW1wbGF0ZSQyID0gdXRpbC5jcmVhdGVGcmFnbWVudCgnXFxuICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJzd2l0Y2hfX2lucHV0XCI+XFxuICA8ZGl2IGNsYXNzPVwic3dpdGNoX190b2dnbGVcIj5cXG4gICAgPGRpdiBjbGFzcz1cInN3aXRjaF9faGFuZGxlXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaF9fdG91Y2hcIj48L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG4nKTtcblxuICAgdmFyIGxvY2F0aW9ucyA9IHtcbiAgICAgaW9zOiBbMSwgMjFdLFxuICAgICBtYXRlcmlhbDogWzAsIDE2XVxuICAgfTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtc3dpdGNoXG4gICAgKiBAY2F0ZWdvcnkgZm9ybVxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgW2VuXVN3aXRjaCBjb21wb25lbnQuIENhbiBkaXNwbGF5IGVpdGhlciBhbiBpT1MgZmxhdCBzd2l0Y2ggb3IgYSBNYXRlcmlhbCBEZXNpZ24gc3dpdGNoLlsvZW5dXG4gICAgKiAgW2phXeOCueOCpOODg+ODgeOCkuihqOekuuOBmeOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gICAgKiBAY29kZXBlbiBMcFhaUVFcbiAgICAqIEBndWlkZSBVc2luZ0Zvcm1Db21wb25lbnRzXG4gICAgKiAgIFtlbl1Vc2luZyBmb3JtIGNvbXBvbmVudHNbL2VuXVxuICAgICogICBbamFd44OV44Kp44O844Og44KS5L2/44GGWy9qYV1cbiAgICAqIEBndWlkZSBFdmVudEhhbmRsaW5nXG4gICAgKiAgIFtlbl1FdmVudCBoYW5kbGluZyBkZXNjcmlwdGlvbnNbL2VuXVxuICAgICogICBbamFd44Kk44OZ44Oz44OI5Yem55CG44Gu5L2/44GE5pa5Wy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1idXR0b25cbiAgICAqICAgW2VuXW9ucy1idXR0b24gY29tcG9uZW50Wy9lbl1cbiAgICAqICAgW2phXW9ucy1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICAgICogQGV4YW1wbGVcbiAgICAqIDxvbnMtc3dpdGNoIGNoZWNrZWQ+PC9vbnMtc3dpdGNoPlxuICAgICogPG9ucy1zd2l0Y2ggbW9kaWZpZXI9XCJtYXRlcmlhbFwiPjwvb25zLXN3aXRjaD5cbiAgICAqL1xuXG4gICB2YXIgU3dpdGNoRWxlbWVudCA9IChmdW5jdGlvbiAoX0Jhc2VFbGVtZW50KSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhTd2l0Y2hFbGVtZW50LCBfQmFzZUVsZW1lbnQpO1xuXG4gICAgIGZ1bmN0aW9uIFN3aXRjaEVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFN3aXRjaEVsZW1lbnQpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3dpdGNoRWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoU3dpdGNoRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdpc0NoZWNrZWQnLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBpc0NoZWNrZWRcbiAgICAgICAgKiBAc2lnbmF0dXJlIGlzQ2hlY2tlZCgpXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKiAgIFtlbl10cnVlIGlmIHRoZSBzd2l0Y2ggaXMgb24uWy9lbl1cbiAgICAgICAgKiAgIFtqYV1PTuOBq+OBquOBo+OBpuOBhOOCi+WgtOWQiOOBq+OBr3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVJldHVybnMgdHJ1ZSBpZiB0aGUgc3dpdGNoIGlzIE9OLlsvZW5dXG4gICAgICAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7loLTlkIjjgat0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNDaGVja2VkKCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tlZDtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHNldENoZWNrZWRcbiAgICAgICAgKiBAc2lnbmF0dXJlIHNldENoZWNrZWQoY2hlY2tlZClcbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrZWRcbiAgICAgICAgKiAgIFtlbl1JZiB0cnVlIHRoZSBzd2l0Y2ggd2lsbCBiZSBzZXQgdG8gb24uWy9lbl1cbiAgICAgICAgKiAgIFtqYV1PTuOBq+OBl+OBn+OBhOWgtOWQiOOBq+OBr3RydWXjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNldCB0aGUgdmFsdWUgb2YgdGhlIHN3aXRjaC4gaXNDaGVja2VkIGNhbiBiZSBlaXRoZXIgdHJ1ZSBvciBmYWxzZS5bL2VuXVxuICAgICAgICAqICAgW2phXeOCueOCpOODg+ODgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgmlzQ2hlY2tlZOOBq+OBr3RydWXjgoLjgZfjgY/jga9mYWxzZeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldENoZWNrZWQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDaGVja2VkKGlzQ2hlY2tlZCkge1xuICAgICAgICAgdGhpcy5jaGVja2VkID0gISFpc0NoZWNrZWQ7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQG1ldGhvZCBnZXRDaGVja2JveEVsZW1lbnRcbiAgICAgICAgKiBAc2lnbmF0dXJlIGdldENoZWNrYm94RWxlbWVudCgpXG4gICAgICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAgICAgICogICBbZW5dVGhlIHVuZGVybHlpbmcgY2hlY2tib3ggZWxlbWVudC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOWGhemDqOOBrmNoZWNrYm946KaB57Sg44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1HZXQgaW5uZXIgaW5wdXRbdHlwZT1jaGVja2JveF0gZWxlbWVudC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCueOCpOODg+ODgeOBjOWGheWMheOBmeOCi+OAgWlucHV0W3R5cGU9Y2hlY2tib3hd44Gu6KaB57Sg44KS5Y+W5b6X44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZ2V0Q2hlY2tib3hFbGVtZW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hlY2tib3hFbGVtZW50KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrYm94O1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2NyZWF0ZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2NoZWNrYm94ID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuc3dpdGNoX19pbnB1dCcpO1xuICAgICAgICAgdGhpcy5faGFuZGxlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcuc3dpdGNoX19oYW5kbGUnKTtcblxuICAgICAgICAgWydjaGVja2VkJywgJ2Rpc2FibGVkJywgJ21vZGlmaWVyJywgJ25hbWUnLCAnaW5wdXQtaWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgIF90aGlzMi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZSwgbnVsbCwgX3RoaXMyLmdldEF0dHJpYnV0ZShlKSk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc3dpdGNoJyk7XG5cbiAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUkMi5jbG9uZU5vZGUodHJ1ZSkpO1xuXG4gICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RldGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5fY2hlY2tib3gucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9vbkhvbGQpO1xuICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0YXAnLCB0aGlzLmNsaWNrKTtcbiAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLl9jaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHsgZHJhZ01pbkRpc3RhbmNlOiAxLCBob2xkVGltZW91dDogMjUxIH0pO1xuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9vbkhvbGQpO1xuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0YXAnLCB0aGlzLmNsaWNrKTtcbiAgICAgICAgIHRoaXMuX2JvdW5kT25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG4gICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uQ2hhbmdlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2hhbmdlKCkge1xuICAgICAgICAgaWYgKHRoaXMuY2hlY2tlZCkge1xuICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJycpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkNsaWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2xpY2soZXYpIHtcbiAgICAgICAgIGlmIChldi50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzd2l0Y2hfX3RvdWNoJykpIHtcbiAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdjbGljaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsaWNrKCkge1xuICAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLmdldENoZWNrYm94RWxlbWVudCgpLCAnY2hhbmdlJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2dldFBvc2l0aW9uJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFBvc2l0aW9uKGUpIHtcbiAgICAgICAgIHZhciBsID0gdGhpcy5fbG9jYXRpb25zO1xuICAgICAgICAgcmV0dXJuIE1hdGgubWluKGxbMV0sIE1hdGgubWF4KGxbMF0sIHRoaXMuX3N0YXJ0WCArIGUuZ2VzdHVyZS5kZWx0YVgpKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25Ib2xkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uSG9sZChlKSB7XG4gICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdzd2l0Y2gtLWFjdGl2ZScpO1xuICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19vbkRyYWdTdGFydCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRyYWdTdGFydChlKSB7XG4gICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGUuZ2VzdHVyZS5kaXJlY3Rpb24pID09PSAtMSkge1xuICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3N3aXRjaC0tYWN0aXZlJyk7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnc3dpdGNoLS1hY3RpdmUnKTtcbiAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuX2xvY2F0aW9uc1t0aGlzLmNoZWNrZWQgPyAxIDogMF07IC8vIC0gZS5nZXN0dXJlLmRlbHRhWDtcblxuICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uRHJhZycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRyYWcoZSkge1xuICAgICAgICAgZS5nZXN0dXJlLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICB0aGlzLl9oYW5kbGUuc3R5bGUubGVmdCA9IHRoaXMuX2dldFBvc2l0aW9uKGUpICsgJ3B4JztcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25SZWxlYXNlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uUmVsZWFzZShlKSB7XG4gICAgICAgICB2YXIgbCA9IHRoaXMuX2xvY2F0aW9ucztcbiAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uKGUpO1xuXG4gICAgICAgICB0aGlzLmNoZWNrZWQgPSBwb3NpdGlvbiA+PSAobFswXSArIGxbMV0pIC8gMjtcblxuICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG5cbiAgICAgICAgIHRoaXMuX2hhbmRsZS5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3N3aXRjaC0tYWN0aXZlJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgICAgICAgdGhpcy5faXNNYXRlcmlhbCA9IChjdXJyZW50IHx8ICcnKS5pbmRleE9mKCdtYXRlcmlhbCcpICE9PSAtMTtcbiAgICAgICAgICAgICB0aGlzLl9sb2NhdGlvbnMgPSBsb2NhdGlvbnNbdGhpcy5faXNNYXRlcmlhbCA/ICdtYXRlcmlhbCcgOiAnaW9zJ107XG4gICAgICAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSQxOSk7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgJ2lucHV0LWlkJzpcbiAgICAgICAgICAgICB0aGlzLl9jaGVja2JveC5pZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICB0aGlzLl9jaGVja2JveC5jaGVja2VkID0gY3VycmVudCAhPT0gbnVsbDtcbiAgICAgICAgICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICB0aGlzLl9jaGVja2JveC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICB0aGlzLl9jaGVja2JveC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2NoZWNrZWQnLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIHZhbHVlIGlzIGNoYW5nZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1PTi9PRkbjgYzlpInjgo/jgaPjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnN3aXRjaFxuICAgICAgICAqICAgW2VuXVN3aXRjaCBvYmplY3QuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9Td2l0Y2jjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQudmFsdWVcbiAgICAgICAgKiAgIFtlbl1DdXJyZW50IHZhbHVlLlsvZW5dXG4gICAgICAgICogICBbamFd54++5Zyo44Gu5YCk44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzSW50ZXJhY3RpdmVcbiAgICAgICAgKiAgIFtlbl1UcnVlIGlmIHRoZSBjaGFuZ2Ugd2FzIHRyaWdnZXJlZCBieSB0aGUgdXNlciBjbGlja2luZyBvbiB0aGUgc3dpdGNoLlsvZW5dXG4gICAgICAgICogICBbamFd44K/44OD44OX44KE44Kv44Oq44OD44Kv44Gq44Gp44Gu44Om44O844K244Gu5pON5L2c44Gr44KI44Gj44Gm5aSJ44KP44Gj44Gf5aC05ZCI44Gr44GvdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBzd2l0Y2guWy9lbl1cbiAgICAgICAgKiAgW2phXeOCueOCpOODg+ODgeOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dV2hldGhlciB0aGUgc3dpdGNoIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCueOCpOODg+ODgeOCkueEoeWKueOBrueKtuaFi+OBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGNoZWNrZWRcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBzd2l0Y2ggaXMgY2hlY2tlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCueOCpOODg+ODgeOBjE9O44Gu54q25oWL44Gr44GZ44KL44Go44GN44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgfSxcbiAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgaWYgKCEhdmFsdWUgIT09IHRoaXMuX2NoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgdGhpcy5fY2hlY2tib3guY2xpY2soKTtcbiAgICAgICAgICAgdGhpcy5fY2hlY2tib3guY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgICAgICAgIGlmICh0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICcnKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZGlzYWJsZWQnLFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrYm94LmRpc2FibGVkO1xuICAgICAgIH0sXG4gICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgIHRoaXMuX2NoZWNrYm94LmRpc2FibGVkID0gdmFsdWU7XG4gICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnJyk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFN3aXRjaEVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNTd2l0Y2hFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtc3dpdGNoJywge1xuICAgICBwcm90b3R5cGU6IFN3aXRjaEVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgLypcbiAgIENvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuICAgKi9cblxuICAgdmFyIFRhYmJhckFuaW1hdG9yID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAvKipcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAgICAqL1xuXG4gICAgIGZ1bmN0aW9uIFRhYmJhckFuaW1hdG9yKCkge1xuICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmJhckFuaW1hdG9yKTtcblxuICAgICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gICAgICAgdGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAnMC40JztcbiAgICAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWxheSA6ICcwJztcbiAgICAgfVxuXG4gICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVudGVyUGFnZSBvbnMtcGFnZSBlbGVtZW50XG4gICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbGVhdmVQYWdlIG9ucy1wYWdlIGVsZW1lbnRcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGVudGVyUGFnZUluZGV4XG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWF2ZVBhZ2VJbmRleFxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAgICAqL1xuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhUYWJiYXJBbmltYXRvciwgW3tcbiAgICAgICBrZXk6ICdhcHBseScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGVudGVyUGFnZSwgbGVhdmVQYWdlLCBlbnRlclBhZ2VJbmRleCwgbGVhdmVQYWdlSW5kZXgsIGRvbmUpIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFRhYmJhckFuaW1hdG9yO1xuICAgfSkoKTtcblxuICAgdmFyIFRhYmJhck5vbmVBbmltYXRvciA9IChmdW5jdGlvbiAoX1RhYmJhckFuaW1hdG9yKSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhUYWJiYXJOb25lQW5pbWF0b3IsIF9UYWJiYXJBbmltYXRvcik7XG5cbiAgICAgZnVuY3Rpb24gVGFiYmFyTm9uZUFuaW1hdG9yKCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJiYXJOb25lQW5pbWF0b3IpO1xuICAgICAgIHJldHVybiBiYWJlbEhlbHBlcnMucG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGFiYmFyTm9uZUFuaW1hdG9yKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhUYWJiYXJOb25lQW5pbWF0b3IsIFt7XG4gICAgICAga2V5OiAnYXBwbHknLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgZW50ZXJJbmRleCwgbGVhdmVJbmRleCwgZG9uZSkge1xuICAgICAgICAgc2V0VGltZW91dChkb25lLCAxMDAwIC8gNjApO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gVGFiYmFyTm9uZUFuaW1hdG9yO1xuICAgfSkoVGFiYmFyQW5pbWF0b3IpO1xuXG4gICB2YXIgVGFiYmFyRmFkZUFuaW1hdG9yID0gKGZ1bmN0aW9uIChfVGFiYmFyQW5pbWF0b3IyKSB7XG4gICAgIGJhYmVsSGVscGVycy5pbmhlcml0cyhUYWJiYXJGYWRlQW5pbWF0b3IsIF9UYWJiYXJBbmltYXRvcjIpO1xuXG4gICAgIGZ1bmN0aW9uIFRhYmJhckZhZGVBbmltYXRvcihvcHRpb25zKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmJhckZhZGVBbmltYXRvcik7XG5cbiAgICAgICBvcHRpb25zLnRpbWluZyA9IG9wdGlvbnMudGltaW5nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpbWluZyA6ICdsaW5lYXInO1xuICAgICAgIG9wdGlvbnMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogJzAuNCc7XG4gICAgICAgb3B0aW9ucy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVsYXkgOiAnMCc7XG5cbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRhYmJhckZhZGVBbmltYXRvcikuY2FsbCh0aGlzLCBvcHRpb25zKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoVGFiYmFyRmFkZUFuaW1hdG9yLCBbe1xuICAgICAgIGtleTogJ2FwcGx5JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGVudGVyUGFnZUluZGV4LCBsZWF2ZVBhZ2VJbmRleCwgZG9uZSkge1xuICAgICAgICAgYW5pbWl0LnJ1bkFsbChhbmltaXQoZW50ZXJQYWdlKS5zYXZlU3R5bGUoKS5xdWV1ZSh7XG4gICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgfSwge1xuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkucmVzdG9yZVN0eWxlKCkucXVldWUoZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgIH0pLCBhbmltaXQobGVhdmVQYWdlKS5xdWV1ZSh7XG4gICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgfSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgfSwge1xuICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgfSkpO1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gVGFiYmFyRmFkZUFuaW1hdG9yO1xuICAgfSkoVGFiYmFyQW5pbWF0b3IpO1xuXG4gICB2YXIgVGFiYmFyU2xpZGVBbmltYXRvciA9IChmdW5jdGlvbiAoX1RhYmJhckFuaW1hdG9yMykge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoVGFiYmFyU2xpZGVBbmltYXRvciwgX1RhYmJhckFuaW1hdG9yMyk7XG5cbiAgICAgZnVuY3Rpb24gVGFiYmFyU2xpZGVBbmltYXRvcihvcHRpb25zKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmJhclNsaWRlQW5pbWF0b3IpO1xuXG4gICAgICAgb3B0aW9ucy50aW1pbmcgPSBvcHRpb25zLnRpbWluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1pbmcgOiAnZWFzZS1pbic7XG4gICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAnMC4xNSc7XG4gICAgICAgb3B0aW9ucy5kZWxheSA9IG9wdGlvbnMuZGVsYXkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVsYXkgOiAnMCc7XG5cbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRhYmJhclNsaWRlQW5pbWF0b3IpLmNhbGwodGhpcywgb3B0aW9ucykpO1xuICAgICB9XG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7anFMaXRlfSBlbnRlclBhZ2VcbiAgICAgICogQHBhcmFtIHtqcUxpdGV9IGxlYXZlUGFnZVxuICAgICAgKi9cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoVGFiYmFyU2xpZGVBbmltYXRvciwgW3tcbiAgICAgICBrZXk6ICdhcHBseScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGVudGVyUGFnZSwgbGVhdmVQYWdlLCBlbnRlckluZGV4LCBsZWF2ZUluZGV4LCBkb25lKSB7XG4gICAgICAgICB2YXIgc2duID0gZW50ZXJJbmRleCA+IGxlYXZlSW5kZXg7XG5cbiAgICAgICAgIGFuaW1pdC5ydW5BbGwoYW5pbWl0KGVudGVyUGFnZSkuc2F2ZVN0eWxlKCkucXVldWUoe1xuICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgnICsgKHNnbiA/ICcnIDogJy0nKSArICcxMDAlLCAwLCAwKSdcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgIH0sIHtcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pLnJlc3RvcmVTdHlsZSgpLnF1ZXVlKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICB9KSwgYW5pbWl0KGxlYXZlUGFnZSkucXVldWUoe1xuICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgIH0pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgnICsgKHNnbiA/ICctJyA6ICcnKSArICcxMDAlLCAwLCAwKSdcbiAgICAgICAgIH0sIHtcbiAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgIH0pKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFRhYmJhclNsaWRlQW5pbWF0b3I7XG4gICB9KShUYWJiYXJBbmltYXRvcik7XG5cbiAgIHZhciBzY2hlbWUkMjEgPSB7XG4gICAgICcudGFiLWJhcl9fY29udGVudCc6ICd0YWItYmFyLS0qX19jb250ZW50JyxcbiAgICAgJy50YWItYmFyJzogJ3RhYi1iYXItLSonXG4gICB9O1xuXG4gICB2YXIgX2FuaW1hdG9yRGljdCQ1ID0ge1xuICAgICAnZGVmYXVsdCc6IFRhYmJhck5vbmVBbmltYXRvcixcbiAgICAgJ2ZhZGUnOiBUYWJiYXJGYWRlQW5pbWF0b3IsXG4gICAgICdzbGlkZSc6IFRhYmJhclNsaWRlQW5pbWF0b3IsXG4gICAgICdub25lJzogVGFiYmFyTm9uZUFuaW1hdG9yXG4gICB9O1xuXG4gICB2YXIgcmV3cml0YWJsZXMkMyA9IHtcbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFiYmFyRWxlbWVudFxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgKi9cblxuICAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkodGFiYmFyRWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICBjYWxsYmFjaygpO1xuICAgICB9LFxuXG4gICAgIC8qKlxuICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhYmJhckVsZW1lbnRcbiAgICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICovXG4gICAgIGxpbms6IGZ1bmN0aW9uIGxpbmsodGFiYmFyRWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgIGNhbGxiYWNrKHRhcmdldCk7XG4gICAgIH0sXG5cbiAgICAgLyoqXG4gICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFiYmFyRWxlbWVudFxuICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgKi9cbiAgICAgdW5saW5rOiBmdW5jdGlvbiB1bmxpbmsodGFiYmFyRWxlbWVudCwgdGFyZ2V0LCBjYWxsYmFjaykge1xuICAgICAgIGNhbGxiYWNrKHRhcmdldCk7XG4gICAgIH1cbiAgIH07XG5cbiAgIHZhciBnZW5lcmF0ZUlkJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICB2YXIgaSA9IDA7XG4gICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgcmV0dXJuICdvbnMtdGFiYmFyLWdlbi0nICsgaSsrO1xuICAgICB9O1xuICAgfSkoKTtcblxuICAgLyoqXG4gICAgKiBAZWxlbWVudCBvbnMtdGFiYmFyXG4gICAgKiBAY2F0ZWdvcnkgbmF2aWdhdGlvblxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1BIGNvbXBvbmVudCB0byBkaXNwbGF5IGEgdGFiIGJhciBvbiB0aGUgYm90dG9tIG9mIGEgcGFnZS4gVXNlZCB3aXRoIG9ucy10YWIgdG8gbWFuYWdlIHBhZ2VzIHVzaW5nIHRhYnMuWy9lbl1cbiAgICAqICAgW2phXeOCv+ODluODkOODvOOCkuODmuODvOOCuOS4i+mDqOOBq+ihqOekuuOBmeOCi+OBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAgm9ucy10YWLjgajntYTjgb/lkIjjgo/jgZvjgabkvb/jgYbjgZPjgajjgafjgIHjg5rjg7zjgrjjgpLnrqHnkIbjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICogQGNvZGVwZW4gcEd1RExcbiAgICAqIEBndWlkZSBVc2luZ1RhYkJhclxuICAgICogICBbZW5dVXNpbmcgdGFiIGJhclsvZW5dXG4gICAgKiAgIFtqYV3jgr/jg5bjg5Djg7zjgpLkvb/jgYZbL2phXVxuICAgICogQGd1aWRlIEV2ZW50SGFuZGxpbmdcbiAgICAqICAgW2VuXUV2ZW50IGhhbmRsaW5nIGRlc2NyaXB0aW9uc1svZW5dXG4gICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlh6bnkIbjga7kvb/jgYTmlrlbL2phXVxuICAgICogQGd1aWRlIENhbGxpbmdDb21wb25lbnRBUElzZnJvbUphdmFTY3JpcHRcbiAgICAqICAgW2VuXVVzaW5nIG5hdmlnYXRvciBmcm9tIEphdmFTY3JpcHRbL2VuXVxuICAgICogICBbamFdSmF2YVNjcmlwdOOBi+OCieOCs+ODs+ODneODvOODjeODs+ODiOOCkuWRvOOBs+WHuuOBmVsvamFdXG4gICAgKiBAZ3VpZGUgRGVmaW5pbmdNdWx0aXBsZVBhZ2VzaW5TaW5nbGVIVE1MXG4gICAgKiAgIFtlbl1EZWZpbmluZyBtdWx0aXBsZSBwYWdlcyBpbiBzaW5nbGUgaHRtbFsvZW5dXG4gICAgKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpIx44Gk44GuSFRNTOOBq+iomOi/sOOBmeOCi1svamFdXG4gICAgKiBAc2VlYWxzbyBvbnMtdGFiXG4gICAgKiAgIFtlbl1vbnMtdGFiIGNvbXBvbmVudFsvZW5dXG4gICAgKiAgIFtqYV1vbnMtdGFi44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1wYWdlXG4gICAgKiAgIFtlbl1vbnMtcGFnZSBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLXBhZ2XjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICAgICogQGV4YW1wbGVcbiAgICAqIDxvbnMtdGFiYmFyPlxuICAgICogICA8b25zLXRhYiBwYWdlPVwiaG9tZS5odG1sXCIgYWN0aXZlPVwidHJ1ZVwiPlxuICAgICogICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLWhvbWVcIj48L29ucy1pY29uPlxuICAgICogICAgIDxzcGFuIHN0eWxlPVwiZm9udC1zaXplOiAxNHB4XCI+SG9tZTwvc3Bhbj5cbiAgICAqICAgPC9vbnMtdGFiPlxuICAgICogICA8b25zLXRhYiBwYWdlPVwiZmF2Lmh0bWxcIiBhY3RpdmU9XCJ0cnVlXCI+XG4gICAgKiAgICAgPG9ucy1pY29uIGljb249XCJpb24tc3RhclwiPjwvb25zLWljb24+XG4gICAgKiAgICAgPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDE0cHhcIj5GYXZvcml0ZXM8L3NwYW4+XG4gICAgKiAgIDwvb25zLXRhYj5cbiAgICAqICAgPG9ucy10YWIgcGFnZT1cInNldHRpbmdzLmh0bWxcIiBhY3RpdmU9XCJ0cnVlXCI+XG4gICAgKiAgICAgPG9ucy1pY29uIGljb249XCJpb24tZ2Vhci1hXCI+PC9vbnMtaWNvbj5cbiAgICAqICAgICA8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMTRweFwiPlNldHRpbmdzPC9zcGFuPlxuICAgICogICA8L29ucy10YWI+XG4gICAgKiA8L29ucy10YWJiYXI+XG4gICAgKlxuICAgICogPG9ucy10ZW1wbGF0ZSBpZD1cImhvbWUuaHRtbFwiPlxuICAgICogICAuLi5cbiAgICAqIDwvb25zLXRlbXBsYXRlPlxuICAgICpcbiAgICAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJmYXYuaHRtbFwiPlxuICAgICogICAuLi5cbiAgICAqIDwvb25zLXRlbXBsYXRlPlxuICAgICpcbiAgICAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJzZXR0aW5ncy5odG1sXCI+XG4gICAgKiAgIC4uLlxuICAgICogPC9vbnMtdGVtcGxhdGU+XG4gICAgKi9cblxuICAgdmFyIFRhYmJhckVsZW1lbnQgPSAoZnVuY3Rpb24gKF9CYXNlRWxlbWVudCkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoVGFiYmFyRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBUYWJiYXJFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJiYXJFbGVtZW50KTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRhYmJhckVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKFRhYmJhckVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBwcmVjaGFuZ2VcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1GaXJlcyBqdXN0IGJlZm9yZSB0aGUgdGFiIGlzIGNoYW5nZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjgYzlpInjgo/jgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAgICAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgICAgICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAgICAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAgICAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgY2hhbmdlIGV2ZW50LlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CB44Ki44Kv44OG44Kj44OW44Gq44K/44OW44Gu5aSJ5pu044GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRmlyZXMganVzdCBhZnRlciB0aGUgdGFiIGlzIGNoYW5nZWQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjgYzlpInjgo/jgaPjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAgICAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgICAgICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAgICAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAZXZlbnQgcmVhY3RpdmVcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1GaXJlcyBpZiB0aGUgYWxyZWFkeSBvcGVuIHRhYiBpcyB0YXBwZWQgYWdhaW4uWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgZnjgafjgavjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovjgr/jg5bjgYzjgoLjgYbkuIDluqbjgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgZXjgozjgZ/loLTlkIjjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAgICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAgICAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgICAgICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi29ucy10YWLjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YWJJdGVtXG4gICAgICAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFddGFiSXRlbeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlZmF1bHQgbm9uZVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBQcmVzZXQgdmFsdWVzIGFyZSBcIm5vbmVcIiwgXCJzbGlkZVwiIGFuZCBcImZhZGVcIi4gRGVmYXVsdCBpcyBcIm5vbmVcIi5bL2VuXVxuICAgICAgICAqICAgW2phXeODmuODvOOCuOiqreOBv+i+vOOBv+aZguOBruOCouODi+ODoeODvOOCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44CBXCJmYWRlXCLjgIFcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLpgbjmip7jgafjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cIm5vbmVcIuOBp+OBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAgICAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvZW5dXG4gICAgICAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgcG9zaXRpb25cbiAgICAgICAgKiBAaW5pdG9ubHlcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZWZhdWx0IGJvdHRvbVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVRhYmJhcidzIHBvc2l0aW9uLiBQcmVzZXQgdmFsdWVzIGFyZSBcImJvdHRvbVwiIGFuZCBcInRvcFwiLiBEZWZhdWx0IGlzIFwiYm90dG9tXCIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgr/jg5bjg5Djg7zjga7kvY3nva7jgpLmjIflrprjgZfjgb7jgZnjgIJcImJvdHRvbVwi44KC44GX44GP44GvXCJ0b3BcIuOCkumBuOaKnuOBp+OBjeOBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr1wiYm90dG9tXCLjgafjgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgIHRoaXMuX3RhYmJhcklkID0gZ2VuZXJhdGVJZCQxKCk7XG5cbiAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpcnN0Q2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgdGhpcy5maXJzdENoaWxkLmNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmVJbmRleCcpO1xuXG4gICAgICAgICBpZiAoYWN0aXZlSW5kZXggJiYgdGhpcy5jaGlsZHJlblsxXS5jaGlsZHJlbi5sZW5ndGggPiBhY3RpdmVJbmRleCkge1xuICAgICAgICAgICB0aGlzLmNoaWxkcmVuWzFdLmNoaWxkcmVuW2FjdGl2ZUluZGV4XS5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICd0cnVlJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgICAgICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUkMjEpO1xuXG4gICAgICAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0JDUsXG4gICAgICAgICAgIGJhc2VDbGFzczogVGFiYmFyQW5pbWF0b3IsXG4gICAgICAgICAgIGJhc2VDbGFzc05hbWU6ICdUYWJiYXJBbmltYXRvcicsXG4gICAgICAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2NvbXBpbGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcGlsZSgpIHtcbiAgICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gJ3RvcCcgOiAnYm90dG9tJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgICAgICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdvbnMtdGFiLWJhcl9fY29udGVudCcpO1xuICAgICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCd0YWItYmFyX19jb250ZW50Jyk7XG5cbiAgICAgICAgIHZhciB0YWJiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgIHRhYmJhci5jbGFzc0xpc3QuYWRkKCd0YWItYmFyJyk7XG4gICAgICAgICB0YWJiYXIuY2xhc3NMaXN0LmFkZCgnb25zLXRhYi1iYXJfX2Zvb3RlcicpO1xuICAgICAgICAgdGFiYmFyLmNsYXNzTGlzdC5hZGQoJ29ucy10YWJiYXItaW5uZXInKTtcblxuICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQodGFiYmFyKTtcblxuICAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgICB0YWJiYXIuYXBwZW5kQ2hpbGQodGhpcy5yZW1vdmVDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcblxuICAgICAgICAgaWYgKHRoaXMuX2hhc1RvcFRhYmJhcigpKSB7XG4gICAgICAgICAgIHRoaXMuX3ByZXBhcmVGb3JUb3BUYWJiYXIoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfaGFzVG9wVGFiYmFyJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhc1RvcFRhYmJhcigpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKSA9PT0gJ3RvcCc7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3ByZXBhcmVGb3JUb3BUYWJiYXInLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZUZvclRvcFRhYmJhcigpIHtcbiAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICB2YXIgY29udGVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcl9fY29udGVudCcpO1xuICAgICAgICAgdmFyIHRhYmJhciA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcicpO1xuXG4gICAgICAgICBjb250ZW50LnNldEF0dHJpYnV0ZSgnbm8tc3RhdHVzLWJhci1maWxsJywgJycpO1xuXG4gICAgICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ3RhYi1iYXItLXRvcF9fY29udGVudCcpO1xuICAgICAgICAgdGFiYmFyLmNsYXNzTGlzdC5hZGQoJ3RhYi1iYXItLXRvcCcpO1xuXG4gICAgICAgICB2YXIgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcbiAgICAgICAgIGlmIChwYWdlKSB7XG4gICAgICAgICAgIHRoaXMuc3R5bGUudG9wID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKTtcblxuICAgICAgICAgICBpZiAocGFnZS5maXJzdENoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10b29sYmFyJykge1xuICAgICAgICAgICAgIHV0aWwuYWRkTW9kaWZpZXIocGFnZS5maXJzdENoaWxkLCAnbm9zaGFkb3cnKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICBpbnRlcm5hbC5zaG91bGRGaWxsU3RhdHVzQmFyKHRoaXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICB2YXIgZmlsbCA9IF90aGlzMi5xdWVyeVNlbGVjdG9yKCcudGFiLWJhcl9fc3RhdHVzLWJhci1maWxsJyk7XG5cbiAgICAgICAgICAgaWYgKGZpbGwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgIHJldHVybiBmaWxsO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgZmlsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICBmaWxsLmNsYXNzTGlzdC5hZGQoJ3RhYi1iYXJfX3N0YXR1cy1iYXItZmlsbCcpO1xuICAgICAgICAgICBmaWxsLnN0eWxlLndpZHRoID0gJzBweCc7XG4gICAgICAgICAgIGZpbGwuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG5cbiAgICAgICAgICAgX3RoaXMyLmluc2VydEJlZm9yZShmaWxsLCBfdGhpczIuY2hpbGRyZW5bMF0pO1xuXG4gICAgICAgICAgIHJldHVybiBmaWxsO1xuICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICB2YXIgZWwgPSBfdGhpczIucXVlcnlTZWxlY3RvcignLnRhYi1iYXJfX3N0YXR1cy1iYXItZmlsbCcpO1xuICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgIGVsLnJlbW92ZSgpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0VGFiYmFyRWxlbWVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUYWJiYXJFbGVtZW50KCkge1xuICAgICAgICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiLWJhcicpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgbG9hZFBhZ2VcbiAgICAgICAgKiBAc2lnbmF0dXJlIGxvYWRQYWdlKHVybCwgW29wdGlvbnNdKVxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIDxjb2RlPiZsdDtvbnMtdGVtcGxhdGUmZ3Q7PC9jb2RlPi5bL2VuXVxuICAgICAgICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga88Y29kZT4mbHQ7b25zLXRlbXBsYXRlJmd0OzwvY29kZT7jgaflrqPoqIDjgZfjgZ9pZOWxnuaAp+OBruWApOOCkuWIqeeUqOOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dRGlzcGxheXMgYSBuZXcgcGFnZSB3aXRob3V0IGNoYW5naW5nIHRoZSBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICAgICAgKiAgIFtqYV3nj77lnKjjga7jgqLjgq/jg4bjgqPjg5bjgarjgqTjg7Pjg4fjg4Pjgq/jgrnjgpLlpInmm7TjgZvjgZrjgavjgIHmlrDjgZfjgYTjg5rjg7zjgrjjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICAgICAgKiAgIFtlbl1bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgICAgICAqICAgW2VuXVsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAgICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAgICAgICogICBbamFdWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnbG9hZFBhZ2UnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkUGFnZShwYWdlKSB7XG4gICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgIE9uc1RhYkVsZW1lbnQucHJvdG90eXBlLl9jcmVhdGVQYWdlRWxlbWVudChwYWdlLCBmdW5jdGlvbiAocGFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICByZXNvbHZlKF90aGlzMy5fbG9hZFBhZ2VET01Bc3luYyhwYWdlRWxlbWVudCwgb3B0aW9ucykpO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgIH0pO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcGFnZUVsZW1lbnRcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAgICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQuXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19sb2FkUGFnZURPTUFzeW5jJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRQYWdlRE9NQXN5bmMocGFnZUVsZW1lbnQpIHtcbiAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgcmV3cml0YWJsZXMkMy5saW5rKF90aGlzNCwgcGFnZUVsZW1lbnQsIG9wdGlvbnMsIGZ1bmN0aW9uIChwYWdlRWxlbWVudCkge1xuICAgICAgICAgICAgIF90aGlzNC5fY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFnZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgaWYgKF90aGlzNC5nZXRBY3RpdmVUYWJJbmRleCgpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpczQuX3N3aXRjaFBhZ2UocGFnZUVsZW1lbnQsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIF90aGlzNC5fb2xkUGFnZUVsZW1lbnQgPSBwYWdlRWxlbWVudDtcbiAgICAgICAgICAgICAgIHJlc29sdmUocGFnZUVsZW1lbnQpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2dldFRhYmJhcklkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFiYmFySWQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fdGFiYmFySWQ7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7RWxlbWVudC9udWxsfVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0Q3VycmVudFBhZ2VFbGVtZW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEN1cnJlbnRQYWdlRWxlbWVudCgpIHtcbiAgICAgICAgIHZhciBwYWdlcyA9IHRoaXMuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuO1xuICAgICAgICAgdmFyIHBhZ2UgPSBudWxsO1xuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICBpZiAocGFnZXNbaV0uc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgcGFnZSA9IHBhZ2VzW2ldO1xuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChwYWdlICYmIHBhZ2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1wYWdlJykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGU6IHBhZ2UgZWxlbWVudCBtdXN0IGJlIGEgXCJvbnMtcGFnZVwiIGVsZW1lbnQuJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBwYWdlO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19zd2l0Y2hQYWdlJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zZWxlY3RlZFRhYkluZGV4XG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucHJldmlvdXNUYWJJbmRleFxuICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlxuICAgICAgICAqL1xuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3dpdGNoUGFnZShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgICB2YXIgb2xkUGFnZUVsZW1lbnQgPSB0aGlzLl9vbGRQYWdlRWxlbWVudCB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgICAgICAgIHRoaXMuX29sZFBhZ2VFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgIHZhciBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcblxuICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgIGlmIChvbGRQYWdlRWxlbWVudCAhPT0gaW50ZXJuYWwubnVsbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICBvbGRQYWdlRWxlbWVudC5faGlkZSgpO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgYW5pbWF0b3IuYXBwbHkoZWxlbWVudCwgb2xkUGFnZUVsZW1lbnQsIG9wdGlvbnMuc2VsZWN0ZWRUYWJJbmRleCwgb3B0aW9ucy5wcmV2aW91c1RhYkluZGV4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgaWYgKG9sZFBhZ2VFbGVtZW50ICE9PSBpbnRlcm5hbC5udWxsRWxlbWVudCkge1xuICAgICAgICAgICAgICAgb2xkUGFnZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgIGVsZW1lbnQuX3Nob3coKTtcblxuICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICByZXNvbHZlKGVsZW1lbnQpO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgIH0pO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2Qgc2V0QWN0aXZlVGFiXG4gICAgICAgICogQHNpZ25hdHVyZSBzZXRBY3RpdmVUYWIoaW5kZXgsIFtvcHRpb25zXSlcbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgICAgKiAgIFtlbl1UYWIgaW5kZXguWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgr/jg5bjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAgICAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmtlZXBQYWdlXVxuICAgICAgICAqICAgW2VuXUlmIHRydWUgdGhlIHBhZ2Ugd2lsbCBub3QgYmUgY2hhbmdlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeOCv+ODluODkOODvOOBjOePvuWcqOihqOekuuOBl+OBpuOBhOOCi3BhZ2XjgpLlpInjgYjjgarjgYTloLTlkIjjgavjga90cnVl44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgICAgICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJmYWRlXCIsIFwic2xpZGVcIiBhbmQgXCJub25lXCIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGVcIuOAgVwic2xpZGVcIuOAgVwibm9uZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICAgICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNob3cgc3BlY2lmaWVkIHRhYiBwYWdlLiBBbmltYXRpb25zIGFuZCBvdGhlciBvcHRpb25zIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHNlY29uZCBwYXJhbWV0ZXIuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3mjIflrprjgZfjgZ/jgqTjg7Pjg4fjg4Pjgq/jgrnjga7jgr/jg5bjgpLooajnpLrjgZfjgb7jgZnjgILjgqLjg4vjg6Hjg7zjgrfjg6fjg7Pjgarjganjga7jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICAgICAgKiAgIFtqYV1bL2phXVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdzZXRBY3RpdmVUYWInLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBY3RpdmVUYWIoaW5kZXgpIHtcbiAgICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICBpZiAob3B0aW9ucyAmJiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBiYWJlbEhlbHBlcnMudHlwZW9mKG9wdGlvbnMpKSAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSwgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkpO1xuXG4gICAgICAgICBpZiAoIW9wdGlvbnMuYW5pbWF0aW9uICYmIHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24nKSkge1xuICAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIHByZXZpb3VzVGFiID0gdGhpcy5fZ2V0QWN0aXZlVGFiRWxlbWVudCgpLFxuICAgICAgICAgICAgIHNlbGVjdGVkVGFiID0gdGhpcy5fZ2V0VGFiRWxlbWVudChpbmRleCksXG4gICAgICAgICAgICAgcHJldmlvdXNUYWJJbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKSxcbiAgICAgICAgICAgICBzZWxlY3RlZFRhYkluZGV4ID0gaW5kZXgsXG4gICAgICAgICAgICAgcHJldmlvdXNQYWdlRWxlbWVudCA9IHRoaXMuX2dldEN1cnJlbnRQYWdlRWxlbWVudCgpO1xuXG4gICAgICAgICBpZiAoIXNlbGVjdGVkVGFiKSB7XG4gICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnU3BlY2lmaWVkIGluZGV4IGRvZXMgbm90IG1hdGNoIGFueSB0YWIuJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChzZWxlY3RlZFRhYkluZGV4ID09PSBwcmV2aW91c1RhYkluZGV4KSB7XG4gICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncmVhY3RpdmUnLCB7XG4gICAgICAgICAgICAgaW5kZXg6IHNlbGVjdGVkVGFiSW5kZXgsXG4gICAgICAgICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWJcbiAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcmV2aW91c1BhZ2VFbGVtZW50KTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG5cbiAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlY2hhbmdlJywge1xuICAgICAgICAgICBpbmRleDogc2VsZWN0ZWRUYWJJbmRleCxcbiAgICAgICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWIsXG4gICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICAgICAgIHJldHVybiBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuXG4gICAgICAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgICAgICAgc2VsZWN0ZWRUYWIuc2V0SW5hY3RpdmUoKTtcbiAgICAgICAgICAgaWYgKHByZXZpb3VzVGFiKSB7XG4gICAgICAgICAgICAgcHJldmlvdXNUYWIuc2V0QWN0aXZlKCk7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVjaGFuZ2UgZXZlbnQuJyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHNlbGVjdGVkVGFiLnNldEFjdGl2ZSgpO1xuXG4gICAgICAgICB2YXIgbmVlZExvYWQgPSAhc2VsZWN0ZWRUYWIuaXNMb2FkZWQoKSAmJiAhb3B0aW9ucy5rZWVwUGFnZTtcblxuICAgICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWIpIHtcbiAgICAgICAgICAgaWYgKHRhYiAhPSBzZWxlY3RlZFRhYikge1xuICAgICAgICAgICAgIHRhYi5zZXRJbmFjdGl2ZSgpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIGlmICghbmVlZExvYWQpIHtcbiAgICAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudChfdGhpczUsICdwb3N0Y2hhbmdlJywge1xuICAgICAgICAgICAgICAgICBpbmRleDogc2VsZWN0ZWRUYWJJbmRleCxcbiAgICAgICAgICAgICAgICAgdGFiSXRlbTogc2VsZWN0ZWRUYWJcbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIGlmIChuZWVkTG9hZCkge1xuICAgICAgICAgICB2YXIgcmVtb3ZlRWxlbWVudDtcbiAgICAgICAgICAgdmFyIHBhcmFtcztcblxuICAgICAgICAgICB2YXIgX3JldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgaWYgKCFwcmV2aW91c1RhYiAmJiBwcmV2aW91c1BhZ2VFbGVtZW50IHx8IHByZXZpb3VzVGFiICYmIHByZXZpb3VzVGFiLl9wYWdlRWxlbWVudCAhPT0gcHJldmlvdXNQYWdlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQoX3RoaXM1LCAncG9zdGNoYW5nZScsIHtcbiAgICAgICAgICAgICAgICAgICBpbmRleDogc2VsZWN0ZWRUYWJJbmRleCxcbiAgICAgICAgICAgICAgICAgICB0YWJJdGVtOiBzZWxlY3RlZFRhYlxuICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgcHJldmlvdXNUYWJJbmRleDogcHJldmlvdXNUYWJJbmRleCxcbiAgICAgICAgICAgICAgIHNlbGVjdGVkVGFiSW5kZXg6IHNlbGVjdGVkVGFiSW5kZXhcbiAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICBwYXJhbXMuYW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb247XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgcGFyYW1zLmFuaW1hdGlvbk9wdGlvbnMgPSBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgICB2YXIgbGluayA9IGZ1bmN0aW9uIGxpbmsoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgIHJld3JpdGFibGVzJDMubGluayhfdGhpczUsIGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIHY6IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgIHNlbGVjdGVkVGFiLl9sb2FkUGFnZUVsZW1lbnQoZnVuY3Rpb24gKHBhZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpczUuX2xvYWRQZXJzaXN0ZW50UGFnZURPTShwYWdlRWxlbWVudCwgcGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgIH0sIGxpbmspO1xuICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICB9O1xuICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgIGlmICgodHlwZW9mIF9yZXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBiYWJlbEhlbHBlcnMudHlwZW9mKF9yZXQpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcmV2aW91c1BhZ2VFbGVtZW50KTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmFuaW1hdGlvblxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfbG9hZFBlcnNpc3RlbnRQYWdlRE9NJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRQZXJzaXN0ZW50UGFnZURPTShlbGVtZW50KSB7XG4gICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICBpZiAoIXV0aWwuaXNBdHRhY2hlZChlbGVtZW50KSkge1xuICAgICAgICAgICB0aGlzLl9jb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICByZXR1cm4gdGhpcy5fc3dpdGNoUGFnZShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAbWV0aG9kIHNldFRhYmJhclZpc2liaWxpdHlcbiAgICAgICAgKiBAc2lnbmF0dXJlIHNldFRhYmJhclZpc2liaWxpdHkodmlzaWJsZSlcbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGVcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1bL2VuXVxuICAgICAgICAqICAgW2phXVsvamFdXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldFRhYmJhclZpc2liaWxpdHknLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUYWJiYXJWaXNpYmlsaXR5KHZpc2libGUpIHtcbiAgICAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LnN0eWxlW3RoaXMuX2hhc1RvcFRhYmJhcigpID8gJ3RvcCcgOiAnYm90dG9tJ10gPSB2aXNpYmxlID8gJycgOiAnMHB4JztcbiAgICAgICAgIHRoaXMuX2dldFRhYmJhckVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/ICcnIDogJ25vbmUnO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBtZXRob2QgZ2V0QWN0aXZlVGFiSW5kZXhcbiAgICAgICAgKiBAc2lnbmF0dXJlIGdldEFjdGl2ZVRhYkluZGV4KClcbiAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICogICBbZW5dVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhYi5bL2VuXVxuICAgICAgICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dUmV0dXJucyB0YWIgaW5kZXggb24gY3VycmVudCBhY3RpdmUgdGFiLiBJZiBhY3RpdmUgdGFiIGlzIG5vdCBmb3VuZCwgcmV0dXJucyAtMS5bL2VuXVxuICAgICAgICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+OCv+ODluOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAguePvuWcqOOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBjOOBquOBhOWgtOWQiOOBq+OBry0x44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZ2V0QWN0aXZlVGFiSW5kZXgnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBY3RpdmVUYWJJbmRleCgpIHtcbiAgICAgICAgIHZhciB0YWJzID0gdGhpcy5fZ2V0VGFiYmFyRWxlbWVudCgpLmNoaWxkcmVuO1xuXG4gICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgaWYgKHRhYnNbaV0gaW5zdGFuY2VvZiB3aW5kb3cuT25zVGFiRWxlbWVudCAmJiB0YWJzW2ldLmlzQWN0aXZlICYmIHRhYnNbaV0uaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICB9XG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFdoZW4gYWN0aXZlIHRhYiBpcyBub3QgZm91bmQsIHJldHVybnMgLTEuXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19nZXRBY3RpdmVUYWJFbGVtZW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFjdGl2ZVRhYkVsZW1lbnQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGFiRWxlbWVudCh0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCkpO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19nZXRUYWJFbGVtZW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRhYkVsZW1lbnQoaW5kZXgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9nZXRUYWJiYXJFbGVtZW50KCkuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RldGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZENhbGxiYWNrKCkge31cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hlZENhbGxiYWNrKCkge31cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19zaG93JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3coKSB7XG4gICAgICAgICB2YXIgY3VycmVudFBhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk7XG4gICAgICAgICBpZiAoY3VycmVudFBhZ2VFbGVtZW50KSB7XG4gICAgICAgICAgIGN1cnJlbnRQYWdlRWxlbWVudC5fc2hvdygpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19oaWRlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoKSB7XG4gICAgICAgICB2YXIgY3VycmVudFBhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0Q3VycmVudFBhZ2VFbGVtZW50KCk7XG4gICAgICAgICBpZiAoY3VycmVudFBhZ2VFbGVtZW50KSB7XG4gICAgICAgICAgIGN1cnJlbnRQYWdlRWxlbWVudC5faGlkZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19kZXN0cm95JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICAgICB2YXIgcGFnZXMgPSB0aGlzLl9jb250ZW50RWxlbWVudC5jaGlsZHJlbjtcbiAgICAgICAgIGZvciAodmFyIGkgPSBwYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICBwYWdlc1tpXS5fZGVzdHJveSgpO1xuICAgICAgICAgfVxuICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUkMjEpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jb250ZW50RWxlbWVudCcsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyX19jb250ZW50Jyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAncGFnZXMnLFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFRhYmJhckVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNUYWJiYXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtdGFiYmFyJywge1xuICAgICBwcm90b3R5cGU6IFRhYmJhckVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQW5pbWF0b3JcbiAgICAqL1xuICAgd2luZG93Lk9uc1RhYmJhckVsZW1lbnQucmVnaXN0ZXJBbmltYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBBbmltYXRvcikge1xuICAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBUYWJiYXJBbmltYXRvcikpIHtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zVGFiYmFyRWxlbWVudC5UYWJiYXJBbmltYXRvcicpO1xuICAgICB9XG4gICAgIF9hbmltYXRvckRpY3QkNVtuYW1lXSA9IEFuaW1hdG9yO1xuICAgfTtcblxuICAgd2luZG93Lk9uc1RhYmJhckVsZW1lbnQucmV3cml0YWJsZXMgPSByZXdyaXRhYmxlcyQzO1xuICAgd2luZG93Lk9uc1RhYmJhckVsZW1lbnQuVGFiYmFyQW5pbWF0b3IgPSBUYWJiYXJBbmltYXRvcjtcblxuICAgdmFyIE9uc1RhYmJhckVsZW1lbnQkMSA9IE9uc1RhYmJhckVsZW1lbnQ7XG5cbiAgIHZhciBzY2hlbWUkMjAgPSB7XG4gICAgICcnOiAndGFiLWJhci0tKl9faXRlbScsXG4gICAgICcudGFiLWJhcl9fYnV0dG9uJzogJ3RhYi1iYXItLSpfX2J1dHRvbidcbiAgIH07XG4gICB2YXIgdGVtcGxhdGVTb3VyY2UkMyA9IHV0aWwuY3JlYXRlRWxlbWVudCgnXFxuICA8ZGl2PlxcbiAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lXCI+XFxuICAgIDxidXR0b24gY2xhc3M9XCJ0YWItYmFyX19idXR0b24gdGFiLWJhci1pbm5lclwiPjwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuJyk7XG4gICB2YXIgZGVmYXVsdElubmVyVGVtcGxhdGVTb3VyY2UgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoJ1xcbiAgPGRpdj5cXG4gICAgPGRpdiBjbGFzcz1cInRhYi1iYXJfX2ljb25cIj5cXG4gICAgICA8b25zLWljb24gaWNvbj1cImlvbi1jbG91ZFwiIHN0eWxlPVwiZm9udC1zaXplOiAyOHB4OyBsaW5lLWhlaWdodDogMzRweDsgdmVydGljYWwtYWxpZ246IHRvcDtcIj48L29ucy1pY29uPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cInRhYi1iYXJfX2xhYmVsXCI+bGFiZWw8L2Rpdj5cXG4gIDwvZGl2PlxcbicpO1xuXG4gICAvKipcbiAgICAqIEBlbGVtZW50IG9ucy10YWJcbiAgICAqIEBjYXRlZ29yeSBuYXZpZ2F0aW9uXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXVJlcHJlc2VudHMgYSB0YWIgaW5zaWRlIHRhYmJhci4gRWFjaCBvbnMtdGFiIHJlcHJlc2VudHMgYSBwYWdlLlsvZW5dXG4gICAgKiAgIFtqYV1cbiAgICAqICAgICDjgr/jg5bjg5Djg7zjgavphY3nva7jgZXjgozjgovlkITjgqLjgqTjg4bjg6Djga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgZ3jgozjgZ7jgozjga5vbnMtdGFi44Gv44Oa44O844K444KS6KGo44GX44G+44GZ44CCXG4gICAgKiAgICAgb25zLXRhYuimgee0oOOBruS4reOBq+OBr+OAgeOCv+ODluOBq+ihqOekuuOBleOCjOOCi+OCs+ODs+ODhuODs+ODhOOCkuebtOaOpeiomOi/sOOBmeOCi+OBk+OBqOOBjOWHuuadpeOBvuOBmeOAglxuICAgICogICBbL2phXVxuICAgICogQGNvZGVwZW4gcEd1RExcbiAgICAqIEBndWlkZSBVc2luZ1RhYkJhclxuICAgICogICBbZW5dVXNpbmcgdGFiIGJhclsvZW5dXG4gICAgKiAgIFtqYV3jgr/jg5bjg5Djg7zjgpLkvb/jgYZbL2phXVxuICAgICogQGd1aWRlIERlZmluaW5nTXVsdGlwbGVQYWdlc2luU2luZ2xlSFRNTFxuICAgICogICBbZW5dRGVmaW5pbmcgbXVsdGlwbGUgcGFnZXMgaW4gc2luZ2xlIGh0bWxbL2VuXVxuICAgICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KSMeOBpOOBrkhUTUzjgavoqJjov7DjgZnjgotbL2phXVxuICAgICogQHNlZWFsc28gb25zLXRhYmJhclxuICAgICogICBbZW5db25zLXRhYmJhciBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLXRhYmJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gICAgKiBAc2VlYWxzbyBvbnMtcGFnZVxuICAgICogICBbZW5db25zLXBhZ2UgY29tcG9uZW50Wy9lbl1cbiAgICAqICAgW2phXW9ucy1wYWdl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1pY29uXG4gICAgKiAgIFtlbl1vbnMtaWNvbiBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLWljb27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICAgICogQGV4YW1wbGVcbiAgICAqIDxvbnMtdGFiYmFyPlxuICAgICogICA8b25zLXRhYiBwYWdlPVwiaG9tZS5odG1sXCIgYWN0aXZlPVwidHJ1ZVwiPlxuICAgICogICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLWhvbWVcIj48L29ucy1pY29uPlxuICAgICogICAgIDxzcGFuIHN0eWxlPVwiZm9udC1zaXplOiAxNHB4XCI+SG9tZTwvc3Bhbj5cbiAgICAqICAgPC9vbnMtdGFiPlxuICAgICogICA8b25zLXRhYiBwYWdlPVwiZmF2Lmh0bWxcIiBhY3RpdmU9XCJ0cnVlXCI+XG4gICAgKiAgICAgPG9ucy1pY29uIGljb249XCJpb24tc3RhclwiPjwvb25zLWljb24+XG4gICAgKiAgICAgPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDE0cHhcIj5GYXZvcml0ZXM8L3NwYW4+XG4gICAgKiAgIDwvb25zLXRhYj5cbiAgICAqICAgPG9ucy10YWIgcGFnZT1cInNldHRpbmdzLmh0bWxcIiBhY3RpdmU9XCJ0cnVlXCI+XG4gICAgKiAgICAgPG9ucy1pY29uIGljb249XCJpb24tZ2Vhci1hXCI+PC9vbnMtaWNvbj5cbiAgICAqICAgICA8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMTRweFwiPlNldHRpbmdzPC9zcGFuPlxuICAgICogICA8L29ucy10YWI+XG4gICAgKiA8L29ucy10YWJiYXI+XG4gICAgKlxuICAgICogPG9ucy10ZW1wbGF0ZSBpZD1cImhvbWUuaHRtbFwiPlxuICAgICogICAuLi5cbiAgICAqIDwvb25zLXRlbXBsYXRlPlxuICAgICpcbiAgICAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJmYXYuaHRtbFwiPlxuICAgICogICAuLi5cbiAgICAqIDwvb25zLXRlbXBsYXRlPlxuICAgICpcbiAgICAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJzZXR0aW5ncy5odG1sXCI+XG4gICAgKiAgIC4uLlxuICAgICogPC9vbnMtdGVtcGxhdGU+XG4gICAgKi9cblxuICAgdmFyIFRhYkVsZW1lbnQgPSAoZnVuY3Rpb24gKF9CYXNlRWxlbWVudCkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoVGFiRWxlbWVudCwgX0Jhc2VFbGVtZW50KTtcblxuICAgICBmdW5jdGlvbiBUYWJFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJFbGVtZW50KTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRhYkVsZW1lbnQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICB9XG5cbiAgICAgYmFiZWxIZWxwZXJzLmNyZWF0ZUNsYXNzKFRhYkVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgICAgICAqIEBpbml0b25seVxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dVGhlIHBhZ2UgdGhhdCB0aGlzIDxjb2RlPiZsdDtvbnMtdGFiJmd0OzwvY29kZT4gcG9pbnRzIHRvLlsvZW5dXG4gICAgICAgICogICBbamFdPGNvZGU+Jmx0O29ucy10YWImZ3Q7PC9jb2RlPuOBjOWPgueFp+OBmeOCi+ODmuODvOOCuOOBuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGljb25cbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVxuICAgICAgICAqICAgICBUaGUgaWNvbiBuYW1lIGZvciB0aGUgdGFiLiBDYW4gc3BlY2lmeSB0aGUgc2FtZSBpY29uIG5hbWUgYXMgPGNvZGU+Jmx0O29ucy1pY29uJmd0OzwvY29kZT4uXG4gICAgICAgICogICAgIElmIHlvdSBuZWVkIHRvIHVzZSB5b3VyIG93biBpY29uLCBjcmVhdGUgYSBjc3MgY2xhc3Mgd2l0aCBiYWNrZ3JvdW5kLWltYWdlIG9yIGFueSBjc3MgcHJvcGVydGllcyBhbmQgc3BlY2lmeSB0aGUgbmFtZSBvZiB5b3VyIGNzcyBjbGFzcyBoZXJlLlxuICAgICAgICAqICAgWy9lbl1cbiAgICAgICAgKiAgIFtqYV1cbiAgICAgICAgKiAgICAg44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCPGNvZGU+Jmx0O29ucy1pY29uJmd0OzwvY29kZT7jgajlkIzjgZjjgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICAgICAgKiAgICAg5YCL5Yil44Gr44Ki44Kk44Kz44Oz44KS44Kr44K544K/44Oe44Kk44K644GZ44KL5aC05ZCI44Gv44CBYmFja2dyb3VuZC1pbWFnZeOBquOBqeOBrkNTU+OCueOCv+OCpOODq+OCkueUqOOBhOOBpuaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgICAgICAqICAgWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgYWN0aXZlLWljb25cbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVRoZSBuYW1lIG9mIHRoZSBpY29uIHdoZW4gdGhlIHRhYiBpcyBhY3RpdmUuWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jgqLjgq/jg4bjgqPjg5bjga7pmpvjga7jgqLjgqTjgrPjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBsYWJlbFxuICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dVGhlIGxhYmVsIG9mIHRoZSB0YWIgaXRlbS5bL2VuXVxuICAgICAgICAqICAgW2phXeOCouOCpOOCs+ODs+S4i+OBq+ihqOekuuOBleOCjOOCi+ODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAYXR0cmlidXRlIGFjdGl2ZVxuICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICogICBbZW5dU2V0IHdoZXRoZXIgdGhpcyBpdGVtIHNob3VsZCBiZSBhY3RpdmUgb3Igbm90LiBWYWxpZCB2YWx1ZXMgYXJlIHRydWUgYW5kIGZhbHNlLlsvZW5dXG4gICAgICAgICogICBbamFd44GT44Gu44K/44OW44Ki44Kk44OG44Og44KS44Ki44Kv44OG44Kj44OW54q25oWL44Gr44GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CCdHJ1ZeOCguOBl+OBj+OBr2ZhbHNl44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdfY29tcGlsZWQnKSkge1xuICAgICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfY29tcGlsZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgIHZhciBoYXNDaGlsZHJlbiA9IGZhbHNlO1xuXG4gICAgICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChub2RlKTtcblxuICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgIGhhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgdGVtcGxhdGUgPSB0ZW1wbGF0ZVNvdXJjZSQzLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgIHdoaWxlICh0ZW1wbGF0ZS5jaGlsZHJlblswXSkge1xuICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgndGFiLWJhcl9faXRlbScpO1xuXG4gICAgICAgICB2YXIgYnV0dG9uID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWItYmFyX19idXR0b24nKTtcblxuICAgICAgICAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgICAgIHRoaXMuX2hhc0RlZmF1bHRUZW1wbGF0ZSA9IGZhbHNlO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgdGhpcy5faGFzRGVmYXVsdFRlbXBsYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgdGhpcy5fdXBkYXRlRGVmYXVsdFRlbXBsYXRlKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2NvbXBpbGVkJywgJycpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ191cGRhdGVSaXBwbGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUmlwcGxlKCkge1xuICAgICAgICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3VwZGF0ZURlZmF1bHRUZW1wbGF0ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVEZWZhdWx0VGVtcGxhdGUoKSB7XG4gICAgICAgICBpZiAoIXRoaXMuX2hhc0RlZmF1bHRUZW1wbGF0ZSkge1xuICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIHZhciBidXR0b24gPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYi1iYXJfX2J1dHRvbicpO1xuXG4gICAgICAgICB2YXIgdGVtcGxhdGUgPSBkZWZhdWx0SW5uZXJUZW1wbGF0ZVNvdXJjZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICB3aGlsZSAodGVtcGxhdGUuY2hpbGRyZW5bMF0pIHtcbiAgICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgdmFyIGljb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpO1xuICAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2xhYmVsJyk7XG5cbiAgICAgICAgIGlmICh0eXBlb2YgaWNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgZ2V0SWNvbkVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ2ljb24nLCBpY29uKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIHZhciB3cmFwcGVyID0gYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19pY29uJyk7XG4gICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgZ2V0TGFiZWxFbGVtZW50KCkudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGdldExhYmVsRWxlbWVudCgpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZ2V0TGFiZWxFbGVtZW50KCkpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBmdW5jdGlvbiBnZXRMYWJlbEVsZW1lbnQoKSB7XG4gICAgICAgICAgIHJldHVybiBzZWxmLnF1ZXJ5U2VsZWN0b3IoJy50YWItYmFyX19sYWJlbCcpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBmdW5jdGlvbiBnZXRJY29uRWxlbWVudCgpIHtcbiAgICAgICAgICAgcmV0dXJuIHNlbGYucXVlcnlTZWxlY3Rvcignb25zLWljb24nKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfb25DbGljaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNsaWNrKCkge1xuICAgICAgICAgdmFyIHRhYmJhciA9IHRoaXMuX2ZpbmRUYWJiYXJFbGVtZW50KCk7XG4gICAgICAgICBpZiAodGFiYmFyKSB7XG4gICAgICAgICAgIHRhYmJhci5zZXRBY3RpdmVUYWIodGhpcy5fZmluZFRhYkluZGV4KCkpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ3NldEFjdGl2ZScsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEFjdGl2ZSgpIHtcbiAgICAgICAgIHZhciByYWRpbyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdpbnB1dCcpO1xuICAgICAgICAgcmFkaW8uY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuXG4gICAgICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWluYWN0aXZlXSwgb25zLXRhYi1pbmFjdGl2ZScpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgIHJldHVybiBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICB9KTtcbiAgICAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnW29ucy10YWItYWN0aXZlXSwgb25zLXRhYi1hY3RpdmUnKSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICByZXR1cm4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnc2V0SW5hY3RpdmUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbmFjdGl2ZSgpIHtcbiAgICAgICAgIHZhciByYWRpbyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdpbnB1dCcpO1xuICAgICAgICAgcmFkaW8uY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcblxuICAgICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLXRhYi1pbmFjdGl2ZV0sIG9ucy10YWItaW5hY3RpdmUnKSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICByZXR1cm4gZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnO1xuICAgICAgICAgfSk7XG4gICAgICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtdGFiLWFjdGl2ZV0sIG9ucy10YWItYWN0aXZlJykpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgIH0pO1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2lzTG9hZGVkJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNMb2FkZWQoKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaW5rXG4gICAgICAgICovXG5cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19sb2FkUGFnZUVsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZFBhZ2VFbGVtZW50KGNhbGxiYWNrLCBsaW5rKSB7XG4gICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgaWYgKCF0aGlzLnBhZ2VFbGVtZW50KSB7XG4gICAgICAgICAgIHRoaXMuX2NyZWF0ZVBhZ2VFbGVtZW50KHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJyksIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgbGluayhlbGVtZW50LCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgX3RoaXMyLnBhZ2VFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGNhbGxiYWNrKHRoaXMucGFnZUVsZW1lbnQpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jcmVhdGVQYWdlRWxlbWVudCcsXG5cbiAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICovXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVQYWdlRWxlbWVudChwYWdlLCBjYWxsYmFjaykge1xuICAgICAgICAgaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgICAgIGNhbGxiYWNrKHV0aWwuY3JlYXRlRWxlbWVudChodG1sLnRyaW0oKSkpO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuXG4gICAgICAgLyoqXG4gICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgKi9cblxuICAgICB9LCB7XG4gICAgICAga2V5OiAnaXNBY3RpdmUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnZGV0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgdGhpcy5fZW5zdXJlRWxlbWVudFBvc2l0aW9uKCk7XG5cbiAgICAgICAgIHZhciB0YWJiYXIgPSB0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpO1xuXG4gICAgICAgICBpZiAodGFiYmFyLmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykgPyB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSArICcgJyA6ICcnO1xuICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBwcmVmaXggKyB0YWJiYXIuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIHZhciB0YWJJbmRleCA9IF90aGlzMy5fZmluZFRhYkluZGV4KCk7XG5cbiAgICAgICAgICAgICBPbnNUYWJiYXJFbGVtZW50JDEucmV3cml0YWJsZXMucmVhZHkodGFiYmFyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICByZXR1cm4gdGFiYmFyLnNldEFjdGl2ZVRhYih0YWJJbmRleCwgeyBhbmltYXRpb246ICdub25lJyB9KTtcbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICB9KSgpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgT25zVGFiYmFyRWxlbWVudCQxLnJld3JpdGFibGVzLnJlYWR5KHRhYmJhciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICBpZiAoX3RoaXMzLmhhc0F0dHJpYnV0ZSgncGFnZScpKSB7XG4gICAgICAgICAgICAgICAgIF90aGlzMy5fY3JlYXRlUGFnZUVsZW1lbnQoX3RoaXMzLmdldEF0dHJpYnV0ZSgncGFnZScpLCBmdW5jdGlvbiAocGFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICBPbnNUYWJiYXJFbGVtZW50JDEucmV3cml0YWJsZXMubGluayh0YWJiYXIsIHBhZ2VFbGVtZW50LCB7fSwgZnVuY3Rpb24gKHBhZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICBfdGhpczMucGFnZUVsZW1lbnQgPSBwYWdlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgIF90aGlzMy5wYWdlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICAgdGFiYmFyLl9jb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczMucGFnZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZmluZFRhYmJhckVsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZFRhYmJhckVsZW1lbnQoKSB7XG4gICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXRhYmJhcicpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGFiYmFyJykge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19maW5kVGFiSW5kZXgnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZFRhYkluZGV4KCkge1xuICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5wYXJlbnROb2RlLmNoaWxkcmVuO1xuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICBpZiAodGhpcyA9PT0gZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19lbnN1cmVFbGVtZW50UG9zaXRpb24nLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5zdXJlRWxlbWVudFBvc2l0aW9uKCkge1xuICAgICAgICAgaWYgKCF0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpKSB7XG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBvbnMtdGFiIGVsZW1lbnQgaXMgbXVzdCBiZSBjaGlsZCBvZiBvbnMtdGFiYmFyIGVsZW1lbnQuJyk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSQyMCk7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgJ2ljb24nOlxuICAgICAgICAgICBjYXNlICdsYWJlbCc6XG4gICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGVmYXVsdFRlbXBsYXRlKCk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAncGFnZUVsZW1lbnQnLFxuICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGVsKSB7XG4gICAgICAgICB0aGlzLl9wYWdlRWxlbWVudCA9IGVsO1xuICAgICAgIH0sXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3BhZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFnZUVsZW1lbnQ7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHZhciB0YWJiYXIgPSB0aGlzLl9maW5kVGFiYmFyRWxlbWVudCgpO1xuICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZFRhYkluZGV4KCk7XG5cbiAgICAgICAgIHJldHVybiB0YWJiYXIuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFRhYkVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNUYWJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtdGFiJywge1xuICAgICBwcm90b3R5cGU6IFRhYkVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KCdvbnMtdGFiYmFyLWl0ZW0nLCB7XG4gICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShUYWJFbGVtZW50LnByb3RvdHlwZSlcbiAgIH0pO1xuXG4gICB2YXIgc2NoZW1lJDIyID0geyAnJzogJ3Rvb2xiYXItYnV0dG9uLS0qJyB9O1xuXG4gICAvKipcbiAgICAqIEBlbGVtZW50IG9ucy10b29sYmFyLWJ1dHRvblxuICAgICogQGNhdGVnb3J5IHBhZ2VcbiAgICAqIEBtb2RpZmllciBvdXRsaW5lXG4gICAgKiAgIFtlbl1BIGJ1dHRvbiB3aXRoIGFuIG91dGxpbmUuWy9lbl1cbiAgICAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuOCguOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXUJ1dHRvbiBjb21wb25lbnQgZm9yIG9ucy10b29sYmFyIGFuZCBvbnMtYm90dG9tLXRvb2xiYXIuWy9lbl1cbiAgICAqICAgW2phXW9ucy10b29sYmFy44GC44KL44GE44Gvb25zLWJvdHRvbS10b29sYmFy44Gr6Kit572u44Gn44GN44KL44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAgICAqIEBjb2RlcGVuIGFIbUdMXG4gICAgKiBAZ3VpZGUgQWRkaW5nYXRvb2xiYXJcbiAgICAqICAgW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVxuICAgICogICBbamFd44OE44O844Or44OQ44O844Gu6L+95YqgWy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gICAgKiAgIFtlbl1vbnMtdG9vbGJhciBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLXRvb2xiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICAgICogQHNlZWFsc28gb25zLWJhY2stYnV0dG9uXG4gICAgKiAgIFtlbl1vbnMtYmFjay1idXR0b24gY29tcG9uZW50Wy9lbl1cbiAgICAqICAgW2phXW9ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gICAgKiBAc2VlYWxzbyBvbnMtdG9vbGJhci1idXR0b25cbiAgICAqICAgW2VuXW9ucy10b29sYmFyLWJ1dHRvbiBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLXRvb2xiYXItYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8b25zLXRvb2xiYXI+XG4gICAgKiAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+PG9ucy10b29sYmFyLWJ1dHRvbj5CdXR0b248L29ucy10b29sYmFyLWJ1dHRvbj48L2Rpdj5cbiAgICAqICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlRpdGxlPC9kaXY+XG4gICAgKiAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPjxvbnMtdG9vbGJhci1idXR0b24+PG9ucy1pY29uIGljb249XCJpb24tbmF2aWNvblwiIHNpemU9XCIyOHB4XCI+PC9vbnMtaWNvbj48L29ucy10b29sYmFyLWJ1dHRvbj48L2Rpdj5cbiAgICAqIDwvb25zLXRvb2xiYXI+XG4gICAgKi9cblxuICAgdmFyIFRvb2xiYXJCdXR0b25FbGVtZW50ID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKFRvb2xiYXJCdXR0b25FbGVtZW50LCBfQmFzZUVsZW1lbnQpO1xuXG4gICAgIGZ1bmN0aW9uIFRvb2xiYXJCdXR0b25FbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBUb29sYmFyQnV0dG9uRWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihUb29sYmFyQnV0dG9uRWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoVG9vbGJhckJ1dHRvbkVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICAgICAgKiAgIFtqYV3jg5zjgr/jg7Pjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAgICAqL1xuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgICAgICAqICAgW2phXeODnOOCv+ODs+OCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBr+aMh+WumuOBl+OBpuOBj+OBoOOBleOBhOOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jb21waWxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBpbGUoKSB7XG4gICAgICAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCd0b29sYmFyLWJ1dHRvbicpO1xuXG4gICAgICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSQyMik7XG5cbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICAgICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICAgICAgIHJldHVybiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lJDIyKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1dKTtcbiAgICAgcmV0dXJuIFRvb2xiYXJCdXR0b25FbGVtZW50O1xuICAgfSkoQmFzZUVsZW1lbnQpO1xuXG4gICB3aW5kb3cuT25zVG9vbGJhckJ1dHRvbiA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXRvb2xiYXItYnV0dG9uJywge1xuICAgICBwcm90b3R5cGU6IFRvb2xiYXJCdXR0b25FbGVtZW50LnByb3RvdHlwZVxuICAgfSk7XG5cbiAgIHZhciBzY2hlbWUkMjMgPSB7XG4gICAgICcnOiAnbmF2aWdhdGlvbi1iYXItLSonLFxuICAgICAnLm5hdmlnYXRpb24tYmFyX19sZWZ0JzogJ25hdmlnYXRpb24tYmFyLS0qX19sZWZ0JyxcbiAgICAgJy5uYXZpZ2F0aW9uLWJhcl9fY2VudGVyJzogJ25hdmlnYXRpb24tYmFyLS0qX19jZW50ZXInLFxuICAgICAnLm5hdmlnYXRpb24tYmFyX19yaWdodCc6ICduYXZpZ2F0aW9uLWJhci0tKl9fcmlnaHQnXG4gICB9O1xuXG4gICAvKipcbiAgICAqIEBlbGVtZW50IG9ucy10b29sYmFyXG4gICAgKiBAY2F0ZWdvcnkgcGFnZVxuICAgICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gICAgKiAgIFtlbl1UcmFuc3BhcmVudCB0b29sYmFyWy9lbl1cbiAgICAqICAgW2phXemAj+aYjuOBquiDjOaZr+OCkuaMgeOBpOODhOODvOODq+ODkOODvOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqICAgW2VuXVRvb2xiYXIgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBuYXZpZ2F0aW9uLiBMZWZ0LCBjZW50ZXIgYW5kIHJpZ2h0IGNvbnRhaW5lciBjYW4gYmUgc3BlY2lmaWVkIGJ5IGNsYXNzIG5hbWVzLlsvZW5dXG4gICAgKiAgIFtqYV3jg4rjg5PjgrLjg7zjgrfjg6fjg7Pjgafkvb/nlKjjgZnjgovjg4Tjg7zjg6vjg5Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgq/jg6njgrnlkI3jgavjgojjgorjgIHlt6bjgIHkuK3lpK7jgIHlj7Pjga7jgrPjg7Pjg4bjg4rjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgICogQGNvZGVwZW4gYUhtR0xcbiAgICAqIEBndWlkZSBBZGRpbmdhdG9vbGJhciBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dW2phXeODhOODvOODq+ODkOODvOOBrui/veWKoFsvamFdXG4gICAgKiBAc2VlYWxzbyBvbnMtYm90dG9tLXRvb2xiYXJcbiAgICAqICAgW2VuXW9ucy1ib3R0b20tdG9vbGJhciBjb21wb25lbnRbL2VuXVxuICAgICogICBbamFdb25zLWJvdHRvbS10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAgICAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICAgICogICBbZW5db25zLWJhY2stYnV0dG9uIGNvbXBvbmVudFsvZW5dXG4gICAgKiAgIFtqYV1vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICAgICogQHNlZWFsc28gb25zLXRvb2xiYXItYnV0dG9uXG4gICAgKiAgIFtlbl1vbnMtdG9vbGJhci1idXR0b24gY29tcG9uZW50Wy9lbl1cbiAgICAqICAgW2phXW9ucy10b29sYmFyLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gICAgKiBAZXhhbXBsZVxuICAgICogPG9ucy1wYWdlPlxuICAgICogICA8b25zLXRvb2xiYXI+XG4gICAgKiAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj48b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj48L2Rpdj5cbiAgICAqICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+VGl0bGU8L2Rpdj5cbiAgICAqICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5MYWJlbDwvZGl2PlxuICAgICogICA8L29ucy10b29sYmFyPlxuICAgICogPC9vbnMtcGFnZT5cbiAgICAqL1xuXG4gICB2YXIgVG9vbGJhckVsZW1lbnQgPSAoZnVuY3Rpb24gKF9CYXNlRWxlbWVudCkge1xuICAgICBiYWJlbEhlbHBlcnMuaW5oZXJpdHMoVG9vbGJhckVsZW1lbnQsIF9CYXNlRWxlbWVudCk7XG5cbiAgICAgZnVuY3Rpb24gVG9vbGJhckVsZW1lbnQoKSB7XG4gICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2xiYXJFbGVtZW50KTtcbiAgICAgICByZXR1cm4gYmFiZWxIZWxwZXJzLnBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRvb2xiYXJFbGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgfVxuXG4gICAgIGJhYmVsSGVscGVycy5jcmVhdGVDbGFzcyhUb29sYmFyRWxlbWVudCwgW3tcbiAgICAgICBrZXk6ICdjcmVhdGVkQ2FsbGJhY2snLFxuXG4gICAgICAgLyoqXG4gICAgICAgICogQGF0dHJpYnV0ZSBpbmxpbmVcbiAgICAgICAgKiBAaW5pdG9ubHlcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1EaXNwbGF5IHRoZSB0b29sYmFyIGFzIGFuIGlubGluZSBlbGVtZW50LlsvZW5dXG4gICAgICAgICogICBbamFd44OE44O844Or44OQ44O844KS44Kk44Oz44Op44Kk44Oz44Gr572u44GN44G+44GZ44CC44K544Kv44Ot44O844Or6aCY5Z+f5YaF44Gr44Gd44Gu44G+44G+6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICAgICAgKi9cblxuICAgICAgIC8qKlxuICAgICAgICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxuICAgICAgICAqICAgW2phXeODhOODvOODq+ODkOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICAgICovXG5cbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ19jb21waWxlZCcpKSB7XG4gICAgICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5fdHJ5VG9FbnN1cmVOb2RlUG9zaXRpb24oKTtcbiAgICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIHJldHVybiBfdGhpczIuX3RyeVRvRW5zdXJlTm9kZVBvc2l0aW9uKCk7XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUkMjMpO1xuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgIHRoaXMuX3RyeVRvRW5zdXJlTm9kZVBvc2l0aW9uKCk7XG4gICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICByZXR1cm4gX3RoaXMzLl90cnlUb0Vuc3VyZU5vZGVQb3NpdGlvbigpO1xuICAgICAgICAgfSk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX3RyeVRvRW5zdXJlTm9kZVBvc2l0aW9uJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyeVRvRW5zdXJlTm9kZVBvc2l0aW9uKCkge1xuICAgICAgICAgaWYgKCF0aGlzLnBhcmVudE5vZGUgfHwgdGhpcy5oYXNBdHRyaWJ1dGUoJ2lubGluZScpKSB7XG4gICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cbiAgICAgICAgIHZhciBwYWdlID0gdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtcGFnZScpO1xuXG4gICAgICAgICBpZiAocGFnZSAmJiBwYWdlICE9PSB0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgcGFnZS5fcmVnaXN0ZXJUb29sYmFyKHRoaXMpO1xuICAgICAgICAgfVxuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcubGVmdCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0VG9vbGJhckNlbnRlckl0ZW1zRWxlbWVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmNlbnRlcicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0VG9vbGJhclJpZ2h0SXRlbXNFbGVtZW50JyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5yaWdodCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICAgICAgIH1cblxuICAgICAgIC8qKlxuICAgICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgICAgICAqL1xuXG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZ2V0VG9vbGJhckJhY2tCdXR0b25MYWJlbEVsZW1lbnQnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VG9vbGJhckJhY2tCdXR0b25MYWJlbEVsZW1lbnQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24gLmJhY2stYnV0dG9uX19sYWJlbCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19jb21waWxlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBpbGUoKSB7XG4gICAgICAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCduYXZpZ2F0aW9uLWJhcicpO1xuXG4gICAgICAgICB0aGlzLl9lbnN1cmVUb29sYmFySXRlbUVsZW1lbnRzKCk7XG5cbiAgICAgICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lJDIzKTtcblxuICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19jb21waWxlZCcsICcnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnN1cmVUb29sYmFySXRlbUVsZW1lbnRzKCkge1xuXG4gICAgICAgICB2YXIgaGFzQ2VudGVyQ2xhc3NFbGVtZW50T25seSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHRoaXMuY2hpbGRyZW5bMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKTtcblxuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgLy8gY2FzZSBvZiBub3QgZWxlbWVudFxuICAgICAgICAgICBpZiAodGhpcy5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cblxuICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdjZW50ZXInKTtcbiAgICAgICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCduYXZpZ2F0aW9uLWJhcl9fdGl0bGUnKTtcblxuICAgICAgICAgaWYgKCFoYXNDZW50ZXJDbGFzc0VsZW1lbnRPbmx5KSB7XG4gICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5fZW5zdXJlVG9vbGJhckVsZW1lbnQoJ2xlZnQnKTtcbiAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5fZW5zdXJlVG9vbGJhckVsZW1lbnQoJ3JpZ2h0Jyk7XG5cbiAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bMF0gIT09IGxlZnQgfHwgdGhpcy5jaGlsZHJlblsxXSAhPT0gY2VudGVyIHx8IHRoaXMuY2hpbGRyZW5bMl0gIT09IHJpZ2h0KSB7XG4gICAgICAgICAgICAgaWYgKGxlZnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChsZWZ0KTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgaWYgKGNlbnRlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGNlbnRlcik7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGlmIChyaWdodC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHJpZ2h0KTtcbiAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGxlZnQpO1xuICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2VudGVyKTtcbiAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHJpZ2h0KTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ19lbnN1cmVUb29sYmFyRWxlbWVudCcsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnN1cmVUb29sYmFyRWxlbWVudChuYW1lKSB7XG4gICAgICAgICB2YXIgZWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcuJyArIG5hbWUpIHx8IHV0aWwuY3JlYXRlKCcuJyArIG5hbWUpO1xuXG4gICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ25hdmlnYXRpb24tYmFyX18nICsgbmFtZSk7XG5cbiAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgIH1cbiAgICAgfV0pO1xuICAgICByZXR1cm4gVG9vbGJhckVsZW1lbnQ7XG4gICB9KShCYXNlRWxlbWVudCk7XG5cbiAgIHdpbmRvdy5PbnNUb29sYmFyRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXRvb2xiYXInLCB7XG4gICAgIHByb3RvdHlwZTogVG9vbGJhckVsZW1lbnQucHJvdG90eXBlXG4gICB9KTtcblxuICAgdmFyIHNjaGVtZSQyNCA9IHtcbiAgICAgJy5yYW5nZSc6ICdyYW5nZS0tKicsXG4gICAgICcucmFuZ2VfX2xlZnQnOiAncmFuZ2UtLSpfX2xlZnQnXG4gICB9O1xuXG4gICB2YXIgSU5QVVRfQVRUUklCVVRFUyQxID0gWydhdXRvZm9jdXMnLCAnZGlzYWJsZWQnLCAnaW5wdXRtb2RlJywgJ21heCcsICdtaW4nLCAnbmFtZScsICdwbGFjZWhvbGRlcicsICdyZWFkb25seScsICdzaXplJywgJ3N0ZXAnLCAndmFsaWRhdG9yJywgJ3ZhbHVlJ107XG5cbiAgIC8qKlxuICAgICogQGVsZW1lbnQgb25zLXJhbmdlXG4gICAgKiBAY2F0ZWdvcnkgZm9ybVxuICAgICogQGRlc2NyaXB0aW9uXG4gICAgKiAgIFtlbl1SYW5nZSBpbnB1dCBjb21wb25lbnQuWy9lbl1cbiAgICAqICAgW2phXVsvamFdXG4gICAgKiBAY29kZXBlbiB4WlFvbU1cbiAgICAqIEBndWlkZSBVc2luZ0Zvcm1Db21wb25lbnRzXG4gICAgKiAgIFtlbl1Vc2luZyBmb3JtIGNvbXBvbmVudHNbL2VuXVxuICAgICogICBbamFd44OV44Kp44O844Og44KS5L2/44GGWy9qYV1cbiAgICAqIEBndWlkZSBFdmVudEhhbmRsaW5nXG4gICAgKiAgIFtlbl1FdmVudCBoYW5kbGluZyBkZXNjcmlwdGlvbnNbL2VuXVxuICAgICogICBbamFd44Kk44OZ44Oz44OI5Yem55CG44Gu5L2/44GE5pa5Wy9qYV1cbiAgICAqIEBleGFtcGxlXG4gICAgKiA8b25zLXJhbmdlIHZhbHVlPVwiMjBcIj48L29ucy1yYW5nZT5cbiAgICAqIDxvbnMtcmFuZ2UgbW9kaWZpZXI9XCJtYXRlcmlhbFwiIHZhbHVlPVwiMTBcIj48L3JhbmdlPlxuICAgICovXG5cbiAgIHZhciBNYXRlcmlhbElucHV0RWxlbWVudCQxID0gKGZ1bmN0aW9uIChfQmFzZUVsZW1lbnQpIHtcbiAgICAgYmFiZWxIZWxwZXJzLmluaGVyaXRzKE1hdGVyaWFsSW5wdXRFbGVtZW50LCBfQmFzZUVsZW1lbnQpO1xuXG4gICAgIGZ1bmN0aW9uIE1hdGVyaWFsSW5wdXRFbGVtZW50KCkge1xuICAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXRlcmlhbElucHV0RWxlbWVudCk7XG4gICAgICAgcmV0dXJuIGJhYmVsSGVscGVycy5wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIE9iamVjdC5nZXRQcm90b3R5cGVPZihNYXRlcmlhbElucHV0RWxlbWVudCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgIH1cblxuICAgICBiYWJlbEhlbHBlcnMuY3JlYXRlQ2xhc3MoTWF0ZXJpYWxJbnB1dEVsZW1lbnQsIFt7XG4gICAgICAga2V5OiAnY3JlYXRlZENhbGxiYWNrJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZENhbGxiYWNrKCkge1xuICAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnX2NvbXBpbGVkJykpIHtcbiAgICAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX2NvbXBpbGUnLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcGlsZSgpIHtcbiAgICAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgICAgICB0aGlzLmlubmVySFRNTCA9ICdcXG4gICAgICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgY2xhc3M9XCJyYW5nZVwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XCJyYW5nZV9fbGVmdFwiPjwvZGl2PlxcbiAgICAnO1xuXG4gICAgICAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSQyNCk7XG5cbiAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfY29tcGlsZWQnLCAnJyk7XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnX29uQ2hhbmdlJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2hhbmdlKCkge1xuICAgICAgICAgdGhpcy5fbGVmdC5zdHlsZS53aWR0aCA9IDEwMCAqIHRoaXMuX3JhdGlvICsgJyUnO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgICAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lJDI0KTtcbiAgICAgICAgIH0gZWxzZSBpZiAoSU5QVVRfQVRUUklCVVRFUyQxLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgICAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcblxuICAgICAgICAgICBpZiAobmFtZSA9PT0gJ21pbicgfHwgbmFtZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9LCB7XG4gICAgICAga2V5OiAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fb25DaGFuZ2UpO1xuICAgICAgIH1cbiAgICAgfSwge1xuICAgICAgIGtleTogJ2RldGFjaGVkQ2FsbGJhY2snLFxuICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZENhbGxiYWNrKCkge1xuICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfdXBkYXRlQm91bmRBdHRyaWJ1dGVzJyxcbiAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpIHtcbiAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICBJTlBVVF9BVFRSSUJVVEVTJDEuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICBpZiAoX3RoaXMyLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICAgICAgIF90aGlzMi5faW5wdXQuc2V0QXR0cmlidXRlKGF0dHIsIF90aGlzMi5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIF90aGlzMi5faW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgICB9XG4gICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfcmF0aW8nLFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgLy8gUmV0dXJucyB0aGUgY3VycmVudCByYXRpby5cbiAgICAgICAgIHZhciBtaW4gPSB0aGlzLl9pbnB1dC5taW4gPT09ICcnID8gMCA6IHBhcnNlSW50KHRoaXMuX2lucHV0Lm1pbik7XG4gICAgICAgICB2YXIgbWF4ID0gdGhpcy5faW5wdXQubWF4ID09PSAnJyA/IDEwMCA6IHBhcnNlSW50KHRoaXMuX2lucHV0Lm1heCk7XG5cbiAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfaW5wdXQnLFxuICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICdfbGVmdCcsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcucmFuZ2VfX2xlZnQnKTtcbiAgICAgICB9XG4gICAgIH0sIHtcbiAgICAgICBrZXk6ICd2YWx1ZScsXG4gICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5faW5wdXQudmFsdWU7XG4gICAgICAgfSxcbiAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdmFsO1xuICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWw7XG4gICAgICAgfVxuICAgICB9XSk7XG4gICAgIHJldHVybiBNYXRlcmlhbElucHV0RWxlbWVudDtcbiAgIH0pKEJhc2VFbGVtZW50KTtcblxuICAgd2luZG93Lk9uc1JhbmdlRWxlbWVudCA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCgnb25zLXJhbmdlJywge1xuICAgICBwcm90b3R5cGU6IE1hdGVyaWFsSW5wdXRFbGVtZW50JDEucHJvdG90eXBlXG4gICB9KTtcblxuICAgLy8gZmFzdGNsaWNrXG4gICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgcmV0dXJuIEZhc3RDbGljay5hdHRhY2goZG9jdW1lbnQuYm9keSk7XG4gICB9LCBmYWxzZSk7XG5cbiAgIC8vIG9ucy5fZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgb25zLl9kZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5lbmFibGUoKTtcbiAgICAgb25zLl9kZWZhdWx0RGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBvbnMuX2RldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIod2luZG93LmRvY3VtZW50LmJvZHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICBuYXZpZ2F0b3IuYXBwLmV4aXRBcHAoKTtcbiAgICAgfSk7XG4gICAgIGRvY3VtZW50LmJvZHkuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBvbnMuR2VzdHVyZURldGVjdG9yKGRvY3VtZW50LmJvZHkpO1xuICAgfSwgZmFsc2UpO1xuXG4gICAvLyBzZXR1cCBsb2FkaW5nIHBsYWNlaG9sZGVyXG4gICBvbnMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICBvbnMuX3NldHVwTG9hZGluZ1BsYWNlSG9sZGVycygpO1xuICAgfSk7XG5cbiAgIC8vIHZpZXdwb3J0LmpzXG4gICBuZXcgVmlld3BvcnQoKS5zZXR1cCgpO1xuXG4gICAvLyBtb2Rlcm5pemVcbiAgIE1vZGVybml6ci50ZXN0U3R5bGVzKCcjbW9kZXJuaXpyIHsgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2ggfScsIGZ1bmN0aW9uIChlbGVtLCBydWxlKSB7XG4gICAgIE1vZGVybml6ci5hZGRUZXN0KCdvdmVyZmxvd3RvdWNoJywgd2luZG93LmdldENvbXB1dGVkU3R5bGUgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSkuZ2V0UHJvcGVydHlWYWx1ZSgnLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmcnKSA9PSAndG91Y2gnKTtcbiAgIH0pO1xuXG4gICByZXR1cm4gb25zO1xuXG59KSk7Il0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9